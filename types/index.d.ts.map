{"mappings":";AiBqCA,OAAO,MAAM,wBAeZ,CAAA;AAED,OAAO,MAAM,4BAA8C,CAAA;AAiB3D;IACI,gBAAgB,EAAE,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAA;IAErC,gBAAgB,EAAE,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA;IAEtC,sBAAsB,EAAE,GAAG,CAAC,MAAM,EAAE,aAAa,CAAC,CAAA;IAElD,uBAAuB,EAAE,GAAG,CAAC,MAAM,EAAE,MAAM,EAAE,CAAC,CAAA;;IAU9C,kBAAkB,CAAC,EACf,IAAI,EACJ,OAAO,EACP,cAAc,EACd,OAAO,EACP,aAAa,GAChB,EAAE,QAAQ;IAaX,WAAW,OAAc,KAAK,GAAG,KAAK,KAAG,QAAQ,MAAM,CAAC,CAgIvD;IAED,cAAc,QAAS,MAAM,WAAW,QAAQ,MAAM,CAAC,OAAO,GAAG,UAUhE;IAED,OAAO,iBACW,MAAM,oCACc,YAAY,mBAoBjD;CACJ;AAED,OAAO,MAAM,kBAAyB,KAAK,cAAc,MAAM,EAAE,oBAiBhE,CAAA","sources":["src/types/protocols/symre.ts","src/src/utils.ts","src/src/protocols/aip.ts","src/src/protocols/b.ts","src/src/protocols/bap.ts","src/src/protocols/bitcom.ts","src/src/protocols/bitcomHashed.ts","src/src/protocols/bitkey.ts","src/src/protocols/bitpic.ts","src/src/protocols/boost.ts","src/src/protocols/haip.ts","src/src/protocols/map.ts","src/src/protocols/metanet.ts","src/src/paymail.ts","src/src/protocols/psp.ts","src/src/protocols/ron.ts","src/src/protocols/_21e8.ts","src/src/bmap.ts","src/bmap.ts"],"sourcesContent":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"// import default protocols\nimport {\n    BmapTx,\n    BobTx,\n    Handler,\n    HandlerProps,\n    In,\n    MetaNet,\n    MomTx,\n    Out,\n    Protocol,\n    ScriptChecker,\n} from '../types/common'\nimport { AIP } from './protocols/aip'\nimport { B } from './protocols/b'\nimport { BAP } from './protocols/bap'\nimport { BITCOM } from './protocols/bitcom'\nimport { BITCOM_HASHED } from './protocols/bitcomHashed'\nimport { BITKEY } from './protocols/bitkey'\nimport { BITPIC } from './protocols/bitpic'\nimport { BOOST } from './protocols/boost'\nimport { HAIP } from './protocols/haip'\nimport { MAP } from './protocols/map'\nimport { METANET } from './protocols/metanet'\nimport { PSP } from './protocols/psp'\nimport { RON } from './protocols/ron'\nimport { _21E8 } from './protocols/_21e8'\nimport { checkOpFalseOpReturn, saveProtocolData } from './utils'\n\n// Names of enabled protocols\nconst enabledProtocols = new Map<string, string>([])\n// Protocol Handlers\nconst protocolHandlers = new Map<string, Handler>([])\n// Script checkers are intentionally minimalistic detection functions for identifying matching scripts for a given protocol. Only if a checker returns true is a handler called for processing.\nconst protocolScriptCheckers = new Map<string, ScriptChecker>([])\nconst protocolOpReturnSchemas = new Map<string, Object[]>()\n\nexport const allProtocols = [\n    AIP,\n    B,\n    BAP,\n    MAP,\n    METANET,\n    BOOST,\n    _21E8,\n    BITCOM,\n    BITKEY,\n    BITPIC,\n    HAIP,\n    BITCOM_HASHED,\n    PSP,\n    RON,\n]\n\nexport const defaultProtocols = [AIP, B, BAP, MAP, METANET]\n\n// prepare protocol map, handlers and schemas\ndefaultProtocols.forEach((protocol) => {\n    if (protocol.address) {\n        enabledProtocols.set(protocol.address, protocol.name)\n    }\n    protocolHandlers.set(protocol.name, protocol.handler)\n    if (protocol.opReturnSchema) {\n        protocolOpReturnSchemas.set(protocol.name, protocol.opReturnSchema)\n    }\n    if (protocol.scriptChecker) {\n        protocolScriptCheckers.set(protocol.name, protocol.scriptChecker)\n    }\n})\n\n// Takes a BOB formatted op_return transaction\nexport class BMAP {\n    enabledProtocols: Map<string, string>\n\n    protocolHandlers: Map<string, Handler>\n\n    protocolScriptCheckers: Map<string, ScriptChecker>\n\n    protocolOpReturnSchemas: Map<string, Object[]>\n\n    constructor() {\n        // initial default protocol handlers in this instantiation\n        this.enabledProtocols = enabledProtocols\n        this.protocolHandlers = protocolHandlers\n        this.protocolScriptCheckers = protocolScriptCheckers\n        this.protocolOpReturnSchemas = protocolOpReturnSchemas\n    }\n\n    addProtocolHandler({\n        name,\n        address,\n        opReturnSchema,\n        handler,\n        scriptChecker,\n    }: Protocol) {\n        if (address) {\n            this.enabledProtocols.set(address, name)\n        }\n        this.protocolHandlers.set(name, handler)\n        if (opReturnSchema) {\n            this.protocolOpReturnSchemas.set(name, opReturnSchema)\n        }\n        if (scriptChecker) {\n            this.protocolScriptCheckers.set(name, scriptChecker)\n        }\n    }\n\n    transformTx = async (tx: BobTx | MomTx): Promise<BmapTx> => {\n        if (!tx || !tx['in'] || !tx['out']) {\n            throw new Error('Cannot process tx')\n        }\n\n        // This will become our nicely formatted response object\n        const dataObj: Partial<BmapTx> = {}\n\n        for (const [key, val] of Object.entries(tx)) {\n            if (key === 'out') {\n                // loop over the outputs\n                for (const out of tx.out) {\n                    const { tape } = out\n\n                    if (tape?.some((cc) => checkOpFalseOpReturn(cc))) {\n                        // loop over tape\n                        for (const cellContainer of tape) {\n                            // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n                            if (checkOpFalseOpReturn(cellContainer)) {\n                                continue\n                            }\n\n                            const { cell } = cellContainer\n                            if (!cell) {\n                                throw new Error('empty cell while parsing')\n                            }\n\n                            const prefix = cell[0].s\n\n                            await this.process(\n                                this.enabledProtocols.get(prefix || '') || '',\n                                {\n                                    cell,\n                                    dataObj: dataObj as BmapTx,\n                                    tape,\n                                    out,\n                                    tx,\n                                }\n                            )\n                        }\n                    } else {\n                        // No OP_RETURN in this tape\n\n                        const boostChecker = this.protocolScriptCheckers.get(\n                            BOOST.name\n                        )\n                        const _21e8Checker = this.protocolScriptCheckers.get(\n                            _21E8.name\n                        )\n\n                        // Check for boostpow and 21e8\n                        if (\n                            tape?.some((cc) => {\n                                const { cell } = cc\n                                if (boostChecker && boostChecker(cell)) {\n                                    // 'found boost'\n                                    return true\n                                }\n                                if (_21e8Checker && _21e8Checker(cell)) {\n                                    // 'found 21e8'\n                                    return true\n                                }\n                            })\n                        ) {\n                            // find the cell array\n                            // loop over tape\n                            for (const cellContainer of tape) {\n                                const { cell } = cellContainer\n                                // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n                                if (!cell) {\n                                    throw new Error('empty cell while parsing')\n                                }\n                                let protocolName = ''\n                                if (boostChecker && boostChecker(cell)) {\n                                    protocolName = BOOST.name\n                                } else if (_21e8Checker && _21e8Checker(cell)) {\n                                    protocolName = _21E8.name\n                                } else {\n                                    // nothing found\n                                    continue\n                                }\n\n                                this.process(protocolName, {\n                                    tx,\n                                    cell,\n                                    dataObj: dataObj as BmapTx,\n                                    tape,\n                                    out,\n                                })\n                            }\n                        } else {\n                            this.processUnknown(key, dataObj, out)\n                        }\n                    }\n                }\n            } else if (key === 'in') {\n                // TODO: Boost check inputs to see if this is a tx solving a puzzle\n                // TODO: 21e8 check inputs to see if this is a tx solving a puzzle\n                dataObj[key] = val.map((v: In) => {\n                    const r = { ...v }\n                    delete r.tape\n                    return r\n                })\n            } else {\n                // known key, just write it retaining original type\n                dataObj[key] = val\n            }\n        }\n\n        // If this is a MOM planaria it will have metanet keys available\n        if (dataObj['METANET'] && (tx as MomTx).parent) {\n            const meta = {\n                ancestor: (tx as MomTx).ancestor,\n                parent: (tx as MomTx).parent,\n                child: (tx as MomTx).child,\n                head: (tx as MomTx).head,\n            } as MetaNet\n\n            ;(dataObj.METANET as MetaNet[]).push(meta)\n            // remove parent and node from root level for (MOM data)\n            delete dataObj.ancestor\n            delete dataObj.child\n            delete dataObj.parent\n            delete dataObj.head\n            delete dataObj.node\n        }\n\n        return dataObj as BmapTx\n    }\n\n    processUnknown = (key: string, dataObj: Partial<BmapTx>, out: Out) => {\n        // no known non-OP_RETURN scripts\n        if (key && !dataObj[key]) {\n            dataObj[key] = []\n        }\n\n        ;(dataObj[key] as Out[]).push({\n            i: out.i,\n            e: out.e,\n        })\n    }\n\n    process = async (\n        protocolName: string,\n        { cell, dataObj, tape, out, tx }: HandlerProps\n    ) => {\n        if (\n            this.protocolHandlers.has(protocolName) &&\n            typeof this.protocolHandlers.get(protocolName) === 'function'\n        ) {\n            const handler = this.protocolHandlers.get(protocolName)\n            if (handler) {\n                /* eslint-disable no-await-in-loop */\n                await handler({\n                    dataObj: dataObj,\n                    cell,\n                    tape,\n                    out,\n                    tx,\n                })\n            }\n        } else {\n            saveProtocolData(dataObj, protocolName, cell)\n        }\n    }\n}\n\nexport const TransformTx = async (tx: BobTx, protocols?: string[]) => {\n    const b = new BMAP()\n\n    // if protocols are specified\n    if (protocols) {\n        // wipe out defaults\n        enabledProtocols.clear()\n\n        // set enabled protocols\n        for (const protocol of allProtocols) {\n            if (protocols?.includes(protocol.name)) {\n                b.addProtocolHandler(protocol)\n            }\n        }\n    }\n\n    return b.transformTx(tx)\n}\n"],"names":[],"version":3,"file":"index.d.ts.map","sourceRoot":"../"}