{"mappings":";ASyBA,OAAO,MAAM,wBAAwD,CAAA;AACrE,OAAO,MAAM,4BAA8C,CAAA;AAc3D;IACI,gBAAgB,EAAE,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAA;IAErC,gBAAgB,EAAE,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA;IAEtC,oBAAoB,EAAE,GAAG,CAAC,MAAM,EAAE,MAAM,EAAE,CAAC,CAAA;;IAS3C,kBAAkB,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE,WAAW,EAAE,OAAO,EAAE,EAAE,QAAQ;IAUpE,WAAW,OAAc,KAAK,GAAG,KAAK,KAAG,QAAQ,MAAM,CAAC,CA+HvD;IAED,cAAc,QAAS,MAAM,WAAW,QAAQ,MAAM,CAAC,OAAO,GAAG,UAUhE;IAED,OAAO,iBACW,MAAM,oCACc,YAAY,mBAoBjD;CACJ;AAED,OAAO,MAAM,kBAAyB,KAAK,cAAc,MAAM,EAAE,oBAiBhE,CAAA","sources":["src/types/protocols/symre.ts","src/src/utils.ts","src/src/protocols/aip.ts","src/src/protocols/b.ts","src/src/protocols/bap.ts","src/src/protocols/boost.ts","src/src/protocols/map.ts","src/src/protocols/metanet.ts","src/src/protocols/_21e8.ts","src/src/bmap.ts","src/bmap.ts"],"sourcesContent":[null,null,null,null,null,null,null,null,null,null,"// import default protocols\nimport {\n    BmapTx,\n    BobTx,\n    Handler,\n    HandlerProps,\n    In,\n    MetaNet,\n    MomTx,\n    Out,\n    Protocol,\n} from '../types/common'\nimport { AIP } from './protocols/aip'\nimport { B } from './protocols/b'\nimport { BAP } from './protocols/bap'\nimport { BOOST, checkBoostpow } from './protocols/boost'\nimport { MAP } from './protocols/map'\nimport { METANET } from './protocols/metanet'\nimport { check21e8, _21E8 } from './protocols/_21e8'\nimport { checkOpFalseOpReturn, saveProtocolData } from './utils'\n\nconst enabledProtocols = new Map<string, string>([])\nconst protocolHandlers = new Map<string, Handler>([])\nconst protocolQuerySchemas = new Map<string, Object[]>()\n\nexport const allProtocols = [AIP, B, BAP, MAP, METANET, BOOST, _21E8]\nexport const defaultProtocols = [AIP, B, BAP, MAP, METANET]\n\n// prepare protocol map, handlers and schemas\ndefaultProtocols.forEach((protocol) => {\n    if (protocol.address) {\n        enabledProtocols.set(protocol.address, protocol.name)\n    }\n    protocolHandlers.set(protocol.name, protocol.handler)\n    if (protocol.querySchema) {\n        protocolQuerySchemas.set(protocol.name, protocol.querySchema)\n    }\n})\n\n// Takes a BOB formatted op_return transaction\nexport class BMAP {\n    enabledProtocols: Map<string, string>\n\n    protocolHandlers: Map<string, Handler>\n\n    protocolQuerySchemas: Map<string, Object[]>\n\n    constructor() {\n        // initial default protocol handlers in this instantiation\n        this.enabledProtocols = enabledProtocols\n        this.protocolHandlers = protocolHandlers\n        this.protocolQuerySchemas = protocolQuerySchemas\n    }\n\n    addProtocolHandler({ name, address, querySchema, handler }: Protocol) {\n        if (address) {\n            this.enabledProtocols.set(address, name)\n        }\n        this.protocolHandlers.set(name, handler)\n        if (querySchema) {\n            this.protocolQuerySchemas.set(name, querySchema)\n        }\n    }\n\n    transformTx = async (tx: BobTx | MomTx): Promise<BmapTx> => {\n        if (!tx || !tx['in'] || !tx['out']) {\n            throw new Error('Cannot process tx')\n        }\n\n        // This will become our nicely formatted response object\n        const dataObj: Partial<BmapTx> = {}\n\n        for (const [key, val] of Object.entries(tx)) {\n            if (key === 'out') {\n                // loop over the outputs\n                for (const out of tx.out) {\n                    const { tape } = out\n\n                    if (tape?.some((cc) => checkOpFalseOpReturn(cc))) {\n                        // loop over tape\n                        for (const cellContainer of tape) {\n                            // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n                            if (checkOpFalseOpReturn(cellContainer)) {\n                                continue\n                            }\n\n                            const { cell } = cellContainer\n                            if (!cell) {\n                                throw new Error('empty cell while parsing')\n                            }\n\n                            const prefix = cell[0].s\n\n                            await this.process(\n                                this.enabledProtocols.get(prefix || '') || '',\n                                {\n                                    cell,\n                                    dataObj: dataObj as BmapTx,\n                                    tape,\n                                    out,\n                                    tx,\n                                }\n                            )\n                        }\n                    } else {\n                        // No OP_RETURN in this tape\n\n                        // Check for boostpow and 21e8\n                        if (\n                            tape?.some((cc) => {\n                                const { cell } = cc\n                                if (\n                                    this.protocolHandlers.has(BOOST.name) &&\n                                    checkBoostpow(cell)\n                                ) {\n                                    // 'found boost'\n                                    return true\n                                }\n                                if (\n                                    this.protocolHandlers.has(_21E8.name) &&\n                                    check21e8(cell)\n                                ) {\n                                    // 'found 21e8'\n                                    return true\n                                }\n                            })\n                        ) {\n                            // find the cell array\n                            // loop over tape\n                            for (const cellContainer of tape) {\n                                const { cell } = cellContainer\n                                // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n                                if (!cell) {\n                                    throw new Error('empty cell while parsing')\n                                }\n                                let protocolName = ''\n                                if (checkBoostpow(cell)) {\n                                    protocolName = BOOST.name\n                                } else if (check21e8(cell)) {\n                                    protocolName = _21E8.name\n                                } else {\n                                    // nothing found\n                                    continue\n                                }\n\n                                this.process(protocolName, {\n                                    tx,\n                                    cell,\n                                    dataObj: dataObj as BmapTx,\n                                    tape,\n                                    out,\n                                })\n                            }\n                        } else {\n                            this.processUnknown(key, dataObj, out)\n                        }\n                    }\n                }\n            } else if (key === 'in') {\n                // TODO: Boost check inputs to see if this is a tx solving a puzzle\n                // TODO: 21e8 check inputs to see if this is a tx solving a puzzle\n                dataObj[key] = val.map((v: In) => {\n                    const r = { ...v }\n                    delete r.tape\n                    return r\n                })\n            } else {\n                // known key, just write it retaining original type\n                dataObj[key] = val\n            }\n        }\n\n        // If this is a MOM planaria it will have metanet keys available\n        if (dataObj['METANET'] && (tx as MomTx).parent) {\n            const meta = {\n                ancestor: (tx as MomTx).ancestor,\n                parent: (tx as MomTx).parent,\n                child: (tx as MomTx).child,\n                head: (tx as MomTx).head,\n            } as MetaNet\n\n            ;(dataObj.METANET as MetaNet[]).push(meta)\n            // remove parent and node from root level for (MOM data)\n            delete dataObj.ancestor\n            delete dataObj.child\n            delete dataObj.parent\n            delete dataObj.head\n            delete dataObj.node\n        }\n\n        return dataObj as BmapTx\n    }\n\n    processUnknown = (key: string, dataObj: Partial<BmapTx>, out: Out) => {\n        // no known non-OP_RETURN scripts\n        if (key && !dataObj[key]) {\n            dataObj[key] = []\n        }\n\n        ;(dataObj[key] as Out[]).push({\n            i: out.i,\n            e: out.e,\n        })\n    }\n\n    process = async (\n        protocolName: string,\n        { cell, dataObj, tape, out, tx }: HandlerProps\n    ) => {\n        if (\n            this.protocolHandlers.has(protocolName) &&\n            typeof this.protocolHandlers.get(protocolName) === 'function'\n        ) {\n            const handler = this.protocolHandlers.get(protocolName)\n            if (handler) {\n                /* eslint-disable no-await-in-loop */\n                await handler({\n                    dataObj: dataObj,\n                    cell,\n                    tape,\n                    out,\n                    tx,\n                })\n            }\n        } else {\n            saveProtocolData(dataObj, protocolName, cell)\n        }\n    }\n}\n\nexport const TransformTx = async (tx: BobTx, protocols?: string[]) => {\n    const b = new BMAP()\n\n    // if protocols are specified\n    if (protocols) {\n        // wipe out defaults\n        enabledProtocols.clear()\n\n        // set enabled protocols\n        for (const protocol of allProtocols) {\n            if (protocols?.includes(protocol.name)) {\n                b.addProtocolHandler(protocol)\n            }\n        }\n    }\n\n    return b.transformTx(tx)\n}\n"],"names":[],"version":3,"file":"index.d.ts.map","sourceRoot":"../"}