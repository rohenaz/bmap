{"mappings":";;AOGA,OAAO,EAAE,aAAa,EAAE,MAAM,6BAA6B,CAAA;AYyC3D,OAAO,MAAM;;;;;;;IAiBZ,CAAA;AAED,OAAO,MAAM,4BAAoD,CAAA;AACjE,OAAO,MAAM,4BAAmD,CAAA;AAiBhE;IACI,gBAAgB,EAAE,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAA;IAErC,gBAAgB,EAAE,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA;IAEtC,sBAAsB,EAAE,GAAG,CAAC,MAAM,EAAE,aAAa,CAAC,CAAA;IAElD,uBAAuB,EAAE,GAAG,CAAC,MAAM,EAAE,MAAM,EAAE,CAAC,CAAA;;IAU9C,kBAAkB,CAAC,EACf,IAAI,EACJ,OAAO,EACP,cAAc,EACd,OAAO,EACP,aAAa,GAChB,EAAE,QAAQ;IAaX,WAAW,OAAc,KAAK,GAAG,KAAK,KAAG,QAAQ,MAAM,CAAC,CAkHvD;IAED,cAAc,QAAS,MAAM,WAAW,QAAQ,MAAM,CAAC,OAAO,GAAG,UAWhE;IAED,OAAO,iBACW,MAAM,oCACc,YAAY,mBAoBjD;IAED,oBAAoB,SACV,IAAI,EAAE,OACP,GAAG,MACJ,KAAK,WACA,QAAQ,KAAK,CAAC,KACxB,QAAQ,QAAQ,KAAK,CAAC,CAAC,CAiCzB;CACJ;AAED,OAAO,MAAM,mBAA0B,MAAM,KAAG,QAAQ,MAAM,CAO7D,CAAA;AAED,OAAO,MAAM,sBAA6B,MAAM,KAAG,QAAQ,KAAK,CAc/D,CAAA;AAOD,OAAO,MAAM,kBACL,KAAK,GAAG,MAAM,GAAG,KAAK,GAAG,MAAM,cACvB,MAAM,EAAE,GAAG,QAAQ,EAAE,oBAwDpC,CAAA","sources":["src/types/protocols/symre.ts","src/src/utils.ts","src/src/protocols/_21e8.ts","src/src/protocols/aip.ts","src/src/protocols/b.ts","src/src/protocols/bap.ts","src/src/protocols/bitcom.ts","src/src/paymail.ts","src/src/protocols/psp.ts","src/src/protocols/bitcomHashed.ts","src/src/protocols/bitkey.ts","src/src/protocols/bitpic.ts","src/src/protocols/boost.ts","src/src/protocols/haip.ts","src/src/protocols/map.ts","src/src/protocols/metanet.ts","src/src/protocols/ord.ts","src/src/protocols/ron.ts","src/src/protocols/symre.ts","src/src/bmap.ts","src/bmap.ts"],"sourcesContent":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"import { parse } from 'bpu-ts'\r\nimport { In, Out, Tape } from 'bpu-ts/src/types/common'\r\nimport {\r\n    BmapTx,\r\n    BobTx,\r\n    Handler,\r\n    HandlerProps,\r\n    MetaNet,\r\n    MomTx,\r\n    Protocol,\r\n    ScriptChecker,\r\n} from '../types/common'\r\nimport { _21E8 } from './protocols/_21e8'\r\nimport { AIP } from './protocols/aip'\r\nimport { B } from './protocols/b'\r\nimport { BAP } from './protocols/bap'\r\nimport { BITCOM } from './protocols/bitcom'\r\nimport { BITCOM_HASHED } from './protocols/bitcomHashed'\r\nimport { BITKEY } from './protocols/bitkey'\r\nimport { BITPIC } from './protocols/bitpic'\r\nimport { BOOST } from './protocols/boost'\r\nimport { HAIP } from './protocols/haip'\r\nimport { MAP } from './protocols/map'\r\nimport { METANET } from './protocols/metanet'\r\nimport { ORD } from './protocols/ord'\r\nimport { PSP } from './protocols/psp'\r\nimport { RON } from './protocols/ron'\r\nimport { SYMRE } from './protocols/symre'\r\nimport {\r\n    checkOpFalseOpReturn,\r\n    checkOpReturn,\r\n    isObjectArray,\r\n    isStringArray,\r\n    saveProtocolData,\r\n} from './utils'\r\n\r\n// Names of enabled protocols\r\nconst enabledProtocols = new Map<string, string>([])\r\n// Protocol Handlers\r\nconst protocolHandlers = new Map<string, Handler>([])\r\n// Script checkers are intentionally minimalistic detection functions for identifying matching scripts for a given protocol. Only if a checker returns true is a handler called for processing.\r\nconst protocolScriptCheckers = new Map<string, ScriptChecker>([])\r\nconst protocolOpReturnSchemas = new Map<string, Object[]>()\r\n\r\nexport const allProtocols = [\r\n    AIP,\r\n    B,\r\n    BAP,\r\n    MAP,\r\n    METANET,\r\n    BOOST,\r\n    _21E8,\r\n    BITCOM,\r\n    BITKEY,\r\n    BITPIC,\r\n    HAIP,\r\n    BITCOM_HASHED,\r\n    PSP,\r\n    RON,\r\n    SYMRE,\r\n    ORD,\r\n]\r\n\r\nexport const supportedProtocols = allProtocols.map((p) => p.name)\r\nexport const defaultProtocols = [AIP, B, BAP, MAP, METANET, ORD]\r\n\r\n// prepare protocol map, handlers and schemas\r\ndefaultProtocols.forEach((protocol) => {\r\n    if (protocol.address) {\r\n        enabledProtocols.set(protocol.address, protocol.name)\r\n    }\r\n    protocolHandlers.set(protocol.name, protocol.handler)\r\n    if (protocol.opReturnSchema) {\r\n        protocolOpReturnSchemas.set(protocol.name, protocol.opReturnSchema)\r\n    }\r\n    if (protocol.scriptChecker) {\r\n        protocolScriptCheckers.set(protocol.name, protocol.scriptChecker)\r\n    }\r\n})\r\n\r\n// Takes a BOB formatted op_return transaction\r\nexport class BMAP {\r\n    enabledProtocols: Map<string, string>\r\n\r\n    protocolHandlers: Map<string, Handler>\r\n\r\n    protocolScriptCheckers: Map<string, ScriptChecker>\r\n\r\n    protocolOpReturnSchemas: Map<string, Object[]>\r\n\r\n    constructor() {\r\n        // initial default protocol handlers in this instantiation\r\n        this.enabledProtocols = enabledProtocols\r\n        this.protocolHandlers = protocolHandlers\r\n        this.protocolScriptCheckers = protocolScriptCheckers\r\n        this.protocolOpReturnSchemas = protocolOpReturnSchemas\r\n    }\r\n\r\n    addProtocolHandler({\r\n        name,\r\n        address,\r\n        opReturnSchema,\r\n        handler,\r\n        scriptChecker,\r\n    }: Protocol) {\r\n        if (address) {\r\n            this.enabledProtocols.set(address, name)\r\n        }\r\n        this.protocolHandlers.set(name, handler)\r\n        if (opReturnSchema) {\r\n            this.protocolOpReturnSchemas.set(name, opReturnSchema)\r\n        }\r\n        if (scriptChecker) {\r\n            this.protocolScriptCheckers.set(name, scriptChecker)\r\n        }\r\n    }\r\n\r\n    transformTx = async (tx: BobTx | MomTx): Promise<BmapTx> => {\r\n        if (!tx || !tx['in'] || !tx['out']) {\r\n            throw new Error('Cannot process tx')\r\n        }\r\n\r\n        // This will become our nicely formatted response object\r\n        let dataObj: Partial<BobTx> = {}\r\n\r\n        for (const [key, val] of Object.entries(tx)) {\r\n            if (key === 'out') {\r\n                // loop over the outputs\r\n                for (const out of tx.out) {\r\n                    const { tape } = out\r\n\r\n                    // Process opReturn data\r\n                    if (tape?.some((cc) => checkOpReturn(cc))) {\r\n                        dataObj = await this.processDataProtocols(\r\n                            tape,\r\n                            out,\r\n                            tx,\r\n                            dataObj\r\n                        )\r\n                    }\r\n\r\n                    // No OP_FALSE OP_RETURN in this tape\r\n                    const boostChecker = this.protocolScriptCheckers.get(\r\n                        BOOST.name\r\n                    )\r\n                    const _21e8Checker = this.protocolScriptCheckers.get(\r\n                        _21E8.name\r\n                    )\r\n                    const ordChecker = this.protocolScriptCheckers.get(ORD.name)\r\n\r\n                    // Check for boostpow, 21e8, and ords\r\n                    if (\r\n                        tape?.some((cc) => {\r\n                            const { cell } = cc\r\n                            if (boostChecker && boostChecker(cell)) {\r\n                                // 'found boost'\r\n                                return true\r\n                            }\r\n                            if (_21e8Checker && _21e8Checker(cell)) {\r\n                                // 'found 21e8'\r\n                                return true\r\n                            }\r\n                            if (ordChecker && ordChecker(cell)) {\r\n                                // 'found 1sat ordinal'\r\n                                return true\r\n                            }\r\n                        })\r\n                    ) {\r\n                        // find the cell array\r\n                        // loop over tape\r\n                        for (const cellContainer of tape) {\r\n                            const { cell } = cellContainer\r\n                            // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\r\n                            if (!cell) {\r\n                                throw new Error('empty cell while parsing')\r\n                            }\r\n                            let protocolName = ''\r\n                            if (boostChecker && boostChecker(cell)) {\r\n                                protocolName = BOOST.name\r\n                            } else if (_21e8Checker && _21e8Checker(cell)) {\r\n                                protocolName = _21E8.name\r\n                            } else if (ordChecker && ordChecker(cell)) {\r\n                                protocolName = ORD.name\r\n                            } else {\r\n                                // nothing found\r\n                                continue\r\n                            }\r\n\r\n                            this.process(protocolName, {\r\n                                tx,\r\n                                cell,\r\n                                dataObj: dataObj as BmapTx,\r\n                                tape,\r\n                                out,\r\n                            })\r\n                        }\r\n                    }\r\n                }\r\n            } else if (key === 'in') {\r\n                // TODO: Boost check inputs to see if this is a tx solving a puzzle\r\n                // TODO: 21e8 check inputs to see if this is a tx solving a puzzle\r\n                dataObj[key] = val.map((v: In) => {\r\n                    const r = { ...v } as any\r\n                    delete r.tape\r\n                    return r as In\r\n                })\r\n            } else {\r\n                // known key, just write it retaining original type\r\n                dataObj[key] = val\r\n            }\r\n        }\r\n\r\n        // If this is a MOM planaria it will have metanet keys available\r\n        if (dataObj['METANET'] && (tx as MomTx).parent) {\r\n            const meta = {\r\n                ancestor: (tx as MomTx).ancestor,\r\n                parent: (tx as MomTx).parent,\r\n                child: (tx as MomTx).child,\r\n                head: (tx as MomTx).head,\r\n            } as MetaNet\r\n\r\n            ;(dataObj.METANET as MetaNet[]).push(meta)\r\n            // remove parent and node from root level for (MOM data)\r\n            delete dataObj.ancestor\r\n            delete dataObj.child\r\n            delete dataObj.parent\r\n            delete dataObj.head\r\n            delete dataObj.node\r\n        }\r\n\r\n        return dataObj as BmapTx\r\n    }\r\n\r\n    processUnknown = (key: string, dataObj: Partial<BmapTx>, out: Out) => {\r\n        // no known non-OP_RETURN scripts\r\n        if (key && !dataObj[key]) {\r\n            dataObj[key] = []\r\n        }\r\n\r\n        ;(dataObj[key] as Out[]).push({\r\n            i: out.i,\r\n            e: out.e,\r\n            tape: [],\r\n        })\r\n    }\r\n\r\n    process = async (\r\n        protocolName: string,\r\n        { cell, dataObj, tape, out, tx }: HandlerProps\r\n    ) => {\r\n        if (\r\n            this.protocolHandlers.has(protocolName) &&\r\n            typeof this.protocolHandlers.get(protocolName) === 'function'\r\n        ) {\r\n            const handler = this.protocolHandlers.get(protocolName)\r\n            if (handler) {\r\n                /* eslint-disable no-await-in-loop */\r\n                await handler({\r\n                    dataObj: dataObj,\r\n                    cell,\r\n                    tape,\r\n                    out,\r\n                    tx,\r\n                })\r\n            }\r\n        } else {\r\n            saveProtocolData(dataObj, protocolName, cell)\r\n        }\r\n    }\r\n\r\n    processDataProtocols = async (\r\n        tape: Tape[],\r\n        out: Out,\r\n        tx: BobTx,\r\n        dataObj: Partial<BobTx>\r\n    ): Promise<Partial<BobTx>> => {\r\n        // loop over tape\r\n        for (const cellContainer of tape) {\r\n            const { cell } = cellContainer\r\n            if (!cell) {\r\n                throw new Error('empty cell while parsing')\r\n            }\r\n\r\n            // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\r\n            if (checkOpFalseOpReturn(cellContainer)) {\r\n                continue\r\n            }\r\n\r\n            const prefix = cell[0].s\r\n\r\n            if (prefix) {\r\n                const bitcomProtocol =\r\n                    this.enabledProtocols.get(prefix) ||\r\n                    defaultProtocols.filter((p) => p.name === prefix)[0]?.name\r\n                if (bitcomProtocol) {\r\n                    await this.process(bitcomProtocol, {\r\n                        cell,\r\n                        dataObj: dataObj as BmapTx,\r\n                        tape,\r\n                        out,\r\n                        tx,\r\n                    })\r\n                } else {\r\n                    this.processUnknown(prefix, dataObj, out)\r\n                }\r\n            }\r\n        }\r\n        return dataObj\r\n    }\r\n}\r\n\r\nexport const fetchRawTx = async (txid: string): Promise<string> => {\r\n    const url = 'https://api.whatsonchain.com/v1/bsv/main/tx/' + txid + '/hex'\r\n\r\n    console.log('hitting', url)\r\n\r\n    const res = await fetch(url)\r\n    return await res.text()\r\n}\r\n\r\nexport const bobFromRawTx = async (rawTx: string): Promise<BobTx> => {\r\n    const bpuTx = await parse({\r\n        tx: { r: rawTx },\r\n        split: [\r\n            {\r\n                token: { op: 106 },\r\n                include: 'l',\r\n            },\r\n            {\r\n                token: { s: '|' },\r\n            },\r\n        ],\r\n    })\r\n    return bpuTx as BobTx\r\n}\r\n\r\n// TransformTx\r\n// tx - a raw hex string or a Bob/Bmap/Mom transaction object\r\n// protocols - the handlers you want to load and use to process the tx\r\n// reducing the number of supported protocols may improve transform speed\r\n// at the expense of detecting more data protocols\r\nexport const TransformTx = async (\r\n    tx: BobTx | string | MomTx | BmapTx,\r\n    protocols?: string[] | Protocol[]\r\n) => {\r\n    if (typeof tx === 'string') {\r\n        let rawTx: string | undefined\r\n        // if it a txid or  complete transaction hex?\r\n        if (tx.length === 64) {\r\n            // txid - fetch raw tx\r\n            rawTx = await fetchRawTx(tx)\r\n        }\r\n\r\n        if (Buffer.from(tx).byteLength <= 146) {\r\n            throw new Error('Invalid rawTx')\r\n        }\r\n\r\n        if (!rawTx) {\r\n            rawTx = tx\r\n        }\r\n\r\n        // TODO: Double check 146 is intended to be minimum possible byte length for a tx\r\n        const bobTx = await bobFromRawTx(rawTx)\r\n\r\n        if (bobTx) {\r\n            tx = bobTx\r\n        } else {\r\n            throw new Error(`Invalid txid`)\r\n        }\r\n    }\r\n\r\n    const b = new BMAP()\r\n\r\n    // if protocols are specified\r\n    if (protocols) {\r\n        // wipe out defaults\r\n        b.enabledProtocols.clear()\r\n        if (isStringArray(protocols)) {\r\n            // set enabled protocols\r\n            for (const protocol of allProtocols) {\r\n                if ((protocols as string[])?.includes(protocol.name)) {\r\n                    b.addProtocolHandler(protocol)\r\n                }\r\n            }\r\n        } else if (isObjectArray(protocols)) {\r\n            for (const p of protocols) {\r\n                const protocol = p as Protocol\r\n                if (protocol) {\r\n                    b.addProtocolHandler(protocol)\r\n                }\r\n            }\r\n        } else {\r\n            throw new Error(\r\n                `Invalid protocol array. Must be either an array of protocol names (string[]), or Protocol objects (Protocol[]).`\r\n            )\r\n        }\r\n    }\r\n\r\n    return b.transformTx(tx)\r\n}\r\n"],"names":[],"version":3,"file":"index.d.ts.map","sourceRoot":"../"}