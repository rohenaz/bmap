{"mappings":";ASuCA;IACI,WAAW,EAAE,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAA;IAEhC,gBAAgB,EAAE,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA;IAEtC,oBAAoB,EAAE,GAAG,CAAC,MAAM,EAAE,MAAM,EAAE,CAAC,CAAA;;IAS3C,kBAAkB,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE,WAAW,EAAE,OAAO,EAAE,EAAE,QAAQ;IAUpE,WAAW,OAAc,KAAK,GAAG,KAAK,KAAG,QAAQ,MAAM,CAAC,CA0HvD;IAED,OAAO,qCAA4C,YAAY,mBAwB9D;CACJ;AAED,OAAO,MAAM,kBAAyB,KAAK,oBAG1C,CAAA","sources":["src/types/protocols/symre.ts","src/src/utils.ts","src/src/protocols/aip.ts","src/src/protocols/b.ts","src/src/protocols/bap.ts","src/src/protocols/boost.ts","src/src/protocols/map.ts","src/src/protocols/metanet.ts","src/src/protocols/_21e8.ts","src/src/bmap.ts","src/bmap.ts"],"sourcesContent":[null,null,null,null,null,null,null,null,null,null,"// import default protocols\nimport {\n    BmapTx,\n    BobTx,\n    Handler,\n    HandlerProps,\n    In,\n    MetaNet,\n    MomTx,\n    Out,\n    Protocol,\n} from '../types/common'\nimport { AIP } from './protocols/aip'\nimport { B } from './protocols/b'\nimport { BAP } from './protocols/bap'\nimport { checkBoostpow } from './protocols/boost'\nimport { MAP } from './protocols/map'\nimport { METANET } from './protocols/metanet'\nimport { check21e8 } from './protocols/_21e8'\nimport { checkOpFalseOpReturn, saveProtocolData } from './utils'\n\nconst protocolMap = new Map<string, string>([])\nconst protocolHandlers = new Map<string, Handler>()\nconst protocolQuerySchemas = new Map<string, Object[]>()\n\nconst defaultProtocols = [AIP, B, BAP, MAP, METANET]\n\n// prepare protocol map, handlers and schemas\ndefaultProtocols.forEach((protocol) => {\n    if (protocol.address) {\n        protocolMap.set(protocol.address, protocol.name)\n    }\n    protocolHandlers.set(protocol.name, protocol.handler)\n    if (protocol.querySchema) {\n        protocolQuerySchemas.set(protocol.name, protocol.querySchema)\n    }\n})\n\n// Takes a BOB formatted op_return transaction\nexport class BMAP {\n    protocolMap: Map<string, string>\n\n    protocolHandlers: Map<string, Handler>\n\n    protocolQuerySchemas: Map<string, Object[]>\n\n    constructor() {\n        // initial default protocol handlers in this instantiation\n        this.protocolMap = protocolMap\n        this.protocolHandlers = protocolHandlers\n        this.protocolQuerySchemas = protocolQuerySchemas\n    }\n\n    addProtocolHandler({ name, address, querySchema, handler }: Protocol) {\n        if (address) {\n            this.protocolMap.set(address, name)\n        }\n        this.protocolHandlers.set(name, handler)\n        if (querySchema) {\n            this.protocolQuerySchemas.set(name, querySchema)\n        }\n    }\n\n    transformTx = async (tx: BobTx | MomTx): Promise<BmapTx> => {\n        if (!tx || !tx['in'] || !tx['out']) {\n            throw new Error('Cannot process tx')\n        }\n\n        // This will become our nicely formatted response object\n        const dataObj: Partial<BmapTx> = {}\n\n        for (const [key, val] of Object.entries(tx)) {\n            if (key === 'out') {\n                // loop over the outputs\n                for (const out of tx.out) {\n                    const { tape } = out\n\n                    if (tape?.some((cc) => checkOpFalseOpReturn(cc))) {\n                        // loop over tape\n                        for (const cellContainer of tape) {\n                            // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n                            if (checkOpFalseOpReturn(cellContainer)) {\n                                continue\n                            }\n\n                            const { cell } = cellContainer\n                            if (!cell) {\n                                throw new Error('empty cell while parsing')\n                            }\n\n                            await this.process({\n                                cell,\n                                dataObj: dataObj as BmapTx,\n                                tape,\n                                out,\n                                tx,\n                            })\n                        }\n                    } else {\n                        // No OP_RETURN in this tape\n\n                        // Check for boostpow and 21e8\n                        if (\n                            tape?.some((cc) => {\n                                const { cell } = cc\n                                if (\n                                    this.protocolMap.has('BOOST') &&\n                                    checkBoostpow(cell)\n                                ) {\n                                    return true\n                                }\n                                if (\n                                    this.protocolMap.has('21E8') &&\n                                    check21e8(cell)\n                                ) {\n                                    return true\n                                }\n                            })\n                        ) {\n                            // find the cell array\n                            // loop over tape\n                            for (const cellContainer of tape) {\n                                const { cell } = cellContainer\n                                // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n                                if (checkBoostpow(cell) || check21e8(cell)) {\n                                    if (!cell) {\n                                        throw new Error(\n                                            'empty cell while parsing'\n                                        )\n                                    }\n                                    this.process({\n                                        tx,\n                                        cell,\n                                        dataObj: dataObj as BmapTx,\n                                        tape,\n                                        out,\n                                    })\n                                }\n                            }\n                        } else {\n                            // no known non-OP_RETURN scripts\n                            if (key && !dataObj[key]) {\n                                dataObj[key] = []\n                            }\n\n                            ;(dataObj[key] as Out[]).push({\n                                i: out.i,\n                                e: out.e,\n                            })\n                        }\n                    }\n                }\n            } else if (key === 'in') {\n                // TODO: Boost check inputs to see if this is a tx solving a puzzle\n                // TODO: 21e8 check inputs to see if this is a tx solving a puzzle\n                dataObj[key] = val.map((v: In) => {\n                    const r = { ...v }\n                    delete r.tape\n                    return r\n                })\n            } else {\n                // known key, just write it retaining original type\n                dataObj[key] = val\n            }\n        }\n\n        // If this is a MOM planaria it will have metanet keys available\n        if (dataObj['METANET'] && (tx as MomTx).parent) {\n            const meta = {\n                ancestor: (tx as MomTx).ancestor,\n                parent: (tx as MomTx).parent,\n                child: (tx as MomTx).child,\n                head: (tx as MomTx).head,\n            } as MetaNet\n\n            ;(dataObj.METANET as MetaNet[]).push(meta)\n            // remove parent and node from root level for (MOM data)\n            delete dataObj.ancestor\n            delete dataObj.child\n            delete dataObj.parent\n            delete dataObj.head\n            delete dataObj.node\n        }\n\n        return dataObj as BmapTx\n    }\n\n    process = async ({ cell, dataObj, tape, out, tx }: HandlerProps) => {\n        // Get protocol name from prefix\n        const prefix = cell[0].s as string\n\n        const protocolName = this.protocolMap.get(prefix) || prefix\n\n        if (\n            this.protocolHandlers.has(protocolName) &&\n            typeof this.protocolHandlers.get(protocolName) === 'function'\n        ) {\n            const handler = this.protocolHandlers.get(protocolName)\n            if (handler) {\n                /* eslint-disable no-await-in-loop */\n                await handler({\n                    dataObj: dataObj,\n                    cell,\n                    tape,\n                    out,\n                    tx,\n                })\n            }\n        } else {\n            saveProtocolData(dataObj, protocolName, cell)\n        }\n    }\n}\n\nexport const TransformTx = async (tx: BobTx) => {\n    const b = new BMAP()\n    return b.transformTx(tx)\n}\n"],"names":[],"version":3,"file":"index.d.ts.map","sourceRoot":"../"}