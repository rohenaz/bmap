{"mappings":";;AiByCA,OAAO,MAAM;;;;;;;IAeZ,CAAC;AAEF,OAAO,MAAM,4BAAoD,CAAC;AAClE,OAAO,MAAM,4BAAmD,CAAC;AAiBjE;IACC,gBAAgB,EAAE,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IAEtC,gBAAgB,EAAE,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IAEvC,sBAAsB,EAAE,GAAG,CAAC,MAAM,EAAE,aAAa,CAAC,CAAC;IAEnD,uBAAuB,EAAE,GAAG,CAAC,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC;;IAU/C,kBAAkB,CAAC,EAClB,IAAI,EACJ,OAAO,EACP,cAAc,EACd,OAAO,EACP,aAAa,GACb,EAAE,QAAQ;IAaX,WAAW,OAAc,KAAK,GAAG,KAAK,KAAG,QAAQ,MAAM,CAAC,CA+FtD;IAEF,cAAc,QAAS,MAAM,WAAW,QAAQ,MAAM,CAAC,OAAO,GAAG,UAU/D;IAEF,OAAO,iBACQ,MAAM,oCACc,YAAY,mBAoB7C;IAEF,oBAAoB,SACb,IAAI,EAAE,OACP,GAAG,MACJ,KAAK,WACA,QAAQ,KAAK,CAAC,KACrB,QAAQ,QAAQ,KAAK,CAAC,CAAC,CAiCxB;CACF;AAED,OAAO,MAAM,mBAA0B,MAAM,KAAG,QAAQ,MAAM,CAO7D,CAAC;AAEF,OAAO,MAAM,sBAA6B,MAAM,KAAG,QAAQ,KAAK,CAc/D,CAAC;AAOF,OAAO,MAAM,kBACR,KAAK,GAAG,MAAM,GAAG,KAAK,GAAG,MAAM,cACvB,MAAM,EAAE,GAAG,QAAQ,EAAE,oBAwDjC,CAAC","sources":["src/types/protocols/symre.ts","src/src/utils.ts","src/src/protocols/_21e8.ts","src/src/protocols/aip.ts","src/src/protocols/b.ts","src/src/protocols/bap.ts","src/src/protocols/bitcom.ts","src/src/utils/signatureVerification.ts","src/src/protocols/bitcomHashed.ts","src/src/protocols/bitkey.ts","src/src/protocols/bitpic.ts","src/src/protocols/haip.ts","src/src/protocols/map.ts","src/src/protocols/metanet.ts","src/src/protocols/ord.ts","src/src/protocols/ron.ts","src/src/protocols/symre.ts","src/src/bmap.ts","src/bmap.ts"],"sourcesContent":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"import { type In, type Out, type Tape, parse } from \"bpu-ts\";\nimport type {\n\tBmapTx,\n\tBobTx,\n\tHandler,\n\tHandlerProps,\n\tMetaNet,\n\tMomTx,\n\tProtocol,\n\tScriptChecker,\n} from \"../types/common\";\nimport { _21E8 } from \"./protocols/_21e8\";\nimport { AIP } from \"./protocols/aip\";\nimport { B } from \"./protocols/b\";\nimport { BAP } from \"./protocols/bap\";\nimport { BITCOM } from \"./protocols/bitcom\";\nimport { BITCOM_HASHED } from \"./protocols/bitcomHashed\";\nimport { BITKEY } from \"./protocols/bitkey\";\nimport { BITPIC } from \"./protocols/bitpic\";\nimport { HAIP } from \"./protocols/haip\";\nimport { MAP } from \"./protocols/map\";\nimport { METANET } from \"./protocols/metanet\";\nimport { ORD } from \"./protocols/ord\";\nimport { RON } from \"./protocols/ron\";\nimport { SYMRE } from \"./protocols/symre\";\nimport {\n\tcheckOpFalseOpReturn,\n\tcheckOpReturn,\n\tisObjectArray,\n\tisStringArray,\n\tsaveProtocolData,\n} from \"./utils\";\n\n// Names of enabled protocols\nconst enabledProtocols = new Map<string, string>([]);\n// Protocol Handlers\nconst protocolHandlers = new Map<string, Handler>([]);\n// Script checkers are intentionally minimalistic detection functions for identifying matching scripts for a given protocol. Only if a checker returns true is a handler called for processing.\nconst protocolScriptCheckers = new Map<string, ScriptChecker>([]);\nconst protocolOpReturnSchemas = new Map<string, Object[]>();\n\nexport const allProtocols = [\n\tAIP,\n\tB,\n\tBAP,\n\tMAP,\n\tMETANET,\n\t_21E8,\n\tBITCOM,\n\tBITKEY,\n\tBITPIC,\n\tHAIP,\n\tBITCOM_HASHED,\n\tRON,\n\tSYMRE,\n\tORD,\n];\n\nexport const supportedProtocols = allProtocols.map((p) => p.name);\nexport const defaultProtocols = [AIP, B, BAP, MAP, METANET, ORD];\n\n// prepare protocol map, handlers and schemas\nfor (const protocol of defaultProtocols) {\n\tif (protocol.address) {\n\t\tenabledProtocols.set(protocol.address, protocol.name);\n\t}\n\tprotocolHandlers.set(protocol.name, protocol.handler);\n\tif (protocol.opReturnSchema) {\n\t\tprotocolOpReturnSchemas.set(protocol.name, protocol.opReturnSchema);\n\t}\n\tif (protocol.scriptChecker) {\n\t\tprotocolScriptCheckers.set(protocol.name, protocol.scriptChecker);\n\t}\n}\n\n// Takes a BOB formatted op_return transaction\nexport class BMAP {\n\tenabledProtocols: Map<string, string>;\n\n\tprotocolHandlers: Map<string, Handler>;\n\n\tprotocolScriptCheckers: Map<string, ScriptChecker>;\n\n\tprotocolOpReturnSchemas: Map<string, Object[]>;\n\n\tconstructor() {\n\t\t// initial default protocol handlers in this instantiation\n\t\tthis.enabledProtocols = enabledProtocols;\n\t\tthis.protocolHandlers = protocolHandlers;\n\t\tthis.protocolScriptCheckers = protocolScriptCheckers;\n\t\tthis.protocolOpReturnSchemas = protocolOpReturnSchemas;\n\t}\n\n\taddProtocolHandler({\n\t\tname,\n\t\taddress,\n\t\topReturnSchema,\n\t\thandler,\n\t\tscriptChecker,\n\t}: Protocol) {\n\t\tif (address) {\n\t\t\tthis.enabledProtocols.set(address, name);\n\t\t}\n\t\tthis.protocolHandlers.set(name, handler);\n\t\tif (opReturnSchema) {\n\t\t\tthis.protocolOpReturnSchemas.set(name, opReturnSchema);\n\t\t}\n\t\tif (scriptChecker) {\n\t\t\tthis.protocolScriptCheckers.set(name, scriptChecker);\n\t\t}\n\t}\n\n\ttransformTx = async (tx: BobTx | MomTx): Promise<BmapTx> => {\n\t\tif (!tx || !tx.in || !tx.out) {\n\t\t\tthrow new Error(\"Cannot process tx\");\n\t\t}\n\n\t\t// This will become our nicely formatted response object\n\t\tlet dataObj: Partial<BobTx> = {};\n\n\t\tfor (const [key, val] of Object.entries(tx)) {\n\t\t\tif (key === \"out\") {\n\t\t\t\t// loop over the outputs\n\t\t\t\tfor (const out of tx.out) {\n\t\t\t\t\tconst { tape } = out;\n\n\t\t\t\t\t// Process opReturn data\n\t\t\t\t\tif (tape?.some((cc) => checkOpReturn(cc))) {\n\t\t\t\t\t\tdataObj = await this.processDataProtocols(tape, out, tx, dataObj);\n\t\t\t\t\t}\n\n\t\t\t\t\t// No OP_FALSE OP_RETURN in this tape\n\t\t\t\t\tconst _21e8Checker = this.protocolScriptCheckers.get(_21E8.name);\n\t\t\t\t\tconst ordChecker = this.protocolScriptCheckers.get(ORD.name);\n\n\t\t\t\t\t// Check for 21e8 and ords\n\t\t\t\t\tif (\n\t\t\t\t\t\ttape?.some((cc) => {\n\t\t\t\t\t\t\tconst { cell } = cc;\n\t\t\t\t\t\t\tif (_21e8Checker?.(cell)) {\n\t\t\t\t\t\t\t\t// 'found 21e8'\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ordChecker?.(cell)) {\n\t\t\t\t\t\t\t\t// 'found 1sat ordinal'\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t) {\n\t\t\t\t\t\t// find the cell array\n\t\t\t\t\t\t// loop over tape\n\t\t\t\t\t\tfor (const cellContainer of tape) {\n\t\t\t\t\t\t\tconst { cell } = cellContainer;\n\t\t\t\t\t\t\t// Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n\t\t\t\t\t\t\tif (!cell) {\n\t\t\t\t\t\t\t\tthrow new Error(\"empty cell while parsing\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet protocolName = \"\";\n\t\t\t\t\t\t\tif (_21e8Checker?.(cell)) {\n\t\t\t\t\t\t\t\tprotocolName = _21E8.name;\n\t\t\t\t\t\t\t} else if (ordChecker?.(cell)) {\n\t\t\t\t\t\t\t\tprotocolName = ORD.name;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// nothing found\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.process(protocolName, {\n\t\t\t\t\t\t\t\ttx,\n\t\t\t\t\t\t\t\tcell,\n\t\t\t\t\t\t\t\tdataObj: dataObj as BmapTx,\n\t\t\t\t\t\t\t\ttape,\n\t\t\t\t\t\t\t\tout,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (key === \"in\") {\n\t\t\t\tdataObj[key] = val.map((v: In) => {\n\t\t\t\t\tconst r = { ...v } as any;\n\t\t\t\t\tdelete r.tape;\n\t\t\t\t\treturn r as In;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// known key, just write it retaining original type\n\t\t\t\tdataObj[key] = val;\n\t\t\t}\n\t\t}\n\n\t\t// If this is a MOM planaria it will have metanet keys available\n\t\tif (dataObj.METANET && (tx as MomTx).parent) {\n\t\t\tconst meta = {\n\t\t\t\tancestor: (tx as MomTx).ancestor,\n\t\t\t\tparent: (tx as MomTx).parent,\n\t\t\t\tchild: (tx as MomTx).child,\n\t\t\t\thead: (tx as MomTx).head,\n\t\t\t} as MetaNet;\n\t\t\t(dataObj.METANET as MetaNet[]).push(meta);\n\t\t\t// remove parent and node from root level for (MOM data)\n\t\t\tdelete dataObj.ancestor;\n\t\t\tdelete dataObj.child;\n\t\t\tdelete dataObj.parent;\n\t\t\tdelete dataObj.head;\n\t\t\tdelete dataObj.node;\n\t\t}\n\n\t\treturn dataObj as BmapTx;\n\t};\n\n\tprocessUnknown = (key: string, dataObj: Partial<BmapTx>, out: Out) => {\n\t\t// no known non-OP_RETURN scripts\n\t\tif (key && !dataObj[key]) {\n\t\t\tdataObj[key] = [];\n\t\t}\n\t\t(dataObj[key] as Out[]).push({\n\t\t\ti: out.i,\n\t\t\te: out.e,\n\t\t\ttape: [],\n\t\t});\n\t};\n\n\tprocess = async (\n\t\tprotocolName: string,\n\t\t{ cell, dataObj, tape, out, tx }: HandlerProps,\n\t) => {\n\t\tif (\n\t\t\tthis.protocolHandlers.has(protocolName) &&\n\t\t\ttypeof this.protocolHandlers.get(protocolName) === \"function\"\n\t\t) {\n\t\t\tconst handler = this.protocolHandlers.get(protocolName);\n\t\t\tif (handler) {\n\t\t\t\t/* eslint-disable no-await-in-loop */\n\t\t\t\tawait handler({\n\t\t\t\t\tdataObj: dataObj,\n\t\t\t\t\tcell,\n\t\t\t\t\ttape,\n\t\t\t\t\tout,\n\t\t\t\t\ttx,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tsaveProtocolData(dataObj, protocolName, cell);\n\t\t}\n\t};\n\n\tprocessDataProtocols = async (\n\t\ttape: Tape[],\n\t\tout: Out,\n\t\ttx: BobTx,\n\t\tdataObj: Partial<BobTx>,\n\t): Promise<Partial<BobTx>> => {\n\t\t// loop over tape\n\t\tfor (const cellContainer of tape) {\n\t\t\tconst { cell } = cellContainer;\n\t\t\tif (!cell) {\n\t\t\t\tthrow new Error(\"empty cell while parsing\");\n\t\t\t}\n\n\t\t\t// Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n\t\t\tif (checkOpFalseOpReturn(cellContainer)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst prefix = cell[0].s;\n\n\t\t\tif (prefix) {\n\t\t\t\tconst bitcomProtocol =\n\t\t\t\t\tthis.enabledProtocols.get(prefix) ||\n\t\t\t\t\tdefaultProtocols.filter((p) => p.name === prefix)[0]?.name;\n\t\t\t\tif (bitcomProtocol) {\n\t\t\t\t\tawait this.process(bitcomProtocol, {\n\t\t\t\t\t\tcell,\n\t\t\t\t\t\tdataObj: dataObj as BmapTx,\n\t\t\t\t\t\ttape,\n\t\t\t\t\t\tout,\n\t\t\t\t\t\ttx,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthis.processUnknown(prefix, dataObj, out);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dataObj;\n\t};\n}\n\nexport const fetchRawTx = async (txid: string): Promise<string> => {\n\tconst url = `https://api.whatsonchain.com/v1/bsv/main/tx/${txid}/hex`;\n\n\tconsole.log(\"hitting\", url);\n\n\tconst res = await fetch(url);\n\treturn await res.text();\n};\n\nexport const bobFromRawTx = async (rawTx: string): Promise<BobTx> => {\n\tconst bpuTx = await parse({\n\t\ttx: { r: rawTx },\n\t\tsplit: [\n\t\t\t{\n\t\t\t\ttoken: { op: 106 },\n\t\t\t\tinclude: \"l\",\n\t\t\t},\n\t\t\t{\n\t\t\t\ttoken: { s: \"|\" },\n\t\t\t},\n\t\t],\n\t});\n\treturn bpuTx as BobTx;\n};\n\n// TransformTx\n// tx - a raw hex string or a Bob/Bmap/Mom transaction object\n// protocols - the handlers you want to load and use to process the tx\n// reducing the number of supported protocols may improve transform speed\n// at the expense of detecting more data protocols\nexport const TransformTx = async (\n\ttx: BobTx | string | MomTx | BmapTx,\n\tprotocols?: string[] | Protocol[],\n) => {\n\tif (typeof tx === \"string\") {\n\t\tlet rawTx: string | undefined;\n\t\t// if it a txid or  complete transaction hex?\n\t\tif (tx.length === 64) {\n\t\t\t// txid - fetch raw tx\n\t\t\trawTx = await fetchRawTx(tx);\n\t\t}\n\n\t\tif (Buffer.from(tx).byteLength <= 146) {\n\t\t\tthrow new Error(\"Invalid rawTx\");\n\t\t}\n\n\t\tif (!rawTx) {\n\t\t\trawTx = tx;\n\t\t}\n\n\t\t// TODO: Double check 146 is intended to be minimum possible byte length for a tx\n\t\tconst bobTx = await bobFromRawTx(rawTx);\n\n\t\tif (bobTx) {\n\t\t\ttx = bobTx;\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid txid\");\n\t\t}\n\t}\n\n\tconst b = new BMAP();\n\n\t// if protocols are specified\n\tif (protocols) {\n\t\t// wipe out defaults\n\t\tb.enabledProtocols.clear();\n\t\tif (isStringArray(protocols)) {\n\t\t\t// set enabled protocols\n\t\t\tfor (const protocol of allProtocols) {\n\t\t\t\tif ((protocols as string[])?.includes(protocol.name)) {\n\t\t\t\t\tb.addProtocolHandler(protocol);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObjectArray(protocols)) {\n\t\t\tfor (const p of protocols) {\n\t\t\t\tconst protocol = p as Protocol;\n\t\t\t\tif (protocol) {\n\t\t\t\t\tb.addProtocolHandler(protocol);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t\"Invalid protocol array. Must be either an array of protocol names (string[]), or Protocol objects (Protocol[]).\",\n\t\t\t);\n\t\t}\n\t}\n\n\treturn b.transformTx(tx);\n};\n"],"names":[],"version":3,"file":"index.d.ts.map","sourceRoot":"../"}