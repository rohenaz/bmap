{"mappings":"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","sources":["src/utils.ts","src/protocols/aip.ts","src/protocols/b.ts","src/protocols/bap.ts","src/protocols/haip.ts","src/protocols/map.ts","src/protocols/metanet.ts","src/paymail.ts","src/protocols/psp.ts","src/bmap.ts"],"sourcesContent":["import { Buffer } from 'buffer'\nimport { webcrypto } from 'crypto'\nimport { BobTx, Cell, Tape } from '../types/common'\n\n/**\n * returns the BOB cell value for a given encoding\n *\n * @param pushData\n * @param schemaEncoding\n * @returns {string|number}\n */\nexport const cellValue = (\n    pushData: Cell,\n    schemaEncoding: string\n): string | number => {\n    if (!pushData) {\n        throw new Error(`cannot get cell value of: ${pushData}`)\n    } else if (schemaEncoding === 'string') {\n        return pushData['s'] ? pushData.s : pushData.ls || ''\n    } else if (schemaEncoding === 'hex') {\n        return pushData['h'] ? pushData.h : pushData.lh || ''\n    } else if (schemaEncoding === 'number') {\n        return parseInt(pushData['h'] ? pushData.h : pushData.lh || '0', 16)\n    } else if (schemaEncoding === 'file') {\n        return `bitfs://${pushData['f'] ? pushData.f : pushData.lf}`\n    }\n\n    return (pushData['b'] ? pushData.b : pushData.lb) || ''\n}\n\n/**\n * Check a cell starts with OP_FALSE OP_RETURN -or- OP_RETURN\n *\n * @param cc\n * @returns {boolean}\n */\nexport const checkOpFalseOpReturn = function (cc: Tape) {\n    return (\n        (cc.cell[0] &&\n            cc.cell[1] &&\n            cc.cell[0].op === 0 &&\n            cc.cell[1].op &&\n            cc.cell[1].op === 106) ||\n        cc.cell[0].op === 106\n    )\n}\n\n/**\n * Helper function to store protocol data\n *\n * @param dataObj\n * @param protocolName\n * @param data\n */\nexport const saveProtocolData = (\n    dataObj: { [key: string]: any },\n    protocolName: string,\n    data: any\n) => {\n    if (!dataObj[protocolName]) {\n        dataObj[protocolName] = [data]\n    } else {\n        if (!Array.isArray(dataObj[protocolName])) {\n            const prevData = dataObj[protocolName]\n            dataObj[protocolName] = []\n            dataObj[protocolName][0] = prevData\n        }\n        dataObj[protocolName][dataObj[protocolName].length] = data\n    }\n}\n\n/**\n * BMAP default handler to work with query schema's\n *\n * @param querySchema\n * @param protocolName\n * @param dataObj\n * @param cell\n * @param tape\n * @param tx\n */\nexport const bmapQuerySchemaHandler = function (\n    protocolName: string,\n    querySchema: Object[],\n    dataObj: Object,\n    cell: Cell[],\n    tape: Tape[],\n    tx: BobTx\n) {\n    // loop over the schema\n    const obj: { [key: string]: any } = {}\n\n    // Does not have the required number of fields\n    const length = querySchema.length + 1\n    if (cell.length < length) {\n        throw new Error(\n            `${protocolName} requires at least ${length} fields including the prefix: ${tx.tx.h}`\n        )\n    }\n\n    for (const [idx, schemaField] of Object.entries(querySchema)) {\n        const x = parseInt(idx, 10)\n\n        const [field] = Object.keys(schemaField)\n        const [schemaEncoding] = Object.values(schemaField)\n        obj[field] = cellValue(cell[x + 1], schemaEncoding)\n    }\n\n    saveProtocolData(dataObj, protocolName, obj)\n}\n\n/**\n * Check whether the given data is base64\n *\n * @param data\n * @returns {boolean}\n */\nexport const isBase64 = function (data: string) {\n    const regex =\n        '(?:[A-Za-z0-9+\\\\/]{4})*(?:[A-Za-z0-9+\\\\/]{2}==|[A-Za-z0-9+/]{3}=)?'\n    return new RegExp(`^${regex}$`, 'gi').test(data)\n}\n\n// hashes a message buffer, returns the hash as a buffer\nexport const sha256 = async (msgBuffer: Buffer) => {\n    // what mbn was doing\n    // $.checkArgument(Buffer.isBuffer(buf))\n    // return crypto.createHash('sha256').update(buf).digest()\n    // and from there...\n    // createHash('sha256').update(buf).digest()\n\n    // original call from bmap\n    // bsv.crypto.Hash.sha256(Buffer.from(dataBuffer.toString('hex'))).toString('hex');\n\n    // Convert Buffer to ArrayBuffer\n    // let ab = msgBuffer.buffer.slice(\n    //     msgBuffer.byteOffset,\n    //     msgBuffer.byteOffset + msgBuffer.byteLength\n    // )\n\n    // const hashBuffer = await webcrypto.subtle.digest(\n    //     'SHA-256',\n    //     Buffer.from(msgBuffer.toString('hex'))\n    // )\n\n    // final?\n\n    const hash = await (webcrypto || window.crypto).subtle.digest(\n        'SHA-256',\n        msgBuffer\n    )\n    return Buffer.from(hash)\n}\n","import { Address, Bsm, Script } from '@ts-bitcoin/core'\nimport { Buffer } from 'buffer'\nimport fetch from 'node-fetch'\nimport { BobTx, Cell, HandlerProps, Tape } from '../../types/common'\nimport { AIP as AIPType } from '../../types/protocols/aip'\n\nimport {\n    cellValue,\n    checkOpFalseOpReturn,\n    isBase64,\n    saveProtocolData,\n    sha256,\n} from '../utils'\n\nconst address = '15PciHG22SNLQJXMoSUaWVi7WSqc7hCfva'\n\nconst querySchema = [\n    { algorithm: 'string' },\n    { address: 'string' },\n    { signature: 'binary' },\n    [{ index: 'binary' }],\n]\n\nconst getFileBuffer = async function (bitfsRef: string) {\n    let fileBuffer = Buffer.from('')\n    try {\n        const result = await fetch(`https://x.bitfs.network/${bitfsRef}`, {})\n        fileBuffer = await result.buffer()\n    } catch (e) {\n        console.error(e)\n    }\n\n    return fileBuffer\n}\n\nconst validateSignature = async function (\n    aipObj: Partial<AIPType>,\n    cell: Cell[],\n    tape: Tape[]\n): Promise<boolean> {\n    if (!Array.isArray(tape) || tape.length < 3) {\n        throw new Error('AIP requires at least 3 cells including the prefix')\n    }\n\n    let cellIndex = -1\n    tape.forEach((cc, index) => {\n        if (cc.cell === cell) {\n            cellIndex = index\n        }\n    })\n    if (cellIndex === -1) {\n        throw new Error('AIP could not find cell in tape')\n    }\n\n    let usingIndexes: number[] = aipObj.index || []\n    const signatureValues = ['6a'] // OP_RETURN - is included in AIP\n    for (let i = 0; i < cellIndex; i++) {\n        const cellContainer = tape[i]\n        if (!checkOpFalseOpReturn(cellContainer)) {\n            for (let nc = 0; nc < cellContainer.cell.length; nc++) {\n                const statement = cellContainer.cell[nc]\n                // add the value as hex\n                if (statement.h) {\n                    signatureValues.push(statement.h)\n                } else if (statement.f) {\n                    // file reference - we need to get the file from bitfs\n                    const fileBuffer = await getFileBuffer(statement.f)\n                    signatureValues.push(fileBuffer.toString('hex'))\n                } else if (statement.b) {\n                    // no hex? try base64\n                    signatureValues.push(\n                        Buffer.from(statement.b, 'base64').toString('hex')\n                    )\n                } else {\n                    if (statement.s) {\n                        signatureValues.push(\n                            Buffer.from(statement.s).toString('hex')\n                        )\n                    }\n                }\n            }\n            signatureValues.push('7c') // | hex\n        }\n    }\n\n    if (aipObj.hashing_algorithm) {\n        // when using HAIP, we need to parse the indexes in a non standard way\n        // indexLength is byte size of the indexes being described\n        if (aipObj.index_unit_size) {\n            const indexLength = aipObj.index_unit_size * 2\n            usingIndexes = []\n            const indexes = cell[6].h as string\n            for (let i = 0; i < indexes.length; i += indexLength) {\n                usingIndexes.push(parseInt(indexes.substr(i, indexLength), 16))\n            }\n            aipObj.index = usingIndexes\n        }\n    }\n\n    const signatureBufferStatements: Buffer[] = []\n    // check whether we need to only sign some indexes\n    if (usingIndexes.length > 0) {\n        usingIndexes.forEach((index) => {\n            signatureBufferStatements.push(\n                Buffer.from(signatureValues[index], 'hex')\n            )\n        })\n    } else {\n        // add all the values to the signature buffer\n        signatureValues.forEach((statement) => {\n            signatureBufferStatements.push(Buffer.from(statement, 'hex'))\n        })\n    }\n\n    let messageBuffer: Buffer | string\n    if (aipObj.hashing_algorithm) {\n        // this is actually Hashed-AIP (HAIP) and works a bit differently\n        if (!aipObj.index_unit_size) {\n            // remove OP_RETURN - will be added by Script.buildDataOut\n            signatureBufferStatements.shift()\n        }\n        const dataScript = Script.fromSafeDataArray(signatureBufferStatements)\n        let dataBuffer = Buffer.from(dataScript.toHex(), 'hex')\n        if (aipObj.index_unit_size) {\n            // the indexed buffer should not contain the OP_RETURN opcode, but this\n            // is added by the buildDataOut function automatically. Remove it.\n            dataBuffer = dataBuffer.slice(1)\n        }\n        messageBuffer = await sha256(Buffer.from(dataBuffer.toString('hex')))\n    } else {\n        // regular AIP\n        messageBuffer = Buffer.concat([...signatureBufferStatements])\n    }\n\n    // verify aip signature\n    try {\n        aipObj.verified = Bsm.verify(\n            messageBuffer,\n            aipObj.signature || '',\n            Address.fromString(aipObj.address || '') ||\n                Address.fromString(aipObj.signing_address || '')\n        )\n    } catch (e) {\n        aipObj.verified = false\n    }\n\n    // Try if this is a Twetch compatible AIP signature\n    if (!aipObj.verified) {\n        // Twetch signs a UTF-8 buffer of the hex string of a sha256 hash of the message\n        // Without 0x06 (OP_RETURN) and without 0x7c at the end, the trailing pipe (\"|\")\n\n        messageBuffer = Buffer.concat([\n            ...signatureBufferStatements.slice(\n                1,\n                signatureBufferStatements.length - 1\n            ),\n        ])\n        const buff = await sha256(messageBuffer)\n        messageBuffer = Buffer.from(buff.toString('hex'))\n        try {\n            aipObj.verified = Bsm.verify(\n                messageBuffer,\n                aipObj.signature || '',\n                Address.fromString(\n                    aipObj.address || aipObj.signing_address || ''\n                )\n            )\n        } catch (e) {\n            aipObj.verified = false\n        }\n    }\n\n    return aipObj.verified || false\n}\n\nexport const AIPhandler = async function (\n    useQuerySchema: Object[],\n    protocolName: string,\n    dataObj: Object,\n    cell: Cell[],\n    tape: Tape[],\n    tx: BobTx\n) {\n    // loop over the schema\n    const aipObj: { [key: string]: number | number[] | string } = {}\n\n    // Does not have the required number of fields\n    if (cell.length < 4) {\n        throw new Error(\n            'AIP requires at least 4 fields including the prefix ' + tx\n        )\n    }\n\n    for (const [idx, schemaField] of Object.entries(useQuerySchema)) {\n        const x = parseInt(idx, 10)\n\n        let schemaEncoding\n        let aipField: keyof AIPType\n        if (schemaField instanceof Array) {\n            // signature indexes are specified\n            schemaEncoding = schemaField[0].index\n            ;[aipField] = Object.keys(schemaField[0]) as (keyof AIPType)[]\n            // run through the rest of the fields in this cell, should be de indexes\n            const fieldData: number[] = []\n            for (let i = x + 1; i < cell.length; i++) {\n                if (cell[i].h && Array.isArray(fieldData)) {\n                    fieldData.push(parseInt(cell[i].h || '', 16))\n                }\n            }\n            aipObj[aipField] = fieldData\n            continue\n        } else {\n            ;[aipField] = Object.keys(schemaField) as (keyof AIPType)[]\n            ;[schemaEncoding] = Object.values(schemaField)\n        }\n\n        aipObj[aipField] = cellValue(cell[x + 1], schemaEncoding) || ''\n    }\n\n    // There is an issue where some services add the signature as binary to the transaction\n    // whereas others add the signature as base64. This will confuse bob and the parser and\n    // the signature will not be verified. When the signature is added in binary cell[3].s is\n    // binary, otherwise cell[3].s contains the base64 signature and should be used.\n    if (cell[0].s === address && cell[3].s && isBase64(cell[3].s)) {\n        aipObj.signature = cell[3].s\n    }\n\n    if (!aipObj.signature) {\n        throw new Error('AIP requires a signature ' + tx)\n    }\n\n    if (!(await validateSignature(aipObj as Partial<AIPType>, cell, tape))) {\n        // throw new Error('AIP requires a valid signature', tx);\n    }\n\n    saveProtocolData(dataObj, protocolName, aipObj)\n}\n\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n    if (!tape) {\n        throw new Error('Invalid AIP transaction. tape is required')\n    }\n    if (!tx) {\n        throw new Error('Invalid AIP transaction. tx is required')\n    }\n    return await AIPhandler(querySchema, 'AIP', dataObj, cell, tape, tx)\n}\n\nexport const AIP = {\n    name: 'AIP',\n    address,\n    querySchema,\n    handler,\n}\n","import { HandlerProps } from '../../types/common'\nimport { cellValue, saveProtocolData } from '../utils'\n\nconst address = '19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut'\n\nconst querySchema = [\n    { content: ['string', 'binary', 'file'] },\n    { 'content-type': 'string' },\n    { encoding: 'string' }, // we use this field to determine content character encoding. If encoding is not a valid character encoding (gzip), we assume it is binary\n    { filename: 'string' },\n]\n\nconst handler = function ({ dataObj, cell, tx }: HandlerProps): void {\n    const encodingMap = new Map<string, string>()\n    encodingMap.set('utf8', 'string')\n    encodingMap.set('text', 'string') // invalid but people use it :(\n    encodingMap.set('gzip', 'binary') // invalid but people use it :(\n    encodingMap.set('text/plain', 'string')\n    encodingMap.set('image/png', 'binary')\n    encodingMap.set('image/jpeg', 'binary')\n\n    if (!cell[1] || !cell[2]) {\n        throw new Error(`Invalid B tx: ${tx}`)\n    }\n\n    // Check pushdata length + 1 for protocol prefix\n    if (cell.length > querySchema.length + 1) {\n        throw new Error('Invalid B tx. Too many fields.')\n    }\n\n    // Make sure there are not more fields than possible\n\n    const bObj: { [key: string]: string | number | undefined } = {}\n    // loop over the schema\n    for (const [idx, schemaField] of Object.entries(querySchema)) {\n        const x = parseInt(idx, 10)\n        const bField = Object.keys(schemaField)[0]\n        let schemaEncoding = Object.values(schemaField)[0]\n        if (bField === 'content') {\n            // If the encoding is ommitted, try to infer from content-type instead of breaking\n            if (cell[1].f) {\n                // this is file reference to B files\n                schemaEncoding = 'file'\n            } else if ((!cell[3] || !cell[3].s) && cell[2].s) {\n                schemaEncoding = encodingMap.get(cell[2].s)\n                if (!schemaEncoding) {\n                    console.warn(\n                        'Problem inferring encoding. Malformed B data.',\n                        cell\n                    )\n                    return\n                }\n\n                // add the missing encoding field\n                if (!cell[3]) {\n                    cell[3] = { h: '', b: '', s: '', i: 0, ii: 0 }\n                }\n                cell[3].s = schemaEncoding === 'string' ? 'utf-8' : 'binary'\n            } else {\n                schemaEncoding =\n                    cell[3] && cell[3].s\n                        ? encodingMap.get(\n                              cell[3].s.replace('-', '').toLowerCase()\n                          )\n                        : null\n            }\n        }\n\n        // encoding is not required\n        if (bField === 'encoding' && !cell[x + 1]) {\n            // encoding omitted\n            continue\n        }\n\n        // filename is not required\n        if (bField === 'filename' && !cell[x + 1]) {\n            // filename omitted\n            continue\n        }\n\n        // check for malformed syntax\n        if (!cell || !cell[x + 1]) {\n            throw new Error('malformed B syntax ' + cell)\n        }\n\n        // set field value from either s, b, ls, or lb depending on encoding and availability\n        const data = cell[x + 1]\n        bObj[bField] = cellValue(data, schemaEncoding)\n    }\n\n    saveProtocolData(dataObj, 'B', bObj)\n}\n\nexport const B = {\n    name: 'B',\n    address,\n    querySchema,\n    handler,\n}\n","import { HandlerProps } from '../../types/common'\nimport { bmapQuerySchemaHandler } from '../utils'\n\nconst address = '1BAPSuaPnfGnSBM3GLV9yhxUdYe4vGbdMT'\n\nconst querySchema = [\n    { type: 'string' },\n    { hash: 'string' },\n    { sequence: 'string' },\n]\n\nexport const handler = ({ dataObj, cell, tape, tx }: HandlerProps) => {\n    if (!tape) {\n        throw new Error(`Invalid BAP tx, tape required`)\n    }\n    if (!tx) {\n        throw new Error(`Invalid BAP tx, tx required`)\n    }\n    bmapQuerySchemaHandler('BAP', querySchema, dataObj, cell, tape, tx)\n}\n\nexport const BAP = {\n    name: 'BAP',\n    address,\n    querySchema,\n    handler,\n}\n","import { HandlerProps } from '../../types/common'\nimport { AIPhandler } from './aip'\n\nconst address = '1HA1P2exomAwCUycZHr8WeyFoy5vuQASE3'\n\nconst querySchema = [\n    { hashing_algorithm: 'string' },\n    { signing_algorithm: 'string' },\n    { signing_address: 'string' },\n    { signature: 'string' },\n    { index_unit_size: 'number' },\n    [{ index: 'binary' }],\n]\n\n// https://github.com/torusJKL/BitcoinBIPs/blob/master/HAIP.md\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n    if (!tape) {\n        throw new Error(`Invalid HAIP tx. Bad tape`)\n    }\n    if (!tx) {\n        throw new Error(`Invalid HAIP tx.`)\n    }\n    return await AIPhandler(querySchema, 'HAIP', dataObj, cell, tape, tx)\n}\n\nexport const HAIP = {\n    name: 'HAIP',\n    address,\n    querySchema,\n    handler,\n}\n","import { decode } from '@msgpack/msgpack'\nimport { Buffer } from 'buffer'\nimport { Cell, HandlerProps } from '../../types/common'\nimport { MAP as MAPType } from '../../types/protocols/map'\nimport { saveProtocolData } from '../utils'\n\nconst address = '1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5'\n\nconst querySchema = [\n    {\n        cmd: {\n            SET: [{ key: 'string' }, { val: 'string' }],\n            SELECT: [{ tx: 'string' }],\n            ADD: [{ key: 'string' }, [{ val: 'string' }]],\n            DELETE: [{ key: 'string' }, [{ val: 'string' }]],\n            JSON: 'string',\n            REMOVE: [[{ key: 'string' }]],\n            CLEAR: [[{ txid: 'string' }]],\n        },\n    },\n]\n\nconst processADD = function (cell: Cell[], mapObj: MAPType) {\n    let last = null\n    for (const pushdataContainer of cell) {\n        // ignore MAP command\n        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n            continue\n        }\n        const pushdata = pushdataContainer.s as string\n        if (pushdataContainer.i === 2) {\n            // Key name\n            mapObj[pushdata] = []\n            last = pushdata\n        } else {\n            if (last && Array.isArray(mapObj[last])) {\n                ;(mapObj[last] as string[]).push(pushdata)\n            }\n        }\n    }\n}\n\nconst proccessDELETE = function (cell: Cell[], mapObj: MAPType) {\n    let last = null\n    for (const pushdataContainer of cell) {\n        // ignore MAP command\n        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n            continue\n        }\n        const pushdata = pushdataContainer.s as string\n        if (pushdataContainer.i === 2) {\n            // Key name\n            mapObj[pushdata] = []\n            last = pushdata\n        } else {\n            if (last) {\n                ;(mapObj[last] as string[]).push(pushdata)\n            }\n        }\n    }\n}\n\nconst processSELECT = function (cell: Cell[], mapObj: MAPType) {\n    // TODO\n    // console.log('MAP SELECT');\n    for (const pushdataContainer of cell) {\n        // ignore MAP command\n        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n            mapObj.SELECT = 'TODO'\n            continue\n        }\n    }\n}\n\nconst processMSGPACK = function (cell: Cell[], mapObj: MAPType) {\n    for (const pushdataContainer of cell) {\n        // ignore MAP command\n        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n            continue\n        }\n        if (pushdataContainer.i === 2) {\n            try {\n                if (!decode) {\n                    throw new Error('Msgpack is required but not loaded')\n                }\n                const buff = Buffer.from(\n                    pushdataContainer.b as string,\n                    'base64'\n                )\n                mapObj = decode(buff) as MAPType\n            } catch (e) {\n                mapObj = {} as MAPType\n            }\n        }\n    }\n    return mapObj\n}\n\nconst processJSON = function (cell: Cell[], mapObj: MAPType) {\n    for (const pushdataContainer of cell) {\n        // ignore MAP command\n        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n            continue\n        }\n        if (pushdataContainer.i === 2) {\n            try {\n                mapObj = JSON.parse(pushdataContainer.s as string)\n            } catch (e) {\n                mapObj = {} as MAPType\n            }\n        }\n    }\n    return mapObj\n}\n\nconst processSET = function (cell: Cell[], mapObj: MAPType) {\n    let last = null\n    for (const pushdataContainer of cell) {\n        // ignore MAP command\n        if (\n            !pushdataContainer.s ||\n            pushdataContainer.i === 0 ||\n            pushdataContainer.i === 1\n        ) {\n            continue\n        }\n\n        const pushdata = pushdataContainer.s\n        if (pushdataContainer.i % 2 === 0) {\n            // key\n            mapObj[pushdata] = ''\n            last = pushdata\n        } else {\n            // value\n            if (!last) {\n                throw new Error(`malformed MAP syntax. Cannot parse.${last}`)\n            }\n            mapObj[last] = pushdata\n        }\n    }\n}\n\nconst handler = function ({ dataObj, cell, tx }: HandlerProps) {\n    // Validate\n    if (\n        cell[0].s !== address ||\n        !cell[1] ||\n        !cell[1].s ||\n        !cell[2] ||\n        !cell[2].s\n    ) {\n        throw new Error(`Invalid MAP record: ${tx}`)\n    }\n\n    let mapObj = {} as MAPType\n\n    // parse the protocol separator\n    const commands: any[] = []\n    let commandSeparator = 0\n    for (let i = 1; i < cell.length; i++) {\n        if (cell[i].s === ':::') {\n            commandSeparator++\n        } else {\n            if (!commands[commandSeparator]) commands[commandSeparator] = []\n            cell[i].i = commands[commandSeparator].length + 1\n            commands[commandSeparator].push(cell[i])\n        }\n    }\n\n    // Get the MAP command key name from the query schema\n    const mapCmdKey = Object.keys(querySchema[0])[0]\n\n    // Add the firt MAP command in the response object\n    mapObj[mapCmdKey] = commands[0][0].s\n\n    commands.forEach((cc) => {\n        // re-add the MAP address\n        cc.unshift({\n            s: address,\n            i: 0,\n        })\n\n        const command = cc[1].s\n        // Individual parsing rules for each MAP command\n        switch (command) {\n            // Also check for SELECT commands and strip off the <SELECT> <TXID> part and run it through\n            case 'ADD': {\n                processADD(cc, mapObj)\n                break\n            }\n            case 'REMOVE': {\n                mapObj.key = cc[2].s\n                break\n            }\n            case 'DELETE': {\n                proccessDELETE(cc, mapObj)\n                break\n            }\n            case 'CLEAR': {\n                // TODO\n                // console.log('MAP CLEAR');\n                break\n            }\n            case 'SELECT': {\n                processSELECT(cc, mapObj)\n                break\n            }\n            case 'MSGPACK': {\n                mapObj = processMSGPACK(cc, mapObj)\n                break\n            }\n            case 'JSON': {\n                mapObj = processJSON(cc, mapObj)\n                break\n            }\n            case 'SET': {\n                processSET(cc, mapObj)\n                break\n            }\n            default: {\n                // don't know what to do ...\n            }\n        }\n    })\n\n    saveProtocolData(dataObj, 'MAP', mapObj)\n}\n\nexport const MAP = {\n    name: 'MAP',\n    address,\n    querySchema,\n    handler,\n}\n","import { Buffer } from 'buffer'\nimport { HandlerProps, MetaNet, MetanetNode } from '../../types/common'\nimport { sha256 } from '../utils'\n\nconst address = 'meta'\n\nconst querySchema = [\n    { address: 'string' },\n    { parent: 'string' },\n    { name: 'string' },\n]\n\nexport const getEnvSafeMetanetID = async function (a: string, tx: string) {\n    // Calculate the node ID\n    const buf = Buffer.from(a + tx)\n    const hashBuf = await sha256(buf)\n    return hashBuf.toString('hex')\n}\n\nconst handler = async ({ dataObj, cell, tx }: HandlerProps) => {\n    if (\n        !cell.length ||\n        cell[0].s !== 'meta' ||\n        !cell[1] ||\n        !cell[1].s ||\n        !cell[2] ||\n        !cell[2].s ||\n        !tx\n    ) {\n        throw new Error('Invalid Metanet tx ' + tx)\n    }\n    // For now, we just copy from MOM keys later if available, or keep BOB format\n\n    const nodeId = await getEnvSafeMetanetID(cell[1].s, tx.tx.h)\n    // Described this node\n    const node = {\n        a: cell[1].s,\n        tx: tx.tx.h,\n        id: nodeId,\n    }\n    let parent = {} as MetanetNode\n    if (tx.in) {\n        const parentId = await getEnvSafeMetanetID(tx.in[0].e.a, cell[2].s)\n        // Parent node\n        parent = {\n            a: tx.in[0].e.a,\n            tx: cell[2].s,\n            id: parentId,\n        }\n    }\n\n    if (!dataObj.METANET) {\n        dataObj.METANET = []\n    }\n    dataObj.METANET.push({\n        node,\n        parent,\n    } as MetaNet)\n}\n\nexport const METANET = {\n    name: 'METANET',\n    address,\n    querySchema,\n    handler,\n}\n","import { PaymailClient } from '@moneybutton/paymail-client'\nimport dns from 'dns'\nimport fetch from 'node-fetch'\n\nexport const verifyPaymailPublicKey = async function (\n    paymail: string,\n    publicKey: string\n) {\n    const client = new PaymailClient(dns, fetch)\n    return client.verifyPubkeyOwner(publicKey, paymail)\n}\n","import { Address, Bsm, PubKey, Script } from '@ts-bitcoin/core'\nimport { Buffer } from 'buffer'\nimport { Cell, HandlerProps, Tape } from '../../types/common'\nimport { PSP as PSPType } from '../../types/protocols/psp'\nimport { verifyPaymailPublicKey } from '../paymail'\nimport { checkOpFalseOpReturn, saveProtocolData } from '../utils'\n\nconst address = '1signyCizp1VyBsJ5Ss2tEAgw7zCYNJu4'\n\nconst querySchema = [\n    { signature: 'string' },\n    { pubkey: 'string' },\n    { paymail: 'string' },\n]\n\nconst validateSignature = function (\n    pspObj: PSPType,\n    cell: Cell[],\n    tape: Tape[]\n) {\n    if (!Array.isArray(tape) || tape.length < 3) {\n        throw new Error('PSP requires at least 3 cells including the prefix')\n    }\n\n    let cellIndex = -1\n    tape.forEach((cc, index) => {\n        if (cc.cell === cell) {\n            cellIndex = index\n        }\n    })\n    if (cellIndex === -1) {\n        throw new Error('PSP could not find cell in tape')\n    }\n\n    const signatureBufferStatements = []\n    for (let i = 0; i < cellIndex; i++) {\n        const cellContainer = tape[i]\n        if (!checkOpFalseOpReturn(cellContainer)) {\n            cellContainer.cell.forEach((statement) => {\n                // add the value as hex\n                let value = statement.h\n                if (!value) {\n                    value = Buffer.from(\n                        statement.b as string,\n                        'base64'\n                    ).toString('hex')\n                }\n                if (!value) {\n                    value = Buffer.from(statement.s as string).toString('hex')\n                }\n                signatureBufferStatements.push(Buffer.from(value, 'hex'))\n            })\n            signatureBufferStatements.push(Buffer.from('7c', 'hex')) // | hex ????\n        }\n    }\n    const dataScript = Script.fromSafeDataArray(signatureBufferStatements)\n    const messageBuffer = Buffer.from(dataScript.toHex(), 'hex')\n\n    // verify psp signature\n    const publicKey = PubKey.fromString(pspObj.pubkey)\n    const signingAddress = Address.fromPubKey(publicKey)\n    try {\n        pspObj.verified = Bsm.verify(\n            messageBuffer,\n            pspObj.signature,\n            signingAddress\n        )\n    } catch (e) {\n        pspObj.verified = false\n    }\n\n    return pspObj.verified\n}\n\nconst handler = async function ({ dataObj, cell, tape }: HandlerProps) {\n    // Paymail Signature Protocol\n    // Validation\n    if (\n        !cell.length ||\n        cell[0].s !== address ||\n        !cell[1] ||\n        !cell[2] ||\n        !cell[3] ||\n        !cell[1].b ||\n        !cell[2].s ||\n        !cell[3].s ||\n        !tape\n    ) {\n        throw new Error(`Invalid Paymail Signature Protocol record`)\n    }\n\n    const pspObj = {\n        signature: cell[1].s,\n        pubkey: cell[2].s,\n        paymail: cell[3].s,\n        verified: false,\n    } as PSPType\n\n    // verify signature\n    validateSignature(pspObj, cell, tape)\n\n    // check the paymail public key\n    const paymailPublicKeyVerified = await verifyPaymailPublicKey(\n        pspObj.paymail,\n        pspObj.pubkey\n    )\n    pspObj.verified = pspObj.verified && paymailPublicKeyVerified\n\n    saveProtocolData(dataObj, 'PSP', pspObj)\n}\n\nexport const PSP = {\n    name: 'PSP',\n    address,\n    querySchema,\n    handler,\n}\n","// import default protocols\nimport {\n    BmapTx,\n    BobTx,\n    Handler,\n    In,\n    MetaNet,\n    MomTx,\n    Out,\n} from '../types/common'\nimport { AIP } from './protocols/aip'\nimport { B } from './protocols/b'\nimport { BAP } from './protocols/bap'\nimport { HAIP } from './protocols/haip'\nimport { MAP } from './protocols/map'\nimport { METANET } from './protocols/metanet'\nimport { PSP } from './protocols/psp'\nimport { checkOpFalseOpReturn, saveProtocolData } from './utils'\n\nconst protocolMap = new Map<string, string>([])\nconst protocolHandlers = new Map<string, Handler>()\nconst protocolQuerySchemas = new Map<string, Object[]>()\n\n;[AIP, B, BAP, HAIP, MAP, METANET, PSP].forEach((protocol) => {\n    protocolMap.set(protocol.address, protocol.name)\n    protocolHandlers.set(protocol.name, protocol.handler)\n    protocolQuerySchemas.set(protocol.name, protocol.querySchema)\n})\n\n// Takes a BOB formatted op_return transaction\nexport class BMAP {\n    protocolMap: Map<string, string>\n\n    protocolHandlers: Map<string, Handler>\n\n    protocolQuerySchemas: Map<string, Object[]>\n\n    constructor() {\n        // initial default protocol handlers in this instantiation\n        this.protocolMap = protocolMap\n        this.protocolHandlers = protocolHandlers\n        this.protocolQuerySchemas = protocolQuerySchemas\n    }\n\n    addProtocolHandler(protocolDefinition: {\n        name: string\n        address: string\n        querySchema: Object[]\n        handler: Handler\n    }) {\n        const { name, address, querySchema, handler } = protocolDefinition\n        this.protocolMap.set(address, name)\n        this.protocolHandlers.set(name, handler)\n        this.protocolQuerySchemas.set(name, querySchema)\n    }\n\n    transformTx = async (tx: BobTx | MomTx): Promise<BmapTx> => {\n        const self = this\n\n        if (!tx || !tx['in'] || !tx['out']) {\n            throw new Error('Cannot process tx')\n        }\n\n        // This will become our nicely formatted response object\n        const dataObj: {\n            [key: string]: (Out | In | MetaNet)[] | string | Object\n        } = {\n            in: [],\n            out: [],\n            _id: '',\n            tx: {},\n            blk: {},\n        }\n\n        for (const [key, val] of Object.entries(tx)) {\n            if (key === 'out') {\n                // loop over the outputs\n                for (const out of tx.out) {\n                    const { tape } = out\n\n                    if (tape?.some((cc) => checkOpFalseOpReturn(cc))) {\n                        // loop over tape\n                        for (const cellContainer of tape) {\n                            // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n                            if (checkOpFalseOpReturn(cellContainer)) {\n                                continue\n                            }\n\n                            const { cell } = cellContainer\n                            if (!cell) {\n                                throw new Error('empty cell while parsing')\n                            }\n\n                            // Get protocol name from prefix\n                            const prefix = cell[0].s as string\n\n                            const protocolName =\n                                self.protocolMap.get(prefix) || prefix\n\n                            if (\n                                self.protocolHandlers.has(protocolName) &&\n                                typeof self.protocolHandlers.get(\n                                    protocolName\n                                ) === 'function'\n                            ) {\n                                const handler =\n                                    self.protocolHandlers.get(protocolName)\n                                if (handler) {\n                                    /* eslint-disable no-await-in-loop */\n                                    await handler({\n                                        dataObj: dataObj as BmapTx,\n                                        cell,\n                                        tape,\n                                        tx,\n                                    })\n                                }\n                            } else {\n                                saveProtocolData(dataObj, protocolName, cell)\n                            }\n                        }\n                    } else {\n                        // No OP_RETURN in this outputs\n                        if (key && !dataObj[key]) {\n                            dataObj[key] = []\n                        }\n\n                        ;(dataObj[key] as Out[]).push({\n                            i: out.i,\n                            e: out.e,\n                        })\n                    }\n                }\n            } else if (key === 'in') {\n                dataObj[key] = val.map((v: In) => {\n                    const r = { ...v }\n                    delete r.tape\n                    return r\n                })\n            } else if (Object.keys(dataObj).includes(key)) {\n                // knwon key, just write it retaining original type\n                dataObj[key] = val\n            } else if (!dataObj[key]) {\n                // unknown key. push into array incase there are many of these detected\n                dataObj[key] = []\n                ;(dataObj[key] as Object[]).push(val)\n            }\n        }\n\n        // If this is a MOM planaria it will have metanet keys available\n        if (dataObj['METANET'] && (tx as MomTx).parent) {\n            const meta = {\n                ancestor: (tx as MomTx).ancestor,\n                parent: (tx as MomTx).parent,\n                child: (tx as MomTx).child,\n                head: (tx as MomTx).head,\n            } as MetaNet\n\n            ;(dataObj.METANET as MetaNet[]).push(meta)\n            // remove parent and node from root level for (MOM data)\n            delete dataObj.ancestor\n            delete dataObj.child\n            delete dataObj.parent\n            delete dataObj.head\n            delete dataObj.node\n        }\n\n        return dataObj as BmapTx\n    }\n}\n\nexport const TransformTx = async (tx: BobTx) => {\n    const b = new BMAP()\n    return b.transformTx(tx)\n}\n"],"names":["$2436a3c07f0d43ac$export$b691916706e0e9cc","pushData","schemaEncoding","Error","s","ls","h","lh","parseInt","f","lf","b","lb","$2436a3c07f0d43ac$export$238b4e54af8fe886","cc","cell","op","$2436a3c07f0d43ac$export$23dbc584560299c3","dataObj","protocolName","data","Array","isArray","prevData","length","$2436a3c07f0d43ac$export$9c363cd18b34077b","querySchema","tape","tx","obj","idx","schemaField","Object","entries","x","field","keys","values","$2436a3c07f0d43ac$export$bced8d2aada2d1c9","async","msgBuffer","hash","$fWLZl$crypto","webcrypto","window","crypto","subtle","digest","$fWLZl$buffer","Buffer","from","$cdf195a9da306c9b$var$address","$cdf195a9da306c9b$var$querySchema","algorithm","address","signature","index","$cdf195a9da306c9b$var$getFileBuffer","bitfsRef","fileBuffer","result","$parcel$interopDefault","$fWLZl$nodefetch","buffer","e","console","error","$cdf195a9da306c9b$export$f0079d0908cdbf96","useQuerySchema","aipObj","aipField","fieldData","i","push","RegExp","test","cellIndex","forEach","usingIndexes","signatureValues","cellContainer","nc","statement","toString","hashing_algorithm","index_unit_size","indexLength","indexes","i1","substr","signatureBufferStatements","messageBuffer","shift","dataScript","$fWLZl$tsbitcoincore","Script","fromSafeDataArray","dataBuffer","toHex","slice","concat","verified","Bsm","verify","Address","fromString","signing_address","buff","e1","$cdf195a9da306c9b$var$validateSignature","$cdf195a9da306c9b$export$474d593e43f12abd","name","$42d589ec431141cf$var$querySchema","content","encoding","filename","$42d589ec431141cf$export$ef35774e6d314e91","encodingMap","Map","set","bObj","bField","get","replace","toLowerCase","warn","ii","$3b3d9a5fa368b0c3$var$querySchema","type","sequence","$3b3d9a5fa368b0c3$export$5935ea4bf04c4453","$3362fd4c89c9fc4a$var$querySchema","signing_algorithm","$3362fd4c89c9fc4a$export$12815d889fe90b8","$d1c6d5e4d0465e9c$var$address","$d1c6d5e4d0465e9c$var$querySchema","cmd","SET","key","val","SELECT","ADD","DELETE","JSON","REMOVE","CLEAR","txid","$d1c6d5e4d0465e9c$export$ce970371e0e850bc","mapObj","commands","commandSeparator","mapCmdKey","unshift","last","pushdataContainer","pushdata","$d1c6d5e4d0465e9c$var$processADD","$d1c6d5e4d0465e9c$var$proccessDELETE","$d1c6d5e4d0465e9c$var$processSELECT","$fWLZl$msgpackmsgpack","decode","$d1c6d5e4d0465e9c$var$processMSGPACK","parse","$d1c6d5e4d0465e9c$var$processJSON","$d1c6d5e4d0465e9c$var$processSET","$c06addbc0854bb97$export$3eb18141230d6532","a","buf","$c06addbc0854bb97$export$7830a85a59ca4593","parent","nodeId","node","id","in","parentId","METANET","$f8ee95f80f538de5$export$fe8725667d42151","paymail","publicKey","$fWLZl$moneybuttonpaymailclient","PaymailClient","$fWLZl$dns","verifyPubkeyOwner","$83d7f49c2ab5bd3d$var$address","$83d7f49c2ab5bd3d$export$bd49ff9d0c7fbe97","pubkey","pspObj","value","PubKey","signingAddress","fromPubKey","$83d7f49c2ab5bd3d$var$validateSignature","paymailPublicKeyVerified","$4d5b07a09e852f9a$var$protocolMap","$4d5b07a09e852f9a$var$protocolHandlers","$4d5b07a09e852f9a$var$protocolQuerySchemas","protocol","handler","$4d5b07a09e852f9a$export$894a720e71f90b3c","constructor","this","protocolMap","protocolHandlers","protocolQuerySchemas","addProtocolHandler","protocolDefinition","transformTx","self","out","_id","blk","some","prefix","has","map","v","r","includes","meta","ancestor","child","head","$4d5b07a09e852f9a$export$b2a90e318402f6bc"],"version":3,"file":"bmap.js.map","sourceRoot":"../"}