{"version":3,"file":"bmap.cjs.js","sources":["../src/utils.ts","../src/protocols/_21e8.ts","../src/protocols/aip.ts","../src/protocols/b.ts","../src/protocols/bap.ts","../src/protocols/bitcom.ts","../src/protocols/bitkey.ts","../src/protocols/bitpic.ts","../src/protocols/haip.ts","../src/protocols/map.ts","../src/protocols/metanet.ts","../src/protocols/ord.ts","../src/protocols/ron.ts","../src/protocols/symre.ts","../src/bmap.ts"],"sourcesContent":["import { Hash, Utils } from \"@bsv/sdk\";\nimport type { Cell, Tape } from \"bpu-ts\";\nimport type { BmapTx, BobTx, SchemaField } from \"./types/common\";\nconst { toArray } = Utils;\n\nexport const isStringArray = (arr: Array<any>): boolean => {\n  return (\n    arr.length > 0 &&\n    arr.every((value) => {\n      return typeof value === \"string\";\n    })\n  );\n};\nexport const isObjectArray = (arr: Array<any>): boolean => {\n  return (\n    arr.length > 0 &&\n    arr.every((value) => {\n      return value === \"object\";\n    })\n  );\n};\n/**\n * returns the BOB cell value for a given encoding\n *\n * @param pushData\n * @param schemaEncoding\n * @returns {string|number}\n */\nexport const cellValue = (pushData: Cell, schemaEncoding?: string): string | number => {\n  if (!pushData) {\n    throw new Error(`cannot get cell value of: ${pushData}`);\n  }\n  if (schemaEncoding === \"string\") {\n    return pushData.s ? pushData.s : pushData.ls || \"\";\n  }\n  if (schemaEncoding === \"hex\") {\n    return pushData.h\n      ? pushData.h\n      : pushData.lh ||\n          (pushData.b\n            ? Buffer.from(pushData.b, \"base64\").toString(\"hex\")\n            : pushData.lb && Buffer.from(pushData.lb, \"base64\").toString(\"hex\")) ||\n          \"\";\n  }\n  if (schemaEncoding === \"number\") {\n    return Number.parseInt(pushData.h ? pushData.h : pushData.lh || \"0\", 16);\n  }\n  if (schemaEncoding === \"file\") {\n    return `bitfs://${pushData.f ? pushData.f : pushData.lf}`;\n  }\n\n  return (pushData.b ? pushData.b : pushData.lb) || \"\";\n};\n\n/**\n * Check if cells end with OP_RETURN\n */\nexport const checkOpReturn = (cc: Tape): boolean => {\n  return cc.cell.some((c: Cell) => c.op === 106);\n};\n\n/**\n * Check if cells end with OP_FALSE + OP_RETURN\n */\nexport const checkOpFalseOpReturn = (cc: Tape): boolean => {\n  if (cc.cell.length !== 2) {\n    return false;\n  }\n  const opReturnIdx = cc.cell.findIndex((c) => c.op === 106);\n  if (opReturnIdx !== -1) {\n    return cc.cell[opReturnIdx - 1]?.op === 0;\n  }\n  return false;\n};\n\n/**\n * Helper function to store protocol data\n *\n * @param dataObj\n * @param protocolName\n * @param data\n */\nexport const saveProtocolData = (\n  dataObj: { [key: string]: any },\n  protocolName: string,\n  data: any\n) => {\n  if (!dataObj[protocolName]) {\n    dataObj[protocolName] = [data];\n  } else {\n    dataObj[protocolName].push(data);\n  }\n};\n\n/**\n * BMAP default handler to work with query schema's\n *\n * @param opReturnSchema\n * @param protocolName\n * @param dataObj\n * @param cell\n * @param tape\n * @param tx\n */\nexport const bmapOpReturnSchemaHandler = (\n  protocolName: string,\n  opReturnSchema: SchemaField[],\n  dataObj: BmapTx,\n  cell: Cell[],\n  tx: BobTx\n) => {\n  // loop over the schema\n  const obj: { [key: string]: any } = {};\n\n  // Does not have the required number of fields\n  const length = opReturnSchema.length + 1;\n  if (cell.length < length) {\n    throw new Error(\n      `${protocolName} requires at least ${length} fields including the prefix: ${tx.tx.h}`\n    );\n  }\n\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n\n    const [field] = Object.keys(schemaField);\n    const [schemaEncoding] = Object.values(schemaField);\n    obj[field] = cellValue(cell[x + 1], schemaEncoding as string);\n  }\n\n  saveProtocolData(dataObj, protocolName, obj);\n};\n\n/**\n * Check whether the given data is base64\n *\n * @param data\n * @returns {boolean}\n */\nexport const isBase64 = (data: string) => {\n  const regex = \"(?:[A-Za-z0-9+\\\\/]{4})*(?:[A-Za-z0-9+\\\\/]{2}==|[A-Za-z0-9+/]{3}=)?\";\n  return new RegExp(`^${regex}$`, \"gi\").test(data);\n};\n\n// hashes a message buffer, returns the hash as a buffer\nexport const sha256 = (msgBuffer: number[]) => {\n  return Hash.sha256(toArray(msgBuffer));\n};\n","import type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { _21E8 as _21E8Type } from \"../types/protocols/_21e8\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\n// 21e8 does not use the first pushdata for id\n// in fact there is no id since the 21e8 is designed for difficulty and can be changed\n// instead we use the static part of the script to indentfy the transaction\n// TODO - the OP_X_PLACEHOLDER is the number of bytes to push onto the stack and must match difficulty size\nconst _21e8Script =\n  \"OP_SIZE <OP_X_PLACEHOLDER> OP_PICK OP_SHA256 OP_SWAP OP_SPLIT OP_DROP OP_EQUALVERIFY OP_DROP OP_CHECKSIG\".split(\n    \" \"\n  );\n\nconst scriptChecker = (cell: Cell[]) => {\n  if (cell.length !== 12) {\n    // wrong length\n    return false;\n  }\n\n  // match exact script\n  const ops = [...cell].map((c) => c.ops).splice(2, cell.length);\n\n  // calculate target byte length\n  const target = cellValue(cell[1], \"hex\") as string;\n  const targetOpSize = Buffer.from(target).byteLength;\n\n  // replace the placeholder opcode with actual\n  ops[1] = `OP_${targetOpSize}`;\n  _21e8Script[1] = `OP_${targetOpSize}`;\n\n  // protocol identifier always in first pushdata\n  return ops.join() === _21e8Script.join();\n};\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n  if (!cell[0] || !out) {\n    throw new Error(\"Invalid 21e8 tx. dataObj, cell, out and tx are required.\");\n  }\n\n  // assemble asm\n  // make sure first piece matches a txid\n  // 2nd piece matches any difficulty. set some resonable limit in bytes if there isnt one documented somewhere\n  // next\n\n  const txid = cellValue(cell[0], \"hex\") as string;\n  const target = cellValue(cell[1], \"hex\") as string;\n  if (!target) {\n    throw new Error(`Invalid 21e8 target. ${JSON.stringify(cell[0], null, 2)}`);\n  }\n  const difficulty = Buffer.from(target, \"hex\").byteLength;\n\n  const _21e8Obj: _21E8Type = {\n    target,\n    difficulty,\n    value: out.e.v,\n    txid,\n  };\n\n  saveProtocolData(dataObj, \"21E8\", _21e8Obj);\n};\n\nexport const _21E8: Protocol = {\n  name: \"21E8\",\n  handler,\n  scriptChecker,\n};\n","import { BSM, BigNumber, Hash, Script, Signature, Utils } from \"@bsv/sdk\";\nimport type { Cell, Tape } from \"bpu-ts\";\nimport type { BmapTx, BobTx, HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport type { AIP as AIPType } from \"../types/protocols/aip\";\nimport type { HAIP as HAIPType } from \"../types/protocols/haip\";\nimport { cellValue, checkOpFalseOpReturn, isBase64, saveProtocolData } from \"../utils\";\n\nconst { toArray, toHex, fromBase58Check, toBase58Check } = Utils;\n\nconst address = \"15PciHG22SNLQJXMoSUaWVi7WSqc7hCfva\";\n\nconst opReturnSchema: SchemaField[] = [\n  { algorithm: \"string\" },\n  { address: \"string\" },\n  { signature: \"binary\" },\n  [{ index: \"binary\" }],\n];\n\nfunction validateSignature(\n  aipObj: Partial<AIPType | HAIPType>,\n  cell: Cell[],\n  tape: Tape[]\n): boolean {\n  if (!Array.isArray(tape) || tape.length < 3) {\n    throw new Error(\"AIP requires at least 3 cells including the prefix\");\n  }\n\n  let cellIndex = -1;\n  for (let i = 0; i < tape.length; i++) {\n    if (tape[i].cell === cell) {\n      cellIndex = i;\n      break;\n    }\n  }\n  if (cellIndex === -1) {\n    throw new Error(\"AIP could not find cell in tape\");\n  }\n\n  let usingIndexes: number[] = aipObj.index || [];\n  const signatureValues = [\"6a\"]; // OP_RETURN - is included in AIP\n  for (let i = 0; i < cellIndex; i++) {\n    const cellContainer = tape[i];\n    if (!checkOpFalseOpReturn(cellContainer)) {\n      for (const statement of cellContainer.cell) {\n        // add the value as hex\n        if (statement.h) {\n          signatureValues.push(statement.h);\n        } else if (statement.b) {\n          // no hex? try base64\n          signatureValues.push(toHex(toArray(statement.b, \"base64\")));\n        } else if (statement.s) {\n          signatureValues.push(toHex(toArray(statement.s)));\n        }\n      }\n      signatureValues.push(\"7c\"); // | hex\n    }\n  }\n\n  if (aipObj.hashing_algorithm) {\n    // when using HAIP, we need to parse the indexes in a non standard way\n    // indexLength is byte size of the indexes being described\n    if (aipObj.index_unit_size) {\n      const indexLength = aipObj.index_unit_size * 2;\n      usingIndexes = [];\n      const indexes = cell[6].h as string;\n      for (let i = 0; i < indexes.length; i += indexLength) {\n        usingIndexes.push(Number.parseInt(indexes.substr(i, indexLength), 16));\n      }\n      aipObj.index = usingIndexes;\n    }\n  }\n\n  const signatureBufferStatements: number[][] = [];\n  // check whether we need to only sign some indexes\n  if (usingIndexes.length > 0) {\n    for (const index of usingIndexes) {\n      if (index >= signatureValues.length) {\n        console.log(\"[validateSignature] Index out of bounds:\", index);\n        return false;\n      }\n      signatureBufferStatements.push(toArray(signatureValues[index], \"hex\"));\n    }\n  } else {\n    // add all the values to the signature buffer\n    for (const statement of signatureValues) {\n      signatureBufferStatements.push(toArray(statement, \"hex\"));\n    }\n  }\n\n  let messageBuffer: number[];\n  if (aipObj.hashing_algorithm) {\n    // this is actually Hashed-AIP (HAIP) and works a bit differently\n    if (!aipObj.index_unit_size) {\n      // remove OP_RETURN - will be added by Script.buildDataOut\n      signatureBufferStatements.shift();\n    }\n    const dataScript = Script.fromHex(toHex(signatureBufferStatements.flat()));\n    let dataArray = toArray(dataScript.toHex(), \"hex\");\n    if (aipObj.index_unit_size) {\n      // the indexed buffer should not contain the OP_RETURN opcode, but this\n      // is added by the buildDataOut function automatically. Remove it.\n      dataArray = dataArray.slice(1);\n    }\n    messageBuffer = Hash.sha256(dataArray);\n  } else {\n    // regular AIP\n    messageBuffer = signatureBufferStatements.flat();\n  }\n\n  // AIOP uses address, HAIP uses signing_address field names\n  const addressString = (aipObj as AIPType).address || (aipObj as HAIPType).signing_address;\n  if (!addressString || !aipObj.signature) {\n    return false;\n  }\n\n  let signature: Signature;\n  try {\n    signature = Signature.fromCompact(aipObj.signature, \"base64\");\n  } catch (e) {\n    console.log(\"[validateSignature] Failed to parse signature:\", e);\n    return false;\n  }\n\n  const tryNormalLogic = (): boolean => {\n    try {\n      const msgHash = BSM.magicHash(messageBuffer);\n      const bigMsg = toBigNumberFromBuffer(msgHash);\n\n      for (let recovery = 0; recovery < 4; recovery++) {\n        try {\n          const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n          const pubKeyHash = publicKey.toHash() as number[];\n          const { prefix } = fromBase58Check(addressString);\n          const recoveredAddress = toBase58Check(pubKeyHash, prefix as number[]);\n          if (recoveredAddress === addressString) {\n            return BSM.verify(messageBuffer, signature, publicKey);\n          }\n        } catch (e) {\n          console.log(\"[tryNormalLogic] Recovery error:\", e);\n        }\n      }\n    } catch (e) {\n      console.log(\"[tryNormalLogic] error:\", e);\n    }\n    return false;\n  };\n\n  const tryTwetchLogic = (): boolean => {\n    // Twetch signs a UTF-8 buffer of the hex string of a sha256 hash of the message\n    // Without 0x06 (OP_RETURN) and without 0x7c at the end, the trailing pipe (\"|\")\n    if (signatureBufferStatements.length <= 2) {\n      return false;\n    }\n\n    try {\n      const trimmed = signatureBufferStatements.slice(1, -1);\n      const buff = Hash.sha256(trimmed.flat());\n      const hexStr = toHex(buff);\n      const twetchMsg = toArray(hexStr, \"utf8\");\n\n      const msgHash = BSM.magicHash(twetchMsg);\n      const bigMsg = toBigNumberFromBuffer(msgHash);\n\n      for (let recovery = 0; recovery < 4; recovery++) {\n        try {\n          const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n          const pubKeyHash = publicKey.toHash() as number[];\n          const { prefix } = fromBase58Check(addressString);\n          const recoveredAddress = toBase58Check(pubKeyHash, prefix as number[]);\n          if (recoveredAddress === addressString) {\n            return BSM.verify(twetchMsg, signature, publicKey);\n          }\n        } catch (e) {\n          console.log(\"[tryTwetchLogic] Recovery error:\", e);\n        }\n      }\n    } catch (e) {\n      console.log(\"[tryTwetchLogic] error:\", e);\n    }\n    return false;\n  };\n\n  let verified = tryNormalLogic();\n  if (!verified) {\n    verified = tryTwetchLogic();\n  }\n\n  aipObj.verified = verified;\n  return verified;\n}\n\nfunction toBigNumberFromBuffer(buffer: number[]): BigNumber {\n  const hex = toHex(buffer);\n  return new BigNumber(hex, 16);\n}\n\nexport enum SIGPROTO {\n  HAIP = \"HAIP\",\n  AIP = \"AIP\",\n  BITCOM_HASHED = \"BITCOM_HASHED\",\n  PSP = \"PSP\",\n}\n\nexport const AIPhandler = async (\n  useOpReturnSchema: SchemaField[],\n  protocol: SIGPROTO,\n  dataObj: Partial<BobTx>,\n  cell: Cell[],\n  tape: Tape[]\n): Promise<HandlerProps> => {\n  // loop over the schema\n  const aipObj: { [key: string]: number | number[] | string | boolean } = {};\n\n  // Does not have the required number of fields\n  if (cell.length < 4) {\n    throw new Error(\"AIP requires at least 4 fields including the prefix\");\n  }\n\n  for (const [idx, schemaField] of Object.entries(useOpReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n\n    if (Array.isArray(schemaField)) {\n      // signature indexes are specified\n      const [aipField] = Object.keys(schemaField[0]) as (keyof AIPType)[];\n      // run through the rest of the fields in this cell, should be de indexes\n      const fieldData: number[] = [];\n      for (let i = x + 1; i < cell.length; i++) {\n        if (cell[i].h && Array.isArray(fieldData)) {\n          fieldData.push(Number.parseInt(cell[i].h || \"\", 16));\n        }\n      }\n      aipObj[aipField] = fieldData;\n    } else {\n      const [aipField] = Object.keys(schemaField) as (keyof AIPType)[];\n      const [schemaEncoding] = Object.values(schemaField);\n      aipObj[aipField] = cellValue(cell[x + 1], schemaEncoding as string) || \"\";\n    }\n  }\n\n  // There is an issue where some services add the signature as binary to the transaction\n  // whereas others add the signature as base64. This will confuse bob and the parser and\n  // the signature will not be verified. When the signature is added in binary cell[3].s is\n  // binary, otherwise cell[3].s contains the base64 signature and should be used.\n  if (cell[0].s === address && cell[3].s && isBase64(cell[3].s)) {\n    aipObj.signature = cell[3].s;\n  }\n\n  if (!aipObj.signature) {\n    throw new Error(\"AIP requires a signature\");\n  }\n\n  validateSignature(aipObj as Partial<AIPType>, cell, tape);\n\n  saveProtocolData(dataObj, protocol, aipObj);\n  return { dataObj: dataObj as BmapTx, cell, tape };\n};\n\nconst handler = async ({ dataObj, cell, tape }: HandlerProps): Promise<HandlerProps> => {\n  if (!tape) {\n    throw new Error(\"Invalid AIP transaction. tape is required\");\n  }\n  return AIPhandler(opReturnSchema, SIGPROTO.AIP, dataObj, cell, tape);\n};\n\nexport const AIP: Protocol = {\n  name: \"AIP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\nconst address = \"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\";\n\nconst opReturnSchema: SchemaField[] = [\n  { content: [\"string\", \"binary\", \"file\"] },\n  { \"content-type\": \"string\" },\n  { encoding: \"string\" }, // we use this field to determine content character encoding. If encoding is not a valid character encoding (gzip), we assume it is binary\n  { filename: \"string\" },\n];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps): void => {\n  const encodingMap = new Map<string, string>();\n  encodingMap.set(\"utf8\", \"string\");\n  encodingMap.set(\"text\", \"string\"); // invalid but people use it :(\n  encodingMap.set(\"gzip\", \"binary\"); // invalid but people use it :(\n  encodingMap.set(\"text/plain\", \"string\");\n  encodingMap.set(\"image/png\", \"binary\");\n  encodingMap.set(\"image/jpeg\", \"binary\");\n\n  if (!cell[1] || !cell[2]) {\n    throw new Error(`Invalid B tx: ${tx}`);\n  }\n\n  // Check pushdata length + 1 for protocol prefix\n  if (cell.length > opReturnSchema.length + 1) {\n    throw new Error(\"Invalid B tx. Too many fields.\");\n  }\n\n  // Make sure there are not more fields than possible\n\n  const bObj: { [key: string]: string | number | undefined } = {};\n  // loop over the schema\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n    const bField = Object.keys(schemaField)[0];\n    let schemaEncoding = Object.values(schemaField)[0];\n    if (bField === \"content\") {\n      // If the encoding is ommitted, try to infer from content-type instead of breaking\n      if (cell[1].f) {\n        // this is file reference to B files\n        schemaEncoding = \"file\";\n      } else if ((!cell[3] || !cell[3].s) && cell[2].s) {\n        schemaEncoding = encodingMap.get(cell[2].s) as string;\n        if (!schemaEncoding) {\n          console.warn(\"Problem inferring encoding. Malformed B data.\", cell);\n          return;\n        }\n\n        // add the missing encoding field\n        if (!cell[3]) {\n          cell[3] = { h: \"\", b: \"\", s: \"\", i: 0, ii: 0 };\n        }\n        cell[3].s = schemaEncoding === \"string\" ? \"utf-8\" : \"binary\";\n      } else {\n        const encoding = (\n          cell[3]?.s ? encodingMap.get(cell[3].s.replace(\"-\", \"\").toLowerCase()) : null\n        ) as string | null;\n        if (!encoding) {\n          console.warn(\"Problem inferring encoding. Malformed B data.\", cell);\n          return;\n        }\n        schemaEncoding = encoding;\n      }\n    }\n\n    // encoding is not required\n    if (bField === \"encoding\" && !cell[x + 1]) {\n      // encoding omitted\n      continue;\n    }\n\n    // filename is not required\n    if (bField === \"filename\" && !cell[x + 1]) {\n      // filename omitted\n      continue;\n    }\n\n    // check for malformed syntax\n    if (!cell || !cell[x + 1]) {\n      throw new Error(`malformed B syntax ${cell}`);\n    }\n\n    // set field value from either s, b, ls, or lb depending on encoding and availability\n    const data = cell[x + 1];\n    bObj[bField] = cellValue(data, schemaEncoding as string);\n  }\n\n  saveProtocolData(dataObj, \"B\", bObj);\n};\n\nexport const B: Protocol = {\n  name: \"B\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { bmapOpReturnSchemaHandler } from \"../utils\";\n\nconst address = \"1BAPSuaPnfGnSBM3GLV9yhxUdYe4vGbdMT\";\n\nconst opReturnSchema: SchemaField[] = [\n  { type: \"string\" },\n  { hash: \"string\" },\n  { sequence: \"string\" },\n];\n\nexport const handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (!tx) {\n    throw new Error(\"Invalid BAP tx, tx required\");\n  }\n  bmapOpReturnSchemaHandler(\"BAP\", opReturnSchema, dataObj, cell, tx);\n};\n\nexport const BAP: Protocol = {\n  name: \"BAP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst protocolAddress = \"$\";\n\nconst opReturnSchema: SchemaField[] = [\n  {\n    su: [{ pubkey: \"string\" }, { sign_position: \"string\" }, { signature: \"string\" }],\n    echo: [{ data: \"string\" }, { to: \"string\" }, { filename: \"string\" }],\n    route: [\n      [\n        {\n          add: [\n            { bitcom_address: \"string\" },\n            { route_matcher: \"string\" },\n            { endpoint_template: \"string\" },\n          ],\n        },\n        {\n          enable: [{ path: \"string\" }],\n        },\n      ],\n    ],\n    useradd: [{ address: \"string\" }],\n  },\n];\n\n// const handler = function (dataObj, protocolName, cell, tape, tx) {\nconst handler = ({ dataObj, cell }: HandlerProps) => {\n  if (!cell.length || !cell.every((c) => c.s)) {\n    throw new Error(\"Invalid Bitcom tx\");\n  }\n\n  // gather up the string values\n  const bitcomObj = cell.map((c) => (c?.s ? c.s : \"\"));\n\n  saveProtocolData(dataObj, \"BITCOM\", bitcomObj);\n};\n\nexport const BITCOM: Protocol = {\n  name: \"BITCOM\",\n  address: protocolAddress,\n  opReturnSchema,\n  handler,\n};\n","import { BSM, BigNumber, Hash, PublicKey, Signature, Utils } from \"@bsv/sdk\";\nimport type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\nconst { toArray, toBase58Check, toHex } = Utils;\nconst { magicHash } = BSM;\n\nconst address = \"13SrNDkVzY5bHBRKNu5iXTQ7K7VqTh5tJC\";\n\nconst opReturnSchema: SchemaField[] = [\n  { bitkey_signature: \"string\" },\n  { user_signature: \"string\" },\n  { paymail: \"string\" },\n  { pubkey: \"string\" },\n];\n\n// Helper to convert array to BigNumber\nfunction toBigNumber(buffer: number[]): BigNumber {\n  const hex = toHex(buffer);\n  return new BigNumber(hex, 16);\n}\n\n// Recovers a public key from a BSM signature by brute forcing recovery factors\n// Steps:\n// 1. Apply magicHash to the raw message.\n// 2. Try all recovery factors 0â€“3 with Signature.RecoverPublicKey()\n// 3. If BSM.verify() returns true with the recovered pubkey, return it.\nfunction recoverPublicKeyFromBSM(message: number[], signature: Signature): PublicKey {\n  // First, BSM signatures are verified by applying magicHash internally,\n  // so we must apply magicHash to the raw message ourselves for recovery:\n  const msgHash = magicHash(message);\n\n  const bigMsg = toBigNumber(msgHash);\n  for (let recovery = 0; recovery < 4; recovery++) {\n    try {\n      const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n      // Verify using BSM.verify() with the original raw message (no magicHash)\n      if (BSM.verify(message, signature, publicKey)) {\n        return publicKey;\n      }\n    } catch {\n      // Try next recovery factor\n    }\n  }\n  throw new Error(\"Failed to recover public key from BSM signature\");\n}\n\nconst handler = async ({ dataObj, cell }: HandlerProps) => {\n  if (cell.length < 5) {\n    throw new Error(\"Invalid Bitkey tx\");\n  }\n\n  const bitkeyObj: { [key: string]: string | boolean } = {};\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n    const bitkeyField = Object.keys(schemaField)[0];\n    const schemaEncoding = Object.values(schemaField)[0];\n    bitkeyObj[bitkeyField] = cellValue(cell[x + 1], schemaEncoding as string) as string;\n  }\n\n  // Derive userAddress from pubkey\n  const pubkeyHex = bitkeyObj.pubkey as string;\n  const userPubkey = PublicKey.fromString(pubkeyHex);\n  const userPubKeyHash = userPubkey.toHash() as number[];\n  const userAddress = toBase58Check(userPubKeyHash);\n\n  // Prepare raw message for bitkey signature verification: sha256(paymail_hex + pubkey_hex)\n  const paymailHex = Buffer.from(bitkeyObj.paymail as string).toString(\"hex\");\n  const concatenated = paymailHex + pubkeyHex;\n  const concatenatedBuffer = Buffer.from(concatenated, \"hex\");\n  const bitkeyMessage = Hash.sha256(toArray(concatenatedBuffer));\n  // This is the raw message. BSM.verify() will do magicHash internally.\n\n  const bitkeySignature = Signature.fromCompact(bitkeyObj.bitkey_signature as string, \"base64\");\n\n  // Recover Bitkey pubkey\n  const recoveredBitkeyPubkey = recoverPublicKeyFromBSM(bitkeyMessage, bitkeySignature);\n  const recoveredBitkeyPubKeyHash = recoveredBitkeyPubkey.toHash() as number[];\n  const recoveredBitkeyAddress = toBase58Check(recoveredBitkeyPubKeyHash);\n  const bitkeySignatureVerified =\n    BSM.verify(bitkeyMessage, bitkeySignature, recoveredBitkeyPubkey) &&\n    recoveredBitkeyAddress === address;\n\n  // Verify user signature by using the pubkey as the message\n  const userMessage = toArray(Buffer.from(pubkeyHex, \"utf8\"));\n  const userSignature = Signature.fromCompact(bitkeyObj.user_signature as string, \"base64\");\n  const recoveredUserPubkey = recoverPublicKeyFromBSM(userMessage, userSignature);\n  const recoveredUserPubKeyHash = recoveredUserPubkey.toHash() as number[];\n  const recoveredUserAddress = toBase58Check(recoveredUserPubKeyHash);\n  const userSignatureVerified =\n    BSM.verify(userMessage, userSignature, recoveredUserPubkey) &&\n    recoveredUserAddress === userAddress;\n\n  bitkeyObj.verified = bitkeySignatureVerified && userSignatureVerified;\n  saveProtocolData(dataObj, \"BITKEY\", bitkeyObj);\n};\n\nexport const BITKEY: Protocol = {\n  name: \"BITKEY\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { BSM, Hash, PublicKey, Signature, Utils } from \"@bsv/sdk\";\nimport type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport type { BITPIC as BITPICType } from \"../types/protocols/bitpic\";\nimport { saveProtocolData } from \"../utils\";\nconst { magicHash } = BSM;\nconst { toArray } = Utils;\n\nconst protocolAddress = \"18pAqbYqhzErT6Zk3a5dwxHtB9icv8jH2p\";\n\nconst opReturnSchema: SchemaField[] = [\n  { paymail: \"string\" },\n  { pubkey: \"binary\" },\n  { signature: \"string\" },\n];\n\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n  // Validation\n  if (\n    cell[0].s !== protocolAddress ||\n    !cell[1] ||\n    !cell[2] ||\n    !cell[3] ||\n    !cell[1].s ||\n    !cell[2].b ||\n    !cell[3].s ||\n    !tape\n  ) {\n    throw new Error(`Invalid BITPIC record: ${tx}`);\n  }\n\n  const bitpicObj: BITPICType = {\n    paymail: cell[1].s,\n    pubkey: Buffer.from(cell[2].b, \"base64\").toString(\"hex\"),\n    signature: cell[3].s || \"\",\n    verified: false,\n  };\n\n  const b = tape[1].cell;\n  if (b[0].s === \"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\") {\n    // verify bitpic signature\n\n    try {\n      // TODO: bob transactions are missing this binary part, cannot verify signature\n      const bin = (cell[1].lb || cell[1].b) as string;\n      const hashBuff = Hash.sha256(toArray(bin, \"base64\"));\n      const sig = Signature.fromCompact(bitpicObj.signature as string, \"base64\");\n      const pubkey = PublicKey.fromString(bitpicObj.pubkey as string);\n      const msgHash = magicHash(hashBuff);\n      bitpicObj.verified = BSM.verify(msgHash, sig, pubkey);\n    } catch (e) {\n      // failed verification\n      bitpicObj.verified = false;\n    }\n  }\n\n  saveProtocolData(dataObj, \"BITPIC\", bitpicObj);\n};\n\nexport const BITPIC: Protocol = {\n  name: \"BITPIC\",\n  address: protocolAddress,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { AIPhandler, SIGPROTO } from \"./aip\";\n\nconst address = \"1HA1P2exomAwCUycZHr8WeyFoy5vuQASE3\";\n\nconst opReturnSchema: SchemaField[] = [\n  { algorithm: \"string\" },\n  { algorithm: \"string\" },\n  { address: \"string\" },\n  { signature: \"string\" },\n  { algorithm: \"string\" },\n  [{ index: \"binary\" }],\n];\n\n// https://github.com/torusJKL/BitcoinBIPs/blob/master/HAIP.md\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n  if (!tape) {\n    throw new Error(\"Invalid HAIP tx. Bad tape\");\n  }\n  if (!tx) {\n    throw new Error(\"Invalid HAIP tx.\");\n  }\n  return await AIPhandler(\n    opReturnSchema,\n    SIGPROTO.HAIP,\n    dataObj,\n    cell,\n    tape\n    // tx,\n  );\n};\n\nexport const HAIP: Protocol = {\n  name: \"HAIP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { decode } from \"@msgpack/msgpack\";\nimport type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport type { MAP as MAPType } from \"../types/protocols/map\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5\";\n\nconst opReturnSchema: SchemaField[] = [\n  {\n    cmd: {\n      SET: [{ key: \"string\" }, { val: \"string\" }],\n      SELECT: [{ tx: \"string\" }],\n      ADD: [{ key: \"string\" }, [{ val: \"string\" }]],\n      DELETE: [{ key: \"string\" }, [{ val: \"string\" }]],\n      JSON: \"string\",\n      REMOVE: [[{ key: \"string\" }]],\n      CLEAR: [[{ txid: \"string\" }]],\n    },\n  },\n];\n\nconst processADD = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    const pushdata = pushdataContainer.s as string;\n    if (pushdataContainer.i === 2) {\n      // Key name\n      mapObj[pushdata] = [];\n      last = pushdata;\n    } else {\n      if (last && Array.isArray(mapObj[last])) {\n        (mapObj[last] as string[]).push(pushdata);\n      }\n    }\n  }\n};\n\nconst proccessDELETE = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    const pushdata = pushdataContainer.s as string;\n    if (pushdataContainer.i === 2) {\n      // Key name\n      mapObj[pushdata] = [];\n      last = pushdata;\n    } else {\n      if (last) {\n        (mapObj[last] as string[]).push(pushdata);\n      }\n    }\n  }\n};\n\nconst processSELECT = (cell: Cell[], mapObj: MAPType) => {\n  // TODO\n  // console.log('MAP SELECT');\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      mapObj.SELECT = \"TODO\";\n    }\n  }\n};\n\nconst processMSGPACK = (cell: Cell[], mapObj: MAPType) => {\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    if (pushdataContainer.i === 2) {\n      try {\n        if (!decode) {\n          throw new Error(\"Msgpack is required but not loaded\");\n        }\n        const buff = Buffer.from(pushdataContainer.b as string, \"base64\");\n        mapObj = decode(buff) as MAPType;\n      } catch (e) {\n        mapObj = {} as MAPType;\n      }\n    }\n  }\n  return mapObj;\n};\n\nconst processJSON = (cell: Cell[], mapObj: MAPType) => {\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    if (pushdataContainer.i === 2) {\n      try {\n        mapObj = JSON.parse(pushdataContainer.s as string);\n      } catch (e) {\n        mapObj = {} as MAPType;\n      }\n    }\n  }\n  return mapObj;\n};\n\nconst processSET = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (!pushdataContainer.s || pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n\n    const pushdata = pushdataContainer.s;\n    if (pushdataContainer.i % 2 === 0) {\n      // key\n      mapObj[pushdata] = \"\";\n      last = pushdata;\n    } else {\n      // value\n      if (!last) {\n        throw new Error(`malformed MAP syntax. Cannot parse.${last}`);\n      }\n      mapObj[last] = pushdata;\n    }\n  }\n};\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  // Validate\n  if (cell[0].s !== address || !cell[1] || !cell[1].s || !cell[2] || !cell[2].s) {\n    throw new Error(`Invalid MAP record: ${tx}`);\n  }\n\n  let mapObj = {} as MAPType;\n\n  // parse the protocol separator\n  const commands: any[] = [];\n  let commandSeparator = 0;\n  for (let i = 1; i < cell.length; i++) {\n    if (cell[i].s === \":::\") {\n      commandSeparator++;\n    } else {\n      if (!commands[commandSeparator]) commands[commandSeparator] = [];\n      cell[i].i = commands[commandSeparator].length + 1;\n      commands[commandSeparator].push(cell[i]);\n    }\n  }\n\n  // Get the MAP command key name from the query schema\n  const mapCmdKey = Object.keys(opReturnSchema[0])[0];\n\n  // Add the firt MAP command in the response object\n  mapObj[mapCmdKey] = commands[0][0].s;\n\n  for (const cc of commands) {\n    // re-add the MAP address\n    cc.unshift({\n      s: address,\n      i: 0,\n    });\n\n    const command = cc[1].s;\n    // Individual parsing rules for each MAP command\n    switch (command) {\n      // Also check for SELECT commands and strip off the <SELECT> <TXID> part and run it through\n      case \"ADD\": {\n        processADD(cc, mapObj);\n        break;\n      }\n      case \"REMOVE\": {\n        mapObj.key = cc[2].s;\n        break;\n      }\n      case \"DELETE\": {\n        proccessDELETE(cc, mapObj);\n        break;\n      }\n      case \"CLEAR\": {\n        // TODO\n        // console.log('MAP CLEAR');\n        break;\n      }\n      case \"SELECT\": {\n        processSELECT(cc, mapObj);\n        break;\n      }\n      case \"MSGPACK\": {\n        mapObj = processMSGPACK(cc, mapObj);\n        break;\n      }\n      case \"JSON\": {\n        mapObj = processJSON(cc, mapObj);\n        break;\n      }\n      case \"SET\": {\n        processSET(cc, mapObj);\n        break;\n      }\n      default: {\n        // don't know what to do ...\n      }\n    }\n  }\n\n  saveProtocolData(dataObj, \"MAP\", mapObj);\n};\n\nexport const MAP: Protocol = {\n  name: \"MAP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { Hash, Utils } from \"@bsv/sdk\";\nimport type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport type { MetaNet } from \"../types/protocols/metanet\";\n\nconst { toArray, toHex } = Utils;\n\nconst address = \"meta\";\n\nconst opReturnSchema: SchemaField[] = [\n  { address: \"string\" },\n  { parent: \"string\" },\n  { name: \"string\" },\n];\n\nexport const getEnvSafeMetanetID = async (a: string, tx: string) => {\n  // Calculate the node ID\n  const buf = Buffer.from(a + tx);\n  const hashBuf = Hash.sha256(toArray(buf));\n  return toHex(hashBuf);\n};\n\nconst handler = async ({ dataObj, cell, tx }: HandlerProps) => {\n  if (\n    !cell.length ||\n    cell[0].s !== \"meta\" ||\n    !cell[1] ||\n    !cell[1].s ||\n    !cell[2] ||\n    !cell[2].s ||\n    !tx\n  ) {\n    throw new Error(`Invalid Metanet tx ${tx}`);\n  }\n  // For now, we just copy from MOM keys later if available, or keep BOB format\n\n  const nodeId = await getEnvSafeMetanetID(cell[1].s, tx.tx.h);\n  // Described this node\n  const node = {\n    a: cell[1].s,\n    tx: tx.tx.h,\n    id: nodeId,\n  };\n  let parent = {\n    a: \"\",\n    tx: \"\",\n    id: \"\",\n  };\n  if (tx.in) {\n    const parentId = await getEnvSafeMetanetID(tx.in[0].e.a, cell[2].s);\n    // Parent node\n    parent = {\n      a: tx.in[0].e.a,\n      tx: cell[2].s,\n      id: parentId,\n    };\n  }\n\n  if (!dataObj.METANET) {\n    dataObj.METANET = [];\n  }\n  dataObj.METANET.push({\n    node,\n    parent,\n  });\n};\n\nexport const METANET: Protocol = {\n  name: \"METANET\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { ORD as OrdType } from \"../types/protocols/ord\";\n\nconst scriptChecker = (cell: Cell[]) => {\n  if (cell.length < 13) {\n    // wrong length\n    return false;\n  }\n\n  // Find OP_IF wrapper\n  const startIdx = findIndex(cell, (c: Cell) => c.ops === \"OP_IF\");\n  const endIdx = findIndex(cell, (c: Cell, i: number) => i > startIdx && c.ops === \"OP_ENDIF\");\n  const ordScript = cell.slice(startIdx, endIdx);\n  const prevCell = cell[startIdx - 1];\n  return prevCell?.op === 0 && !!ordScript[0] && !!ordScript[1] && ordScript[1].s === \"ord\";\n};\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n  if (!cell[0] || !out) {\n    throw new Error(\"Invalid Ord tx. dataObj, cell, out and tx are required.\");\n  }\n\n  // Find OP_IF wrapper\n  const startIdx = findIndex(cell, (c: Cell) => c.ops === \"OP_IF\");\n  const endIdx = findIndex(cell, (c: Cell, i: number) => i > startIdx && c.ops === \"OP_ENDIF\") + 1;\n  const ordScript = cell.slice(startIdx, endIdx);\n\n  if (!ordScript[0] || !ordScript[1] || ordScript[1].s !== \"ord\") {\n    throw new Error(\"Invalid Ord tx. Prefix not found.\");\n  }\n\n  let data: string | undefined;\n  let contentType: string | undefined;\n  ordScript.forEach((push, idx, all) => {\n    // content-type\n    if (push.ops === \"OP_1\") {\n      contentType = all[idx + 1].s;\n    }\n    // data\n    if (push.ops === \"OP_0\") {\n      data = all[idx + 1].b;\n    }\n  });\n\n  if (!data) {\n    throw new Error(\"Invalid Ord data.\");\n  }\n  if (!contentType) {\n    throw new Error(\"Invalid Ord content type.\");\n  }\n\n  const OrdObj: OrdType = {\n    data,\n    contentType,\n  };\n\n  if (!dataObj.ORD) {\n    dataObj.ORD = [];\n  }\n  dataObj.ORD.push(OrdObj);\n};\n\nexport const ORD: Protocol = {\n  name: \"ORD\",\n  handler,\n  scriptChecker,\n};\n\nfunction findIndex<T>(\n  array: T[],\n  predicate: (value: T, index: number, array: T[]) => boolean\n): number {\n  return findLastIndex(array, predicate);\n}\n\nfunction findLastIndex<T>(\n  array: T[],\n  predicate: (value: T, index: number, array: T[]) => boolean,\n  fromIndex?: number\n): number {\n  const length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  let index = length - 1;\n  if (fromIndex !== undefined) {\n    index = fromIndex;\n    index = fromIndex < 0 ? Math.max(length + index, 0) : Math.min(index, length - 1);\n  }\n  return baseFindIndex(array, predicate, index, true);\n}\n\nfunction baseFindIndex<T>(\n  array: T[],\n  predicate: (value: T, index: number, array: T[]) => boolean,\n  fromIndex: number,\n  fromRight: boolean\n): number {\n  const { length } = array;\n  let index = fromIndex + (fromRight ? 1 : -1);\n\n  while (fromRight ? index-- : ++index < length) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1GvFYzwtFix3qSAZhESQVTz9DeudHZNoh1\";\n\nconst opReturnSchema: SchemaField[] = [\n  { pair: \"json\" },\n  { address: \"string\" },\n  { timestamp: \"string\" },\n];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (\n    cell[0].s !== address ||\n    !cell[1] ||\n    !cell[2] ||\n    !cell[3] ||\n    !cell[1].s ||\n    !cell[2].s ||\n    !cell[3].s\n  ) {\n    throw new Error(`Invalid RON record ${tx?.tx.h}`);\n  }\n\n  const pair = JSON.parse(cell[1].s);\n  const timestamp = Number(cell[3].s);\n\n  saveProtocolData(dataObj, \"RON\", {\n    pair,\n    address: cell[2].s,\n    timestamp,\n  });\n};\n\nexport const RON: Protocol = {\n  name: \"RON\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1SymRe7erxM46GByucUWnB9fEEMgo7spd\";\n\nconst opReturnSchema = [{ url: \"string\" }];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (cell[0].s !== address || !cell[1] || !cell[1].s) {\n    throw new Error(`Invalid SymRe tx: ${tx}`);\n  }\n\n  saveProtocolData(dataObj, \"SYMRE\", { url: cell[1].s });\n};\n\nexport const SYMRE = {\n  name: \"SYMRE\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { type In, type Out, type Tape, parse } from \"bpu-ts\";\nimport { _21E8 } from \"./protocols/_21e8\";\nimport { AIP } from \"./protocols/aip\";\nimport { B } from \"./protocols/b\";\nimport { BAP } from \"./protocols/bap\";\nimport { BITCOM } from \"./protocols/bitcom\";\nimport { BITKEY } from \"./protocols/bitkey\";\nimport { BITPIC } from \"./protocols/bitpic\";\nimport { HAIP } from \"./protocols/haip\";\nimport { MAP } from \"./protocols/map\";\nimport { METANET } from \"./protocols/metanet\";\nimport { ORD } from \"./protocols/ord\";\nimport { RON } from \"./protocols/ron\";\nimport { SYMRE } from \"./protocols/symre\";\nimport type {\n  BmapTx,\n  BobTx,\n  Handler,\n  HandlerProps,\n  MetaNet,\n  MomTx,\n  Protocol,\n  SchemaField,\n  ScriptChecker,\n} from \"./types/common\";\nimport {\n  checkOpFalseOpReturn,\n  checkOpReturn,\n  isObjectArray,\n  isStringArray,\n  saveProtocolData,\n} from \"./utils\";\n\n// Names of enabled protocols\nconst enabledProtocols = new Map<string, string>([]);\n// Protocol Handlers\nconst protocolHandlers = new Map<string, Handler>([]);\n// Script checkers are intentionally minimalistic detection functions for identifying matching scripts for a given protocol. Only if a checker returns true is a handler called for processing.\nconst protocolScriptCheckers = new Map<string, ScriptChecker>([]);\nconst protocolOpReturnSchemas = new Map<string, SchemaField[]>();\n\nexport const allProtocols = [\n  AIP,\n  B,\n  BAP,\n  MAP,\n  METANET,\n  _21E8,\n  BITCOM,\n  BITKEY,\n  BITPIC,\n  HAIP,\n  RON,\n  SYMRE,\n  ORD,\n];\n\nexport const supportedProtocols = allProtocols.map((p) => p.name);\nexport const defaultProtocols = [AIP, B, BAP, MAP, METANET, ORD];\n\n// prepare protocol map, handlers and schemas\nfor (const protocol of defaultProtocols) {\n  if (protocol.address) {\n    enabledProtocols.set(protocol.address, protocol.name);\n  }\n  protocolHandlers.set(protocol.name, protocol.handler);\n  if (protocol.opReturnSchema) {\n    protocolOpReturnSchemas.set(protocol.name, protocol.opReturnSchema);\n  }\n  if (protocol.scriptChecker) {\n    protocolScriptCheckers.set(protocol.name, protocol.scriptChecker);\n  }\n}\n\n// Takes a BOB formatted op_return transaction\nexport class BMAP {\n  enabledProtocols: Map<string, string>;\n  protocolHandlers: Map<string, Handler>;\n  protocolScriptCheckers: Map<string, ScriptChecker>;\n  protocolOpReturnSchemas: Map<string, SchemaField[]>;\n\n  constructor() {\n    // initial default protocol handlers in this instantiation\n    this.enabledProtocols = enabledProtocols;\n    this.protocolHandlers = protocolHandlers;\n    this.protocolScriptCheckers = protocolScriptCheckers;\n    this.protocolOpReturnSchemas = protocolOpReturnSchemas;\n  }\n\n  addProtocolHandler({ name, address, opReturnSchema, handler, scriptChecker }: Protocol) {\n    if (address) {\n      this.enabledProtocols.set(address, name);\n    }\n    this.protocolHandlers.set(name, handler);\n    if (opReturnSchema) {\n      this.protocolOpReturnSchemas.set(name, opReturnSchema);\n    }\n    if (scriptChecker) {\n      this.protocolScriptCheckers.set(name, scriptChecker);\n    }\n  }\n\n  transformTx = async (tx: BobTx | MomTx): Promise<BmapTx> => {\n    if (!tx || !tx.in || !tx.out) {\n      throw new Error(\"Cannot process tx\");\n    }\n\n    // This will become our nicely formatted response object\n    let dataObj: Partial<BobTx> = {};\n\n    for (const [key, val] of Object.entries(tx)) {\n      if (key === \"out\") {\n        // loop over the outputs\n        for (const out of tx.out) {\n          const { tape } = out;\n\n          // Process opReturn data\n          if (tape?.some((cc) => checkOpReturn(cc))) {\n            dataObj = await this.processDataProtocols(tape, out, tx, dataObj);\n          }\n\n          // No OP_FALSE OP_RETURN in this tape\n          const _21e8Checker = this.protocolScriptCheckers.get(_21E8.name);\n          const ordChecker = this.protocolScriptCheckers.get(ORD.name);\n\n          // Check for 21e8 and ords\n          if (\n            tape?.some((cc) => {\n              const { cell } = cc;\n              if (_21e8Checker?.(cell)) {\n                // 'found 21e8'\n                return true;\n              }\n              if (ordChecker?.(cell)) {\n                // 'found 1sat ordinal'\n                return true;\n              }\n            })\n          ) {\n            // find the cell array\n            // loop over tape\n            for (const cellContainer of tape) {\n              const { cell } = cellContainer;\n              // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n              if (!cell) {\n                throw new Error(\"empty cell while parsing\");\n              }\n              let protocolName = \"\";\n              if (_21e8Checker?.(cell)) {\n                protocolName = _21E8.name;\n              } else if (ordChecker?.(cell)) {\n                protocolName = ORD.name;\n              } else {\n                // nothing found\n                continue;\n              }\n\n              this.process(protocolName, {\n                tx,\n                cell,\n                dataObj: dataObj as BmapTx,\n                tape,\n                out,\n              });\n            }\n          }\n        }\n      } else if (key === \"in\") {\n        dataObj[key] = val.map((v: In) => {\n          const r = { ...v } as any;\n          r.tape = undefined;\n          return r as In;\n        });\n      } else {\n        // known key, just write it retaining original type\n        dataObj[key] = val;\n      }\n    }\n\n    // If this is a MOM planaria it will have metanet keys available\n    if (dataObj.METANET && (tx as MomTx).parent) {\n      const meta = {\n        ancestor: (tx as MomTx).ancestor,\n        parent: (tx as MomTx).parent,\n        child: (tx as MomTx).child,\n        head: (tx as MomTx).head,\n      } as MetaNet;\n      (dataObj.METANET as MetaNet[]).push(meta);\n      // remove parent and node from root level for (MOM data)\n      dataObj.ancestor = undefined;\n      dataObj.child = undefined;\n      dataObj.parent = undefined;\n      dataObj.head = undefined;\n      dataObj.node = undefined;\n    }\n\n    return dataObj as BmapTx;\n  };\n\n  processUnknown = (key: string, dataObj: Partial<BmapTx>, out: Out) => {\n    // no known non-OP_RETURN scripts\n    if (key && !dataObj[key]) {\n      dataObj[key] = [];\n    }\n    (dataObj[key] as Out[]).push({\n      i: out.i,\n      e: out.e,\n      tape: [],\n    });\n  };\n\n  process = async (protocolName: string, { cell, dataObj, tape, out, tx }: HandlerProps) => {\n    if (\n      this.protocolHandlers.has(protocolName) &&\n      typeof this.protocolHandlers.get(protocolName) === \"function\"\n    ) {\n      const handler = this.protocolHandlers.get(protocolName);\n      if (handler) {\n        /* eslint-disable no-await-in-loop */\n        await handler({\n          dataObj,\n          cell,\n          tape,\n          out,\n          tx,\n        });\n      }\n    } else {\n      saveProtocolData(dataObj, protocolName, cell);\n    }\n  };\n\n  processDataProtocols = async (\n    tape: Tape[],\n    out: Out,\n    tx: BobTx,\n    dataObj: Partial<BobTx>\n  ): Promise<Partial<BobTx>> => {\n    // loop over tape\n    for (const cellContainer of tape) {\n      const { cell } = cellContainer;\n      if (!cell) {\n        throw new Error(\"empty cell while parsing\");\n      }\n\n      // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n      if (checkOpFalseOpReturn(cellContainer)) {\n        continue;\n      }\n\n      const prefix = cell[0].s;\n\n      if (prefix) {\n        const bitcomProtocol =\n          this.enabledProtocols.get(prefix) ||\n          defaultProtocols.filter((p) => p.name === prefix)[0]?.name;\n        if (bitcomProtocol) {\n          await this.process(bitcomProtocol, {\n            cell,\n            dataObj: dataObj as BmapTx,\n            tape,\n            out,\n            tx,\n          });\n        } else {\n          this.processUnknown(prefix, dataObj, out);\n        }\n      }\n    }\n    return dataObj;\n  };\n}\n\nexport const fetchRawTx = async (txid: string): Promise<string> => {\n  const url = `https://api.whatsonchain.com/v1/bsv/main/tx/${txid}/hex`;\n  console.log(\"hitting\", url);\n  const res = await fetch(url);\n  return await res.text();\n};\n\nexport const bobFromRawTx = async (rawTx: string): Promise<BobTx> => {\n  const bpuTx = await parse({\n    tx: { r: rawTx },\n    split: [\n      {\n        token: { op: 106 },\n        include: \"l\",\n      },\n      {\n        token: { s: \"|\" },\n      },\n    ],\n  });\n  return bpuTx as BobTx;\n};\n\n// TransformTx\n// tx - a raw hex string or a Bob/Bmap/Mom transaction object\n// protocols - the handlers you want to load and use to process the tx\n// reducing the number of supported protocols may improve transform speed\n// at the expense of detecting more data protocols\nexport const TransformTx = async (\n  tx: BobTx | string | MomTx | BmapTx,\n  protocols?: string[] | Protocol[]\n) => {\n  if (typeof tx === \"string\") {\n    let rawTx: string | undefined;\n    // if it a txid or  complete transaction hex?\n    if (tx.length === 64) {\n      // txid - fetch raw tx\n      rawTx = await fetchRawTx(tx);\n    }\n\n    if (Buffer.from(tx).byteLength <= 146) {\n      throw new Error(\"Invalid rawTx\");\n    }\n\n    if (!rawTx) {\n      rawTx = tx;\n    }\n\n    // TODO: Double check 146 is intended to be minimum possible byte length for a tx\n    const bobTx = await bobFromRawTx(rawTx);\n\n    if (bobTx) {\n      tx = bobTx;\n    } else {\n      throw new Error(\"Invalid txid\");\n    }\n  }\n\n  const b = new BMAP();\n\n  // if protocols are specified\n  if (protocols) {\n    // wipe out defaults\n    b.enabledProtocols.clear();\n    if (isStringArray(protocols)) {\n      // set enabled protocols\n      for (const protocol of allProtocols) {\n        if ((protocols as string[])?.includes(protocol.name)) {\n          b.addProtocolHandler(protocol);\n        }\n      }\n    } else if (isObjectArray(protocols)) {\n      for (const p of protocols) {\n        const protocol = p as Protocol;\n        if (protocol) {\n          b.addProtocolHandler(protocol);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Invalid protocol array. Must be either an array of protocol names (string[]), or Protocol objects (Protocol[]).\"\n      );\n    }\n  }\n\n  return b.transformTx(tx);\n};\n\n// Export types\nexport type {\n  BmapTx,\n  BobTx,\n  Handler,\n  HandlerProps,\n  MomTx,\n  Protocol,\n  ScriptChecker,\n} from \"./types/common\";\n"],"names":["isStringArray","arr","value","isObjectArray","cellValue","pushData","schemaEncoding","checkOpReturn","cc","c","checkOpFalseOpReturn","opReturnIdx","_a","saveProtocolData","dataObj","protocolName","data","bmapOpReturnSchemaHandler","opReturnSchema","cell","tx","obj","length","idx","schemaField","x","field","isBase64","regex","_21e8Script","scriptChecker","ops","target","targetOpSize","handler","out","txid","difficulty","_21e8Obj","_21E8","toArray","toHex","fromBase58Check","toBase58Check","Utils","address","validateSignature","aipObj","tape","cellIndex","i","usingIndexes","signatureValues","cellContainer","statement","indexLength","indexes","signatureBufferStatements","index","messageBuffer","dataScript","Script","dataArray","Hash","addressString","signature","Signature","e","tryNormalLogic","msgHash","BSM","bigMsg","toBigNumberFromBuffer","recovery","publicKey","pubKeyHash","prefix","tryTwetchLogic","trimmed","buff","hexStr","twetchMsg","verified","buffer","hex","BigNumber","SIGPROTO","AIPhandler","useOpReturnSchema","protocol","aipField","fieldData","AIP","encodingMap","bObj","bField","encoding","B","BAP","protocolAddress","bitcomObj","BITCOM","magicHash","toBigNumber","recoverPublicKeyFromBSM","message","bitkeyObj","bitkeyField","pubkeyHex","userPubKeyHash","PublicKey","userAddress","concatenated","concatenatedBuffer","bitkeyMessage","bitkeySignature","recoveredBitkeyPubkey","recoveredBitkeyPubKeyHash","recoveredBitkeyAddress","bitkeySignatureVerified","userMessage","userSignature","recoveredUserPubkey","recoveredUserPubKeyHash","recoveredUserAddress","userSignatureVerified","BITKEY","bitpicObj","bin","hashBuff","sig","pubkey","BITPIC","HAIP","processADD","mapObj","last","pushdataContainer","pushdata","proccessDELETE","processSELECT","processMSGPACK","decode","processJSON","processSET","commands","commandSeparator","mapCmdKey","MAP","getEnvSafeMetanetID","a","buf","hashBuf","nodeId","node","parent","parentId","METANET","startIdx","findIndex","endIdx","ordScript","prevCell","contentType","push","all","OrdObj","ORD","array","predicate","findLastIndex","fromIndex","baseFindIndex","fromRight","pair","timestamp","RON","SYMRE","enabledProtocols","protocolHandlers","protocolScriptCheckers","protocolOpReturnSchemas","allProtocols","supportedProtocols","p","defaultProtocols","BMAP","name","key","val","_21e8Checker","ordChecker","v","r","meta","bitcomProtocol","fetchRawTx","url","bobFromRawTx","rawTx","parse","TransformTx","protocols","bobTx","b"],"mappings":"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"}