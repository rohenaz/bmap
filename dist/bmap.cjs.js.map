{"version":3,"file":"bmap.cjs.js","sources":["../src/utils.ts","../src/protocols/_21e8.ts","../src/protocols/aip.ts","../src/protocols/b.ts","../src/protocols/bap.ts","../src/protocols/bitcom.ts","../src/protocols/bitkey.ts","../src/protocols/bitpic.ts","../src/protocols/haip.ts","../src/protocols/map.ts","../src/protocols/metanet.ts","../src/protocols/ord.ts","../src/protocols/ron.ts","../src/protocols/symre.ts","../src/bmap.ts"],"sourcesContent":["import { Hash, Utils } from \"@bsv/sdk\";\nimport type { Cell, Tape } from \"bpu-ts\";\nimport type { BmapTx, BobTx, SchemaField } from \"./types/common\";\nconst { toArray } = Utils;\n\nexport const isStringArray = (arr: Array<any>): boolean => {\n  return (\n    arr.length > 0 &&\n    arr.every((value) => {\n      return typeof value === \"string\";\n    })\n  );\n};\nexport const isObjectArray = (arr: Array<any>): boolean => {\n  return (\n    arr.length > 0 &&\n    arr.every((value) => {\n      return value === \"object\";\n    })\n  );\n};\n/**\n * returns the BOB cell value for a given encoding\n *\n * @param pushData\n * @param schemaEncoding\n * @returns {string|number}\n */\nexport const cellValue = (pushData: Cell, schemaEncoding?: string): string | number => {\n  if (!pushData) {\n    throw new Error(`cannot get cell value of: ${pushData}`);\n  }\n  if (schemaEncoding === \"string\") {\n    return pushData.s ? pushData.s : pushData.ls || \"\";\n  }\n  if (schemaEncoding === \"hex\") {\n    return pushData.h\n      ? pushData.h\n      : pushData.lh ||\n      (pushData.b\n        ? Buffer.from(pushData.b, \"base64\").toString(\"hex\")\n        : pushData.lb && Buffer.from(pushData.lb, \"base64\").toString(\"hex\")) ||\n      \"\";\n  }\n  if (schemaEncoding === \"number\") {\n    return Number.parseInt(pushData.h ? pushData.h : pushData.lh || \"0\", 16);\n  }\n  if (schemaEncoding === \"file\") {\n    return `bitfs://${pushData.f ? pushData.f : pushData.lf}`;\n  }\n  if (schemaEncoding === \"binary\") {\n    return pushData.b || pushData.lb || \"\";\n  }\n\n  return (pushData.b ? pushData.b : pushData.lb) || \"\";\n};\n\n/**\n * Check if cells end with OP_RETURN\n */\nexport const checkOpReturn = (cc: Tape): boolean => {\n  return cc.cell.some((c: Cell) => c.op === 106);\n};\n\n/**\n * Check if cells end with OP_FALSE + OP_RETURN\n */\nexport const checkOpFalseOpReturn = (cc: Tape): boolean => {\n  if (cc.cell.length !== 2) {\n    return false;\n  }\n  const opReturnIdx = cc.cell.findIndex((c) => c.op === 106);\n  if (opReturnIdx !== -1) {\n    return cc.cell[opReturnIdx - 1]?.op === 0;\n  }\n  return false;\n};\n\n/**\n * Helper function to store protocol data\n *\n * @param dataObj\n * @param protocolName\n * @param data\n */\nexport const saveProtocolData = (\n  dataObj: { [key: string]: any },\n  protocolName: string,\n  data: any\n) => {\n  if (!dataObj[protocolName]) {\n    dataObj[protocolName] = [data];\n  } else {\n    if (!Array.isArray(dataObj[protocolName])) {\n      const prevData = dataObj[protocolName];\n      dataObj[protocolName] = [];\n      dataObj[protocolName][0] = prevData;\n    }\n    dataObj[protocolName].push(data);\n  }\n};\n\n/**\n * BMAP default handler to work with query schema's\n *\n * @param opReturnSchema\n * @param protocolName\n * @param dataObj\n * @param cell\n * @param tape\n * @param tx\n */\nexport const bmapOpReturnSchemaHandler = (\n  protocolName: string,\n  opReturnSchema: SchemaField[],\n  dataObj: BmapTx,\n  cell: Cell[],\n  tx: BobTx\n) => {\n  // loop over the schema\n  const obj: { [key: string]: any } = {};\n\n  // Does not have the required number of fields\n  const length = opReturnSchema.length + 1;\n  if (cell.length < length) {\n    throw new Error(\n      `${protocolName} requires at least ${length} fields including the prefix: ${tx.tx.h}`\n    );\n  }\n\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n\n    const [field] = Object.keys(schemaField);\n    const [schemaEncoding] = Object.values(schemaField);\n    obj[field] = cellValue(cell[x + 1], schemaEncoding as string);\n  }\n\n  saveProtocolData(dataObj, protocolName, obj);\n};\n\n/**\n * Check whether the given data is base64\n *\n * @param data\n * @returns {boolean}\n */\nexport const isBase64 = (data: string) => {\n  const regex = \"(?:[A-Za-z0-9+\\\\/]{4})*(?:[A-Za-z0-9+\\\\/]{2}==|[A-Za-z0-9+/]{3}=)?\";\n  return new RegExp(`^${regex}$`, \"gi\").test(data);\n};\n\n// hashes a message buffer, returns the hash as a buffer\nexport const sha256 = (msgBuffer: number[]) => {\n  return Hash.sha256(toArray(msgBuffer));\n};\n\n\nexport const shallowEqualArrays = <T>(arr1: T[], arr2: T[]): boolean => {\n  return (\n    arr1.length === arr2.length &&\n    arr1.every((value, index) => value === arr2[index])\n  );\n}\n","import type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { _21E8 as _21E8Type } from \"../types/protocols/_21e8\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\n// 21e8 does not use the first pushdata for id\n// in fact there is no id since the 21e8 is designed for difficulty and can be changed\n// instead we use the static part of the script to indentfy the transaction\n// TODO - the OP_X_PLACEHOLDER is the number of bytes to push onto the stack and must match difficulty size\nconst _21e8Script =\n  \"OP_SIZE <OP_X_PLACEHOLDER> OP_PICK OP_SHA256 OP_SWAP OP_SPLIT OP_DROP OP_EQUALVERIFY OP_DROP OP_CHECKSIG\".split(\n    \" \"\n  );\n\nconst scriptChecker = (cell: Cell[]) => {\n  if (cell.length !== 12) {\n    // wrong length\n    return false;\n  }\n\n  // match exact script\n  const ops = [...cell].map((c) => c.ops).splice(2, cell.length);\n\n  // calculate target byte length\n  const target = cellValue(cell[1], \"hex\") as string;\n  const targetOpSize = Buffer.from(target).byteLength;\n\n  // replace the placeholder opcode with actual\n  ops[1] = `OP_${targetOpSize}`;\n  _21e8Script[1] = `OP_${targetOpSize}`;\n\n  // protocol identifier always in first pushdata\n  return ops.join() === _21e8Script.join();\n};\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n  if (!cell[0] || !out) {\n    throw new Error(\"Invalid 21e8 tx. dataObj, cell, out and tx are required.\");\n  }\n\n  // assemble asm\n  // make sure first piece matches a txid\n  // 2nd piece matches any difficulty. set some resonable limit in bytes if there isnt one documented somewhere\n  // next\n\n  const txid = cellValue(cell[0], \"hex\") as string;\n  const target = cellValue(cell[1], \"hex\") as string;\n  if (!target) {\n    throw new Error(`Invalid 21e8 target. ${JSON.stringify(cell[0], null, 2)}`);\n  }\n  const difficulty = Buffer.from(target, \"hex\").byteLength;\n\n  const _21e8Obj: _21E8Type = {\n    target,\n    difficulty,\n    value: out.e.v,\n    txid,\n  };\n\n  saveProtocolData(dataObj, \"21E8\", _21e8Obj);\n};\n\nexport const _21E8: Protocol = {\n  name: \"21E8\",\n  handler,\n  scriptChecker,\n};\n","import { BSM, BigNumber, Hash, Script, Signature, Utils } from \"@bsv/sdk\";\nimport type { Cell, Tape } from \"bpu-ts\";\nimport type { BmapTx, BobTx, HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport type { AIP as AIPType } from \"../types/protocols/aip\";\nimport type { HAIP as HAIPType } from \"../types/protocols/haip\";\nimport { cellValue, checkOpFalseOpReturn, isBase64, saveProtocolData, shallowEqualArrays } from \"../utils\";\n\nconst { toArray, toHex, fromBase58Check, toBase58Check } = Utils;\n\nconst address = \"15PciHG22SNLQJXMoSUaWVi7WSqc7hCfva\";\n\nconst opReturnSchema: SchemaField[] = [\n  { algorithm: \"string\" },\n  { address: \"string\" },\n  { signature: \"binary\" },\n  [{ index: \"number[]\" }],\n];\n\nfunction validateSignature(\n  aipObj: Partial<AIPType | HAIPType>,\n  cell: Cell[],\n  tape: Tape[]\n): boolean {\n  if (!Array.isArray(tape) || tape.length < 3) {\n    throw new Error(\"AIP requires at least 3 cells including the prefix\");\n  }\n\n  let cellIndex = -1;\n  for (let i = 0; i < tape.length; i++) {\n    if (shallowEqualArrays(tape[i].cell, cell)) {\n      console.log(\"[validateSignature] found cell in tape\");\n      cellIndex = i;\n      break;\n    }\n  }\n  if (cellIndex === -1) {\n    throw new Error(\"AIP could not find cell in tape\");\n  }\n\n  console.log(\"[validateSignature] tape:\", tape.map(t => t.cell.map(c => `c.ii: ${c.ii}, c.h: ${c.h?.slice(0, 10)}, c.b: ${c.b?.slice(0, 10)}, c.s: ${c.s?.slice(0, 10)}`)));\n\n  let usingIndexes: number[] = aipObj.index || [];\n  const signatureValues: number[][] = [];\n\n  // Always start with OP_RETURN\n  const allCells = tape.flatMap(t => t.cell)\n    .filter(c => c.ii !== undefined)\n    .sort((a, b) => (a.ii || 0) - (b.ii || 0));\n\n  const firstCell = allCells[0];\n  if (firstCell?.op === 106) {\n    signatureValues.push(toArray(\"6a\", \"hex\")); // Use OP_RETURN from opcode\n  } else {\n    // If no opcode, just use the standard OP_RETURN\n    signatureValues.push(toArray(\"6a\", \"hex\"));\n  }\n\n  // Create a map of all cells by their ii value\n  const cellsByIndex = new Map<number, Cell>();\n  for (const cell of allCells) {\n    if (cell.ii !== undefined) {\n      cellsByIndex.set(cell.ii, cell);\n    }\n  }\n\n  // Print out all cells in order with their hex values\n  console.log(\"[validateSignature] All cells in order:\");\n  for (const c of allCells) {\n    console.log(`ii: ${c.ii}, hex: ${c.h}, s: ${c.s}`);\n  }\n\n  if (usingIndexes.length > 0) {\n    console.log(\"[validateSignature] Using indexes:\", usingIndexes);\n\n    // Filter to only the values at the specified indices\n    for (let i = 0; i < usingIndexes.length; i++) {\n      const index = usingIndexes[i];\n\n      // Skip index 0 since we already handled OP_RETURN\n      if (index === 0) continue;\n\n      // Find the cell with exact ii match\n      const targetCell = allCells.find(c => (c.ii || 0) === index);\n\n      // If we don't find a cell at this index, it's a protocol separator\n      if (!targetCell) {\n        signatureValues.push(toArray(\"7c\", \"hex\")); // |\n        continue;\n      }\n\n      if (targetCell.h) {\n        signatureValues.push(toArray(targetCell.h, \"hex\"));\n      } else if (targetCell.b) {\n        signatureValues.push(toArray(targetCell.b, \"base64\"));\n      } else if (targetCell.s) {\n        signatureValues.push(toArray(targetCell.s));\n      } else {\n        console.log(`[validateSignature] No usable value found in cell with ii: ${targetCell.ii}`);\n        return false;\n      }\n    }\n  } else {\n    // Process each tape up to the AIP tape\n    for (let i = 1; i < cellIndex; i++) {\n      const tapeCells = tape[i].cell;\n      if (!checkOpFalseOpReturn({ cell: tapeCells } as Tape)) {\n        // Add each cell's value\n        for (const cell of tapeCells) {\n          if (cell.h) {\n            signatureValues.push(toArray(cell.h, \"hex\"));\n          } else if (cell.b) {\n            signatureValues.push(toArray(cell.b, \"base64\"));\n          } else if (cell.s) {\n            signatureValues.push(toArray(cell.s));\n          }\n        }\n\n        // Add protocol separator after each tape\n        signatureValues.push(toArray(\"7c\", \"hex\")); // |\n      }\n    }\n  }\n\n  // Handle HAIP specific logic\n  if (aipObj.hashing_algorithm) {\n    // when using HAIP, we need to parse the indexes in a non standard way\n    // indexLength is byte size of the indexes being described\n    if (aipObj.index_unit_size) {\n      const indexLength = aipObj.index_unit_size * 2;\n      usingIndexes = [];\n      const indexes = cell[6].h as string;\n      for (let i = 0; i < indexes.length; i += indexLength) {\n        usingIndexes.push(Number.parseInt(indexes.substr(i, indexLength), 16));\n      }\n      aipObj.index = usingIndexes;\n    }\n  }\n\n  console.log(\"[validateSignature] Final signature values:\", signatureValues.map(v => toHex(v)));\n\n  let messageBuffer: number[];\n  if (aipObj.hashing_algorithm) {\n    // this is actually Hashed-AIP (HAIP) and works a bit differently\n    if (!aipObj.index_unit_size) {\n      // remove OP_RETURN - will be added by Script.buildDataOut\n      signatureValues.shift();\n    }\n    const dataScript = Script.fromHex(toHex(signatureValues.flat()));\n    let dataArray = toArray(dataScript.toHex(), \"hex\");\n    if (aipObj.index_unit_size) {\n      // the indexed buffer should not contain the OP_RETURN opcode, but this\n      // is added by the buildDataOut function automatically. Remove it.\n      dataArray = dataArray.slice(1);\n    }\n    messageBuffer = Hash.sha256(dataArray);\n  } else {\n    // regular AIP\n    messageBuffer = signatureValues.flat();\n  }\n\n  // AIOP uses address, HAIP uses signing_address field names\n  const addressString = (aipObj as AIPType).address || (aipObj as HAIPType).signing_address;\n  if (!addressString || !aipObj.signature) {\n    return false;\n  }\n\n  let signature: Signature;\n  try {\n    // the signature is always base64 encoded\n    signature = Signature.fromCompact(aipObj.signature, \"base64\");\n  } catch (e) {\n    console.log(\"[validateSignature] Failed to parse signature:\", e);\n    return false;\n  }\n\n  const tryNormalLogic = (): boolean => {\n    try {\n      const msgHash = BSM.magicHash(messageBuffer);\n      const bigMsg = toBigNumberFromBuffer(msgHash);\n\n      for (let recovery = 0; recovery < 4; recovery++) {\n        try {\n          const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n          const pubKeyHash = publicKey.toHash() as number[];\n          const { prefix } = fromBase58Check(addressString);\n          const recoveredAddress = toBase58Check(pubKeyHash, prefix as number[]);\n          if (recoveredAddress === addressString) {\n            return BSM.verify(messageBuffer, signature, publicKey);\n          }\n        } catch (e) {\n          console.log(\"[tryNormalLogic] Recovery error:\", e);\n        }\n      }\n    } catch (e) {\n      console.log(\"[tryNormalLogic] error:\", e);\n    }\n    return false;\n  };\n\n  const tryTwetchLogic = (): boolean => {\n    // Twetch signs a UTF-8 buffer of the hex string of a sha256 hash of the message\n    // Without 0x06 (OP_RETURN) and without 0x7c at the end, the trailing pipe (\"|\")\n    if (signatureValues.length <= 2) {\n      return false;\n    }\n\n    try {\n      const trimmed = signatureValues.slice(1, -1);\n      const buff = Hash.sha256(trimmed.flat());\n      const hexStr = toHex(buff);\n      const twetchMsg = toArray(hexStr, \"utf8\");\n\n      const msgHash = BSM.magicHash(twetchMsg);\n      const bigMsg = toBigNumberFromBuffer(msgHash);\n\n      for (let recovery = 0; recovery < 4; recovery++) {\n        try {\n          const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n          const pubKeyHash = publicKey.toHash() as number[];\n          const { prefix } = fromBase58Check(addressString);\n          const recoveredAddress = toBase58Check(pubKeyHash, prefix as number[]);\n          if (recoveredAddress === addressString) {\n            return BSM.verify(twetchMsg, signature, publicKey);\n          }\n        } catch (e) {\n          console.log(\"[tryTwetchLogic] Recovery error:\", e);\n        }\n      }\n    } catch (e) {\n      console.log(\"[tryTwetchLogic] error:\", e);\n    }\n    return false;\n  };\n\n  let verified = tryNormalLogic();\n  if (!verified) {\n    verified = tryTwetchLogic();\n  }\n\n  aipObj.verified = verified;\n  return verified;\n}\n\nfunction toBigNumberFromBuffer(buffer: number[]): BigNumber {\n  const hex = toHex(buffer);\n  return new BigNumber(hex, 16);\n}\n\nexport enum SIGPROTO {\n  HAIP = \"HAIP\",\n  AIP = \"AIP\",\n}\n\nexport const AIPhandler = async (\n  useOpReturnSchema: SchemaField[],\n  protocol: SIGPROTO,\n  dataObj: Partial<BobTx>,\n  cell: Cell[],\n  tape: Tape[]\n): Promise<HandlerProps> => {\n  // loop over the schema\n  const aipObj: { [key: string]: number | number[] | string | boolean } = {};\n\n  // Does not have the required number of fields\n  if (cell.length < 4) {\n    throw new Error(\"AIP requires at least 4 fields including the prefix\");\n  }\n\n  for (const [idx, schemaField] of Object.entries(useOpReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n\n    if (Array.isArray(schemaField)) {\n      // signature indexes are specified\n      const [aipField] = Object.keys(schemaField[0]) as (keyof AIPType)[];\n      // field \"index\"\n      console.log(\"[AIPhandler] aipField:\", aipField);\n      // run through the rest of the fields in this cell, should be de indexes\n      const fieldData: number[] = [];\n      for (let i = x + 1; i < cell.length; i++) {\n        if (cell[i].h && Array.isArray(fieldData)) {\n          fieldData.push(Number.parseInt(cell[i].h || \"\", 16));\n        }\n      }\n      console.log(\"[AIPhandler] fieldData:\", fieldData);\n      aipObj[aipField] = fieldData;\n    } else {\n      const [aipField] = Object.keys(schemaField) as (keyof AIPType)[];\n      const [schemaEncoding] = Object.values(schemaField);\n      aipObj[aipField] = cellValue(cell[x + 1], schemaEncoding as string) || \"\";\n    }\n  }\n\n  // There is an issue where some services add the signature as binary to the transaction\n  // whereas others add the signature as base64. This will confuse bob and the parser and\n  // the signature will not be verified. When the signature is added in binary cell[3].s is\n  // binary, otherwise cell[3].s contains the base64 signature and should be used.\n  if (cell[0].s === address && cell[3].s && isBase64(cell[3].s)) {\n    aipObj.signature = cell[3].s;\n  }\n\n  if (!aipObj.signature) {\n    throw new Error(\"AIP requires a signature\");\n  }\n\n  validateSignature(aipObj as Partial<AIPType>, cell, tape);\n\n  saveProtocolData(dataObj, protocol, aipObj);\n  return { dataObj: dataObj as BmapTx, cell, tape };\n};\n\nconst handler = async ({ dataObj, cell, tape }: HandlerProps): Promise<HandlerProps> => {\n  if (!tape) {\n    throw new Error(\"Invalid AIP transaction. tape is required\");\n  }\n  return AIPhandler(opReturnSchema, SIGPROTO.AIP, dataObj, cell, tape);\n};\n\nexport const AIP: Protocol = {\n  name: \"AIP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\nconst address = \"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\";\n\nconst opReturnSchema: SchemaField[] = [\n  { content: [\"string\", \"binary\", \"file\"] },\n  { \"content-type\": \"string\" },\n  { encoding: \"string\" }, // we use this field to determine content character encoding. If encoding is not a valid character encoding (gzip), we assume it is binary\n  { filename: \"string\" },\n];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps): void => {\n  const encodingMap = new Map<string, string>();\n  encodingMap.set(\"utf8\", \"string\");\n  encodingMap.set(\"text\", \"string\"); // invalid but people use it :(\n  encodingMap.set(\"gzip\", \"binary\"); // invalid but people use it :(\n  encodingMap.set(\"text/plain\", \"string\");\n  encodingMap.set(\"image/png\", \"binary\");\n  encodingMap.set(\"image/jpeg\", \"binary\");\n  encodingMap.set(\"application/octet-stream\", \"binary\"); // for encrypted data\n\n  if (!cell[1] || !cell[2]) {\n    throw new Error(`Invalid B tx: ${tx}`);\n  }\n\n  // Check pushdata length + 1 for protocol prefix\n  if (cell.length > opReturnSchema.length + 1) {\n    throw new Error(\"Invalid B tx. Too many fields.\");\n  }\n\n  const bObj: { [key: string]: string | number | undefined } = {};\n  // loop over the schema\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n    const bField = Object.keys(schemaField)[0];\n    let schemaEncoding = Object.values(schemaField)[0];\n    if (bField === \"content\") {\n      // If the encoding is ommitted, try to infer from content-type instead of breaking\n      if (cell[1].f) {\n        // this is file reference to B files\n        schemaEncoding = \"file\";\n      } else if ((!cell[3] || !cell[3].s) && cell[2].s) {\n        schemaEncoding = encodingMap.get(cell[2].s) as string;\n        if (!schemaEncoding) {\n          // If we can't infer from content-type, assume binary for encrypted data\n          schemaEncoding = \"binary\";\n        }\n\n        // add the missing encoding field\n        if (!cell[3]) {\n          cell[3] = { h: \"\", b: \"\", s: \"\", i: 0, ii: 0 };\n        }\n        cell[3].s = schemaEncoding === \"string\" ? \"utf-8\" : \"binary\";\n      } else {\n        const encoding = (\n          cell[3]?.s ? encodingMap.get(cell[3].s.replace(\"-\", \"\").toLowerCase()) : null\n        ) as string | null;\n        if (!encoding) {\n          // If we can't determine encoding, assume binary for encrypted data\n          schemaEncoding = \"binary\";\n        } else {\n          schemaEncoding = encoding;\n        }\n      }\n    }\n\n    // encoding is not required\n    if (bField === \"encoding\" && !cell[x + 1]) {\n      // encoding omitted\n      continue;\n    }\n\n    // filename is not required\n    if (bField === \"filename\" && !cell[x + 1]) {\n      // filename omitted\n      continue;\n    }\n\n    // check for malformed syntax\n    if (!cell || !cell[x + 1]) {\n      throw new Error(`malformed B syntax ${cell}`);\n    }\n\n    // set field value from either s, b, ls, or lb depending on encoding and availability\n    const data = cell[x + 1];\n    bObj[bField] = cellValue(data, schemaEncoding as string);\n  }\n\n  saveProtocolData(dataObj, \"B\", bObj);\n};\n\nexport const B: Protocol = {\n  name: \"B\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { bmapOpReturnSchemaHandler } from \"../utils\";\n\nconst address = \"1BAPSuaPnfGnSBM3GLV9yhxUdYe4vGbdMT\";\n\nconst opReturnSchema: SchemaField[] = [\n  { type: \"string\" },\n  { hash: \"string\" },\n  { sequence: \"string\" },\n];\n\nexport const handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (!tx) {\n    throw new Error(\"Invalid BAP tx, tx required\");\n  }\n  bmapOpReturnSchemaHandler(\"BAP\", opReturnSchema, dataObj, cell, tx);\n};\n\nexport const BAP: Protocol = {\n  name: \"BAP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst protocolAddress = \"$\";\n\nconst opReturnSchema: SchemaField[] = [\n  {\n    su: [{ pubkey: \"string\" }, { sign_position: \"string\" }, { signature: \"string\" }],\n    echo: [{ data: \"string\" }, { to: \"string\" }, { filename: \"string\" }],\n    route: [\n      [\n        {\n          add: [\n            { bitcom_address: \"string\" },\n            { route_matcher: \"string\" },\n            { endpoint_template: \"string\" },\n          ],\n        },\n        {\n          enable: [{ path: \"string\" }],\n        },\n      ],\n    ],\n    useradd: [{ address: \"string\" }],\n  },\n];\n\n// const handler = function (dataObj, protocolName, cell, tape, tx) {\nconst handler = ({ dataObj, cell }: HandlerProps) => {\n  if (!cell.length || !cell.every((c) => c.s)) {\n    throw new Error(\"Invalid Bitcom tx\");\n  }\n\n  // gather up the string values\n  const bitcomObj = cell.map((c) => (c?.s ? c.s : \"\"));\n\n  saveProtocolData(dataObj, \"BITCOM\", bitcomObj);\n};\n\nexport const BITCOM: Protocol = {\n  name: \"BITCOM\",\n  address: protocolAddress,\n  opReturnSchema,\n  handler,\n};\n","import { BSM, BigNumber, Hash, PublicKey, Signature, Utils } from \"@bsv/sdk\";\nimport type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\nconst { toArray, toBase58Check, toHex } = Utils;\nconst { magicHash } = BSM;\n\nconst address = \"13SrNDkVzY5bHBRKNu5iXTQ7K7VqTh5tJC\";\n\nconst opReturnSchema: SchemaField[] = [\n  { bitkey_signature: \"string\" },\n  { user_signature: \"string\" },\n  { paymail: \"string\" },\n  { pubkey: \"string\" },\n];\n\n// Helper to convert array to BigNumber\nfunction toBigNumber(buffer: number[]): BigNumber {\n  const hex = toHex(buffer);\n  return new BigNumber(hex, 16);\n}\n\n// Recovers a public key from a BSM signature by brute forcing recovery factors\n// Steps:\n// 1. Apply magicHash to the raw message.\n// 2. Try all recovery factors 0â€“3 with Signature.RecoverPublicKey()\n// 3. If BSM.verify() returns true with the recovered pubkey, return it.\nfunction recoverPublicKeyFromBSM(message: number[], signature: Signature): PublicKey {\n  // First, BSM signatures are verified by applying magicHash internally,\n  // so we must apply magicHash to the raw message ourselves for recovery:\n  const msgHash = magicHash(message);\n\n  const bigMsg = toBigNumber(msgHash);\n  for (let recovery = 0; recovery < 4; recovery++) {\n    try {\n      const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n      // Verify using BSM.verify() with the original raw message (no magicHash)\n      if (BSM.verify(message, signature, publicKey)) {\n        return publicKey;\n      }\n    } catch {\n      // Try next recovery factor\n    }\n  }\n  throw new Error(\"Failed to recover public key from BSM signature\");\n}\n\nconst handler = async ({ dataObj, cell }: HandlerProps) => {\n  if (cell.length < 5) {\n    throw new Error(\"Invalid Bitkey tx\");\n  }\n\n  const bitkeyObj: { [key: string]: string | boolean } = {};\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n    const bitkeyField = Object.keys(schemaField)[0];\n    const schemaEncoding = Object.values(schemaField)[0];\n    bitkeyObj[bitkeyField] = cellValue(cell[x + 1], schemaEncoding as string) as string;\n  }\n\n  // Derive userAddress from pubkey\n  const pubkeyHex = bitkeyObj.pubkey as string;\n  const userPubkey = PublicKey.fromString(pubkeyHex);\n  const userPubKeyHash = userPubkey.toHash() as number[];\n  const userAddress = toBase58Check(userPubKeyHash);\n\n  // Prepare raw message for bitkey signature verification: sha256(paymail_hex + pubkey_hex)\n  const paymailHex = Buffer.from(bitkeyObj.paymail as string).toString(\"hex\");\n  const concatenated = paymailHex + pubkeyHex;\n  const concatenatedBuffer = Buffer.from(concatenated, \"hex\");\n  const bitkeyMessage = Hash.sha256(toArray(concatenatedBuffer));\n  // This is the raw message. BSM.verify() will do magicHash internally.\n\n  const bitkeySignature = Signature.fromCompact(bitkeyObj.bitkey_signature as string, \"base64\");\n\n  // Recover Bitkey pubkey\n  const recoveredBitkeyPubkey = recoverPublicKeyFromBSM(bitkeyMessage, bitkeySignature);\n  const recoveredBitkeyPubKeyHash = recoveredBitkeyPubkey.toHash() as number[];\n  const recoveredBitkeyAddress = toBase58Check(recoveredBitkeyPubKeyHash);\n  const bitkeySignatureVerified =\n    BSM.verify(bitkeyMessage, bitkeySignature, recoveredBitkeyPubkey) &&\n    recoveredBitkeyAddress === address;\n\n  // Verify user signature by using the pubkey as the message\n  const userMessage = toArray(Buffer.from(pubkeyHex, \"utf8\"));\n  const userSignature = Signature.fromCompact(bitkeyObj.user_signature as string, \"base64\");\n  const recoveredUserPubkey = recoverPublicKeyFromBSM(userMessage, userSignature);\n  const recoveredUserPubKeyHash = recoveredUserPubkey.toHash() as number[];\n  const recoveredUserAddress = toBase58Check(recoveredUserPubKeyHash);\n  const userSignatureVerified =\n    BSM.verify(userMessage, userSignature, recoveredUserPubkey) &&\n    recoveredUserAddress === userAddress;\n\n  bitkeyObj.verified = bitkeySignatureVerified && userSignatureVerified;\n  saveProtocolData(dataObj, \"BITKEY\", bitkeyObj);\n};\n\nexport const BITKEY: Protocol = {\n  name: \"BITKEY\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { BSM, Hash, PublicKey, Signature, Utils } from \"@bsv/sdk\";\nimport type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport type { BITPIC as BITPICType } from \"../types/protocols/bitpic\";\nimport { saveProtocolData } from \"../utils\";\nconst { magicHash } = BSM;\nconst { toArray } = Utils;\n\nconst protocolAddress = \"18pAqbYqhzErT6Zk3a5dwxHtB9icv8jH2p\";\n\nconst opReturnSchema: SchemaField[] = [\n  { paymail: \"string\" },\n  { pubkey: \"binary\" },\n  { signature: \"string\" },\n];\n\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n  // Validation\n  if (\n    cell[0].s !== protocolAddress ||\n    !cell[1] ||\n    !cell[2] ||\n    !cell[3] ||\n    !cell[1].s ||\n    !cell[2].b ||\n    !cell[3].s ||\n    !tape\n  ) {\n    throw new Error(`Invalid BITPIC record: ${tx}`);\n  }\n\n  const bitpicObj: BITPICType = {\n    paymail: cell[1].s,\n    pubkey: Buffer.from(cell[2].b, \"base64\").toString(\"hex\"),\n    signature: cell[3].s || \"\",\n    verified: false,\n  };\n\n  const b = tape[1].cell;\n  if (b[0].s === \"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\") {\n    // verify bitpic signature\n\n    try {\n      // TODO: bob transactions are missing this binary part, cannot verify signature\n      const bin = (cell[1].lb || cell[1].b) as string;\n      const hashBuff = Hash.sha256(toArray(bin, \"base64\"));\n      const sig = Signature.fromCompact(bitpicObj.signature as string, \"base64\");\n      const pubkey = PublicKey.fromString(bitpicObj.pubkey as string);\n      const msgHash = magicHash(hashBuff);\n      bitpicObj.verified = BSM.verify(msgHash, sig, pubkey);\n    } catch (e) {\n      // failed verification\n      bitpicObj.verified = false;\n    }\n  }\n\n  saveProtocolData(dataObj, \"BITPIC\", bitpicObj);\n};\n\nexport const BITPIC: Protocol = {\n  name: \"BITPIC\",\n  address: protocolAddress,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { AIPhandler, SIGPROTO } from \"./aip\";\n\nconst address = \"1HA1P2exomAwCUycZHr8WeyFoy5vuQASE3\";\n\nconst opReturnSchema: SchemaField[] = [\n  { algorithm: \"string\" },\n  { algorithm: \"string\" },\n  { address: \"string\" },\n  { signature: \"string\" },\n  { algorithm: \"string\" },\n  [{ index: \"binary\" }],\n];\n\n// https://github.com/torusJKL/BitcoinBIPs/blob/master/HAIP.md\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n  if (!tape) {\n    throw new Error(\"Invalid HAIP tx. Bad tape\");\n  }\n  if (!tx) {\n    throw new Error(\"Invalid HAIP tx.\");\n  }\n  return await AIPhandler(\n    opReturnSchema,\n    SIGPROTO.HAIP,\n    dataObj,\n    cell,\n    tape\n    // tx,\n  );\n};\n\nexport const HAIP: Protocol = {\n  name: \"HAIP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { decode } from \"@msgpack/msgpack\";\nimport type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport type { MAP as MAPType } from \"../types/protocols/map\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5\";\n\nconst opReturnSchema: SchemaField[] = [\n  {\n    cmd: {\n      SET: [{ key: \"string\" }, { val: \"string\" }],\n      SELECT: [{ tx: \"string\" }],\n      ADD: [{ key: \"string\" }, [{ val: \"string\" }]],\n      DELETE: [{ key: \"string\" }, [{ val: \"string\" }]],\n      JSON: \"string\",\n      REMOVE: [[{ key: \"string\" }]],\n      CLEAR: [[{ txid: \"string\" }]],\n    },\n  },\n];\n\nconst processADD = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    const pushdata = pushdataContainer.s as string;\n    if (pushdataContainer.i === 2) {\n      // Key name\n      mapObj[pushdata] = [];\n      last = pushdata;\n    } else {\n      if (last && Array.isArray(mapObj[last])) {\n        (mapObj[last] as string[]).push(pushdata);\n      }\n    }\n  }\n};\n\nconst proccessDELETE = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    const pushdata = pushdataContainer.s as string;\n    if (pushdataContainer.i === 2) {\n      // Key name\n      mapObj[pushdata] = [];\n      last = pushdata;\n    } else {\n      if (last) {\n        (mapObj[last] as string[]).push(pushdata);\n      }\n    }\n  }\n};\n\nconst processSELECT = (cell: Cell[], mapObj: MAPType) => {\n  // TODO\n  // console.log('MAP SELECT');\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      mapObj.SELECT = \"TODO\";\n    }\n  }\n};\n\nconst processMSGPACK = (cell: Cell[], mapObj: MAPType) => {\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    if (pushdataContainer.i === 2) {\n      try {\n        if (!decode) {\n          throw new Error(\"Msgpack is required but not loaded\");\n        }\n        const buff = Buffer.from(pushdataContainer.b as string, \"base64\");\n        mapObj = decode(buff) as MAPType;\n      } catch (e) {\n        mapObj = {} as MAPType;\n      }\n    }\n  }\n  return mapObj;\n};\n\nconst processJSON = (cell: Cell[], mapObj: MAPType) => {\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    if (pushdataContainer.i === 2) {\n      try {\n        mapObj = JSON.parse(pushdataContainer.s as string);\n      } catch (e) {\n        mapObj = {} as MAPType;\n      }\n    }\n  }\n  return mapObj;\n};\n\nconst processSET = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (!pushdataContainer.s || pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n\n    const pushdata = pushdataContainer.s;\n    if (pushdataContainer.i % 2 === 0) {\n      // key\n      mapObj[pushdata] = \"\";\n      last = pushdata;\n    } else {\n      // value\n      if (!last) {\n        throw new Error(`malformed MAP syntax. Cannot parse.${last}`);\n      }\n      mapObj[last] = pushdata;\n    }\n  }\n};\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  // Validate\n  if (cell[0].s !== address || !cell[1] || !cell[1].s || !cell[2] || !cell[2].s) {\n    // limit each error message to 100 characters\n    throw new Error(`Invalid MAP record: ${JSON.stringify(tx, null, 2).substring(0, 100)}`);\n  }\n\n  let mapObj = {} as MAPType;\n\n  // parse the protocol separator\n  const commands: any[] = [];\n  let commandSeparator = 0;\n  for (let i = 1; i < cell.length; i++) {\n    if (cell[i].s === \":::\") {\n      commandSeparator++;\n    } else {\n      if (!commands[commandSeparator]) commands[commandSeparator] = [];\n      cell[i].i = commands[commandSeparator].length + 1;\n      commands[commandSeparator].push(cell[i]);\n    }\n  }\n\n  // Get the MAP command key name from the query schema\n  const mapCmdKey = Object.keys(opReturnSchema[0])[0];\n\n  // Add the firt MAP command in the response object\n  mapObj[mapCmdKey] = commands[0][0].s;\n\n  for (const cc of commands) {\n    // re-add the MAP address\n    cc.unshift({\n      s: address,\n      i: 0,\n    });\n\n    const command = cc[1].s;\n    // Individual parsing rules for each MAP command\n    switch (command) {\n      // Also check for SELECT commands and strip off the <SELECT> <TXID> part and run it through\n      case \"ADD\": {\n        processADD(cc, mapObj);\n        break;\n      }\n      case \"REMOVE\": {\n        mapObj.key = cc[2].s;\n        break;\n      }\n      case \"DELETE\": {\n        proccessDELETE(cc, mapObj);\n        break;\n      }\n      case \"CLEAR\": {\n        // TODO\n        // console.log('MAP CLEAR');\n        break;\n      }\n      case \"SELECT\": {\n        processSELECT(cc, mapObj);\n        break;\n      }\n      case \"MSGPACK\": {\n        mapObj = processMSGPACK(cc, mapObj);\n        break;\n      }\n      case \"JSON\": {\n        mapObj = processJSON(cc, mapObj);\n        break;\n      }\n      case \"SET\": {\n        processSET(cc, mapObj);\n        break;\n      }\n      default: {\n        // don't know what to do ...\n      }\n    }\n  }\n\n  saveProtocolData(dataObj, \"MAP\", mapObj);\n};\n\nexport const MAP: Protocol = {\n  name: \"MAP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { Hash, Utils } from \"@bsv/sdk\";\nimport type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\n\nconst { toArray, toHex } = Utils;\n\nconst address = \"meta\";\n\nconst opReturnSchema: SchemaField[] = [\n  { address: \"string\" },\n  { parent: \"string\" },\n  { name: \"string\" },\n];\n\nexport const getEnvSafeMetanetID = async (a: string, tx: string) => {\n  // Calculate the node ID\n  const buf = Buffer.from(a + tx);\n  const hashBuf = Hash.sha256(toArray(buf));\n  return toHex(hashBuf);\n};\n\nconst handler = async ({ dataObj, cell, tx }: HandlerProps) => {\n  if (\n    !cell.length ||\n    cell[0].s !== \"meta\" ||\n    !cell[1] ||\n    !cell[1].s ||\n    !cell[2] ||\n    !cell[2].s ||\n    !tx\n  ) {\n    throw new Error(`Invalid Metanet tx ${tx}`);\n  }\n  // For now, we just copy from MOM keys later if available, or keep BOB format\n\n  const nodeId = await getEnvSafeMetanetID(cell[1].s, tx.tx.h);\n  // Described this node\n  const node = {\n    a: cell[1].s,\n    tx: tx.tx.h,\n    id: nodeId,\n  };\n  let parent = {\n    a: \"\",\n    tx: \"\",\n    id: \"\",\n  };\n  if (tx.in) {\n    const parentId = await getEnvSafeMetanetID(tx.in[0].e.a, cell[2].s);\n    // Parent node\n    parent = {\n      a: tx.in[0].e.a,\n      tx: cell[2].s,\n      id: parentId,\n    };\n  }\n\n  if (!dataObj.METANET) {\n    dataObj.METANET = [];\n  }\n  dataObj.METANET.push({\n    node,\n    parent,\n  });\n};\n\nexport const METANET: Protocol = {\n  name: \"METANET\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { ORD as OrdType } from \"../types/protocols/ord\";\n\nconst scriptChecker = (cell: Cell[]) => {\n  if (cell.length < 13) {\n    // wrong length\n    return false;\n  }\n\n  // Find OP_IF wrapper\n  const startIdx = findIndex(cell, (c: Cell) => c.ops === \"OP_IF\");\n  const endIdx = findIndex(cell, (c: Cell, i: number) => i > startIdx && c.ops === \"OP_ENDIF\");\n  const ordScript = cell.slice(startIdx, endIdx);\n  const prevCell = cell[startIdx - 1];\n  return prevCell?.op === 0 && !!ordScript[0] && !!ordScript[1] && ordScript[1].s === \"ord\";\n};\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n  if (!cell[0] || !out) {\n    throw new Error(\"Invalid Ord tx. dataObj, cell, out and tx are required.\");\n  }\n\n  // Find OP_IF wrapper\n  const startIdx = findIndex(cell, (c: Cell) => c.ops === \"OP_IF\");\n  const endIdx = findIndex(cell, (c: Cell, i: number) => i > startIdx && c.ops === \"OP_ENDIF\") + 1;\n  const ordScript = cell.slice(startIdx, endIdx);\n\n  if (!ordScript[0] || !ordScript[1] || ordScript[1].s !== \"ord\") {\n    throw new Error(\"Invalid Ord tx. Prefix not found.\");\n  }\n\n  let data: string | undefined;\n  let contentType: string | undefined;\n  ordScript.forEach((push, idx, all) => {\n    // content-type\n    if (push.ops === \"OP_1\") {\n      contentType = all[idx + 1].s;\n    }\n    // data\n    if (push.ops === \"OP_0\") {\n      data = all[idx + 1].b;\n    }\n  });\n\n  if (!data) {\n    throw new Error(\"Invalid Ord data.\");\n  }\n  if (!contentType) {\n    throw new Error(\"Invalid Ord content type.\");\n  }\n\n  const OrdObj: OrdType = {\n    data,\n    contentType,\n  };\n\n  if (!dataObj.ORD) {\n    dataObj.ORD = [];\n  }\n  dataObj.ORD.push(OrdObj);\n};\n\nexport const ORD: Protocol = {\n  name: \"ORD\",\n  handler,\n  scriptChecker,\n};\n\nfunction findIndex<T>(\n  array: T[],\n  predicate: (value: T, index: number, array: T[]) => boolean\n): number {\n  return findLastIndex(array, predicate);\n}\n\nfunction findLastIndex<T>(\n  array: T[],\n  predicate: (value: T, index: number, array: T[]) => boolean,\n  fromIndex?: number\n): number {\n  const length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  let index = length - 1;\n  if (fromIndex !== undefined) {\n    index = fromIndex;\n    index = fromIndex < 0 ? Math.max(length + index, 0) : Math.min(index, length - 1);\n  }\n  return baseFindIndex(array, predicate, index, true);\n}\n\nfunction baseFindIndex<T>(\n  array: T[],\n  predicate: (value: T, index: number, array: T[]) => boolean,\n  fromIndex: number,\n  fromRight: boolean\n): number {\n  const { length } = array;\n  let index = fromIndex + (fromRight ? 1 : -1);\n\n  while (fromRight ? index-- : ++index < length) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1GvFYzwtFix3qSAZhESQVTz9DeudHZNoh1\";\n\nconst opReturnSchema: SchemaField[] = [\n  { pair: \"json\" },\n  { address: \"string\" },\n  { timestamp: \"string\" },\n];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (\n    cell[0].s !== address ||\n    !cell[1] ||\n    !cell[2] ||\n    !cell[3] ||\n    !cell[1].s ||\n    !cell[2].s ||\n    !cell[3].s\n  ) {\n    throw new Error(`Invalid RON record ${tx?.tx.h}`);\n  }\n\n  const pair = JSON.parse(cell[1].s);\n  const timestamp = Number(cell[3].s);\n\n  saveProtocolData(dataObj, \"RON\", {\n    pair,\n    address: cell[2].s,\n    timestamp,\n  });\n};\n\nexport const RON: Protocol = {\n  name: \"RON\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1SymRe7erxM46GByucUWnB9fEEMgo7spd\";\n\nconst opReturnSchema = [{ url: \"string\" }];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (cell[0].s !== address || !cell[1] || !cell[1].s) {\n    throw new Error(`Invalid SymRe tx: ${tx}`);\n  }\n\n  saveProtocolData(dataObj, \"SYMRE\", { url: cell[1].s });\n};\n\nexport const SYMRE = {\n  name: \"SYMRE\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { type In, type Out, type Tape, parse } from \"bpu-ts\";\nimport { _21E8 } from \"./protocols/_21e8\";\nimport { AIP } from \"./protocols/aip\";\nimport { B } from \"./protocols/b\";\nimport { BAP } from \"./protocols/bap\";\nimport { BITCOM } from \"./protocols/bitcom\";\nimport { BITKEY } from \"./protocols/bitkey\";\nimport { BITPIC } from \"./protocols/bitpic\";\nimport { HAIP } from \"./protocols/haip\";\nimport { MAP } from \"./protocols/map\";\nimport { METANET } from \"./protocols/metanet\";\nimport { ORD } from \"./protocols/ord\";\nimport { RON } from \"./protocols/ron\";\nimport { SYMRE } from \"./protocols/symre\";\nimport type {\n  BmapTx,\n  BobTx,\n  Handler,\n  HandlerProps,\n  MetaNet,\n  MomTx,\n  Protocol,\n  SchemaField,\n  ScriptChecker,\n} from \"./types/common\";\nimport {\n  checkOpFalseOpReturn,\n  checkOpReturn,\n  isObjectArray,\n  isStringArray,\n  saveProtocolData,\n} from \"./utils\";\n\n// Names of enabled protocols\nconst enabledProtocols = new Map<string, string>([]);\n// Protocol Handlers\nconst protocolHandlers = new Map<string, Handler>([]);\n// Script checkers are intentionally minimalistic detection functions for identifying matching scripts for a given protocol. Only if a checker returns true is a handler called for processing.\nconst protocolScriptCheckers = new Map<string, ScriptChecker>([]);\nconst protocolOpReturnSchemas = new Map<string, SchemaField[]>();\n\nexport const allProtocols: Protocol[] = [\n  AIP,\n  B,\n  BAP,\n  MAP,\n  METANET,\n  _21E8,\n  BITCOM,\n  BITKEY,\n  BITPIC,\n  HAIP,\n  RON,\n  SYMRE,\n  ORD,\n];\n\nexport const supportedProtocols = allProtocols.map((p) => p.name);\nexport const defaultProtocols = [AIP, B, BAP, MAP, METANET, ORD];\n\n// prepare protocol map, handlers and schemas\nfor (const protocol of defaultProtocols) {\n  if (protocol.address) {\n    enabledProtocols.set(protocol.address, protocol.name);\n  }\n  protocolHandlers.set(protocol.name, protocol.handler);\n  if (protocol.opReturnSchema) {\n    protocolOpReturnSchemas.set(protocol.name, protocol.opReturnSchema);\n  }\n  if (protocol.scriptChecker) {\n    protocolScriptCheckers.set(protocol.name, protocol.scriptChecker);\n  }\n}\n\n// Takes a BOB formatted op_return transaction\nexport class BMAP {\n  enabledProtocols: Map<string, string>;\n  protocolHandlers: Map<string, Handler>;\n  protocolScriptCheckers: Map<string, ScriptChecker>;\n  protocolOpReturnSchemas: Map<string, SchemaField[]>;\n\n  constructor() {\n    // initial default protocol handlers in this instantiation\n    this.enabledProtocols = enabledProtocols;\n    this.protocolHandlers = protocolHandlers;\n    this.protocolScriptCheckers = protocolScriptCheckers;\n    this.protocolOpReturnSchemas = protocolOpReturnSchemas;\n  }\n\n  addProtocolHandler({ name, address, opReturnSchema, handler, scriptChecker }: Protocol) {\n    if (address) {\n      this.enabledProtocols.set(address, name);\n    }\n    this.protocolHandlers.set(name, handler);\n    if (opReturnSchema) {\n      this.protocolOpReturnSchemas.set(name, opReturnSchema);\n    }\n    if (scriptChecker) {\n      this.protocolScriptCheckers.set(name, scriptChecker);\n    }\n  }\n\n  transformTx = async (tx: BobTx | MomTx): Promise<BmapTx> => {\n    if (!tx || !tx.in || !tx.out) {\n      throw new Error(\"Cannot process tx\");\n    }\n\n    // This will become our nicely formatted response object\n    let dataObj: Partial<BobTx> = {\n      // Initialize blk with default values\n      blk: {\n        i: tx.blk?.i ?? 0,\n        t: tx.blk?.t ?? 0,\n        h: tx.blk?.h ?? \"\"\n      }\n    };\n\n    for (const [key, val] of Object.entries(tx)) {\n      if (key === \"out\") {\n        // loop over the outputs\n        for (const out of tx.out) {\n          const { tape } = out;\n\n          // Process opReturn data\n          if (tape?.some((cc) => checkOpReturn(cc))) {\n            dataObj = await this.processDataProtocols(tape, out, tx, dataObj);\n          }\n\n          // No OP_FALSE OP_RETURN in this tape\n          const _21e8Checker = this.protocolScriptCheckers.get(_21E8.name);\n          const ordChecker = this.protocolScriptCheckers.get(ORD.name);\n\n          // Check for 21e8 and ords\n          if (\n            tape?.some((cc) => {\n              const { cell } = cc;\n              if (_21e8Checker?.(cell)) {\n                // 'found 21e8'\n                return true;\n              }\n              if (ordChecker?.(cell)) {\n                // 'found 1sat ordinal'\n                return true;\n              }\n            })\n          ) {\n            // find the cell array\n            // loop over tape\n            for (const cellContainer of tape) {\n              const { cell } = cellContainer;\n              // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n              if (!cell) {\n                throw new Error(\"empty cell while parsing\");\n              }\n              let protocolName = \"\";\n              if (_21e8Checker?.(cell)) {\n                protocolName = _21E8.name;\n              } else if (ordChecker?.(cell)) {\n                protocolName = ORD.name;\n              } else {\n                // nothing found\n                continue;\n              }\n\n              this.process(protocolName, {\n                tx,\n                cell,\n                dataObj: dataObj as BmapTx,\n                tape,\n                out,\n              });\n            }\n          }\n        }\n      } else if (key === \"in\") {\n        dataObj[key] = val.map((v: In) => {\n          const r = { ...v } as any;\n          r.tape = undefined;\n          return r as In;\n        });\n      } else {\n        // known key, just write it retaining original type\n        dataObj[key] = val;\n      }\n    }\n\n    // If this is a MOM planaria it will have metanet keys available\n    if (dataObj.METANET && (tx as MomTx).parent) {\n      const meta = {\n        ancestor: (tx as MomTx).ancestor,\n        parent: (tx as MomTx).parent,\n        child: (tx as MomTx).child,\n        head: (tx as MomTx).head,\n      } as MetaNet;\n      (dataObj.METANET as MetaNet[]).push(meta);\n      // remove parent and node from root level for (MOM data)\n      dataObj.ancestor = undefined;\n      dataObj.child = undefined;\n      dataObj.parent = undefined;\n      dataObj.head = undefined;\n      dataObj.node = undefined;\n    }\n\n    return dataObj as BmapTx;\n  };\n\n  processUnknown = (key: string, dataObj: Partial<BmapTx>, out: Out) => {\n    // no known non-OP_RETURN scripts\n    if (key && !dataObj[`_${key}`]) {\n      dataObj[`_${key}`] = [];\n    }\n    (dataObj[`_${key}`] as Out[]).push({\n      i: out.i,\n      e: out.e,\n      tape: [],\n    });\n  };\n\n  process = async (protocolName: string, { cell, dataObj, tape, out, tx }: HandlerProps) => {\n    if (\n      this.protocolHandlers.has(protocolName) &&\n      typeof this.protocolHandlers.get(protocolName) === \"function\"\n    ) {\n      const handler = this.protocolHandlers.get(protocolName);\n      if (handler) {\n        await handler({\n          dataObj,\n          cell,\n          tape,\n          out,\n          tx,\n        });\n      }\n    } else {\n      saveProtocolData(dataObj, protocolName, cell);\n    }\n  };\n\n  processDataProtocols = async (\n    tape: Tape[],\n    out: Out,\n    tx: BobTx,\n    dataObj: Partial<BobTx>\n  ): Promise<Partial<BobTx>> => {\n    // loop over tape\n    for (const cellContainer of tape) {\n      const { cell } = cellContainer;\n      if (!cell) {\n        throw new Error(\"empty cell while parsing\");\n      }\n\n      // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n      if (checkOpFalseOpReturn(cellContainer)) {\n        continue;\n      }\n\n      const prefix = cell[0].s;\n\n      if (prefix) {\n        const protocolName = this.enabledProtocols.get(prefix);\n        if (protocolName) {\n          await this.process(protocolName, {\n            cell,\n            dataObj: dataObj as BmapTx,\n            tape,\n            out,\n            tx,\n          });\n        } else {\n          this.processUnknown(prefix, dataObj, out);\n        }\n      }\n    }\n    return dataObj;\n  };\n}\n\nexport const fetchRawTx = async (txid: string): Promise<string> => {\n  const url = `https://api.whatsonchain.com/v1/bsv/main/tx/${txid}/hex`;\n  console.log(\"hitting\", url);\n  const res = await fetch(url);\n  return await res.text();\n};\n\nexport const bobFromRawTx = async (rawTx: string): Promise<BobTx> => {\n  const bpuTx = await parse({\n    tx: { r: rawTx },\n    split: [\n      {\n        token: { op: 106 },\n        include: \"l\",\n      },\n      {\n        token: { s: \"|\" },\n      },\n    ],\n  });\n  return bpuTx as BobTx;\n};\n\n// TransformTx\n// tx - a raw hex string or a Bob/Bmap/Mom transaction object\n// protocols - the handlers you want to load and use to process the tx\n// reducing the number of supported protocols may improve transform speed\n// at the expense of detecting more data protocols\nexport const TransformTx = async (\n  tx: BobTx | string | MomTx | BmapTx,\n  protocols?: string[] | Protocol[]\n) => {\n  if (typeof tx === \"string\") {\n    let rawTx: string | undefined;\n    // if it a txid or  complete transaction hex?\n    if (tx.length === 64) {\n      // txid - fetch raw tx\n      rawTx = await fetchRawTx(tx);\n    }\n\n    if (Buffer.from(tx).byteLength <= 146) {\n      throw new Error(\"Invalid rawTx\");\n    }\n\n    if (!rawTx) {\n      rawTx = tx;\n    }\n\n    // TODO: Double check 146 is intended to be minimum possible byte length for a tx\n    const bobTx = await bobFromRawTx(rawTx);\n\n    if (bobTx) {\n      tx = bobTx;\n    } else {\n      throw new Error(\"Invalid txid\");\n    }\n  }\n\n  const b = new BMAP();\n\n  // if protocols are specified\n  if (protocols) {\n    // wipe out defaults\n    b.enabledProtocols.clear();\n    if (isStringArray(protocols)) {\n      // set enabled protocols\n      for (const protocol of allProtocols) {\n        if ((protocols as string[])?.includes(protocol.name)) {\n          b.addProtocolHandler(protocol);\n        }\n      }\n    } else if (isObjectArray(protocols)) {\n      for (const p of protocols) {\n        const protocol = p as Protocol;\n        if (protocol) {\n          b.addProtocolHandler(protocol);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Invalid protocol array. Must be either an array of protocol names (string[]), or Protocol objects (Protocol[]).\"\n      );\n    }\n  }\n\n  return b.transformTx(tx);\n};\n\n// Export types\nexport type {\n  BmapTx,\n  BobTx,\n  Handler,\n  HandlerProps,\n  MomTx,\n  Protocol,\n  ScriptChecker,\n} from \"./types/common\";\n\n// Export all protocol types\nexport type { _21E8 } from \"./types/protocols/_21e8\";\nexport type { AIP } from \"./types/protocols/aip\";\nexport type { B } from \"./types/protocols/b\";\nexport type { BAP } from \"./types/protocols/bap\";\nexport type { BITCOM } from \"./types/protocols/bitcom\";\nexport type { BITKEY } from \"./types/protocols/bitkey\";\nexport type { BITPIC } from \"./types/protocols/bitpic\";\nexport type { HAIP } from \"./types/protocols/haip\";\nexport type { MAP } from \"./types/protocols/map\";\nexport type { ORD } from \"./types/protocols/ord\";\nexport type { RON } from \"./types/protocols/ron\";\nexport type { SYMRE } from \"./types/protocols/symre\";\n"],"names":["toArray","Utils","isStringArray","arr","value","isObjectArray","cellValue","pushData","schemaEncoding","checkOpReturn","cc","c","checkOpFalseOpReturn","opReturnIdx","_a","saveProtocolData","dataObj","protocolName","data","prevData","bmapOpReturnSchemaHandler","opReturnSchema","cell","tx","obj","length","idx","schemaField","x","field","isBase64","regex","shallowEqualArrays","arr1","arr2","index","_21e8Script","scriptChecker","ops","target","targetOpSize","handler","out","txid","difficulty","_21e8Obj","_21E8","toHex","fromBase58Check","toBase58Check","address","validateSignature","aipObj","tape","cellIndex","t","_b","_c","usingIndexes","signatureValues","allCells","a","b","firstCell","cellsByIndex","targetCell","tapeCells","indexLength","indexes","i","v","messageBuffer","dataScript","Script","dataArray","Hash","addressString","signature","Signature","e","tryNormalLogic","msgHash","BSM","bigMsg","toBigNumberFromBuffer","recovery","publicKey","pubKeyHash","prefix","tryTwetchLogic","trimmed","buff","hexStr","twetchMsg","verified","buffer","hex","BigNumber","SIGPROTO","AIPhandler","useOpReturnSchema","protocol","aipField","fieldData","AIP","encodingMap","bObj","bField","encoding","B","BAP","protocolAddress","bitcomObj","BITCOM","magicHash","toBigNumber","recoverPublicKeyFromBSM","message","bitkeyObj","bitkeyField","pubkeyHex","userPubKeyHash","PublicKey","userAddress","concatenated","concatenatedBuffer","bitkeyMessage","bitkeySignature","recoveredBitkeyPubkey","recoveredBitkeyPubKeyHash","recoveredBitkeyAddress","bitkeySignatureVerified","userMessage","userSignature","recoveredUserPubkey","recoveredUserPubKeyHash","recoveredUserAddress","userSignatureVerified","BITKEY","bitpicObj","bin","hashBuff","sig","pubkey","BITPIC","HAIP","processADD","mapObj","last","pushdataContainer","pushdata","proccessDELETE","processSELECT","processMSGPACK","decode","processJSON","processSET","commands","commandSeparator","mapCmdKey","MAP","getEnvSafeMetanetID","buf","hashBuf","nodeId","node","parent","parentId","METANET","startIdx","findIndex","endIdx","ordScript","prevCell","contentType","push","all","OrdObj","ORD","array","predicate","findLastIndex","fromIndex","baseFindIndex","fromRight","pair","timestamp","RON","SYMRE","enabledProtocols","protocolHandlers","protocolScriptCheckers","protocolOpReturnSchemas","allProtocols","supportedProtocols","p","defaultProtocols","BMAP","name","key","val","_21e8Checker","ordChecker","cellContainer","r","meta","fetchRawTx","url","bobFromRawTx","rawTx","parse","TransformTx","protocols","bobTx"],"mappings":"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"}