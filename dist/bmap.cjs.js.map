{"version":3,"file":"bmap.cjs.js","sources":["../src/utils.ts","../src/protocols/_21e8.ts","../src/protocols/aip.ts","../src/protocols/b.ts","../src/protocols/bap.ts","../src/protocols/bitcom.ts","../src/protocols/bitkey.ts","../src/protocols/bitpic.ts","../src/protocols/haip.ts","../src/protocols/map.ts","../src/protocols/metanet.ts","../src/protocols/ord.ts","../src/protocols/ron.ts","../src/protocols/symre.ts","../src/bmap.ts"],"sourcesContent":["\nimport { Hash, Utils } from '@bsv/sdk';\nimport type { Cell, Tape } from 'bpu-ts';\nimport type { BobTx } from './types/common';\nconst { toArray } = Utils;\n\nexport const isStringArray = (arr: Array<any>): boolean => {\n  return (\n    arr.length > 0 &&\n    arr.every((value) => {\n      return typeof value === 'string'\n    })\n  )\n}\nexport const isObjectArray = (arr: Array<any>): boolean => {\n  return (\n    arr.length > 0 &&\n    arr.every((value) => {\n      return value === 'object'\n    })\n  )\n}\n/**\n * returns the BOB cell value for a given encoding\n *\n * @param pushData\n * @param schemaEncoding\n * @returns {string|number}\n */\nexport const cellValue = (\n  pushData: Cell,\n  schemaEncoding?: string\n): string | number => {\n  if (!pushData) {\n    throw new Error(`cannot get cell value of: ${pushData}`)\n  } else if (schemaEncoding === 'string') {\n    return pushData['s'] ? pushData.s : pushData.ls || ''\n  } else if (schemaEncoding === 'hex') {\n    return pushData['h']\n      ? pushData.h\n      : pushData.lh ||\n      (pushData['b']\n        ? Buffer.from(pushData.b, 'base64').toString('hex')\n        : pushData.lb &&\n        Buffer.from(pushData.lb, 'base64').toString('hex')) ||\n      ''\n  } else if (schemaEncoding === 'number') {\n    return parseInt(pushData['h'] ? pushData.h : pushData.lh || '0', 16)\n  } else if (schemaEncoding === 'file') {\n    return `bitfs://${pushData['f'] ? pushData.f : pushData.lf}`\n  }\n\n  return (pushData['b'] ? pushData.b : pushData.lb) || ''\n}\n\n/**\n * Check if cells end with OP_RETURN\n */\nexport const checkOpReturn = (cc: Tape): boolean => {\n  return cc.cell.some((c: Cell) => c.op === 106)\n}\n\n/**\n * Check if cells end with OP_FALSE + OP_RETURN\n */\nexport const checkOpFalseOpReturn = (cc: Tape): boolean => {\n  if (cc.cell.length !== 2) {\n    return false\n  }\n  const opReturnIdx = cc.cell.findIndex((c) => c.op === 106)\n  if (opReturnIdx !== -1) {\n    return cc.cell[opReturnIdx - 1]?.op === 0\n  }\n  return false\n}\n\n/**\n * Helper function to store protocol data\n *\n * @param dataObj\n * @param protocolName\n * @param data\n */\nexport const saveProtocolData = (\n  dataObj: { [key: string]: any },\n  protocolName: string,\n  data: any\n) => {\n  if (!dataObj[protocolName]) {\n    dataObj[protocolName] = [data]\n  } else {\n    dataObj[protocolName].push(data)\n  }\n}\n\n/**\n * BMAP default handler to work with query schema's\n *\n * @param opReturnSchema\n * @param protocolName\n * @param dataObj\n * @param cell\n * @param tape\n * @param tx\n */\nexport const bmapOpReturnSchemaHandler = (\n  protocolName: string,\n  opReturnSchema: Object[],\n  dataObj: Object,\n  cell: Cell[],\n  tx: BobTx\n) => {\n  // loop over the schema\n  const obj: { [key: string]: any } = {}\n\n  // Does not have the required number of fields\n  const length = opReturnSchema.length + 1\n  if (cell.length < length) {\n    throw new Error(\n      `${protocolName} requires at least ${length} fields including the prefix: ${tx.tx.h}`\n    )\n  }\n\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10)\n\n    const [field] = Object.keys(schemaField)\n    const [schemaEncoding] = Object.values(schemaField)\n    obj[field] = cellValue(cell[x + 1], schemaEncoding)\n  }\n\n  saveProtocolData(dataObj, protocolName, obj)\n}\n\n/**\n * Check whether the given data is base64\n *\n * @param data\n * @returns {boolean}\n */\nexport const isBase64 = (data: string) => {\n  const regex =\n    '(?:[A-Za-z0-9+\\\\/]{4})*(?:[A-Za-z0-9+\\\\/]{2}==|[A-Za-z0-9+/]{3}=)?'\n  return new RegExp(`^${regex}$`, 'gi').test(data)\n}\n\n// hashes a message buffer, returns the hash as a buffer\nexport const sha256 = (msgBuffer: number[]) => {\n  return Hash.sha256(toArray(msgBuffer))\n}\n","import type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { _21E8 as _21E8Type } from \"../types/protocols/_21e8\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\n// 21e8 does not use the first pushdata for id\n// in fact there is no id since the 21e8 is designed for difficulty and can be changed\n// instead we use the static part of the script to indentfy the transaction\n// TODO - the OP_X_PLACEHOLDER is the number of bytes to push onto the stack and must match difficulty size\nconst _21e8Script =\n  \"OP_SIZE <OP_X_PLACEHOLDER> OP_PICK OP_SHA256 OP_SWAP OP_SPLIT OP_DROP OP_EQUALVERIFY OP_DROP OP_CHECKSIG\".split(\n    \" \",\n  );\n\nconst scriptChecker = (cell: Cell[]) => {\n  if (cell.length !== 12) {\n    // wrong length\n    return false;\n  }\n\n  // match exact script\n  const ops = [...cell].map((c) => c.ops).splice(2, cell.length);\n\n  // calculate target byte length\n  const target = cellValue(cell[1], \"hex\") as string;\n  const targetOpSize = Buffer.from(target).byteLength;\n\n  // replace the placeholder opcode with actual\n  ops[1] = `OP_${targetOpSize}`;\n  _21e8Script[1] = `OP_${targetOpSize}`;\n\n  // protocol identifier always in first pushdata\n  return ops.join() === _21e8Script.join();\n};\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n  if (!cell[0] || !out) {\n    throw new Error(\"Invalid 21e8 tx. dataObj, cell, out and tx are required.\");\n  }\n\n  // assemble asm\n  // make sure first piece matches a txid\n  // 2nd piece matches any difficulty. set some resonable limit in bytes if there isnt one documented somewhere\n  // next\n\n  const txid = cellValue(cell[0], \"hex\") as string;\n  const target = cellValue(cell[1], \"hex\") as string;\n  if (!target) {\n    throw new Error(`Invalid 21e8 target. ${JSON.stringify(cell[0], null, 2)}`);\n  }\n  const difficulty = Buffer.from(target, \"hex\").byteLength;\n\n  const _21e8Obj: _21E8Type = {\n    target,\n    difficulty,\n    value: out.e.v,\n    txid,\n  };\n\n  saveProtocolData(dataObj, \"21E8\", _21e8Obj);\n};\n\nexport const _21E8: Protocol = {\n  name: \"21E8\",\n  handler,\n  scriptChecker,\n};\n","\nimport { BSM, BigNumber, Hash, type PublicKey, Script, Signature, Utils } from \"@bsv/sdk\";\nimport type { Cell, Tape } from \"bpu-ts\";\nimport fetch from \"node-fetch\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { AIP as AIPType } from \"../types/protocols/aip\";\nimport type { HAIP as HAIPType } from \"../types/protocols/haip\";\nimport { cellValue, checkOpFalseOpReturn, isBase64, saveProtocolData } from \"../utils\";\n\nconst { toArray, toHex, fromBase58Check, toBase58Check } = Utils;\n\nconst address = \"15PciHG22SNLQJXMoSUaWVi7WSqc7hCfva\";\nconst opReturnSchema = [\n  { algorithm: \"string\" },\n  { address: \"string\" },\n  { signature: \"binary\" },\n  [{ index: \"binary\" }],\n];\n\nconst getFileBuffer = async (bitfsRef: string) => {\n  try {\n    const result = await fetch(`https://x.bitfs.network/${bitfsRef}`);\n    return await result.buffer();\n  } catch {\n    return Buffer.from(\"\");\n  }\n};\n\nfunction toBigNumberFromBuffer(buffer: number[]): BigNumber {\n  const hex = toHex(buffer);\n  return new BigNumber(hex, 16);\n}\n\nfunction recoverPublicKeyFromBSM(message: number[], signature: Signature, expectedAddress: string): PublicKey {\n  const msgHash = BSM.magicHash(message);\n  const bigMsg = toBigNumberFromBuffer(msgHash);\n\n  for (let recovery = 0; recovery < 4; recovery++) {\n    try {\n      const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n      const pubKeyHash = publicKey.toHash() as number[];\n      const { prefix } = fromBase58Check(expectedAddress);\n      const recoveredAddress = toBase58Check(pubKeyHash, prefix as number[]);\n      if (recoveredAddress === expectedAddress) {\n        console.log(\"[recoverPublicKeyFromBSM] Successfully recovered matching public key\");\n        return publicKey;\n      } else {\n        console.log(\"[recoverPublicKeyFromBSM] Trying recovery=\", recovery, \"Recovered address=\", recoveredAddress, \"expected=\", expectedAddress);\n      }\n    } catch (e) {\n      console.log(\"[recoverPublicKeyFromBSM] Recovery error:\", e);\n    }\n  }\n\n  console.log(\"[recoverPublicKeyFromBSM] Failed to recover any matching address\");\n  throw new Error(\"Failed to recover public key matching the expected address\");\n}\n\nfunction fromSafeDataArray(dataBufs: Buffer[]): Script {\n  const script = new Script();\n  script.chunks.push({ op: 0 }); // OP_FALSE\n  script.chunks.push({ op: 106 }); // OP_RETURN\n  for (const buf of dataBufs) {\n    const length = buf.length;\n    if (length <= 75) {\n      script.chunks.push({ op: length, data: Array.from(buf) });\n    } else if (length <= 0xff) {\n      script.chunks.push({ op: 0x4c, data: Array.from(buf) });\n    } else if (length <= 0xffff) {\n      script.chunks.push({ op: 0x4d, data: Array.from(buf) });\n    } else {\n      script.chunks.push({ op: 0x4e, data: Array.from(buf) });\n    }\n  }\n  return script;\n}\n\nasync function validateSignature(\n  aipObj: Partial<AIPType | HAIPType>,\n  cell: Cell[],\n  tape: Tape[]\n): Promise<boolean> {\n  if (!Array.isArray(tape) || tape.length < 3) {\n    throw new Error(\"AIP requires at least 3 cells including the prefix\");\n  }\n\n  let cellIndex = -1;\n  tape.forEach((cc, index) => {\n    if (cc.cell === cell) {\n      cellIndex = index;\n    }\n  });\n  if (cellIndex === -1) {\n    throw new Error(\"AIP could not find cell in tape\");\n  }\n\n  let usingIndexes: number[] = (aipObj.index as number[]) || [];\n  const signatureValues: string[] = [\"6a\"]; // index 0: OP_RETURN\n\n  // Gather data from all previous cells\n  for (let i = 0; i < cellIndex; i++) {\n    const cellContainer = tape[i];\n    if (!checkOpFalseOpReturn(cellContainer)) {\n      const cellData: string[] = [];\n      for (const statement of cellContainer.cell) {\n        let value: string | undefined;\n        if (statement.h) {\n          value = statement.h;\n        } else if (statement.f) {\n          const fileBuffer = await getFileBuffer(statement.f);\n          value = fileBuffer.length > 0 ? fileBuffer.toString(\"hex\") : undefined;\n        } else if (statement.b) {\n          const buf = Buffer.from(statement.b, \"base64\");\n          if (buf.length > 0) {\n            value = buf.toString(\"hex\");\n          }\n        } else if (statement.s) {\n          if (statement.s.length > 0) {\n            value = Buffer.from(statement.s).toString(\"hex\");\n          }\n        }\n\n        if (value && value.length > 0) {\n          cellData.push(value);\n        }\n      }\n      if (cellData.length > 0) {\n        // add all cellData\n        signatureValues.push(...cellData);\n        // add pipe after this cell\n        signatureValues.push(\"7c\");\n      }\n    }\n  }\n\n  // Now HAIP indexing logic\n  if (aipObj.hashing_algorithm && aipObj.index_unit_size) {\n    const indexLength = aipObj.index_unit_size * 2;\n    usingIndexes = [];\n    const indexesHex = cell[6]?.h || \"\";\n    for (let i = 0; i < indexesHex.length; i += indexLength) {\n      usingIndexes.push(Number.parseInt(indexesHex.substr(i, indexLength), 16));\n    }\n    aipObj.index = usingIndexes;\n  }\n\n  console.log(\"usingIndexes\", usingIndexes);\n  console.log(\"signatureValues\", signatureValues);\n\n  const signatureBufferStatements: Buffer[] = [];\n  if (usingIndexes.length > 0) {\n    for (const idx of usingIndexes) {\n      if (typeof signatureValues[idx] !== 'string') {\n        console.log(\"signatureValues[idx]\", signatureValues[idx], \"idx\", idx);\n      }\n      if (!signatureValues[idx]) {\n        console.log(\"signatureValues is missing an index\", idx, \"This means indexing is off\");\n        return false;\n      }\n      signatureBufferStatements.push(Buffer.from(signatureValues[idx], \"hex\"));\n    }\n  } else {\n    for (const val of signatureValues) {\n      signatureBufferStatements.push(Buffer.from(val, \"hex\"));\n    }\n  }\n\n  console.log(\"signatureBufferStatements\", signatureBufferStatements.map((b) => b.toString(\"hex\")));\n\n  let messageBuffer: Buffer;\n  if (aipObj.hashing_algorithm) {\n    // HAIP logic\n    if (!aipObj.index_unit_size) {\n      // remove OP_RETURN chunk\n      signatureBufferStatements.shift();\n    }\n    const dataScript = fromSafeDataArray(signatureBufferStatements);\n    let dataBuffer = Buffer.from(dataScript.toHex(), \"hex\");\n    if (aipObj.index_unit_size) {\n      dataBuffer = dataBuffer.slice(1);\n    }\n    const hashed = Hash.sha256(toArray(dataBuffer));\n    messageBuffer = Buffer.from(hashed);\n  } else {\n    // regular AIP\n    messageBuffer = Buffer.concat(signatureBufferStatements);\n  }\n\n  const addressString = (aipObj as AIPType).address || (aipObj as HAIPType).signing_address;\n  const signatureStr = aipObj.signature as string;\n  const signature = Signature.fromCompact(signatureStr, 'base64');\n\n  const tryNormalLogic = (): boolean => {\n    console.log(\"[validateSignature:tryNormalLogic] start\");\n    try {\n      const msgArr = toArray(messageBuffer);\n      const recoveredPubkey = recoverPublicKeyFromBSM(msgArr, signature, addressString);\n      console.log(\"[tryNormalLogic] recoveredPubkey ok, verifying with BSM.verify now\");\n      const res = BSM.verify(msgArr, signature, recoveredPubkey);\n      console.log(\"[tryNormalLogic] BSM.verify result:\", res);\n      return res;\n    } catch (err) {\n      console.log(\"[tryNormalLogic] error:\", err);\n      return false;\n    }\n  };\n\n  const tryTwetchLogic = (): boolean => {\n    console.log(\"[validateSignature:tryTwetchLogic] start\");\n    // For twetch: remove first and last item and sha256 the remainder, interpret hex as utf8\n    if (signatureBufferStatements.length <= 2) {\n      return false;\n    }\n    const trimmed = signatureBufferStatements.slice(1, -1);\n    console.log(\"[tryTwetchLogic] trimmedStatements count:\", trimmed.length);\n    const buff = Hash.sha256(toArray(Buffer.concat(trimmed)));\n    const hexStr = toHex(buff);\n    const twetchMsg = Buffer.from(hexStr, \"utf8\");\n    try {\n      const recoveredPubkey = recoverPublicKeyFromBSM(toArray(twetchMsg), signature, addressString);\n      console.log(\"[tryTwetchLogic] recoveredPubkey ok, verifying with BSM.verify now\");\n      const res = BSM.verify(toArray(twetchMsg), signature, recoveredPubkey);\n      console.log(\"[tryTwetchLogic] BSM.verify result:\", res);\n      return res;\n    } catch (err) {\n      console.log(\"[tryTwetchLogic] error:\", err);\n      return false;\n    }\n  };\n\n  let verified = tryNormalLogic();\n  if (!verified) {\n    verified = tryTwetchLogic();\n  }\n\n  console.log(\"[validateSignature] final verified=\", verified);\n  (aipObj as AIPType).verified = verified;\n  return verified;\n}\n\nexport enum SIGPROTO {\n  HAIP = \"HAIP\",\n  AIP = \"AIP\",\n}\n\nexport const AIPhandler = async (\n  useOpReturnSchema: any[],\n  protocol: SIGPROTO,\n  dataObj: any,\n  cell: Cell[],\n  tape: Tape[],\n  tx?: any\n) => {\n  const aipObj: { [key: string]: any } = { verified: false };\n\n  // minimal fields check\n  if (cell.length < 4) {\n    throw new Error(\"AIP requires at least 4 fields including the prefix\");\n  }\n\n  for (const [idx, schemaField] of Object.entries(useOpReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n    if (Array.isArray(schemaField)) {\n      const [aipField] = Object.keys(schemaField[0]) as (keyof AIPType)[];\n      const fieldData: number[] = [];\n      for (let i = x + 1; i < cell.length; i++) {\n        if (cell[i].h) {\n          fieldData.push(Number.parseInt(cell[i].h!, 16));\n        }\n      }\n      aipObj[aipField] = fieldData;\n    } else {\n      const [aipField] = Object.keys(schemaField) as (keyof AIPType)[];\n      const [schemaEncoding] = Object.values(schemaField);\n      aipObj[aipField] = cellValue(cell[x + 1], schemaEncoding as string) || \"\";\n    }\n  }\n\n  if (cell[0].s === address && cell[3].s && isBase64(cell[3].s)) {\n    aipObj.signature = cell[3].s;\n  }\n\n  console.log(\"[AIPhandler] AIP object before validate:\", aipObj);\n\n  if (!aipObj.signature) {\n    throw new Error(\"AIP requires a signature\");\n  }\n\n  await validateSignature(aipObj as Partial<AIPType>, cell, tape);\n  console.log(\"[AIPhandler] After validate, verified:\", aipObj.verified);\n\n  saveProtocolData(dataObj, protocol, aipObj);\n};\n\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n  if (!tape) {\n    throw new Error(\"Invalid AIP transaction\");\n  }\n  return await AIPhandler(\n    opReturnSchema,\n    SIGPROTO.AIP,\n    dataObj,\n    cell,\n    tape,\n    tx\n  );\n};\n\nexport const AIP: Protocol = {\n  name: \"AIP\",\n  address,\n  opReturnSchema,\n  handler,\n};","import type { HandlerProps, Protocol } from \"../types/common\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\nconst address = \"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\";\n\nconst opReturnSchema = [\n  { content: [\"string\", \"binary\", \"file\"] },\n  { \"content-type\": \"string\" },\n  { encoding: \"string\" }, // we use this field to determine content character encoding. If encoding is not a valid character encoding (gzip), we assume it is binary\n  { filename: \"string\" },\n];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps): void => {\n  const encodingMap = new Map<string, string>();\n  encodingMap.set(\"utf8\", \"string\");\n  encodingMap.set(\"text\", \"string\"); // invalid but people use it :(\n  encodingMap.set(\"gzip\", \"binary\"); // invalid but people use it :(\n  encodingMap.set(\"text/plain\", \"string\");\n  encodingMap.set(\"image/png\", \"binary\");\n  encodingMap.set(\"image/jpeg\", \"binary\");\n\n  if (!cell[1] || !cell[2]) {\n    throw new Error(`Invalid B tx: ${tx}`);\n  }\n\n  // Check pushdata length + 1 for protocol prefix\n  if (cell.length > opReturnSchema.length + 1) {\n    throw new Error(\"Invalid B tx. Too many fields.\");\n  }\n\n  // Make sure there are not more fields than possible\n\n  const bObj: { [key: string]: string | number | undefined } = {};\n  // loop over the schema\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n    const bField = Object.keys(schemaField)[0];\n    let schemaEncoding = Object.values(schemaField)[0];\n    if (bField === \"content\") {\n      // If the encoding is ommitted, try to infer from content-type instead of breaking\n      if (cell[1].f) {\n        // this is file reference to B files\n        schemaEncoding = \"file\";\n      } else if ((!cell[3] || !cell[3].s) && cell[2].s) {\n        schemaEncoding = encodingMap.get(cell[2].s);\n        if (!schemaEncoding) {\n          console.warn(\"Problem inferring encoding. Malformed B data.\", cell);\n          return;\n        }\n\n        // add the missing encoding field\n        if (!cell[3]) {\n          cell[3] = { h: \"\", b: \"\", s: \"\", i: 0, ii: 0 };\n        }\n        cell[3].s = schemaEncoding === \"string\" ? \"utf-8\" : \"binary\";\n      } else {\n        schemaEncoding = cell[3]?.s\n          ? encodingMap.get(cell[3].s.replace(\"-\", \"\").toLowerCase())\n          : null;\n      }\n    }\n\n    // encoding is not required\n    if (bField === \"encoding\" && !cell[x + 1]) {\n      // encoding omitted\n      continue;\n    }\n\n    // filename is not required\n    if (bField === \"filename\" && !cell[x + 1]) {\n      // filename omitted\n      continue;\n    }\n\n    // check for malformed syntax\n    if (!cell || !cell[x + 1]) {\n      throw new Error(`malformed B syntax ${cell}`);\n    }\n\n    // set field value from either s, b, ls, or lb depending on encoding and availability\n    const data = cell[x + 1];\n    bObj[bField] = cellValue(data, schemaEncoding);\n  }\n\n  saveProtocolData(dataObj, \"B\", bObj);\n};\n\nexport const B: Protocol = {\n  name: \"B\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol } from \"../types/common\";\nimport { bmapOpReturnSchemaHandler } from \"../utils\";\n\nconst address = \"1BAPSuaPnfGnSBM3GLV9yhxUdYe4vGbdMT\";\n\nconst opReturnSchema = [\n  { type: \"string\" },\n  { hash: \"string\" },\n  { sequence: \"string\" },\n];\n\nexport const handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (!tx) {\n    throw new Error(\"Invalid BAP tx, tx required\");\n  }\n  bmapOpReturnSchemaHandler(\"BAP\", opReturnSchema, dataObj, cell, tx);\n};\n\nexport const BAP: Protocol = {\n  name: \"BAP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst protocolAddress = \"$\";\n\nconst opReturnSchema = [\n  {\n    su: [\n      { pubkey: \"string\" },\n      { sign_position: \"string\" },\n      { signature: \"string\" },\n    ],\n    echo: [{ data: \"string\" }, { to: \"string\" }, { filename: \"string\" }],\n    route: [\n      [\n        {\n          add: [\n            { bitcom_address: \"string\" },\n            { route_matcher: \"string\" },\n            { endpoint_template: \"string\" },\n          ],\n        },\n        {\n          enable: [{ path: \"string\" }],\n        },\n      ],\n    ],\n    useradd: [{ address: \"string\" }],\n  },\n];\n\n// const handler = function (dataObj, protocolName, cell, tape, tx) {\nconst handler = ({ dataObj, cell }: HandlerProps) => {\n  if (!cell.length || !cell.every((c) => c.s)) {\n    throw new Error(\"Invalid Bitcom tx\");\n  }\n\n  // gather up the string values\n  const bitcomObj = cell.map((c) => (c?.s ? c.s : \"\"));\n\n  saveProtocolData(dataObj, \"BITCOM\", bitcomObj);\n};\n\nexport const BITCOM: Protocol = {\n  name: \"BITCOM\",\n  address: protocolAddress,\n  opReturnSchema,\n  handler,\n};\n","import { BSM, BigNumber, Hash, PublicKey, Signature, Utils } from \"@bsv/sdk\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\nconst { toArray, toBase58Check, toHex } = Utils;\nconst { magicHash } = BSM;\n\nconst address = \"13SrNDkVzY5bHBRKNu5iXTQ7K7VqTh5tJC\";\n\nconst opReturnSchema = [\n  { bitkey_signature: \"string\" },\n  { user_signature: \"string\" },\n  { paymail: \"string\" },\n  { pubkey: \"string\" },\n];\n\n// Helper to convert array to BigNumber\nfunction toBigNumber(buffer: number[]): BigNumber {\n  const hex = toHex(buffer);\n  return new BigNumber(hex, 16);\n}\n\n// Recovers a public key from a BSM signature by brute forcing recovery factors\n// Steps:\n// 1. Apply magicHash to the raw message.\n// 2. Try all recovery factors 0–3 with Signature.RecoverPublicKey()\n// 3. If BSM.verify() returns true with the recovered pubkey, return it.\nfunction recoverPublicKeyFromBSM(message: number[], signature: Signature): PublicKey {\n  // First, BSM signatures are verified by applying magicHash internally,\n  // so we must apply magicHash to the raw message ourselves for recovery:\n  const msgHash = magicHash(message);\n\n  const bigMsg = toBigNumber(msgHash);\n  for (let recovery = 0; recovery < 4; recovery++) {\n    try {\n      const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n      // Verify using BSM.verify() with the original raw message (no magicHash)\n      if (BSM.verify(message, signature, publicKey)) {\n        return publicKey;\n      }\n    } catch {\n      // Try next recovery factor\n    }\n  }\n  throw new Error(\"Failed to recover public key from BSM signature\");\n}\n\nconst handler = async ({ dataObj, cell }: HandlerProps) => {\n  if (cell.length < 5) {\n    throw new Error(\"Invalid Bitkey tx\");\n  }\n\n  const bitkeyObj: { [key: string]: string | boolean } = {};\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n    const bitkeyField = Object.keys(schemaField)[0];\n    const schemaEncoding = Object.values(schemaField)[0];\n    bitkeyObj[bitkeyField] = cellValue(cell[x + 1], schemaEncoding) as string;\n  }\n\n  // Derive userAddress from pubkey\n  const pubkeyHex = bitkeyObj.pubkey as string;\n  const userPubkey = PublicKey.fromString(pubkeyHex);\n  const userPubKeyHash = userPubkey.toHash() as number[];\n  const userAddress = toBase58Check(userPubKeyHash);\n\n  // Prepare raw message for bitkey signature verification: sha256(paymail_hex + pubkey_hex)\n  const paymailHex = Buffer.from(bitkeyObj.paymail as string).toString(\"hex\");\n  const concatenated = paymailHex + pubkeyHex;\n  const concatenatedBuffer = Buffer.from(concatenated, \"hex\");\n  const bitkeyMessage = Hash.sha256(toArray(concatenatedBuffer));\n  // This is the raw message. BSM.verify() will do magicHash internally.\n\n  const bitkeySignature = Signature.fromCompact(bitkeyObj.bitkey_signature as string, 'base64');\n\n  // Recover Bitkey pubkey\n  const recoveredBitkeyPubkey = recoverPublicKeyFromBSM(bitkeyMessage, bitkeySignature);\n  const recoveredBitkeyPubKeyHash = recoveredBitkeyPubkey.toHash() as number[];\n  const recoveredBitkeyAddress = toBase58Check(recoveredBitkeyPubKeyHash);\n  const bitkeySignatureVerified = BSM.verify(bitkeyMessage, bitkeySignature, recoveredBitkeyPubkey) && (recoveredBitkeyAddress === address);\n\n  // Verify user signature by using the pubkey as the message\n  const userMessage = toArray(Buffer.from(pubkeyHex, \"utf8\"));\n  const userSignature = Signature.fromCompact(bitkeyObj.user_signature as string, 'base64');\n  const recoveredUserPubkey = recoverPublicKeyFromBSM(userMessage, userSignature);\n  const recoveredUserPubKeyHash = recoveredUserPubkey.toHash() as number[];\n  const recoveredUserAddress = toBase58Check(recoveredUserPubKeyHash);\n  const userSignatureVerified = BSM.verify(userMessage, userSignature, recoveredUserPubkey) && (recoveredUserAddress === userAddress);\n\n  bitkeyObj.verified = bitkeySignatureVerified && userSignatureVerified;\n  saveProtocolData(dataObj, \"BITKEY\", bitkeyObj);\n};\n\nexport const BITKEY: Protocol = {\n  name: \"BITKEY\",\n  address,\n  opReturnSchema,\n  handler,\n};","import { BSM, Hash, PublicKey, Signature, Utils } from \"@bsv/sdk\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { BITPIC as BITPICType } from \"../types/protocols/bitpic\";\nimport { saveProtocolData } from \"../utils\";\nconst { magicHash } = BSM;\nconst { toArray } = Utils;\n\n\nconst protocolAddress = \"18pAqbYqhzErT6Zk3a5dwxHtB9icv8jH2p\";\n\nconst opReturnSchema = [\n  { paymail: \"string\" },\n  { pubkey: \"binary\" },\n  { signature: \"string\" },\n];\n\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n  // Validation\n  if (\n    cell[0].s !== protocolAddress ||\n    !cell[1] ||\n    !cell[2] ||\n    !cell[3] ||\n    !cell[1].s ||\n    !cell[2].b ||\n    !cell[3].s ||\n    !tape\n  ) {\n    throw new Error(`Invalid BITPIC record: ${tx}`);\n  }\n\n  const bitpicObj: BITPICType = {\n    paymail: cell[1].s,\n    pubkey: Buffer.from(cell[2].b, \"base64\").toString(\"hex\"),\n    signature: cell[3].s || \"\",\n    verified: false,\n  };\n\n  const b = tape[1].cell;\n  if (b[0].s === \"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\") {\n    // verify bitpic signature\n\n    try {\n      // TODO: bob transactions are missing this binary part, cannot verify signature\n      const bin = (cell[1].lb || cell[1].b) as string;\n      const hashBuff = Hash.sha256(toArray(bin, \"base64\"));\n      const sig = Signature.fromCompact(bitpicObj.signature as string, \"base64\");\n      const pubkey = PublicKey.fromString(bitpicObj.pubkey as string);\n      const msgHash = magicHash(hashBuff);\n      bitpicObj.verified = BSM.verify(msgHash, sig, pubkey);\n    } catch (e) {\n      // failed verification\n      bitpicObj.verified = false;\n    }\n  }\n\n  saveProtocolData(dataObj, \"BITPIC\", bitpicObj);\n};\n\nexport const BITPIC: Protocol = {\n  name: \"BITPIC\",\n  address: protocolAddress,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol } from \"../types/common\";\nimport { AIPhandler, SIGPROTO } from \"./aip\";\n\nconst address = \"1HA1P2exomAwCUycZHr8WeyFoy5vuQASE3\";\n\nconst opReturnSchema = [\n  { hashing_algorithm: \"string\" },\n  { signing_algorithm: \"string\" },\n  { signing_address: \"string\" },\n  { signature: \"string\" },\n  { index_unit_size: \"number\" },\n  [{ index: \"binary\" }],\n];\n\n// https://github.com/torusJKL/BitcoinBIPs/blob/master/HAIP.md\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n  if (!tape) {\n    throw new Error(\"Invalid HAIP tx. Bad tape\");\n  }\n  if (!tx) {\n    throw new Error(\"Invalid HAIP tx.\");\n  }\n  return await AIPhandler(\n    opReturnSchema,\n    SIGPROTO.HAIP,\n    dataObj,\n    cell,\n    tape,\n    // tx,\n  );\n};\n\nexport const HAIP: Protocol = {\n  name: \"HAIP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","\nimport { decode } from \"@msgpack/msgpack\";\nimport type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { MAP as MAPType } from \"../types/protocols/map\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5\";\n\nconst opReturnSchema = [\n  {\n    cmd: {\n      SET: [{ key: \"string\" }, { val: \"string\" }],\n      SELECT: [{ tx: \"string\" }],\n      ADD: [{ key: \"string\" }, [{ val: \"string\" }]],\n      DELETE: [{ key: \"string\" }, [{ val: \"string\" }]],\n      JSON: \"string\",\n      REMOVE: [[{ key: \"string\" }]],\n      CLEAR: [[{ txid: \"string\" }]],\n    },\n  },\n];\n\nconst processADD = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    const pushdata = pushdataContainer.s as string;\n    if (pushdataContainer.i === 2) {\n      // Key name\n      mapObj[pushdata] = [];\n      last = pushdata;\n    } else {\n      if (last && Array.isArray(mapObj[last])) {\n        (mapObj[last] as string[]).push(pushdata);\n      }\n    }\n  }\n};\n\nconst proccessDELETE = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    const pushdata = pushdataContainer.s as string;\n    if (pushdataContainer.i === 2) {\n      // Key name\n      mapObj[pushdata] = [];\n      last = pushdata;\n    } else {\n      if (last) {\n        (mapObj[last] as string[]).push(pushdata);\n      }\n    }\n  }\n};\n\nconst processSELECT = (cell: Cell[], mapObj: MAPType) => {\n  // TODO\n  // console.log('MAP SELECT');\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      mapObj.SELECT = \"TODO\";\n      continue;\n    }\n  }\n};\n\nconst processMSGPACK = (cell: Cell[], mapObj: MAPType) => {\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    if (pushdataContainer.i === 2) {\n      try {\n        if (!decode) {\n          throw new Error(\"Msgpack is required but not loaded\");\n        }\n        const buff = Buffer.from(pushdataContainer.b as string, \"base64\");\n        mapObj = decode(buff) as MAPType;\n      } catch (e) {\n        mapObj = {} as MAPType;\n      }\n    }\n  }\n  return mapObj;\n};\n\nconst processJSON = (cell: Cell[], mapObj: MAPType) => {\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    if (pushdataContainer.i === 2) {\n      try {\n        mapObj = JSON.parse(pushdataContainer.s as string);\n      } catch (e) {\n        mapObj = {} as MAPType;\n      }\n    }\n  }\n  return mapObj;\n};\n\nconst processSET = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (\n      !pushdataContainer.s ||\n      pushdataContainer.i === 0 ||\n      pushdataContainer.i === 1\n    ) {\n      continue;\n    }\n\n    const pushdata = pushdataContainer.s;\n    if (pushdataContainer.i % 2 === 0) {\n      // key\n      mapObj[pushdata] = \"\";\n      last = pushdata;\n    } else {\n      // value\n      if (!last) {\n        throw new Error(`malformed MAP syntax. Cannot parse.${last}`);\n      }\n      mapObj[last] = pushdata;\n    }\n  }\n};\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  // Validate\n  if (\n    cell[0].s !== address ||\n    !cell[1] ||\n    !cell[1].s ||\n    !cell[2] ||\n    !cell[2].s\n  ) {\n    throw new Error(`Invalid MAP record: ${tx}`);\n  }\n\n  let mapObj = {} as MAPType;\n\n  // parse the protocol separator\n  const commands: any[] = [];\n  let commandSeparator = 0;\n  for (let i = 1; i < cell.length; i++) {\n    if (cell[i].s === \":::\") {\n      commandSeparator++;\n    } else {\n      if (!commands[commandSeparator]) commands[commandSeparator] = [];\n      cell[i].i = commands[commandSeparator].length + 1;\n      commands[commandSeparator].push(cell[i]);\n    }\n  }\n\n  // Get the MAP command key name from the query schema\n  const mapCmdKey = Object.keys(opReturnSchema[0])[0];\n\n  // Add the firt MAP command in the response object\n  mapObj[mapCmdKey] = commands[0][0].s;\n\n  for (const cc of commands) {\n    // re-add the MAP address\n    cc.unshift({\n      s: address,\n      i: 0,\n    });\n\n    const command = cc[1].s;\n    // Individual parsing rules for each MAP command\n    switch (command) {\n      // Also check for SELECT commands and strip off the <SELECT> <TXID> part and run it through\n      case \"ADD\": {\n        processADD(cc, mapObj);\n        break;\n      }\n      case \"REMOVE\": {\n        mapObj.key = cc[2].s;\n        break;\n      }\n      case \"DELETE\": {\n        proccessDELETE(cc, mapObj);\n        break;\n      }\n      case \"CLEAR\": {\n        // TODO\n        // console.log('MAP CLEAR');\n        break;\n      }\n      case \"SELECT\": {\n        processSELECT(cc, mapObj);\n        break;\n      }\n      case \"MSGPACK\": {\n        mapObj = processMSGPACK(cc, mapObj);\n        break;\n      }\n      case \"JSON\": {\n        mapObj = processJSON(cc, mapObj);\n        break;\n      }\n      case \"SET\": {\n        processSET(cc, mapObj);\n        break;\n      }\n      default: {\n        // don't know what to do ...\n      }\n    }\n  }\n\n  saveProtocolData(dataObj, \"MAP\", mapObj);\n};\n\nexport const MAP: Protocol = {\n  name: \"MAP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","\nimport { Hash, Utils } from \"@bsv/sdk\";\nimport type {\n  HandlerProps,\n  MetaNet,\n  MetanetNode,\n  Protocol,\n} from \"../types/common\";\n\nconst { toArray, toHex } = Utils;\n\nconst address = \"meta\";\n\nconst opReturnSchema = [\n  { address: \"string\" },\n  { parent: \"string\" },\n  { name: \"string\" },\n];\n\nexport const getEnvSafeMetanetID = async (a: string, tx: string) => {\n  // Calculate the node ID\n  const buf = Buffer.from(a + tx);\n  const hashBuf = Hash.sha256(toArray(buf));\n  return toHex(hashBuf);\n};\n\nconst handler = async ({ dataObj, cell, tx }: HandlerProps) => {\n  if (\n    !cell.length ||\n    cell[0].s !== \"meta\" ||\n    !cell[1] ||\n    !cell[1].s ||\n    !cell[2] ||\n    !cell[2].s ||\n    !tx\n  ) {\n    throw new Error(`Invalid Metanet tx ${tx}`);\n  }\n  // For now, we just copy from MOM keys later if available, or keep BOB format\n\n  const nodeId = await getEnvSafeMetanetID(cell[1].s, tx.tx.h);\n  // Described this node\n  const node = {\n    a: cell[1].s,\n    tx: tx.tx.h,\n    id: nodeId,\n  };\n  let parent = {} as MetanetNode;\n  if (tx.in) {\n    const parentId = await getEnvSafeMetanetID(tx.in[0].e.a, cell[2].s);\n    // Parent node\n    parent = {\n      a: tx.in[0].e.a,\n      tx: cell[2].s,\n      id: parentId,\n    };\n  }\n\n  if (!dataObj.METANET) {\n    dataObj.METANET = [];\n  }\n  dataObj.METANET.push({\n    node,\n    parent,\n  } as MetaNet);\n};\n\nexport const METANET: Protocol = {\n  name: \"METANET\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { ORD as OrdType } from \"../types/protocols/ord\";\nimport { saveProtocolData } from \"../utils\";\n\n// const OrdScript =\n//     'OP_FALSE OP_IF 6F7264 OP_1 <CONTENT_TYPE_PLACEHOLDER> OP_0 <DATA_PLACEHOLDER> OP_ENDIF'.split(\n//         ' '\n//     )\n\nconst scriptChecker = (cell: Cell[]) => {\n  if (cell.length < 13) {\n    // wrong length\n    return false;\n  }\n\n  // Find OP_IF wrapper\n  const startIdx = findIndex(cell, (c: Cell) => c.ops === \"OP_IF\");\n  const endIdx = findIndex(\n    cell,\n    (c: Cell, i: number) => i > startIdx && c.ops === \"OP_ENDIF\",\n  );\n  const ordScript = cell.slice(startIdx, endIdx);\n  const prevCell = cell[startIdx - 1];\n  return (\n    prevCell?.op === 0 &&\n    !!ordScript[0] &&\n    !!ordScript[1] &&\n    ordScript[1].s == \"ord\"\n  );\n};\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n  if (!cell[0] || !out) {\n    throw new Error(\"Invalid Ord tx. dataObj, cell, out and tx are required.\");\n  }\n\n  // assemble asm\n  // make sure first piece matches a txid\n  // 2nd piece matches any difficulty. set some resonable limit in bytes if there isnt one documented somewhere\n  // next\n\n  // Find OP_IF wrapper\n  const startIdx = findIndex(cell, (c: Cell) => c.ops === \"OP_IF\");\n  const endIdx =\n    findIndex(\n      cell,\n      (c: Cell, i: number) => i > startIdx && c.ops === \"OP_ENDIF\",\n    ) + 1;\n  const ordScript = cell.slice(startIdx, endIdx);\n\n  if (!ordScript[0] || !ordScript[1] || ordScript[1].s !== \"ord\") {\n    throw new Error(\"Invalid Ord tx. Prefix not found.\");\n  }\n\n  let data: string | undefined;\n  let contentType: string | undefined;\n  ordScript.forEach((push, idx, all) => {\n    // content-type\n    if (push.ops === \"OP_1\") {\n      contentType = all[idx + 1].s;\n    }\n    // data\n    if (push.ops === \"OP_0\") {\n      data = all[idx + 1].b;\n    }\n  });\n\n  if (!data) {\n    throw new Error(\"Invalid Ord data.\");\n  }\n  if (!contentType) {\n    throw new Error(\"Invalid Ord content type.\");\n  }\n\n  const OrdObj: OrdType = {\n    data,\n    contentType,\n  };\n\n  saveProtocolData(dataObj, \"ORD\", OrdObj);\n};\n\nexport const ORD: Protocol = {\n  name: \"ORD\",\n  handler,\n  scriptChecker,\n};\n\nfunction findIndex(array: any[], predicate: Function) {\n  return findLastIndex(array, predicate);\n}\nfunction findLastIndex(array: any[], predicate: Function, fromIndex?: number) {\n  const length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  let index = length - 1;\n  if (fromIndex !== undefined) {\n    index = fromIndex;\n    index =\n      fromIndex < 0 ? Math.max(length + index, 0) : Math.min(index, length - 1);\n  }\n  return baseFindIndex(array, predicate, index, true);\n}\n\nfunction baseFindIndex(\n  array: any[],\n  predicate: Function,\n  fromIndex: number,\n  fromRight: boolean,\n) {\n  const { length } = array;\n  let index = fromIndex + (fromRight ? 1 : -1);\n\n  while (fromRight ? index-- : ++index < length) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n","import type { HandlerProps, Protocol } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1GvFYzwtFix3qSAZhESQVTz9DeudHZNoh1\";\n\nconst opReturnSchema = [\n  { pair: \"json\" },\n  { address: \"string\" },\n  { timestamp: \"string\" },\n];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (\n    cell[0].s !== address ||\n    !cell[1] ||\n    !cell[2] ||\n    !cell[3] ||\n    !cell[1].s ||\n    !cell[2].s ||\n    !cell[3].s\n  ) {\n    throw new Error(`Invalid RON record ${tx?.tx.h}`);\n  }\n\n  const pair = JSON.parse(cell[1].s);\n  const timestamp = Number(cell[3].s);\n\n  saveProtocolData(dataObj, \"RON\", {\n    pair,\n    address: cell[2].s,\n    timestamp,\n  });\n};\n\nexport const RON: Protocol = {\n  name: \"RON\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1SymRe7erxM46GByucUWnB9fEEMgo7spd\";\n\nconst opReturnSchema = [{ url: \"string\" }];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (cell[0].s !== address || !cell[1] || !cell[1].s) {\n    throw new Error(`Invalid SymRe tx: ${tx}`);\n  }\n\n  saveProtocolData(dataObj, \"SYMRE\", { url: cell[1].s });\n};\n\nexport const SYMRE = {\n  name: \"SYMRE\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { type In, type Out, type Tape, parse } from \"bpu-ts\";\nimport { _21E8 } from \"./protocols/_21e8\";\nimport { AIP } from \"./protocols/aip\";\nimport { B } from \"./protocols/b\";\nimport { BAP } from \"./protocols/bap\";\nimport { BITCOM } from \"./protocols/bitcom\";\nimport { BITKEY } from \"./protocols/bitkey\";\nimport { BITPIC } from \"./protocols/bitpic\";\nimport { HAIP } from \"./protocols/haip\";\nimport { MAP } from \"./protocols/map\";\nimport { METANET } from \"./protocols/metanet\";\nimport { ORD } from \"./protocols/ord\";\nimport { RON } from \"./protocols/ron\";\nimport { SYMRE } from \"./protocols/symre\";\nimport type {\n  BmapTx,\n  BobTx,\n  Handler,\n  HandlerProps,\n  MetaNet,\n  MomTx,\n  Protocol,\n  ScriptChecker,\n} from \"./types/common\";\nimport {\n  checkOpFalseOpReturn,\n  checkOpReturn,\n  isObjectArray,\n  isStringArray,\n  saveProtocolData,\n} from \"./utils\";\n\n// Names of enabled protocols\nconst enabledProtocols = new Map<string, string>([]);\n// Protocol Handlers\nconst protocolHandlers = new Map<string, Handler>([]);\n// Script checkers are intentionally minimalistic detection functions for identifying matching scripts for a given protocol. Only if a checker returns true is a handler called for processing.\nconst protocolScriptCheckers = new Map<string, ScriptChecker>([]);\nconst protocolOpReturnSchemas = new Map<string, Object[]>();\n\nexport const allProtocols = [\n  AIP,\n  B,\n  BAP,\n  MAP,\n  METANET,\n  _21E8,\n  BITCOM,\n  BITKEY,\n  BITPIC,\n  HAIP,\n  RON,\n  SYMRE,\n  ORD,\n];\n\nexport const supportedProtocols = allProtocols.map((p) => p.name);\nexport const defaultProtocols = [AIP, B, BAP, MAP, METANET, ORD];\n\n// prepare protocol map, handlers and schemas\nfor (const protocol of defaultProtocols) {\n  if (protocol.address) {\n    enabledProtocols.set(protocol.address, protocol.name);\n  }\n  protocolHandlers.set(protocol.name, protocol.handler);\n  if (protocol.opReturnSchema) {\n    protocolOpReturnSchemas.set(protocol.name, protocol.opReturnSchema);\n  }\n  if (protocol.scriptChecker) {\n    protocolScriptCheckers.set(protocol.name, protocol.scriptChecker);\n  }\n}\n\n// Takes a BOB formatted op_return transaction\nexport class BMAP {\n  enabledProtocols: Map<string, string>;\n\n  protocolHandlers: Map<string, Handler>;\n\n  protocolScriptCheckers: Map<string, ScriptChecker>;\n\n  protocolOpReturnSchemas: Map<string, Object[]>;\n\n  constructor() {\n    // initial default protocol handlers in this instantiation\n    this.enabledProtocols = enabledProtocols;\n    this.protocolHandlers = protocolHandlers;\n    this.protocolScriptCheckers = protocolScriptCheckers;\n    this.protocolOpReturnSchemas = protocolOpReturnSchemas;\n  }\n\n  addProtocolHandler({\n    name,\n    address,\n    opReturnSchema,\n    handler,\n    scriptChecker,\n  }: Protocol) {\n    if (address) {\n      this.enabledProtocols.set(address, name);\n    }\n    this.protocolHandlers.set(name, handler);\n    if (opReturnSchema) {\n      this.protocolOpReturnSchemas.set(name, opReturnSchema);\n    }\n    if (scriptChecker) {\n      this.protocolScriptCheckers.set(name, scriptChecker);\n    }\n  }\n\n  transformTx = async (tx: BobTx | MomTx): Promise<BmapTx> => {\n    if (!tx || !tx.in || !tx.out) {\n      throw new Error(\"Cannot process tx\");\n    }\n\n    // This will become our nicely formatted response object\n    let dataObj: Partial<BobTx> = {};\n\n    for (const [key, val] of Object.entries(tx)) {\n      if (key === \"out\") {\n        // loop over the outputs\n        for (const out of tx.out) {\n          const { tape } = out;\n\n          // Process opReturn data\n          if (tape?.some((cc) => checkOpReturn(cc))) {\n            dataObj = await this.processDataProtocols(tape, out, tx, dataObj);\n          }\n\n          // No OP_FALSE OP_RETURN in this tape\n          const _21e8Checker = this.protocolScriptCheckers.get(_21E8.name);\n          const ordChecker = this.protocolScriptCheckers.get(ORD.name);\n\n          // Check for 21e8 and ords\n          if (\n            tape?.some((cc) => {\n              const { cell } = cc;\n              if (_21e8Checker?.(cell)) {\n                // 'found 21e8'\n                return true;\n              }\n              if (ordChecker?.(cell)) {\n                // 'found 1sat ordinal'\n                return true;\n              }\n            })\n          ) {\n            // find the cell array\n            // loop over tape\n            for (const cellContainer of tape) {\n              const { cell } = cellContainer;\n              // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n              if (!cell) {\n                throw new Error(\"empty cell while parsing\");\n              }\n              let protocolName = \"\";\n              if (_21e8Checker?.(cell)) {\n                protocolName = _21E8.name;\n              } else if (ordChecker?.(cell)) {\n                protocolName = ORD.name;\n              } else {\n                // nothing found\n                continue;\n              }\n\n              this.process(protocolName, {\n                tx,\n                cell,\n                dataObj: dataObj as BmapTx,\n                tape,\n                out,\n              });\n            }\n          }\n        }\n      } else if (key === \"in\") {\n        dataObj[key] = val.map((v: In) => {\n          const r = { ...v } as any;\n          delete r.tape;\n          return r as In;\n        });\n      } else {\n        // known key, just write it retaining original type\n        dataObj[key] = val;\n      }\n    }\n\n    // If this is a MOM planaria it will have metanet keys available\n    if (dataObj.METANET && (tx as MomTx).parent) {\n      const meta = {\n        ancestor: (tx as MomTx).ancestor,\n        parent: (tx as MomTx).parent,\n        child: (tx as MomTx).child,\n        head: (tx as MomTx).head,\n      } as MetaNet;\n      (dataObj.METANET as MetaNet[]).push(meta);\n      // remove parent and node from root level for (MOM data)\n      delete dataObj.ancestor;\n      delete dataObj.child;\n      delete dataObj.parent;\n      delete dataObj.head;\n      delete dataObj.node;\n    }\n\n    return dataObj as BmapTx;\n  };\n\n  processUnknown = (key: string, dataObj: Partial<BmapTx>, out: Out) => {\n    // no known non-OP_RETURN scripts\n    if (key && !dataObj[key]) {\n      dataObj[key] = [];\n    }\n    (dataObj[key] as Out[]).push({\n      i: out.i,\n      e: out.e,\n      tape: [],\n    });\n  };\n\n  process = async (\n    protocolName: string,\n    { cell, dataObj, tape, out, tx }: HandlerProps,\n  ) => {\n    if (\n      this.protocolHandlers.has(protocolName) &&\n      typeof this.protocolHandlers.get(protocolName) === \"function\"\n    ) {\n      const handler = this.protocolHandlers.get(protocolName);\n      if (handler) {\n        /* eslint-disable no-await-in-loop */\n        await handler({\n          dataObj: dataObj,\n          cell,\n          tape,\n          out,\n          tx,\n        });\n      }\n    } else {\n      saveProtocolData(dataObj, protocolName, cell);\n    }\n  };\n\n  processDataProtocols = async (\n    tape: Tape[],\n    out: Out,\n    tx: BobTx,\n    dataObj: Partial<BobTx>,\n  ): Promise<Partial<BobTx>> => {\n    // loop over tape\n    for (const cellContainer of tape) {\n      const { cell } = cellContainer;\n      if (!cell) {\n        throw new Error(\"empty cell while parsing\");\n      }\n\n      // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n      if (checkOpFalseOpReturn(cellContainer)) {\n        continue;\n      }\n\n      const prefix = cell[0].s;\n\n      if (prefix) {\n        const bitcomProtocol =\n          this.enabledProtocols.get(prefix) ||\n          defaultProtocols.filter((p) => p.name === prefix)[0]?.name;\n        if (bitcomProtocol) {\n          await this.process(bitcomProtocol, {\n            cell,\n            dataObj: dataObj as BmapTx,\n            tape,\n            out,\n            tx,\n          });\n        } else {\n          this.processUnknown(prefix, dataObj, out);\n        }\n      }\n    }\n    return dataObj;\n  };\n}\n\nexport const fetchRawTx = async (txid: string): Promise<string> => {\n  const url = `https://api.whatsonchain.com/v1/bsv/main/tx/${txid}/hex`;\n\n  console.log(\"hitting\", url);\n\n  const res = await fetch(url);\n  return await res.text();\n};\n\nexport const bobFromRawTx = async (rawTx: string): Promise<BobTx> => {\n  const bpuTx = await parse({\n    tx: { r: rawTx },\n    split: [\n      {\n        token: { op: 106 },\n        include: \"l\",\n      },\n      {\n        token: { s: \"|\" },\n      },\n    ],\n  });\n  return bpuTx as BobTx;\n};\n\n// TransformTx\n// tx - a raw hex string or a Bob/Bmap/Mom transaction object\n// protocols - the handlers you want to load and use to process the tx\n// reducing the number of supported protocols may improve transform speed\n// at the expense of detecting more data protocols\nexport const TransformTx = async (\n  tx: BobTx | string | MomTx | BmapTx,\n  protocols?: string[] | Protocol[],\n) => {\n  if (typeof tx === \"string\") {\n    let rawTx: string | undefined;\n    // if it a txid or  complete transaction hex?\n    if (tx.length === 64) {\n      // txid - fetch raw tx\n      rawTx = await fetchRawTx(tx);\n    }\n\n    if (Buffer.from(tx).byteLength <= 146) {\n      throw new Error(\"Invalid rawTx\");\n    }\n\n    if (!rawTx) {\n      rawTx = tx;\n    }\n\n    // TODO: Double check 146 is intended to be minimum possible byte length for a tx\n    const bobTx = await bobFromRawTx(rawTx);\n\n    if (bobTx) {\n      tx = bobTx;\n    } else {\n      throw new Error(\"Invalid txid\");\n    }\n  }\n\n  const b = new BMAP();\n\n  // if protocols are specified\n  if (protocols) {\n    // wipe out defaults\n    b.enabledProtocols.clear();\n    if (isStringArray(protocols)) {\n      // set enabled protocols\n      for (const protocol of allProtocols) {\n        if ((protocols as string[])?.includes(protocol.name)) {\n          b.addProtocolHandler(protocol);\n        }\n      }\n    } else if (isObjectArray(protocols)) {\n      for (const p of protocols) {\n        const protocol = p as Protocol;\n        if (protocol) {\n          b.addProtocolHandler(protocol);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Invalid protocol array. Must be either an array of protocol names (string[]), or Protocol objects (Protocol[]).\",\n      );\n    }\n  }\n\n  return b.transformTx(tx);\n};\n\n// Export types\nexport type { BmapTx, BobTx, Handler, HandlerProps, MetaNet, MomTx, Protocol, ScriptChecker } from './types/common';\nexport type { _21E8 } from './types/protocols/_21e8';\nexport type { AIP } from './types/protocols/aip';\nexport type { B } from './types/protocols/b';\nexport type { BAP } from './types/protocols/bap';\nexport type { BITCOM } from './types/protocols/bitcom';\nexport type { BITKEY } from './types/protocols/bitkey';\nexport type { BITPIC } from './types/protocols/bitpic';\nexport type { HAIP } from './types/protocols/haip';\nexport type { MAP } from './types/protocols/map';\nexport type { ORD } from './types/protocols/ord';\nexport type { RON } from './types/protocols/ron';\nexport type { SYMRE } from './types/protocols/symre';\n\n"],"names":["isStringArray","arr","value","isObjectArray","cellValue","pushData","schemaEncoding","checkOpReturn","cc","c","checkOpFalseOpReturn","opReturnIdx","_a","saveProtocolData","dataObj","protocolName","data","bmapOpReturnSchemaHandler","opReturnSchema","cell","tx","obj","length","idx","schemaField","x","field","isBase64","regex","_21e8Script","scriptChecker","ops","target","targetOpSize","handler","out","txid","difficulty","_21e8Obj","_21E8","toArray","toHex","fromBase58Check","toBase58Check","Utils","address","getFileBuffer","bitfsRef","fetch","toBigNumberFromBuffer","buffer","hex","BigNumber","recoverPublicKeyFromBSM","message","signature","expectedAddress","msgHash","BSM","bigMsg","recovery","publicKey","pubKeyHash","prefix","recoveredAddress","e","fromSafeDataArray","dataBufs","script","Script","buf","validateSignature","aipObj","tape","cellIndex","index","usingIndexes","signatureValues","i","cellContainer","cellData","statement","fileBuffer","indexLength","indexesHex","signatureBufferStatements","val","b","messageBuffer","dataScript","dataBuffer","hashed","Hash","addressString","signatureStr","Signature","tryNormalLogic","msgArr","recoveredPubkey","res","err","tryTwetchLogic","trimmed","buff","hexStr","twetchMsg","verified","SIGPROTO","AIPhandler","useOpReturnSchema","protocol","aipField","fieldData","AIP","encodingMap","bObj","bField","B","BAP","protocolAddress","bitcomObj","BITCOM","magicHash","toBigNumber","bitkeyObj","bitkeyField","pubkeyHex","userPubKeyHash","PublicKey","userAddress","concatenated","concatenatedBuffer","bitkeyMessage","bitkeySignature","recoveredBitkeyPubkey","recoveredBitkeyPubKeyHash","recoveredBitkeyAddress","bitkeySignatureVerified","userMessage","userSignature","recoveredUserPubkey","recoveredUserPubKeyHash","recoveredUserAddress","userSignatureVerified","BITKEY","bitpicObj","bin","hashBuff","sig","pubkey","BITPIC","HAIP","processADD","mapObj","last","pushdataContainer","pushdata","proccessDELETE","processSELECT","processMSGPACK","decode","processJSON","processSET","commands","commandSeparator","mapCmdKey","MAP","getEnvSafeMetanetID","a","hashBuf","nodeId","node","parent","parentId","METANET","startIdx","findIndex","endIdx","ordScript","prevCell","contentType","push","all","ORD","array","predicate","findLastIndex","fromIndex","baseFindIndex","fromRight","pair","timestamp","RON","SYMRE","enabledProtocols","protocolHandlers","protocolScriptCheckers","protocolOpReturnSchemas","allProtocols","supportedProtocols","p","defaultProtocols","BMAP","name","key","_21e8Checker","ordChecker","v","r","meta","bitcomProtocol","fetchRawTx","url","bobFromRawTx","rawTx","parse","TransformTx","protocols","bobTx"],"mappings":"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"}