{"mappings":";AS8BA;IACI,WAAW,EAAE,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAA;IAEhC,gBAAgB,EAAE,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA;IAEtC,oBAAoB,EAAE,GAAG,CAAC,MAAM,EAAE,MAAM,EAAE,CAAC,CAAA;;IAS3C,kBAAkB,CAAC,kBAAkB,EAAE;QACnC,IAAI,EAAE,MAAM,CAAA;QACZ,OAAO,EAAE,MAAM,CAAA;QACf,WAAW,EAAE,MAAM,EAAE,CAAA;QACrB,OAAO,EAAE,OAAO,CAAA;KACnB;IAOD,WAAW,OAAc,KAAK,GAAG,KAAK,KAAG,QAAQ,MAAM,CAAC,CA+GvD;CACJ;AAED,OAAO,MAAM,kBAAyB,KAAK,oBAG1C,CAAA","sources":["src/src/utils.ts","src/src/protocols/aip.ts","src/src/protocols/b.ts","src/src/protocols/bap.ts","src/src/protocols/haip.ts","src/src/protocols/map.ts","src/src/protocols/metanet.ts","src/src/paymail.ts","src/src/protocols/psp.ts","src/src/bmap.ts","src/bmap.ts"],"sourcesContent":[null,null,null,null,null,null,null,null,null,null,"// import default protocols\nimport {\n    BmapTx,\n    BobTx,\n    Handler,\n    In,\n    MetaNet,\n    MomTx,\n    Out,\n} from '../types/common'\nimport { AIP } from './protocols/aip'\nimport { B } from './protocols/b'\nimport { BAP } from './protocols/bap'\nimport { HAIP } from './protocols/haip'\nimport { MAP } from './protocols/map'\nimport { METANET } from './protocols/metanet'\nimport { PSP } from './protocols/psp'\nimport { checkOpFalseOpReturn, saveProtocolData } from './utils'\n\nconst protocolMap = new Map<string, string>([])\nconst protocolHandlers = new Map<string, Handler>()\nconst protocolQuerySchemas = new Map<string, Object[]>()\n\n;[AIP, B, BAP, HAIP, MAP, METANET, PSP].forEach((protocol) => {\n    protocolMap.set(protocol.address, protocol.name)\n    protocolHandlers.set(protocol.name, protocol.handler)\n    protocolQuerySchemas.set(protocol.name, protocol.querySchema)\n})\n\n// Takes a BOB formatted op_return transaction\nexport class BMAP {\n    protocolMap: Map<string, string>\n\n    protocolHandlers: Map<string, Handler>\n\n    protocolQuerySchemas: Map<string, Object[]>\n\n    constructor() {\n        // initial default protocol handlers in this instantiation\n        this.protocolMap = protocolMap\n        this.protocolHandlers = protocolHandlers\n        this.protocolQuerySchemas = protocolQuerySchemas\n    }\n\n    addProtocolHandler(protocolDefinition: {\n        name: string\n        address: string\n        querySchema: Object[]\n        handler: Handler\n    }) {\n        const { name, address, querySchema, handler } = protocolDefinition\n        this.protocolMap.set(address, name)\n        this.protocolHandlers.set(name, handler)\n        this.protocolQuerySchemas.set(name, querySchema)\n    }\n\n    transformTx = async (tx: BobTx | MomTx): Promise<BmapTx> => {\n        const self = this\n\n        if (!tx || !tx['in'] || !tx['out']) {\n            throw new Error('Cannot process tx')\n        }\n\n        // This will become our nicely formatted response object\n        const dataObj: {\n            [key: string]: (Out | In | MetaNet)[] | string | Object\n        } = {\n            in: [],\n            out: [],\n            _id: '',\n            tx: {},\n            blk: {},\n        }\n\n        for (const [key, val] of Object.entries(tx)) {\n            if (key === 'out') {\n                // loop over the outputs\n                for (const out of tx.out) {\n                    const { tape } = out\n\n                    if (tape?.some((cc) => checkOpFalseOpReturn(cc))) {\n                        // loop over tape\n                        for (const cellContainer of tape) {\n                            // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n                            if (checkOpFalseOpReturn(cellContainer)) {\n                                continue\n                            }\n\n                            const { cell } = cellContainer\n                            if (!cell) {\n                                throw new Error('empty cell while parsing')\n                            }\n\n                            // Get protocol name from prefix\n                            const prefix = cell[0].s as string\n\n                            const protocolName =\n                                self.protocolMap.get(prefix) || prefix\n\n                            if (\n                                self.protocolHandlers.has(protocolName) &&\n                                typeof self.protocolHandlers.get(\n                                    protocolName\n                                ) === 'function'\n                            ) {\n                                const handler =\n                                    self.protocolHandlers.get(protocolName)\n                                if (handler) {\n                                    /* eslint-disable no-await-in-loop */\n                                    await handler({\n                                        dataObj: dataObj as BmapTx,\n                                        cell,\n                                        tape,\n                                        tx,\n                                    })\n                                }\n                            } else {\n                                saveProtocolData(dataObj, protocolName, cell)\n                            }\n                        }\n                    } else {\n                        // No OP_RETURN in this outputs\n                        if (key && !dataObj[key]) {\n                            dataObj[key] = []\n                        }\n\n                        ;(dataObj[key] as Out[]).push({\n                            i: out.i,\n                            e: out.e,\n                        })\n                    }\n                }\n            } else if (key === 'in') {\n                dataObj[key] = val.map((v: In) => {\n                    const r = { ...v }\n                    delete r.tape\n                    return r\n                })\n            } else if (Object.keys(dataObj).includes(key)) {\n                // knwon key, just write it retaining original type\n                dataObj[key] = val\n            } else if (!dataObj[key]) {\n                // unknown key. push into array incase there are many of these detected\n                dataObj[key] = []\n                ;(dataObj[key] as Object[]).push(val)\n            }\n        }\n\n        // If this is a MOM planaria it will have metanet keys available\n        if (dataObj['METANET'] && (tx as MomTx).parent) {\n            const meta = {\n                ancestor: (tx as MomTx).ancestor,\n                parent: (tx as MomTx).parent,\n                child: (tx as MomTx).child,\n                head: (tx as MomTx).head,\n            } as MetaNet\n\n            ;(dataObj.METANET as MetaNet[]).push(meta)\n            // remove parent and node from root level for (MOM data)\n            delete dataObj.ancestor\n            delete dataObj.child\n            delete dataObj.parent\n            delete dataObj.head\n            delete dataObj.node\n        }\n\n        return dataObj as BmapTx\n    }\n}\n\nexport const TransformTx = async (tx: BobTx) => {\n    const b = new BMAP()\n    return b.transformTx(tx)\n}\n"],"names":[],"version":3,"file":"types.d.ts.map","sourceRoot":"../"}