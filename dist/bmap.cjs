var $hiCjL$buffer = require("buffer");
var $hiCjL$assert = require("assert");
var $hiCjL$crypto = require("crypto");
var $hiCjL$process = require("process");

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequire7c15"];
if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequire7c15"] = parcelRequire;
}
parcelRequire.register("4apJo", function(module, exports) {
"use strict";
// ref: https://github.com/tc39/proposal-global
var getGlobal = function() {
    // the only reliable means to get the global object is
    // `Function('return this')()`
    // However, this causes CSP violations in Chrome apps.
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw new Error("unable to locate global object");
};
var global = getGlobal();
module.exports = exports = global.fetch;
// Needed for TypeScript and Webpack.
if (global.fetch) exports.default = global.fetch.bind(global);
exports.Headers = global.Headers;
exports.Request = global.Request;
exports.Response = global.Response;

});

parcelRequire.register("5St76", function(module, exports) {
"use strict";
var $44789440faae671d$var$bsv = module.exports;





















$44789440faae671d$var$bsv.crypto = {}, $44789440faae671d$var$bsv.crypto.BN = (parcelRequire("iDkJI")), $44789440faae671d$var$bsv.crypto.ECDSA = (parcelRequire("dNWce")), $44789440faae671d$var$bsv.crypto.Hash = (parcelRequire("626sY")), $44789440faae671d$var$bsv.crypto.Random = (parcelRequire("7Ri8i")), $44789440faae671d$var$bsv.crypto.Point = (parcelRequire("eEHbt")), $44789440faae671d$var$bsv.crypto.Signature = (parcelRequire("217RI")), $44789440faae671d$var$bsv.encoding = {}, $44789440faae671d$var$bsv.encoding.Base58 = (parcelRequire("4NRZk")), $44789440faae671d$var$bsv.encoding.Base58Check = (parcelRequire("jDRhN")), $44789440faae671d$var$bsv.encoding.BufferReader = (parcelRequire("3vHUG")), $44789440faae671d$var$bsv.encoding.BufferWriter = (parcelRequire("i6ihF")), $44789440faae671d$var$bsv.encoding.Varint = (parcelRequire("3fWN4")), $44789440faae671d$var$bsv.util = {}, $44789440faae671d$var$bsv.util.js = (parcelRequire("aYsCb")), $44789440faae671d$var$bsv.util.preconditions = (parcelRequire("2EPYC")), $44789440faae671d$var$bsv.errors = (parcelRequire("7Wzz9")), $44789440faae671d$var$bsv.Address = (parcelRequire("bM62Y")), $44789440faae671d$var$bsv.BlockHeader = (parcelRequire("6i5yx")), $44789440faae671d$var$bsv.Opcode = (parcelRequire("bs6mg")), $44789440faae671d$var$bsv.PrivateKey = (parcelRequire("9jEuU")), $44789440faae671d$var$bsv.PublicKey = (parcelRequire("2OQpG")), $44789440faae671d$var$bsv.Script = (parcelRequire("51Dlk")), $44789440faae671d$var$bsv.Transaction = (parcelRequire("iOIbA"));

});
parcelRequire.register("iDkJI", function(module, exports) {

var $d90bf44c93f3eb70$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $kcp1M = parcelRequire("kcp1M");

var $2EPYC = parcelRequire("2EPYC");

var $jk7hO = parcelRequire("jk7hO");
var $d90bf44c93f3eb70$var$reversebuf = function(r) {
    for(var e = $d90bf44c93f3eb70$require$Buffer.alloc(r.length), t = 0; t < r.length; t++)e[t] = r[r.length - 1 - t];
    return e;
};
$kcp1M.Zero = new $kcp1M(0), $kcp1M.One = new $kcp1M(1), $kcp1M.Minus1 = new $kcp1M(-1), $kcp1M.fromNumber = function(r) {
    return $2EPYC.checkArgument($jk7hO.isNumber(r)), new $kcp1M(r);
}, $kcp1M.fromString = function(r, e) {
    return $2EPYC.checkArgument($jk7hO.isString(r)), new $kcp1M(r, e);
}, $kcp1M.fromBuffer = function(r, e) {
    void 0 !== e && "little" === e.endian && (r = $d90bf44c93f3eb70$var$reversebuf(r));
    var t = r.toString("hex");
    return new $kcp1M(t, 16);
}, $kcp1M.fromSM = function(r, e) {
    var t;
    if (0 === r.length) return $kcp1M.fromBuffer($d90bf44c93f3eb70$require$Buffer.from([
        0
    ]));
    var n = "big";
    return e && (n = e.endian), "little" === n && (r = $d90bf44c93f3eb70$var$reversebuf(r)), 128 & r[0] ? (r[0] = 127 & r[0], (t = $kcp1M.fromBuffer(r)).neg().copy(t)) : t = $kcp1M.fromBuffer(r), t;
}, $kcp1M.prototype.toNumber = function() {
    return parseInt(this.toString(10), 10);
}, $kcp1M.prototype.toBuffer = function(r) {
    var e, t;
    if (r && r.size) {
        var n = (t = this.toString(16, 2)).length / 2;
        e = $d90bf44c93f3eb70$require$Buffer.from(t, "hex"), n === r.size || (n > r.size ? e = $kcp1M.trim(e, n) : n < r.size && (e = $kcp1M.pad(e, n, r.size)));
    } else t = this.toString(16, 2), e = $d90bf44c93f3eb70$require$Buffer.from(t, "hex");
    return void 0 !== r && "little" === r.endian && (e = $d90bf44c93f3eb70$var$reversebuf(e)), e;
}, $kcp1M.prototype.toSMBigEndian = function() {
    var r;
    return -1 === this.cmp($kcp1M.Zero) ? 128 & (r = this.neg().toBuffer())[0] ? r = $d90bf44c93f3eb70$require$Buffer.concat([
        $d90bf44c93f3eb70$require$Buffer.from([
            128
        ]),
        r
    ]) : r[0] = 128 | r[0] : 128 & (r = this.toBuffer())[0] && (r = $d90bf44c93f3eb70$require$Buffer.concat([
        $d90bf44c93f3eb70$require$Buffer.from([
            0
        ]),
        r
    ])), 1 === r.length & 0 === r[0] && (r = $d90bf44c93f3eb70$require$Buffer.from([])), r;
}, $kcp1M.prototype.toSM = function(r) {
    var e = r ? r.endian : "big", t = this.toSMBigEndian();
    return "little" === e && (t = $d90bf44c93f3eb70$var$reversebuf(t)), t;
}, $kcp1M.fromScriptNumBuffer = function(r, e, t) {
    var n = t || 4;
    if ($2EPYC.checkArgument(r.length <= n, new Error("script number overflow")), e && r.length > 0 && 0 == (127 & r[r.length - 1]) && (r.length <= 1 || 0 == (128 & r[r.length - 2]))) throw new Error("non-minimally encoded script number");
    return $kcp1M.fromSM(r, {
        endian: "little"
    });
}, $kcp1M.prototype.toScriptNumBuffer = function() {
    return this.toSM({
        endian: "little"
    });
}, $kcp1M.trim = function(r, e) {
    return r.slice(e - r.length, r.length);
}, $kcp1M.pad = function(r, e, t) {
    for(var n = $d90bf44c93f3eb70$require$Buffer.alloc(t), f = 0; f < r.length; f++)n[n.length - 1 - f] = r[r.length - 1 - f];
    for(f = 0; f < t - e; f++)n[f] = 0;
    return n;
}, $kcp1M.prototype.toHex = function(...r) {
    return this.toBuffer(...r).toString("hex");
}, $kcp1M.fromHex = function(r, ...e) {
    return $kcp1M.fromBuffer($d90bf44c93f3eb70$require$Buffer.from(r, "hex"), ...e);
}, module.exports = $kcp1M;

});
parcelRequire.register("kcp1M", function(module, exports) {

(function(module1, exports) {
    "use strict";
    // Utils
    function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
    }
    // Could use `inherits` module, but don't want to move from single file
    // architecture yet.
    function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
    // BN
    function BN(number, base, endian) {
        if (BN.isBN(number)) return number;
        this.negative = 0;
        this.words = null;
        this.length = 0;
        // Reduction context
        this.red = null;
        if (number !== null) {
            if (base === "le" || base === "be") {
                endian = base;
                base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
        }
    }
    if (typeof module1 === "object") module1.exports = BN;
    else exports.BN = BN;
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;
    try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") Buffer = window.Buffer;
        else Buffer = (parcelRequire("cY7r0")).Buffer;
    } catch (e) {}
    BN.isBN = function isBN(num) {
        if (num instanceof BN) return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
    };
    BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
    };
    BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") return this._initNumber(number, base, endian);
        if (typeof number === "object") return this._initArray(number, base, endian);
        if (base === "hex") base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
            start++;
            this.negative = 1;
        }
        if (start < number.length) {
            if (base === 16) this._parseHex(number, start, endian);
            else {
                this._parseBase(number, base, start);
                if (endian === "le") this._initArray(this.toArray(), base, endian);
            }
        }
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
            this.negative = 1;
            number = -number;
        }
        if (number < 0x4000000) {
            this.words = [
                number & 0x3ffffff
            ];
            this.length = 1;
        } else if (number < 0x10000000000000) {
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff
            ];
            this.length = 2;
        } else {
            assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff,
                1
            ];
            this.length = 3;
        }
        if (endian !== "le") return;
        // Reverse the bytes
        this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === "number");
        if (number.length <= 0) {
            this.words = [
                0
            ];
            this.length = 1;
            return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        var j, w;
        var off = 0;
        if (endian === "be") for(i = number.length - 1, j = 0; i >= 0; i -= 3){
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        else if (endian === "le") for(i = 0, j = 0; i < number.length; i += 3){
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        return this.strip();
    };
    function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        // 'A' - 'F'
        if (c >= 65 && c <= 70) return c - 55;
        else if (c >= 97 && c <= 102) return c - 87;
        else return c - 48 & 0xf;
    }
    function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) r |= parseHex4Bits(string, index - 1) << 4;
        return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start, endian) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        // 24-bits chunks
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") for(i = number.length - 1; i >= start; i -= 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else off += 8;
        }
        else {
            var parseLength = number.length - start;
            for(i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2){
                w = parseHexByte(number, start, i) << off;
                this.words[j] |= w & 0x3ffffff;
                if (off >= 18) {
                    off -= 18;
                    j += 1;
                    this.words[j] |= w >>> 26;
                } else off += 8;
            }
        }
        this.strip();
    };
    function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for(var i = start; i < len; i++){
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            // 'a'
            if (c >= 49) r += c - 49 + 0xa;
            else if (c >= 17) r += c - 17 + 0xa;
            else r += c;
        }
        return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [
            0
        ];
        this.length = 1;
        // Find length of limb in base
        for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)limbLen++;
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for(var i = start; i < end; i += limbLen){
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for(i = 0; i < mod; i++)pow *= base;
            this.imuln(pow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        this.strip();
    };
    BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)dest.words[i] = this.words[i];
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
    };
    BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
    };
    BN.prototype._expand = function _expand(size) {
        while(this.length < size)this.words[this.length++] = 0;
        return this;
    };
    // Remove leading `0` from `this`
    BN.prototype.strip = function strip() {
        while(this.length > 1 && this.words[this.length - 1] === 0)this.length--;
        return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
    };
    BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */ var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
    ];
    var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
    ];
    var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        10000000,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64000000,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        24300000,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for(var i = 0; i < this.length; i++){
                var w = this.words[i];
                var word = ((w << off | carry) & 0xffffff).toString(16);
                carry = w >>> 24 - off & 0xffffff;
                if (carry !== 0 || i !== this.length - 1) out = zeros[6 - word.length] + word + out;
                else out = word + out;
                off += 2;
                if (off >= 26) {
                    off -= 26;
                    i--;
                }
            }
            if (carry !== 0) out = carry.toString(16) + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
            var groupSize = groupSizes[base];
            // var groupBase = Math.pow(base, groupSize);
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while(!c.isZero()){
                var r = c.modn(groupBase).toString(base);
                c = c.idivn(groupBase);
                if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;
                else out = r + out;
            }
            if (this.isZero()) out = "0" + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        assert(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) ret += this.words[1] * 0x4000000;
        else if (this.length === 3 && this.words[2] === 0x01) // NOTE: at this stage it is known that the top bit is set
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
        else if (this.length > 2) assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
    };
    BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer !== "undefined");
        return this.toArrayLike(Buffer, endian, length);
    };
    BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
            // Assume big-endian
            for(i = 0; i < reqLength - byteLength; i++)res[i] = 0;
            for(i = 0; !q.isZero(); i++){
                b = q.andln(0xff);
                q.iushrn(8);
                res[reqLength - i - 1] = b;
            }
        } else {
            for(i = 0; !q.isZero(); i++){
                b = q.andln(0xff);
                q.iushrn(8);
                res[i] = b;
            }
            for(; i < reqLength; i++)res[i] = 0;
        }
        return res;
    };
    if (Math.clz32) BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
    else BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
    BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 0x1fff) === 0) {
            r += 13;
            t >>>= 13;
        }
        if ((t & 0x7f) === 0) {
            r += 7;
            t >>>= 7;
        }
        if ((t & 0xf) === 0) {
            r += 4;
            t >>>= 4;
        }
        if ((t & 0x3) === 0) {
            r += 2;
            t >>>= 2;
        }
        if ((t & 0x1) === 0) r++;
        return r;
    };
    // Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
        var w = new Array(num.bitLength());
        for(var bit = 0; bit < w.length; bit++){
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
    }
    // Number of trailing zero bits
    BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for(var i = 0; i < this.length; i++){
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
        }
        return r;
    };
    BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);
        return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();
        return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
    };
    // Return negative clone of `this`
    BN.prototype.neg = function neg() {
        return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
    };
    // Or `num` with `this` in-place
    BN.prototype.iuor = function iuor(num) {
        while(this.length < num.length)this.words[this.length++] = 0;
        for(var i = 0; i < num.length; i++)this.words[i] = this.words[i] | num.words[i];
        return this.strip();
    };
    BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
    };
    // Or `num` with `this`
    BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
    };
    // And `num` with `this` in-place
    BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;
        if (this.length > num.length) b = num;
        else b = this;
        for(var i = 0; i < b.length; i++)this.words[i] = this.words[i] & num.words[i];
        this.length = b.length;
        return this.strip();
    };
    BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
    };
    // And `num` with `this`
    BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
    };
    // Xor `num` with `this` in-place
    BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        for(var i = 0; i < b.length; i++)this.words[i] = a.words[i] ^ b.words[i];
        if (this !== a) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = a.length;
        return this.strip();
    };
    BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
    };
    // Xor `num` with `this`
    BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
    };
    // Not ``this`` with ``width`` bitwidth
    BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        // Extend the buffer with leading zeroes
        this._expand(bytesNeeded);
        if (bitsLeft > 0) bytesNeeded--;
        // Handle complete words
        for(var i = 0; i < bytesNeeded; i++)this.words[i] = ~this.words[i] & 0x3ffffff;
        // Handle the residue
        if (bitsLeft > 0) this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        // And remove leading zeroes
        return this.strip();
    };
    BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
    };
    // Set `bit` of `this`
    BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) this.words[off] = this.words[off] | 1 << wbit;
        else this.words[off] = this.words[off] & ~(1 << wbit);
        return this.strip();
    };
    // Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
        var r;
        // negative + positive
        if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
        // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
        }
        // a.length > b.length
        var a, b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
        // Copy the rest of the words
        } else if (a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        return this;
    };
    // Add `num` to `this`
    BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
        } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
    };
    // Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
        // -this - num = -(this + num)
        } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
        }
        // At this point both numbers are positive
        var cmp = this.cmp(num);
        // Optimization - zeroify
        if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
        }
        // a > b
        var a, b;
        if (cmp > 0) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        // Copy rest of the words
        if (carry === 0 && i < a.length && a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = Math.max(this.length, i);
        if (a !== this) this.negative = 1;
        return this.strip();
    };
    // Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
    };
    function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        // Peel one iteration (compiler can't do it, because of code complexity)
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;
        for(var k = 1; k < len; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = carry >>> 26;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j | 0;
                a = self.words[i] | 0;
                b = num.words[j] | 0;
                r = a * b + rword;
                ncarry += r / 0x4000000 | 0;
                rword = r & 0x3ffffff;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
        }
        if (carry !== 0) out.words[k] = carry | 0;
        else out.length--;
        return out.strip();
    }
    // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).
    var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */ lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */ lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */ lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */ lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */ lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */ lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */ lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */ lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */ lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */ lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */ lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */ lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */ lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */ lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */ lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */ lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */ lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */ lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */ lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
            o[19] = c;
            out.length++;
        }
        return out;
    };
    // Polyfill comb
    if (!Math.imul) comb10MulTo = smallMulTo;
    function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for(var k = 0; k < out.length - 1; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j;
                var a = self.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;
                var lo = r & 0x3ffffff;
                ncarry = ncarry + (r / 0x4000000 | 0) | 0;
                lo = lo + rword | 0;
                rword = lo & 0x3ffffff;
                ncarry = ncarry + (lo >>> 26) | 0;
                hncarry += ncarry >>> 26;
                ncarry &= 0x3ffffff;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
        }
        if (carry !== 0) out.words[k] = carry;
        else out.length--;
        return out.strip();
    }
    function jumboMulTo(self, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) res = comb10MulTo(this, num, out);
        else if (len < 63) res = smallMulTo(this, num, out);
        else if (len < 1024) res = bigMulTo(this, num, out);
        else res = jumboMulTo(this, num, out);
        return res;
    };
    // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion
    function FFTM(x, y) {
        this.x = x;
        this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for(var i = 0; i < N; i++)t[i] = this.revBin(i, l, N);
        return t;
    };
    // Returns binary-reversed representation of `x`
    FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for(var i = 0; i < l; i++){
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
        }
        return rb;
    };
    // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for(var i = 0; i < N; i++){
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
        }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for(var s = 1; s < N; s <<= 1){
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for(var p = 0; p < N; p += l){
                var rtwdf_ = rtwdf;
                var itwdf_ = itwdf;
                for(var j = 0; j < s; j++){
                    var re = rtws[p + j];
                    var ie = itws[p + j];
                    var ro = rtws[p + j + s];
                    var io = itws[p + j + s];
                    var rx = rtwdf_ * ro - itwdf_ * io;
                    io = rtwdf_ * io + itwdf_ * ro;
                    ro = rx;
                    rtws[p + j] = re + ro;
                    itws[p + j] = ie + io;
                    rtws[p + j + s] = re - ro;
                    itws[p + j + s] = ie - io;
                    /* jshint maxdepth : false */ if (j !== l) {
                        rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                        itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                        rtwdf_ = rx;
                    }
                }
            }
        }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for(N = N / 2 | 0; N; N = N >>> 1)i++;
        return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for(var i = 0; i < N / 2; i++){
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
        }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for(var i = 0; i < N / 2; i++){
            var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 0x3ffffff;
            if (w < 0x4000000) carry = 0;
            else carry = w / 0x4000000 | 0;
        }
        return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for(var i = 0; i < len; i++){
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 0x1fff;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 0x1fff;
            carry = carry >>> 13;
        }
        // Pad with zeroes
        for(i = 2 * len; i < N; ++i)rws[i] = 0;
        assert(carry === 0);
        assert((carry & -8192) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for(var i = 0; i < N; i++)ph[i] = 0;
        return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for(var i = 0; i < N; i++){
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
    };
    // Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
    };
    // Multiply employing FFT
    BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
    };
    // In-place Multiplication
    BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        // Carry
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = (this.words[i] | 0) * num;
            var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
            carry >>= 26;
            carry += w / 0x4000000 | 0;
            // NOTE: lo is 27bit maximum
            carry += lo >>> 26;
            this.words[i] = lo & 0x3ffffff;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
    };
    // `this` * `this`
    BN.prototype.sqr = function sqr() {
        return this.mul(this);
    };
    // `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
    };
    // Math.pow(`this`, `num`)
    BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        // Skip leading zeroes
        var res = this;
        for(var i = 0; i < w.length; i++, res = res.sqr()){
            if (w[i] !== 0) break;
        }
        if (++i < w.length) for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
            if (w[i] === 0) continue;
            res = res.mul(q);
        }
        return res;
    };
    // Shift-left in-place
    BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
            var carry = 0;
            for(i = 0; i < this.length; i++){
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] | 0) - newCarry << r;
                this.words[i] = c | carry;
                carry = newCarry >>> 26 - r;
            }
            if (carry) {
                this.words[i] = carry;
                this.length++;
            }
        }
        if (s !== 0) {
            for(i = this.length - 1; i >= 0; i--)this.words[i + s] = this.words[i];
            for(i = 0; i < s; i++)this.words[i] = 0;
            this.length += s;
        }
        return this.strip();
    };
    BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
    };
    // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) h = (hint - hint % 26) / 26;
        else h = 0;
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        // Extended mode, copy masked part
        if (maskedWords) {
            for(var i = 0; i < s; i++)maskedWords.words[i] = this.words[i];
            maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
            this.length -= s;
            for(i = 0; i < this.length; i++)this.words[i] = this.words[i + s];
        } else {
            this.words[0] = 0;
            this.length = 1;
        }
        var carry = 0;
        for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
        }
        // Push carried bits as a mask
        if (maskedWords && carry !== 0) maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
        }
        return this.strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
    };
    // Shift-left
    BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
    };
    // Shift-right
    BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
    };
    // Test if n bit is set
    BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) return false;
        // Check bit and return
        var w = this.words[s];
        return !!(w & q);
    };
    // Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) return this;
        if (r !== 0) s++;
        this.length = Math.min(s, this.length);
        if (r !== 0) {
            var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
            this.words[this.length - 1] &= mask;
        }
        return this.strip();
    };
    // Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
    };
    // Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num);
        // Possible sign change
        if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
                this.words[0] = num - (this.words[0] | 0);
                this.negative = 0;
                return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
        }
        // Add without checks
        return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        // Carry
        for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
            this.words[i] -= 0x4000000;
            if (i === this.length - 1) this.words[i + 1] = 1;
            else this.words[i + 1]++;
        }
        this.length = Math.max(this.length, i + 1);
        return this;
    };
    // Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
        } else // Carry
        for(var i = 0; i < this.length && this.words[i] < 0; i++){
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }
        return this.strip();
    };
    BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
    };
    BN.prototype.abs = function abs() {
        return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for(i = 0; i < num.length; i++){
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 0x3ffffff;
            carry = (w >> 26) - (right / 0x4000000 | 0);
            this.words[i + shift] = w & 0x3ffffff;
        }
        for(; i < this.length - shift; i++){
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 0x3ffffff;
        }
        if (carry === 0) return this.strip();
        // Subtraction overflow
        assert(carry === -1);
        carry = 0;
        for(i = 0; i < this.length; i++){
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 0x3ffffff;
        }
        this.negative = 1;
        return this.strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        // Normalize
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
        }
        // Initialize quotient
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for(var i = 0; i < q.length; i++)q.words[i] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
            a = diff;
            if (q) q.words[m] = 1;
        }
        for(var j = m - 1; j >= 0; j--){
            var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
            // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
            // (0x7ffffff)
            qj = Math.min(qj / bhi | 0, 0x3ffffff);
            a._ishlnsubmul(b, qj, j);
            while(a.negative !== 0){
                qj--;
                a.negative = 0;
                a._ishlnsubmul(b, 1, j);
                if (!a.isZero()) a.negative ^= 1;
            }
            if (q) q.words[j] = qj;
        }
        if (q) q.strip();
        a.strip();
        // Denormalize
        if (mode !== "div" && shift !== 0) a.iushrn(shift);
        return {
            div: q || null,
            mod: a
        };
    };
    // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested
    BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) return {
            div: new BN(0),
            mod: new BN(0)
        };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") div = res.div.neg();
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.iadd(num);
            }
            return {
                div: div,
                mod: mod
            };
        }
        if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") div = res.div.neg();
            return {
                div: div,
                mod: res.mod
            };
        }
        if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.isub(num);
            }
            return {
                div: res.div,
                mod: mod
            };
        }
        // Both numbers are positive at this point
        // Strip both numbers to approximate shift value
        if (num.length > this.length || this.cmp(num) < 0) return {
            div: new BN(0),
            mod: this
        };
        // Very short reduction
        if (num.length === 1) {
            if (mode === "div") return {
                div: this.divn(num.words[0]),
                mod: null
            };
            if (mode === "mod") return {
                div: null,
                mod: new BN(this.modn(num.words[0]))
            };
            return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modn(num.words[0]))
            };
        }
        return this._wordDiv(num, mode);
    };
    // Find `this` / `num`
    BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
    };
    // Find `this` % `num`
    BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
    };
    // Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        // Fast case - exact division
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        // Round down
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        // Round up
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modn = function modn(num) {
        assert(num <= 0x3ffffff);
        var p = 67108864 % num;
        var acc = 0;
        for(var i = this.length - 1; i >= 0; i--)acc = (p * acc + (this.words[i] | 0)) % num;
        return acc;
    };
    // In-place division by number
    BN.prototype.idivn = function idivn(num) {
        assert(num <= 0x3ffffff);
        var carry = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var w = (this.words[i] | 0) + carry * 0x4000000;
            this.words[i] = w / num | 0;
            carry = w % num;
        }
        return this.strip();
    };
    BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) x = x.umod(p);
        else x = x.clone();
        // A * x + B * y = x
        var A = new BN(1);
        var B = new BN(0);
        // C * x + D * y = y
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while(x.isEven() && y.isEven()){
            x.iushrn(1);
            y.iushrn(1);
            ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while(!x.isZero()){
            for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                x.iushrn(i);
                while(i-- > 0){
                    if (A.isOdd() || B.isOdd()) {
                        A.iadd(yp);
                        B.isub(xp);
                    }
                    A.iushrn(1);
                    B.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                y.iushrn(j);
                while(j-- > 0){
                    if (C.isOdd() || D.isOdd()) {
                        C.iadd(yp);
                        D.isub(xp);
                    }
                    C.iushrn(1);
                    D.iushrn(1);
                }
            }
            if (x.cmp(y) >= 0) {
                x.isub(y);
                A.isub(C);
                B.isub(D);
            } else {
                y.isub(x);
                C.isub(A);
                D.isub(B);
            }
        }
        return {
            a: C,
            b: D,
            gcd: y.iushln(g)
        };
    };
    // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed
    BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) a = a.umod(p);
        else a = a.clone();
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
            for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                a.iushrn(i);
                while(i-- > 0){
                    if (x1.isOdd()) x1.iadd(delta);
                    x1.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                b.iushrn(j);
                while(j-- > 0){
                    if (x2.isOdd()) x2.iadd(delta);
                    x2.iushrn(1);
                }
            }
            if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
            } else {
                b.isub(a);
                x2.isub(x1);
            }
        }
        var res;
        if (a.cmpn(1) === 0) res = x1;
        else res = x2;
        if (res.cmpn(0) < 0) res.iadd(p);
        return res;
    };
    BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        // Remove common factor of two
        for(var shift = 0; a.isEven() && b.isEven(); shift++){
            a.iushrn(1);
            b.iushrn(1);
        }
        do {
            while(a.isEven())a.iushrn(1);
            while(b.isEven())b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
                // Swap `a` and `b` to make `a` always bigger than `b`
                var t = a;
                a = b;
                b = t;
            } else if (r === 0 || b.cmpn(1) === 0) break;
            a.isub(b);
        }while (true);
        return b.iushln(shift);
    };
    // Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
    };
    // And first word and num
    BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
    };
    // Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
        }
        // Add bit and propagate, if needed
        var carry = q;
        for(var i = s; carry !== 0 && i < this.length; i++){
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 0x3ffffff;
            this.words[i] = w;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) res = 1;
        else {
            if (negative) num = -num;
            assert(num <= 0x3ffffff, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) res = -1;
            else if (a > b) res = 1;
            break;
        }
        return res;
    };
    BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
    };
    //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //
    BN.red = function red(num) {
        return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
    };
    // Square root over p
    BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
    };
    // Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
    };
    // Prime numbers with efficient reduction
    var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
    };
    // Pseudo-Mersenne prime
    function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;
        do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
        }while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
        } else if (cmp > 0) r.isub(this.p);
        else if (r.strip !== undefined) // r is BN v4 instance
        r.strip();
        else // r is BN v5 instance
        r._strip();
        return r;
    };
    MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
    };
    function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);
        for(var i = 0; i < outLen; i++)output.words[i] = input.words[i];
        output.length = outLen;
        if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
        }
        // Shift by 9 limbs
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for(i = 10; i < input.length; i++){
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) input.length -= 10;
        else input.length -= 9;
    };
    K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
        var lo = 0;
        for(var i = 0; i < num.length; i++){
            var w = num.words[i] | 0;
            lo += w * 0x3d1;
            num.words[i] = lo & 0x3ffffff;
            lo = w * 0x40 + (lo / 0x4000000 | 0);
        }
        // Fast length reduction
        if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) num.length--;
        }
        return num;
    };
    function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;
        for(var i = 0; i < num.length; i++){
            var hi = (num.words[i] | 0) * 0x13 + carry;
            var lo = hi & 0x3ffffff;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
        }
        if (carry !== 0) num.words[num.length++] = carry;
        return num;
    };
    // Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;
        if (name === "k256") prime = new K256();
        else if (name === "p224") prime = new P224();
        else if (name === "p192") prime = new P192();
        else if (name === "p25519") prime = new P25519();
        else throw new Error("Unknown prime " + name);
        primes[name] = prime;
        return prime;
    };
    //
    // Base reduction engine
    //
    function Red(m) {
        if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
        } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
        }
    }
    Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg(a) {
        if (a.isZero()) return a.clone();
        return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res;
    };
    Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res;
    };
    Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        // Fast case
        if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
        }
        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        var q = this.m.subn(1);
        var s = 0;
        while(!q.isZero() && q.andln(1) === 0){
            s++;
            q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while(this.pow(z, lpow).cmp(nOne) !== 0)z.redIAdd(nOne);
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while(t.cmp(one) !== 0){
            var tmp = t;
            for(var i = 0; tmp.cmp(one) !== 0; i++)tmp = tmp.redSqr();
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
        }
        return r;
    };
    Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
        } else return this.imod(inv);
    };
    Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for(var i = 2; i < wnd.length; i++)wnd[i] = this.mul(wnd[i - 1], a);
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) start = 26;
        for(i = num.length - 1; i >= 0; i--){
            var word = num.words[i];
            for(var j = start - 1; j >= 0; j--){
                var bit = word >> j & 1;
                if (res !== wnd[0]) res = this.sqr(res);
                if (bit === 0 && current === 0) {
                    currentLen = 0;
                    continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
            }
            start = 26;
        }
        return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
    };
    //
    // Montgomery method engine
    //
    BN.mont = function mont(num) {
        return new Mont(num);
    };
    function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
    };
    Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
    };
})(module, this);

});
parcelRequire.register("cY7r0", function(module, exports) {
"use strict";

});


parcelRequire.register("2EPYC", function(module, exports) {
"use strict";

var $7Wzz9 = parcelRequire("7Wzz9");

var $jk7hO = parcelRequire("jk7hO");

module.exports = {
    checkState: function(e, r) {
        if (!e) throw new $7Wzz9.InvalidState(r);
    },
    checkArgument: function(e, r, n, t) {
        if (!e) throw new $7Wzz9.InvalidArgument(r, n, t);
    },
    checkArgumentType: function(e, r, n) {
        if (n = n || "(unknown name)", $jk7hO.isString(r)) {
            if ("Buffer" === r) {
                if (!$hiCjL$buffer.Buffer.isBuffer(e)) throw new $7Wzz9.InvalidArgumentType(e, r, n);
            } else if (typeof e !== r) throw new $7Wzz9.InvalidArgumentType(e, r, n);
        } else if (!(e instanceof r)) throw new $7Wzz9.InvalidArgumentType(e, r.name, n);
    }
};

});
parcelRequire.register("7Wzz9", function(module, exports) {
"use strict";

var $jk7hO = parcelRequire("jk7hO");
function $5c8989d29420f776$var$format(r, e) {
    return r.replace("{0}", e[0]).replace("{1}", e[1]).replace("{2}", e[2]);
}
var $5c8989d29420f776$var$traverseNode = function(r, e) {
    var t = function() {
        if ($jk7hO.isString(e.message)) this.message = $5c8989d29420f776$var$format(e.message, arguments);
        else {
            if (!$jk7hO.isFunction(e.message)) throw new Error("Invalid error definition for " + e.name);
            this.message = e.message.apply(null, arguments);
        }
        this.stack = this.message + "\n" + (new Error).stack;
    };
    return (t.prototype = Object.create(r.prototype)).name = r.prototype.name + e.name, r[e.name] = t, e.errors && $5c8989d29420f776$var$childDefinitions(t, e.errors), t;
}, $5c8989d29420f776$var$childDefinitions = function(r, e) {
    $jk7hO.each(e, function(e) {
        $5c8989d29420f776$var$traverseNode(r, e);
    });
}, $5c8989d29420f776$var$traverseRoot = function(r, e) {
    return $5c8989d29420f776$var$childDefinitions(r, e), r;
}, $5c8989d29420f776$var$bsv = {
    Error: function() {
        this.message = "Internal error", this.stack = this.message + "\n" + (new Error).stack;
    }
};
$5c8989d29420f776$var$bsv.Error.prototype = Object.create(Error.prototype), $5c8989d29420f776$var$bsv.Error.prototype.name = "bsv.Error";

var $ffngq = parcelRequire("ffngq");
$5c8989d29420f776$var$traverseRoot($5c8989d29420f776$var$bsv.Error, $ffngq), module.exports = $5c8989d29420f776$var$bsv.Error, module.exports.extend = function(r) {
    return $5c8989d29420f776$var$traverseNode($5c8989d29420f776$var$bsv.Error, r);
};

});
parcelRequire.register("jk7hO", function(module, exports) {
"use strict";
var $e11589806c60ab59$var$_ = {
    isArray: (e)=>Array.isArray(e),
    isNumber: (e)=>"number" == typeof e,
    isObject: (e)=>e && "object" == typeof e,
    isString: (e)=>"string" == typeof e,
    isUndefined: (e)=>void 0 === e,
    isFunction: (e)=>"function" == typeof e,
    isNull: (e)=>null === e,
    isDate: (e)=>e instanceof Date,
    extend: (e, r)=>Object.assign(e, r),
    noop: ()=>{},
    every: (e, r)=>e.every(r || ((e)=>e)),
    map: (e, r)=>Array.from(e).map(r || ((e)=>e)),
    includes: (e, r)=>e.includes(r),
    each: (e, r)=>e.forEach(r),
    clone: (e)=>Object.assign({}, e),
    pick: (e, r)=>{
        const t = {};
        return r.forEach((r)=>{
            void 0 !== e[r] && (t[r] = e[r]);
        }), t;
    },
    values: (e)=>Object.values(e),
    filter: (e, r)=>e.filter(r),
    reduce: (e, r, t)=>e.reduce(r, t),
    without: (e, r)=>e.filter((e)=>e !== r),
    shuffle: (e)=>{
        const r = e.slice(0);
        for(let e1 = r.length - 1; e1 > 0; e1--){
            const t = Math.floor(Math.random() * (e1 + 1));
            [r[e1], r[t]] = [
                r[t],
                r[e1]
            ];
        }
        return r;
    },
    difference: (e, r)=>e.filter((e)=>!r.includes(e)),
    findIndex: (e, r)=>e.findIndex(r),
    some: (e, r)=>e.some(r),
    range: (e)=>[
            ...Array(e).keys()
        ]
};
module.exports = $e11589806c60ab59$var$_;

});

parcelRequire.register("ffngq", function(module, exports) {
"use strict";
var $b19a4d6faf11d853$var$docsURL = "https://docs.moneybutton.com/";
module.exports = [
    {
        name: "InvalidB58Char",
        message: "Invalid Base58 character: {0} in {1}"
    },
    {
        name: "InvalidB58Checksum",
        message: "Invalid Base58 checksum for {0}"
    },
    {
        name: "InvalidNetwork",
        message: "Invalid version for network: got {0}"
    },
    {
        name: "InvalidState",
        message: "Invalid state: {0}"
    },
    {
        name: "NotImplemented",
        message: "Function {0} was not implemented yet"
    },
    {
        name: "InvalidNetworkArgument",
        message: 'Invalid network: must be "livenet" or "testnet", got {0}'
    },
    {
        name: "InvalidArgument",
        message: function() {
            return "Invalid Argument" + (arguments[0] ? ": " + arguments[0] : "") + (arguments[1] ? " Documentation: " + $b19a4d6faf11d853$var$docsURL + arguments[1] : "");
        }
    },
    {
        name: "AbstractMethodInvoked",
        message: "Abstract Method Invocation: {0}"
    },
    {
        name: "InvalidArgumentType",
        message: function() {
            return "Invalid Argument for " + arguments[2] + ", expected " + arguments[1] + " but got " + typeof arguments[0];
        }
    },
    {
        name: "Unit",
        message: "Internal Error on Unit {0}",
        errors: [
            {
                name: "UnknownCode",
                message: "Unrecognized unit code: {0}"
            },
            {
                name: "InvalidRate",
                message: "Invalid exchange rate: {0}"
            }
        ]
    },
    {
        name: "MerkleBlock",
        message: "Internal Error on MerkleBlock {0}",
        errors: [
            {
                name: "InvalidMerkleTree",
                message: "This MerkleBlock contain an invalid Merkle Tree"
            }
        ]
    },
    {
        name: "Transaction",
        message: "Internal Error on Transaction {0}",
        errors: [
            {
                name: "Input",
                message: "Internal Error on Input {0}",
                errors: [
                    {
                        name: "MissingScript",
                        message: "Need a script to create an input"
                    },
                    {
                        name: "UnsupportedScript",
                        message: "Unsupported input script type: {0}"
                    },
                    {
                        name: "MissingPreviousOutput",
                        message: "No previous output information."
                    }
                ]
            },
            {
                name: "NeedMoreInfo",
                message: "{0}"
            },
            {
                name: "InvalidSorting",
                message: "The sorting function provided did not return the change output as one of the array elements"
            },
            {
                name: "InvalidOutputAmountSum",
                message: "{0}"
            },
            {
                name: "MissingSignatures",
                message: "Some inputs have not been fully signed"
            },
            {
                name: "InvalidIndex",
                message: "Invalid index: {0} is not between 0, {1}"
            },
            {
                name: "UnableToVerifySignature",
                message: "Unable to verify signature: {0}"
            },
            {
                name: "DustOutputs",
                message: "Dust amount detected in one output"
            },
            {
                name: "InvalidSatoshis",
                message: "Output satoshis are invalid"
            },
            {
                name: "FeeError",
                message: "Internal Error on Fee {0}",
                errors: [
                    {
                        name: "TooSmall",
                        message: "Fee is too small: {0}"
                    },
                    {
                        name: "TooLarge",
                        message: "Fee is too large: {0}"
                    },
                    {
                        name: "Different",
                        message: "Unspent value is different from specified fee: {0}"
                    }
                ]
            },
            {
                name: "ChangeAddressMissing",
                message: "Change address is missing"
            },
            {
                name: "BlockHeightTooHigh",
                message: "Block Height can be at most 2^32 -1"
            },
            {
                name: "NLockTimeOutOfRange",
                message: "Block Height can only be between 0 and 499 999 999"
            },
            {
                name: "LockTimeTooEarly",
                message: "Lock Time can't be earlier than UNIX date 500 000 000"
            }
        ]
    },
    {
        name: "Script",
        message: "Internal Error on Script {0}",
        errors: [
            {
                name: "UnrecognizedAddress",
                message: "Expected argument {0} to be an address"
            },
            {
                name: "CantDeriveAddress",
                message: "Can't derive address associated with script {0}, needs to be p2pkh in, p2pkh out, p2sh in, or p2sh out."
            },
            {
                name: "InvalidBuffer",
                message: "Invalid script buffer: can't parse valid script from given buffer {0}"
            }
        ]
    },
    {
        name: "HDPrivateKey",
        message: "Internal Error on HDPrivateKey {0}",
        errors: [
            {
                name: "InvalidDerivationArgument",
                message: "Invalid derivation argument {0}, expected string, or number and boolean"
            },
            {
                name: "InvalidEntropyArgument",
                message: "Invalid entropy: must be an hexa string or binary buffer, got {0}",
                errors: [
                    {
                        name: "TooMuchEntropy",
                        message: 'Invalid entropy: more than 512 bits is non standard, got "{0}"'
                    },
                    {
                        name: "NotEnoughEntropy",
                        message: 'Invalid entropy: at least 128 bits needed, got "{0}"'
                    }
                ]
            },
            {
                name: "InvalidLength",
                message: "Invalid length for xprivkey string in {0}"
            },
            {
                name: "InvalidPath",
                message: "Invalid derivation path: {0}"
            },
            {
                name: "UnrecognizedArgument",
                message: 'Invalid argument: creating a HDPrivateKey requires a string, buffer, json or object, got "{0}"'
            }
        ]
    },
    {
        name: "HDPublicKey",
        message: "Internal Error on HDPublicKey {0}",
        errors: [
            {
                name: "ArgumentIsPrivateExtended",
                message: "Argument is an extended private key: {0}"
            },
            {
                name: "InvalidDerivationArgument",
                message: "Invalid derivation argument: got {0}"
            },
            {
                name: "InvalidLength",
                message: 'Invalid length for xpubkey: got "{0}"'
            },
            {
                name: "InvalidPath",
                message: 'Invalid derivation path, it should look like: "m/1/100", got "{0}"'
            },
            {
                name: "InvalidIndexCantDeriveHardened",
                message: "Invalid argument: creating a hardened path requires an HDPrivateKey"
            },
            {
                name: "MustSupplyArgument",
                message: "Must supply an argument to create a HDPublicKey"
            },
            {
                name: "UnrecognizedArgument",
                message: "Invalid argument for creation, must be string, json, buffer, or object"
            }
        ]
    }
];

});




parcelRequire.register("dNWce", function(module, exports) {

var $a0ccfe8e7387f7dd$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $iDkJI = parcelRequire("iDkJI");

var $eEHbt = parcelRequire("eEHbt");

var $217RI = parcelRequire("217RI");

var $2OQpG = parcelRequire("2OQpG");

var $7Ri8i = parcelRequire("7Ri8i");

var $626sY = parcelRequire("626sY");

var $jk7hO = parcelRequire("jk7hO");

var $2EPYC = parcelRequire("2EPYC");
var $a0ccfe8e7387f7dd$var$ECDSA = function i(t) {
    if (!(this instanceof i)) return new i(t);
    t && this.set(t);
};
$a0ccfe8e7387f7dd$var$ECDSA.prototype.set = function(i) {
    return this.hashbuf = i.hashbuf || this.hashbuf, this.endian = i.endian || this.endian, this.privkey = i.privkey || this.privkey, this.pubkey = i.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey), this.sig = i.sig || this.sig, this.k = i.k || this.k, this.verified = i.verified || this.verified, this;
}, $a0ccfe8e7387f7dd$var$ECDSA.prototype.privkey2pubkey = function() {
    this.pubkey = this.privkey.toPublicKey();
}, $a0ccfe8e7387f7dd$var$ECDSA.prototype.calci = function() {
    for(var i = 0; i < 4; i++){
        var t;
        this.sig.i = i;
        try {
            t = this.toPublicKey();
        } catch (i1) {
            console.error(i1);
            continue;
        }
        if (t.point.eq(this.pubkey.point)) return this.sig.compressed = this.pubkey.compressed, this;
    }
    throw this.sig.i = void 0, new Error("Unable to find valid recovery factor");
}, $a0ccfe8e7387f7dd$var$ECDSA.fromString = function(i) {
    var t = JSON.parse(i);
    return new $a0ccfe8e7387f7dd$var$ECDSA(t);
}, $a0ccfe8e7387f7dd$var$ECDSA.prototype.randomK = function() {
    var i, t = $eEHbt.getN();
    do i = $iDkJI.fromBuffer($7Ri8i.getRandomBuffer(32));
    while (!i.lt(t) || !i.gt($iDkJI.Zero));
    return this.k = i, this;
}, $a0ccfe8e7387f7dd$var$ECDSA.prototype.deterministicK = function(i) {
    $jk7hO.isUndefined(i) && (i = 0);
    var t = $a0ccfe8e7387f7dd$require$Buffer.alloc(32);
    t.fill(1);
    var e = $a0ccfe8e7387f7dd$require$Buffer.alloc(32);
    e.fill(0);
    var r = this.privkey.bn.toBuffer({
        size: 32
    }), s = "little" === this.endian ? $a0ccfe8e7387f7dd$require$Buffer.from(this.hashbuf).reverse() : this.hashbuf;
    e = $626sY.sha256hmac($a0ccfe8e7387f7dd$require$Buffer.concat([
        t,
        $a0ccfe8e7387f7dd$require$Buffer.from([
            0
        ]),
        r,
        s
    ]), e), t = $626sY.sha256hmac(t, e), e = $626sY.sha256hmac($a0ccfe8e7387f7dd$require$Buffer.concat([
        t,
        $a0ccfe8e7387f7dd$require$Buffer.from([
            1
        ]),
        r,
        s
    ]), e), t = $626sY.sha256hmac(t, e), t = $626sY.sha256hmac(t, e);
    for(var n = $iDkJI.fromBuffer(t), h = $eEHbt.getN(), o = 0; o < i || !n.lt(h) || !n.gt($iDkJI.Zero); o++)e = $626sY.sha256hmac($a0ccfe8e7387f7dd$require$Buffer.concat([
        t,
        $a0ccfe8e7387f7dd$require$Buffer.from([
            0
        ])
    ]), e), t = $626sY.sha256hmac(t, e), t = $626sY.sha256hmac(t, e), n = $iDkJI.fromBuffer(t);
    return this.k = n, this;
}, $a0ccfe8e7387f7dd$var$ECDSA.prototype.toPublicKey = function() {
    var i = this.sig.i;
    $2EPYC.checkArgument(0 === i || 1 === i || 2 === i || 3 === i, new Error("i must be equal to 0, 1, 2, or 3"));
    var t = $iDkJI.fromBuffer(this.hashbuf), e = this.sig.r, r = this.sig.s, s = 1 & i, n = i >> 1, h = $eEHbt.getN(), o = $eEHbt.getG(), u = n ? e.add(h) : e, f = $eEHbt.fromX(s, u);
    if (!f.mul(h).isInfinity()) throw new Error("nR is not a valid curve point");
    var a = t.neg().umod(h), c = e.invm(h), p = f.mul(r).add(o.mul(a)).mul(c);
    return $2OQpG.fromPoint(p, this.sig.compressed);
}, $a0ccfe8e7387f7dd$var$ECDSA.prototype.sigError = function() {
    if (!$a0ccfe8e7387f7dd$require$Buffer.isBuffer(this.hashbuf) || 32 !== this.hashbuf.length) return "hashbuf must be a 32 byte buffer";
    var i = this.sig.r, t = this.sig.s;
    if (!(i.gt($iDkJI.Zero) && i.lt($eEHbt.getN()) && t.gt($iDkJI.Zero) && t.lt($eEHbt.getN()))) return "r and s not in range";
    var e = $iDkJI.fromBuffer(this.hashbuf, this.endian ? {
        endian: this.endian
    } : void 0), r = $eEHbt.getN(), s = t.invm(r), n = s.mul(e).umod(r), h = s.mul(i).umod(r), o = $eEHbt.getG().mulAdd(n, this.pubkey.point, h);
    return o.isInfinity() ? "p is infinity" : 0 !== o.getX().umod(r).cmp(i) && "Invalid signature";
}, $a0ccfe8e7387f7dd$var$ECDSA.toLowS = function(i) {
    return i.gt($iDkJI.fromBuffer($a0ccfe8e7387f7dd$require$Buffer.from("7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0", "hex"))) && (i = $eEHbt.getN().sub(i)), i;
}, $a0ccfe8e7387f7dd$var$ECDSA.prototype._findSignature = function(i, t) {
    var e, r, s, n = $eEHbt.getN(), h = $eEHbt.getG(), o = 0;
    do (!this.k || o > 0) && this.deterministicK(o), o++, e = this.k, r = h.mul(e).x.umod(n), s = e.invm(n).mul(t.add(i.mul(r))).umod(n);
    while (r.cmp($iDkJI.Zero) <= 0 || s.cmp($iDkJI.Zero) <= 0);
    return {
        s: s = $a0ccfe8e7387f7dd$var$ECDSA.toLowS(s),
        r: r
    };
}, $a0ccfe8e7387f7dd$var$ECDSA.prototype.sign = function() {
    var i = this.hashbuf, t = this.privkey, e = t.bn;
    $2EPYC.checkState(i && t && e, new Error("invalid parameters")), $2EPYC.checkState($a0ccfe8e7387f7dd$require$Buffer.isBuffer(i) && 32 === i.length, new Error("hashbuf must be a 32 byte buffer"));
    var r = $iDkJI.fromBuffer(i, this.endian ? {
        endian: this.endian
    } : void 0), s = this._findSignature(e, r);
    return s.compressed = this.pubkey.compressed, this.sig = new $217RI(s), this;
}, $a0ccfe8e7387f7dd$var$ECDSA.prototype.signRandomK = function() {
    return this.randomK(), this.sign();
}, $a0ccfe8e7387f7dd$var$ECDSA.prototype.toString = function() {
    var i = {};
    return this.hashbuf && (i.hashbuf = this.hashbuf.toString("hex")), this.privkey && (i.privkey = this.privkey.toString()), this.pubkey && (i.pubkey = this.pubkey.toString()), this.sig && (i.sig = this.sig.toString()), this.k && (i.k = this.k.toString()), JSON.stringify(i);
}, $a0ccfe8e7387f7dd$var$ECDSA.prototype.verify = function() {
    return this.sigError() ? this.verified = !1 : this.verified = !0, this;
}, $a0ccfe8e7387f7dd$var$ECDSA.sign = function(i, t, e) {
    return $a0ccfe8e7387f7dd$var$ECDSA().set({
        hashbuf: i,
        endian: e,
        privkey: t
    }).sign().sig;
}, $a0ccfe8e7387f7dd$var$ECDSA.signWithCalcI = function(i, t, e) {
    return $a0ccfe8e7387f7dd$var$ECDSA().set({
        hashbuf: i,
        endian: e,
        privkey: t
    }).sign().calci().sig;
}, $a0ccfe8e7387f7dd$var$ECDSA.signRandomK = function(i, t, e) {
    return $a0ccfe8e7387f7dd$var$ECDSA().set({
        hashbuf: i,
        endian: e,
        privkey: t
    }).signRandomK().sig;
}, $a0ccfe8e7387f7dd$var$ECDSA.verify = function(i, t, e, r) {
    return $a0ccfe8e7387f7dd$var$ECDSA().set({
        hashbuf: i,
        endian: r,
        sig: t,
        pubkey: e
    }).verify().verified;
}, module.exports = $a0ccfe8e7387f7dd$var$ECDSA;

});
parcelRequire.register("eEHbt", function(module, exports) {

var $aab64c9131884b87$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $iDkJI = parcelRequire("iDkJI");

var $7Zc1i = parcelRequire("7Zc1i");
var $aab64c9131884b87$require$EC = $7Zc1i.ec;
var $aab64c9131884b87$var$ec = new $aab64c9131884b87$require$EC("secp256k1"), $aab64c9131884b87$var$ecPoint = $aab64c9131884b87$var$ec.curve.point.bind($aab64c9131884b87$var$ec.curve), $aab64c9131884b87$var$ecPointFromX = $aab64c9131884b87$var$ec.curve.pointFromX.bind($aab64c9131884b87$var$ec.curve), $aab64c9131884b87$var$Point = function(t, e, o) {
    try {
        var r = $aab64c9131884b87$var$ecPoint(t, e, o);
    } catch (t1) {
        throw new Error("Invalid Point");
    }
    return r.validate(), r;
};
$aab64c9131884b87$var$Point.prototype = Object.getPrototypeOf($aab64c9131884b87$var$ec.curve.point()), $aab64c9131884b87$var$Point.fromX = function(t, e) {
    try {
        var o = $aab64c9131884b87$var$ecPointFromX(e, t);
    } catch (t1) {
        throw new Error("Invalid X");
    }
    return o.validate(), o;
}, $aab64c9131884b87$var$Point.getG = function() {
    return $aab64c9131884b87$var$ec.curve.g;
}, $aab64c9131884b87$var$Point.getN = function() {
    return new $iDkJI($aab64c9131884b87$var$ec.curve.n.toArray());
}, $aab64c9131884b87$var$Point.prototype._getX || ($aab64c9131884b87$var$Point.prototype._getX = $aab64c9131884b87$var$Point.prototype.getX), $aab64c9131884b87$var$Point.prototype.getX = function() {
    return new $iDkJI(this._getX().toArray());
}, $aab64c9131884b87$var$Point.prototype._getY || ($aab64c9131884b87$var$Point.prototype._getY = $aab64c9131884b87$var$Point.prototype.getY), $aab64c9131884b87$var$Point.prototype.getY = function() {
    return new $iDkJI(this._getY().toArray());
}, $aab64c9131884b87$var$Point.prototype.validate = function() {
    if (this.isInfinity()) throw new Error("Point cannot be equal to Infinity");
    var t;
    try {
        t = $aab64c9131884b87$var$ecPointFromX(this.getX(), this.getY().isOdd());
    } catch (t1) {
        throw new Error("Point does not lie on the curve");
    }
    if (0 !== t.y.cmp(this.y)) throw new Error("Invalid y value for curve.");
    if (!this.mul($aab64c9131884b87$var$Point.getN()).isInfinity()) throw new Error("Point times N must be infinity");
    return this;
}, $aab64c9131884b87$var$Point.pointToCompressed = function(t) {
    var e, o = t.getX().toBuffer({
        size: 32
    }), r = t.getY().toBuffer({
        size: 32
    });
    return e = r[r.length - 1] % 2 ? $aab64c9131884b87$require$Buffer.from([
        3
    ]) : $aab64c9131884b87$require$Buffer.from([
        2
    ]), $aab64c9131884b87$require$Buffer.concat([
        e,
        o
    ]);
}, $aab64c9131884b87$var$Point.pointFromCompressed = function(t) {
    if (33 !== t.length) throw new Error("invalid buffer length");
    let e, o = t[0];
    if (3 === o) e = !0;
    else {
        if (2 !== o) throw new Error("invalid value of compressed prefix");
        e = !1;
    }
    let r = t.slice(1, 33), n = $iDkJI.fromBuffer(r);
    return $aab64c9131884b87$var$Point.fromX(e, n);
}, $aab64c9131884b87$var$Point.prototype.toBuffer = function() {
    return $aab64c9131884b87$var$Point.pointToCompressed(this);
}, $aab64c9131884b87$var$Point.prototype.toHex = function() {
    return this.toBuffer().toString("hex");
}, $aab64c9131884b87$var$Point.fromBuffer = function(t) {
    return $aab64c9131884b87$var$Point.pointFromCompressed(t);
}, $aab64c9131884b87$var$Point.fromHex = function(t) {
    return $aab64c9131884b87$var$Point.fromBuffer($aab64c9131884b87$require$Buffer.from(t, "hex"));
}, module.exports = $aab64c9131884b87$var$Point;

});
parcelRequire.register("7Zc1i", function(module, exports) {
"use strict";
var $5d078dcefd491088$var$elliptic = module.exports;

$5d078dcefd491088$var$elliptic.version = (parcelRequire("1VnFC")).version;

$5d078dcefd491088$var$elliptic.utils = (parcelRequire("jQJy0"));

$5d078dcefd491088$var$elliptic.rand = (parcelRequire("aXpSo"));

$5d078dcefd491088$var$elliptic.curve = (parcelRequire("eyNRW"));

$5d078dcefd491088$var$elliptic.curves = (parcelRequire("h9Ptd"));

// Protocols
$5d078dcefd491088$var$elliptic.ec = (parcelRequire("ic6Nr"));

$5d078dcefd491088$var$elliptic.eddsa = (parcelRequire("5ThYo"));

});
parcelRequire.register("1VnFC", function(module, exports) {
module.exports = JSON.parse('{"name":"elliptic","version":"6.5.4","description":"EC cryptography","main":"lib/elliptic.js","files":["lib"],"scripts":{"lint":"eslint lib test","lint:fix":"npm run lint -- --fix","unit":"istanbul test _mocha --reporter=spec test/index.js","test":"npm run lint && npm run unit","version":"grunt dist && git add dist/"},"repository":{"type":"git","url":"git@github.com:indutny/elliptic"},"keywords":["EC","Elliptic","curve","Cryptography"],"author":"Fedor Indutny <fedor@indutny.com>","license":"MIT","bugs":{"url":"https://github.com/indutny/elliptic/issues"},"homepage":"https://github.com/indutny/elliptic","devDependencies":{"brfs":"^2.0.2","coveralls":"^3.1.0","eslint":"^7.6.0","grunt":"^1.2.1","grunt-browserify":"^5.3.0","grunt-cli":"^1.3.2","grunt-contrib-connect":"^3.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^5.0.0","grunt-mocha-istanbul":"^5.0.2","grunt-saucelabs":"^9.0.1","istanbul":"^0.4.5","mocha":"^8.0.1"},"dependencies":{"bn.js":"^4.11.9","brorand":"^1.1.0","hash.js":"^1.0.0","hmac-drbg":"^1.0.1","inherits":"^2.0.4","minimalistic-assert":"^1.0.1","minimalistic-crypto-utils":"^1.0.1"}}');

});

parcelRequire.register("jQJy0", function(module, exports) {
"use strict";
var $e73634689248cbfe$var$utils = module.exports;

var $kcp1M = parcelRequire("kcp1M");

var $lBpFJ = parcelRequire("lBpFJ");

var $kXo4G = parcelRequire("kXo4G");
$e73634689248cbfe$var$utils.assert = $lBpFJ;
$e73634689248cbfe$var$utils.toArray = $kXo4G.toArray;
$e73634689248cbfe$var$utils.zero2 = $kXo4G.zero2;
$e73634689248cbfe$var$utils.toHex = $kXo4G.toHex;
$e73634689248cbfe$var$utils.encode = $kXo4G.encode;
// Represent num in a w-NAF form
function $e73634689248cbfe$var$getNAF(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w + 1;
    var k = num.clone();
    for(var i = 0; i < naf.length; i++){
        var z;
        var mod = k.andln(ws - 1);
        if (k.isOdd()) {
            if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;
            else z = mod;
            k.isubn(z);
        } else z = 0;
        naf[i] = z;
        k.iushrn(1);
    }
    return naf;
}
$e73634689248cbfe$var$utils.getNAF = $e73634689248cbfe$var$getNAF;
// Represent k1, k2 in a Joint Sparse Form
function $e73634689248cbfe$var$getJSF(k1, k2) {
    var jsf = [
        [],
        []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while(k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0){
        // First phase
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3) m14 = -1;
        if (m24 === 3) m24 = -1;
        var u1;
        if ((m14 & 1) === 0) u1 = 0;
        else {
            m8 = k1.andln(7) + d1 & 7;
            if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;
            else u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) u2 = 0;
        else {
            m8 = k2.andln(7) + d2 & 7;
            if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;
            else u2 = m24;
        }
        jsf[1].push(u2);
        // Second phase
        if (2 * d1 === u1 + 1) d1 = 1 - d1;
        if (2 * d2 === u2 + 1) d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
    }
    return jsf;
}
$e73634689248cbfe$var$utils.getJSF = $e73634689248cbfe$var$getJSF;
function $e73634689248cbfe$var$cachedProperty(obj, name, computer) {
    var key = "_" + name;
    obj.prototype[name] = function cachedProperty() {
        return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
    };
}
$e73634689248cbfe$var$utils.cachedProperty = $e73634689248cbfe$var$cachedProperty;
function $e73634689248cbfe$var$parseBytes(bytes) {
    return typeof bytes === "string" ? $e73634689248cbfe$var$utils.toArray(bytes, "hex") : bytes;
}
$e73634689248cbfe$var$utils.parseBytes = $e73634689248cbfe$var$parseBytes;
function $e73634689248cbfe$var$intFromLE(bytes) {
    return new $kcp1M(bytes, "hex", "le");
}
$e73634689248cbfe$var$utils.intFromLE = $e73634689248cbfe$var$intFromLE;

});
parcelRequire.register("lBpFJ", function(module, exports) {
module.exports = $fba0f79c9dca744c$var$assert;
function $fba0f79c9dca744c$var$assert(val, msg) {
    if (!val) throw new Error(msg || "Assertion failed");
}
$fba0f79c9dca744c$var$assert.equal = function assertEqual(l, r, msg) {
    if (l != r) throw new Error(msg || "Assertion failed: " + l + " != " + r);
};

});

parcelRequire.register("kXo4G", function(module, exports) {
"use strict";
var $f41bfe0ceb21632b$var$utils = module.exports;
function $f41bfe0ceb21632b$var$toArray(msg, enc) {
    if (Array.isArray(msg)) return msg.slice();
    if (!msg) return [];
    var res = [];
    if (typeof msg !== "string") {
        for(var i = 0; i < msg.length; i++)res[i] = msg[i] | 0;
        return res;
    }
    if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0) msg = "0" + msg;
        for(var i = 0; i < msg.length; i += 2)res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else for(var i = 0; i < msg.length; i++){
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi) res.push(hi, lo);
        else res.push(lo);
    }
    return res;
}
$f41bfe0ceb21632b$var$utils.toArray = $f41bfe0ceb21632b$var$toArray;
function $f41bfe0ceb21632b$var$zero2(word) {
    if (word.length === 1) return "0" + word;
    else return word;
}
$f41bfe0ceb21632b$var$utils.zero2 = $f41bfe0ceb21632b$var$zero2;
function $f41bfe0ceb21632b$var$toHex(msg) {
    var res = "";
    for(var i = 0; i < msg.length; i++)res += $f41bfe0ceb21632b$var$zero2(msg[i].toString(16));
    return res;
}
$f41bfe0ceb21632b$var$utils.toHex = $f41bfe0ceb21632b$var$toHex;
$f41bfe0ceb21632b$var$utils.encode = function encode(arr, enc) {
    if (enc === "hex") return $f41bfe0ceb21632b$var$toHex(arr);
    else return arr;
};

});


parcelRequire.register("aXpSo", function(module, exports) {
var $7fa37c920fcec3c4$var$r;
module.exports = function rand(len) {
    if (!$7fa37c920fcec3c4$var$r) $7fa37c920fcec3c4$var$r = new $7fa37c920fcec3c4$var$Rand(null);
    return $7fa37c920fcec3c4$var$r.generate(len);
};
function $7fa37c920fcec3c4$var$Rand(rand) {
    this.rand = rand;
}
module.exports.Rand = $7fa37c920fcec3c4$var$Rand;
$7fa37c920fcec3c4$var$Rand.prototype.generate = function generate(len) {
    return this._rand(len);
};
// Emulate crypto API using randy
$7fa37c920fcec3c4$var$Rand.prototype._rand = function _rand(n) {
    if (this.rand.getBytes) return this.rand.getBytes(n);
    var res = new Uint8Array(n);
    for(var i = 0; i < res.length; i++)res[i] = this.rand.getByte();
    return res;
};

if (typeof self === "object") {
    if (self.crypto && self.crypto.getRandomValues) // Modern browsers
    $7fa37c920fcec3c4$var$Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.crypto.getRandomValues(arr);
        return arr;
    };
    else if (self.msCrypto && self.msCrypto.getRandomValues) // IE
    $7fa37c920fcec3c4$var$Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.msCrypto.getRandomValues(arr);
        return arr;
    };
    else if (typeof window === "object") // Old junk
    $7fa37c920fcec3c4$var$Rand.prototype._rand = function() {
        throw new Error("Not implemented yet");
    };
} else // Node.js or Web worker with no crypto support
try {
    var $7fa37c920fcec3c4$var$crypto = (parcelRequire("cY7r0"));
    if (typeof $7fa37c920fcec3c4$var$crypto.randomBytes !== "function") throw new Error("Not supported");
    $7fa37c920fcec3c4$var$Rand.prototype._rand = function _rand(n) {
        return $7fa37c920fcec3c4$var$crypto.randomBytes(n);
    };
} catch (e) {}

});

parcelRequire.register("eyNRW", function(module, exports) {
"use strict";
var $a99aec9811bf81a7$var$curve = module.exports;

$a99aec9811bf81a7$var$curve.base = (parcelRequire("2MrQx"));

$a99aec9811bf81a7$var$curve.short = (parcelRequire("eghVf"));

$a99aec9811bf81a7$var$curve.mont = (parcelRequire("hzAeo"));

$a99aec9811bf81a7$var$curve.edwards = (parcelRequire("6udxL"));

});
parcelRequire.register("2MrQx", function(module, exports) {
"use strict";

var $kcp1M = parcelRequire("kcp1M");

var $jQJy0 = parcelRequire("jQJy0");
var $2065aa2a8f89a5aa$var$getNAF = $jQJy0.getNAF;
var $2065aa2a8f89a5aa$var$getJSF = $jQJy0.getJSF;
var $2065aa2a8f89a5aa$var$assert = $jQJy0.assert;
function $2065aa2a8f89a5aa$var$BaseCurve(type, conf) {
    this.type = type;
    this.p = new $kcp1M(conf.p, 16);
    // Use Montgomery, when there is no fast reduction for the prime
    this.red = conf.prime ? $kcp1M.red(conf.prime) : $kcp1M.mont(this.p);
    // Useful for many curves
    this.zero = new $kcp1M(0).toRed(this.red);
    this.one = new $kcp1M(1).toRed(this.red);
    this.two = new $kcp1M(2).toRed(this.red);
    // Curve configuration, optional
    this.n = conf.n && new $kcp1M(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    // Temporary arrays
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    // Generalized Greg Maxwell's trick
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) this.redN = null;
    else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
    }
}
module.exports = $2065aa2a8f89a5aa$var$BaseCurve;
$2065aa2a8f89a5aa$var$BaseCurve.prototype.point = function point() {
    throw new Error("Not implemented");
};
$2065aa2a8f89a5aa$var$BaseCurve.prototype.validate = function validate() {
    throw new Error("Not implemented");
};
$2065aa2a8f89a5aa$var$BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
    $2065aa2a8f89a5aa$var$assert(p.precomputed);
    var doubles = p._getDoubles();
    var naf = $2065aa2a8f89a5aa$var$getNAF(k, 1, this._bitLength);
    var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;
    // Translate into more windowed form
    var repr = [];
    var j;
    var nafW;
    for(j = 0; j < naf.length; j += doubles.step){
        nafW = 0;
        for(var l = j + doubles.step - 1; l >= j; l--)nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
    }
    var a = this.jpoint(null, null, null);
    var b = this.jpoint(null, null, null);
    for(var i = I; i > 0; i--){
        for(j = 0; j < repr.length; j++){
            nafW = repr[j];
            if (nafW === i) b = b.mixedAdd(doubles.points[j]);
            else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
    }
    return a.toP();
};
$2065aa2a8f89a5aa$var$BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
    var w = 4;
    // Precompute window
    var nafPoints = p._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;
    // Get NAF form
    var naf = $2065aa2a8f89a5aa$var$getNAF(k, w, this._bitLength);
    // Add `this`*(N+1) for every w-NAF index
    var acc = this.jpoint(null, null, null);
    for(var i = naf.length - 1; i >= 0; i--){
        // Count zeroes
        for(var l = 0; i >= 0 && naf[i] === 0; i--)l++;
        if (i >= 0) l++;
        acc = acc.dblp(l);
        if (i < 0) break;
        var z = naf[i];
        $2065aa2a8f89a5aa$var$assert(z !== 0);
        if (p.type === "affine") {
            // J +- P
            if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]);
            else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else // J +- J
        if (z > 0) acc = acc.add(wnd[z - 1 >> 1]);
        else acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
    return p.type === "affine" ? acc.toP() : acc;
};
$2065aa2a8f89a5aa$var$BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    // Fill all arrays
    var max = 0;
    var i;
    var j;
    var p;
    for(i = 0; i < len; i++){
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
    }
    // Comb small window NAFs
    for(i = len - 1; i >= 1; i -= 2){
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
            naf[a] = $2065aa2a8f89a5aa$var$getNAF(coeffs[a], wndWidth[a], this._bitLength);
            naf[b] = $2065aa2a8f89a5aa$var$getNAF(coeffs[b], wndWidth[b], this._bitLength);
            max = Math.max(naf[a].length, max);
            max = Math.max(naf[b].length, max);
            continue;
        }
        var comb = [
            points[a],
            /* 1 */ null,
            /* 3 */ null,
            /* 5 */ points[b]
        ];
        // Try to avoid Projective points, if possible
        if (points[a].y.cmp(points[b].y) === 0) {
            comb[1] = points[a].add(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].add(points[b].neg());
        } else {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index = [
            -3,
            /* -1 -1 */ -1,
            /* -1 0 */ -5,
            /* -1 1 */ -7,
            /* 0 -1 */ 0,
            /* 0 0 */ 7,
            /* 0 1 */ 5,
            /* 1 -1 */ 1,
            /* 1 0 */ 3
        ];
        var jsf = $2065aa2a8f89a5aa$var$getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for(j = 0; j < max; j++){
            var ja = jsf[0][j] | 0;
            var jb = jsf[1][j] | 0;
            naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
            naf[b][j] = 0;
            wnd[a] = comb;
        }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for(i = max; i >= 0; i--){
        var k = 0;
        while(i >= 0){
            var zero = true;
            for(j = 0; j < len; j++){
                tmp[j] = naf[j][i] | 0;
                if (tmp[j] !== 0) zero = false;
            }
            if (!zero) break;
            k++;
            i--;
        }
        if (i >= 0) k++;
        acc = acc.dblp(k);
        if (i < 0) break;
        for(j = 0; j < len; j++){
            var z = tmp[j];
            p;
            if (z === 0) continue;
            else if (z > 0) p = wnd[j][z - 1 >> 1];
            else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();
            if (p.type === "affine") acc = acc.mixedAdd(p);
            else acc = acc.add(p);
        }
    }
    // Zeroify references
    for(i = 0; i < len; i++)wnd[i] = null;
    if (jacobianResult) return acc;
    else return acc.toP();
};
function $2065aa2a8f89a5aa$var$BasePoint(curve, type) {
    this.curve = curve;
    this.type = type;
    this.precomputed = null;
}
$2065aa2a8f89a5aa$var$BaseCurve.BasePoint = $2065aa2a8f89a5aa$var$BasePoint;
$2065aa2a8f89a5aa$var$BasePoint.prototype.eq = function eq() {
    throw new Error("Not implemented");
};
$2065aa2a8f89a5aa$var$BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
};
$2065aa2a8f89a5aa$var$BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = $jQJy0.toArray(bytes, enc);
    var len = this.p.byteLength();
    // uncompressed, hybrid-odd, hybrid-even
    if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 0x06) $2065aa2a8f89a5aa$var$assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 0x07) $2065aa2a8f89a5aa$var$assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
        return res;
    } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) && bytes.length - 1 === len) return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
    throw new Error("Unknown point format");
};
$2065aa2a8f89a5aa$var$BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
};
$2065aa2a8f89a5aa$var$BasePoint.prototype._encode = function _encode(compact) {
    var len = this.curve.p.byteLength();
    var x = this.getX().toArray("be", len);
    if (compact) return [
        this.getY().isEven() ? 0x02 : 0x03
    ].concat(x);
    return [
        0x04
    ].concat(x, this.getY().toArray("be", len));
};
$2065aa2a8f89a5aa$var$BasePoint.prototype.encode = function encode(enc, compact) {
    return $jQJy0.encode(this._encode(compact), enc);
};
$2065aa2a8f89a5aa$var$BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed) return this;
    var precomputed = {
        doubles: null,
        naf: null,
        beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
};
$2065aa2a8f89a5aa$var$BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
    if (!this.precomputed) return false;
    var doubles = this.precomputed.doubles;
    if (!doubles) return false;
    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
$2065aa2a8f89a5aa$var$BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
    var doubles = [
        this
    ];
    var acc = this;
    for(var i = 0; i < power; i += step){
        for(var j = 0; j < step; j++)acc = acc.dbl();
        doubles.push(acc);
    }
    return {
        step: step,
        points: doubles
    };
};
$2065aa2a8f89a5aa$var$BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
    var res = [
        this
    ];
    var max = (1 << wnd) - 1;
    var dbl = max === 1 ? null : this.dbl();
    for(var i = 1; i < max; i++)res[i] = res[i - 1].add(dbl);
    return {
        wnd: wnd,
        points: res
    };
};
$2065aa2a8f89a5aa$var$BasePoint.prototype._getBeta = function _getBeta() {
    return null;
};
$2065aa2a8f89a5aa$var$BasePoint.prototype.dblp = function dblp(k) {
    var r = this;
    for(var i = 0; i < k; i++)r = r.dbl();
    return r;
};

});

parcelRequire.register("eghVf", function(module, exports) {
"use strict";

var $jQJy0 = parcelRequire("jQJy0");

var $kcp1M = parcelRequire("kcp1M");

var $hP1iE = parcelRequire("hP1iE");

var $2MrQx = parcelRequire("2MrQx");
var $a620765518fe488a$var$assert = $jQJy0.assert;
function $a620765518fe488a$var$ShortCurve(conf) {
    $2MrQx.call(this, "short", conf);
    this.a = new $kcp1M(conf.a, 16).toRed(this.red);
    this.b = new $kcp1M(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    // If the curve is endomorphic, precalculate beta and lambda
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
}
$hP1iE($a620765518fe488a$var$ShortCurve, $2MrQx);
module.exports = $a620765518fe488a$var$ShortCurve;
$a620765518fe488a$var$ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    // No efficient endomorphism
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;
    // Compute beta and lambda, that lambda * P = (beta * Px; Py)
    var beta;
    var lambda;
    if (conf.beta) beta = new $kcp1M(conf.beta, 16).toRed(this.red);
    else {
        var betas = this._getEndoRoots(this.p);
        // Choose the smallest beta
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
    }
    if (conf.lambda) lambda = new $kcp1M(conf.lambda, 16);
    else {
        // Choose the lambda that is matching selected beta
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) lambda = lambdas[0];
        else {
            lambda = lambdas[1];
            $a620765518fe488a$var$assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
    }
    // Get basis vectors, used for balanced length-two representation
    var basis;
    if (conf.basis) basis = conf.basis.map(function(vec) {
        return {
            a: new $kcp1M(vec.a, 16),
            b: new $kcp1M(vec.b, 16)
        };
    });
    else basis = this._getEndoBasis(lambda);
    return {
        beta: beta,
        lambda: lambda,
        basis: basis
    };
};
$a620765518fe488a$var$ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    // Find roots of for x^2 + x + 1 in F
    // Root = (-1 +- Sqrt(-3)) / 2
    //
    var red = num === this.p ? this.red : $kcp1M.mont(num);
    var tinv = new $kcp1M(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s = new $kcp1M(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s).fromRed();
    var l2 = ntinv.redSub(s).fromRed();
    return [
        l1,
        l2
    ];
};
$a620765518fe488a$var$ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    // aprxSqrt >= sqrt(this.n)
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    // 3.74
    // Run EGCD, until r(L + 1) < aprxSqrt
    var u = lambda;
    var v = this.n.clone();
    var x1 = new $kcp1M(1);
    var y1 = new $kcp1M(0);
    var x2 = new $kcp1M(0);
    var y2 = new $kcp1M(1);
    // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
    var a0;
    var b0;
    // First vector
    var a1;
    var b1;
    // Second vector
    var a2;
    var b2;
    var prevR;
    var i = 0;
    var r;
    var x;
    while(u.cmpn(0) !== 0){
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
            a0 = prevR.neg();
            b0 = x1;
            a1 = r.neg();
            b1 = x;
        } else if (a1 && ++i === 2) break;
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
    }
    a2 = r.neg();
    b2 = x;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
    }
    // Normalize signs
    if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
    }
    if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
    }
    return [
        {
            a: a1,
            b: b1
        },
        {
            a: a2,
            b: b2
        }
    ];
};
$a620765518fe488a$var$ShortCurve.prototype._endoSplit = function _endoSplit(k) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k).divRound(this.n);
    var c2 = v1.b.neg().mul(k).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
    // Calculate answer
    var k1 = k.sub(p1).sub(p2);
    var k2 = q1.add(q2).neg();
    return {
        k1: k1,
        k2: k2
    };
};
$a620765518fe488a$var$ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new $kcp1M(x, 16);
    if (!x.red) x = x.toRed(this.red);
    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error("invalid point");
    // XXX Is there any way to tell if the number is odd without converting it
    // to non-red form?
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
    return this.point(x, y);
};
$a620765518fe488a$var$ShortCurve.prototype.validate = function validate(point) {
    if (point.inf) return true;
    var x = point.x;
    var y = point.y;
    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
$a620765518fe488a$var$ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for(var i = 0; i < points.length; i++){
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split.k1.negative) {
            split.k1.ineg();
            p = p.neg(true);
        }
        if (split.k2.negative) {
            split.k2.ineg();
            beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
    // Clean-up references to points and coefficients
    for(var j = 0; j < i * 2; j++){
        npoints[j] = null;
        ncoeffs[j] = null;
    }
    return res;
};
function $a620765518fe488a$var$Point(curve, x, y, isRed) {
    $2MrQx.BasePoint.call(this, curve, "affine");
    if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
    } else {
        this.x = new $kcp1M(x, 16);
        this.y = new $kcp1M(y, 16);
        // Force redgomery representation when loading from JSON
        if (isRed) {
            this.x.forceRed(this.curve.red);
            this.y.forceRed(this.curve.red);
        }
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        this.inf = false;
    }
}
$hP1iE($a620765518fe488a$var$Point, $2MrQx.BasePoint);
$a620765518fe488a$var$ShortCurve.prototype.point = function point(x, y, isRed) {
    return new $a620765518fe488a$var$Point(this, x, y, isRed);
};
$a620765518fe488a$var$ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return $a620765518fe488a$var$Point.fromJSON(this, obj, red);
};
$a620765518fe488a$var$Point.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo) return;
    var pre = this.precomputed;
    if (pre && pre.beta) return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
            return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
            beta: null,
            naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: pre.naf.points.map(endoMul)
            },
            doubles: pre.doubles && {
                step: pre.doubles.step,
                points: pre.doubles.points.map(endoMul)
            }
        };
    }
    return beta;
};
$a620765518fe488a$var$Point.prototype.toJSON = function toJSON() {
    if (!this.precomputed) return [
        this.x,
        this.y
    ];
    return [
        this.x,
        this.y,
        this.precomputed && {
            doubles: this.precomputed.doubles && {
                step: this.precomputed.doubles.step,
                points: this.precomputed.doubles.points.slice(1)
            },
            naf: this.precomputed.naf && {
                wnd: this.precomputed.naf.wnd,
                points: this.precomputed.naf.points.slice(1)
            }
        }
    ];
};
$a620765518fe488a$var$Point.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === "string") obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2]) return res;
    function obj2point(obj) {
        return curve.point(obj[0], obj[1], red);
    }
    var pre = obj[2];
    res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
            step: pre.doubles.step,
            points: [
                res
            ].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: [
                res
            ].concat(pre.naf.points.map(obj2point))
        }
    };
    return res;
};
$a620765518fe488a$var$Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
$a620765518fe488a$var$Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
};
$a620765518fe488a$var$Point.prototype.add = function add(p) {
    // O + P = P
    if (this.inf) return p;
    // P + O = P
    if (p.inf) return this;
    // P + P = 2P
    if (this.eq(p)) return this.dbl();
    // P + (-P) = O
    if (this.neg().eq(p)) return this.curve.point(null, null);
    // P + Q = O
    if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
    var c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p.x);
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
};
$a620765518fe488a$var$Point.prototype.dbl = function dbl() {
    if (this.inf) return this;
    // 2P = O
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
    var a = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
};
$a620765518fe488a$var$Point.prototype.getX = function getX() {
    return this.x.fromRed();
};
$a620765518fe488a$var$Point.prototype.getY = function getY() {
    return this.y.fromRed();
};
$a620765518fe488a$var$Point.prototype.mul = function mul(k) {
    k = new $kcp1M(k, 16);
    if (this.isInfinity()) return this;
    else if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);
    else if (this.curve.endo) return this.curve._endoWnafMulAdd([
        this
    ], [
        k
    ]);
    else return this.curve._wnafMul(this, k);
};
$a620765518fe488a$var$Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [
        this,
        p2
    ];
    var coeffs = [
        k1,
        k2
    ];
    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs);
    else return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
$a620765518fe488a$var$Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    var points = [
        this,
        p2
    ];
    var coeffs = [
        k1,
        k2
    ];
    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true);
    else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
$a620765518fe488a$var$Point.prototype.eq = function eq(p) {
    return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};
$a620765518fe488a$var$Point.prototype.neg = function neg(_precompute) {
    if (this.inf) return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
            return p.neg();
        };
        res.precomputed = {
            naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: pre.naf.points.map(negate)
            },
            doubles: pre.doubles && {
                step: pre.doubles.step,
                points: pre.doubles.points.map(negate)
            }
        };
    }
    return res;
};
$a620765518fe488a$var$Point.prototype.toJ = function toJ() {
    if (this.inf) return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
};
function $a620765518fe488a$var$JPoint(curve, x, y, z) {
    $2MrQx.BasePoint.call(this, curve, "jacobian");
    if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new $kcp1M(0);
    } else {
        this.x = new $kcp1M(x, 16);
        this.y = new $kcp1M(y, 16);
        this.z = new $kcp1M(z, 16);
    }
    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
}
$hP1iE($a620765518fe488a$var$JPoint, $2MrQx.BasePoint);
$a620765518fe488a$var$ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
    return new $a620765518fe488a$var$JPoint(this, x, y, z);
};
$a620765518fe488a$var$JPoint.prototype.toP = function toP() {
    if (this.isInfinity()) return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
};
$a620765518fe488a$var$JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
$a620765518fe488a$var$JPoint.prototype.add = function add(p) {
    // O + P = P
    if (this.isInfinity()) return p;
    // P + O = P
    if (p.isInfinity()) return this;
    // 12M + 4S + 7A
    var pz2 = p.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p.z));
    var s2 = p.y.redMul(z2.redMul(this.z));
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
        else return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p.z).redMul(h);
    return this.curve.jpoint(nx, ny, nz);
};
$a620765518fe488a$var$JPoint.prototype.mixedAdd = function mixedAdd(p) {
    // O + P = P
    if (this.isInfinity()) return p.toJ();
    // P + O = P
    if (p.isInfinity()) return this;
    // 8M + 3S + 7A
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p.x.redMul(z2);
    var s1 = this.y;
    var s2 = p.y.redMul(z2).redMul(this.z);
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
        else return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h);
    return this.curve.jpoint(nx, ny, nz);
};
$a620765518fe488a$var$JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0) return this;
    if (this.isInfinity()) return this;
    if (!pow) return this.dbl();
    var i;
    if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for(i = 0; i < pow; i++)r = r.dbl();
        return r;
    }
    // 1M + 2S + 1A + N * (4S + 5M + 8A)
    // N = 1 => 6M + 6S + 9A
    var a = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    // Reuse results
    var jyd = jy.redAdd(jy);
    for(i = 0; i < pow; i++){
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
$a620765518fe488a$var$JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity()) return this;
    if (this.curve.zeroA) return this._zeroDbl();
    else if (this.curve.threeA) return this._threeDbl();
    else return this._dbl();
};
$a620765518fe488a$var$JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    // Z = 1
    if (this.zOne) {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
        //     #doubling-mdbl-2007-bl
        // 1M + 5S + 14A
        // XX = X1^2
        var xx = this.x.redSqr();
        // YY = Y1^2
        var yy = this.y.redSqr();
        // YYYY = YY^2
        var yyyy = yy.redSqr();
        // S = 2 * ((X1 + YY)^2 - XX - YYYY)
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        // M = 3 * XX + a; a = 0
        var m = xx.redAdd(xx).redIAdd(xx);
        // T = M ^ 2 - 2*S
        var t = m.redSqr().redISub(s).redISub(s);
        // 8 * YYYY
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        // X3 = T
        nx = t;
        // Y3 = M * (S - T) - 8 * YYYY
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        // Z3 = 2*Y1
        nz = this.y.redAdd(this.y);
    } else {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
        //     #doubling-dbl-2009-l
        // 2M + 5S + 13A
        // A = X1^2
        var a = this.x.redSqr();
        // B = Y1^2
        var b = this.y.redSqr();
        // C = B^2
        var c = b.redSqr();
        // D = 2 * ((X1 + B)^2 - A - C)
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        // E = 3 * A
        var e = a.redAdd(a).redIAdd(a);
        // F = E^2
        var f = e.redSqr();
        // 8 * C
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        // X3 = F - 2 * D
        nx = f.redISub(d).redISub(d);
        // Y3 = E * (D - X3) - 8 * C
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        // Z3 = 2 * Y1 * Z1
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
};
$a620765518fe488a$var$JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    // Z = 1
    if (this.zOne) {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
        //     #doubling-mdbl-2007-bl
        // 1M + 5S + 15A
        // XX = X1^2
        var xx = this.x.redSqr();
        // YY = Y1^2
        var yy = this.y.redSqr();
        // YYYY = YY^2
        var yyyy = yy.redSqr();
        // S = 2 * ((X1 + YY)^2 - XX - YYYY)
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        // M = 3 * XX + a
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        // T = M^2 - 2 * S
        var t = m.redSqr().redISub(s).redISub(s);
        // X3 = T
        nx = t;
        // Y3 = M * (S - T) - 8 * YYYY
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        // Z3 = 2 * Y1
        nz = this.y.redAdd(this.y);
    } else {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
        // 3M + 5S
        // delta = Z1^2
        var delta = this.z.redSqr();
        // gamma = Y1^2
        var gamma = this.y.redSqr();
        // beta = X1 * gamma
        var beta = this.x.redMul(gamma);
        // alpha = 3 * (X1 - delta) * (X1 + delta)
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        // X3 = alpha^2 - 8 * beta
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        // Z3 = (Y1 + Z1)^2 - gamma - delta
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
};
$a620765518fe488a$var$JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a;
    // 4M + 6S + 10A
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
};
$a620765518fe488a$var$JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA) return this.dbl().add(this);
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
    // 5M + 10S + ...
    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // ZZ = Z1^2
    var zz = this.z.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // M = 3 * XX + a * ZZ2; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // MM = M^2
    var mm = m.redSqr();
    // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);
    // EE = E^2
    var ee = e.redSqr();
    // T = 16*YYYY
    var t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    // U = (M + E)^2 - MM - EE - T
    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
    // X3 = 4 * (X1 * EE - 4 * YY * U)
    var yyu4 = yy.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    // Z3 = (Z1 + E)^2 - ZZ - EE
    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
    return this.curve.jpoint(nx, ny, nz);
};
$a620765518fe488a$var$JPoint.prototype.mul = function mul(k, kbase) {
    k = new $kcp1M(k, kbase);
    return this.curve._wnafMul(this, k);
};
$a620765518fe488a$var$JPoint.prototype.eq = function eq(p) {
    if (p.type === "affine") return this.eq(p.toJ());
    if (this === p) return true;
    // x1 * z2^2 == x2 * z1^2
    var z2 = this.z.redSqr();
    var pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false;
    // y1 * z2^3 == y2 * z1^3
    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};
$a620765518fe488a$var$JPoint.prototype.eqXToP = function eqXToP(x) {
    var zs = this.z.redSqr();
    var rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0) return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(zs);
    for(;;){
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0) return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0) return true;
    }
};
$a620765518fe488a$var$JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC JPoint Infinity>";
    return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
$a620765518fe488a$var$JPoint.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.z.cmpn(0) === 0;
};

});
parcelRequire.register("hP1iE", function(module, exports) {
if (typeof Object.create === "function") // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

});


parcelRequire.register("hzAeo", function(module, exports) {
"use strict";

var $kcp1M = parcelRequire("kcp1M");

var $hP1iE = parcelRequire("hP1iE");

var $2MrQx = parcelRequire("2MrQx");

var $jQJy0 = parcelRequire("jQJy0");
function $ccb1cf4a1e31bf5e$var$MontCurve(conf) {
    $2MrQx.call(this, "mont", conf);
    this.a = new $kcp1M(conf.a, 16).toRed(this.red);
    this.b = new $kcp1M(conf.b, 16).toRed(this.red);
    this.i4 = new $kcp1M(4).toRed(this.red).redInvm();
    this.two = new $kcp1M(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
$hP1iE($ccb1cf4a1e31bf5e$var$MontCurve, $2MrQx);
module.exports = $ccb1cf4a1e31bf5e$var$MontCurve;
$ccb1cf4a1e31bf5e$var$MontCurve.prototype.validate = function validate(point) {
    var x = point.normalize().x;
    var x2 = x.redSqr();
    var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
    var y = rhs.redSqrt();
    return y.redSqr().cmp(rhs) === 0;
};
function $ccb1cf4a1e31bf5e$var$Point(curve, x, z) {
    $2MrQx.BasePoint.call(this, curve, "projective");
    if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
    } else {
        this.x = new $kcp1M(x, 16);
        this.z = new $kcp1M(z, 16);
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    }
}
$hP1iE($ccb1cf4a1e31bf5e$var$Point, $2MrQx.BasePoint);
$ccb1cf4a1e31bf5e$var$MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    return this.point($jQJy0.toArray(bytes, enc), 1);
};
$ccb1cf4a1e31bf5e$var$MontCurve.prototype.point = function point(x, z) {
    return new $ccb1cf4a1e31bf5e$var$Point(this, x, z);
};
$ccb1cf4a1e31bf5e$var$MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return $ccb1cf4a1e31bf5e$var$Point.fromJSON(this, obj);
};
$ccb1cf4a1e31bf5e$var$Point.prototype.precompute = function precompute() {
// No-op
};
$ccb1cf4a1e31bf5e$var$Point.prototype._encode = function _encode() {
    return this.getX().toArray("be", this.curve.p.byteLength());
};
$ccb1cf4a1e31bf5e$var$Point.fromJSON = function fromJSON(curve, obj) {
    return new $ccb1cf4a1e31bf5e$var$Point(curve, obj[0], obj[1] || curve.one);
};
$ccb1cf4a1e31bf5e$var$Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
$ccb1cf4a1e31bf5e$var$Point.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.z.cmpn(0) === 0;
};
$ccb1cf4a1e31bf5e$var$Point.prototype.dbl = function dbl() {
    // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
    // 2M + 2S + 4A
    // A = X1 + Z1
    var a = this.x.redAdd(this.z);
    // AA = A^2
    var aa = a.redSqr();
    // B = X1 - Z1
    var b = this.x.redSub(this.z);
    // BB = B^2
    var bb = b.redSqr();
    // C = AA - BB
    var c = aa.redSub(bb);
    // X3 = AA * BB
    var nx = aa.redMul(bb);
    // Z3 = C * (BB + A24 * C)
    var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
    return this.curve.point(nx, nz);
};
$ccb1cf4a1e31bf5e$var$Point.prototype.add = function add() {
    throw new Error("Not supported on Montgomery curve");
};
$ccb1cf4a1e31bf5e$var$Point.prototype.diffAdd = function diffAdd(p, diff) {
    // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
    // 4M + 2S + 6A
    // A = X2 + Z2
    var a = this.x.redAdd(this.z);
    // B = X2 - Z2
    var b = this.x.redSub(this.z);
    // C = X3 + Z3
    var c = p.x.redAdd(p.z);
    // D = X3 - Z3
    var d = p.x.redSub(p.z);
    // DA = D * A
    var da = d.redMul(a);
    // CB = C * B
    var cb = c.redMul(b);
    // X5 = Z1 * (DA + CB)^2
    var nx = diff.z.redMul(da.redAdd(cb).redSqr());
    // Z5 = X1 * (DA - CB)^2
    var nz = diff.x.redMul(da.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
};
$ccb1cf4a1e31bf5e$var$Point.prototype.mul = function mul(k) {
    var t = k.clone();
    var a = this; // (N / 2) * Q + Q
    var b = this.curve.point(null, null); // (N / 2) * Q
    var c = this; // Q
    for(var bits = []; t.cmpn(0) !== 0; t.iushrn(1))bits.push(t.andln(1));
    for(var i = bits.length - 1; i >= 0; i--)if (bits[i] === 0) {
        // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
        a = a.diffAdd(b, c);
        // N * Q = 2 * ((N / 2) * Q + Q))
        b = b.dbl();
    } else {
        // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
        b = a.diffAdd(b, c);
        // N * Q + Q = 2 * ((N / 2) * Q + Q)
        a = a.dbl();
    }
    return b;
};
$ccb1cf4a1e31bf5e$var$Point.prototype.mulAdd = function mulAdd() {
    throw new Error("Not supported on Montgomery curve");
};
$ccb1cf4a1e31bf5e$var$Point.prototype.jumlAdd = function jumlAdd() {
    throw new Error("Not supported on Montgomery curve");
};
$ccb1cf4a1e31bf5e$var$Point.prototype.eq = function eq(other) {
    return this.getX().cmp(other.getX()) === 0;
};
$ccb1cf4a1e31bf5e$var$Point.prototype.normalize = function normalize() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
};
$ccb1cf4a1e31bf5e$var$Point.prototype.getX = function getX() {
    // Normalize coordinates
    this.normalize();
    return this.x.fromRed();
};

});

parcelRequire.register("6udxL", function(module, exports) {
"use strict";

var $jQJy0 = parcelRequire("jQJy0");

var $kcp1M = parcelRequire("kcp1M");

var $hP1iE = parcelRequire("hP1iE");

var $2MrQx = parcelRequire("2MrQx");
var $4b900ce77e431c3e$var$assert = $jQJy0.assert;
function $4b900ce77e431c3e$var$EdwardsCurve(conf) {
    // NOTE: Important as we are creating point in Base.call()
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
    $2MrQx.call(this, "edwards", conf);
    this.a = new $kcp1M(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new $kcp1M(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new $kcp1M(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    $4b900ce77e431c3e$var$assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
}
$hP1iE($4b900ce77e431c3e$var$EdwardsCurve, $2MrQx);
module.exports = $4b900ce77e431c3e$var$EdwardsCurve;
$4b900ce77e431c3e$var$EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA) return num.redNeg();
    else return this.a.redMul(num);
};
$4b900ce77e431c3e$var$EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC) return num;
    else return this.c.redMul(num);
};
// Just for compatibility with Short curve
$4b900ce77e431c3e$var$EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
    return this.point(x, y, z, t);
};
$4b900ce77e431c3e$var$EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new $kcp1M(x, 16);
    if (!x.red) x = x.toRed(this.red);
    var x2 = x.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x2));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
    var y2 = rhs.redMul(lhs.redInvm());
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error("invalid point");
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
    return this.point(x, y);
};
$4b900ce77e431c3e$var$EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
    y = new $kcp1M(y, 16);
    if (!y.red) y = y.toRed(this.red);
    // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
    var y2 = y.redSqr();
    var lhs = y2.redSub(this.c2);
    var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
    var x2 = lhs.redMul(rhs.redInvm());
    if (x2.cmp(this.zero) === 0) {
        if (odd) throw new Error("invalid point");
        else return this.point(this.zero, y);
    }
    var x = x2.redSqrt();
    if (x.redSqr().redSub(x2).cmp(this.zero) !== 0) throw new Error("invalid point");
    if (x.fromRed().isOdd() !== odd) x = x.redNeg();
    return this.point(x, y);
};
$4b900ce77e431c3e$var$EdwardsCurve.prototype.validate = function validate(point) {
    if (point.isInfinity()) return true;
    // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
    point.normalize();
    var x2 = point.x.redSqr();
    var y2 = point.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y2);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
    return lhs.cmp(rhs) === 0;
};
function $4b900ce77e431c3e$var$Point(curve, x, y, z, t) {
    $2MrQx.BasePoint.call(this, curve, "projective");
    if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
    } else {
        this.x = new $kcp1M(x, 16);
        this.y = new $kcp1M(y, 16);
        this.z = z ? new $kcp1M(z, 16) : this.curve.one;
        this.t = t && new $kcp1M(t, 16);
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        // Use extended coordinates
        if (this.curve.extended && !this.t) {
            this.t = this.x.redMul(this.y);
            if (!this.zOne) this.t = this.t.redMul(this.z.redInvm());
        }
    }
}
$hP1iE($4b900ce77e431c3e$var$Point, $2MrQx.BasePoint);
$4b900ce77e431c3e$var$EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return $4b900ce77e431c3e$var$Point.fromJSON(this, obj);
};
$4b900ce77e431c3e$var$EdwardsCurve.prototype.point = function point(x, y, z, t) {
    return new $4b900ce77e431c3e$var$Point(this, x, y, z, t);
};
$4b900ce77e431c3e$var$Point.fromJSON = function fromJSON(curve, obj) {
    return new $4b900ce77e431c3e$var$Point(curve, obj[0], obj[1], obj[2]);
};
$4b900ce77e431c3e$var$Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
$4b900ce77e431c3e$var$Point.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
$4b900ce77e431c3e$var$Point.prototype._extDbl = function _extDbl() {
    // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     #doubling-dbl-2008-hwcd
    // 4M + 4S
    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = 2 * Z1^2
    var c = this.z.redSqr();
    c = c.redIAdd(c);
    // D = a * A
    var d = this.curve._mulA(a);
    // E = (X1 + Y1)^2 - A - B
    var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
    // G = D + B
    var g = d.redAdd(b);
    // F = G - C
    var f = g.redSub(c);
    // H = D - B
    var h = d.redSub(b);
    // X3 = E * F
    var nx = e.redMul(f);
    // Y3 = G * H
    var ny = g.redMul(h);
    // T3 = E * H
    var nt = e.redMul(h);
    // Z3 = F * G
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
};
$4b900ce77e431c3e$var$Point.prototype._projDbl = function _projDbl() {
    // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     #doubling-dbl-2008-bbjlp
    //     #doubling-dbl-2007-bl
    // and others
    // Generally 3M + 4S or 2M + 4S
    // B = (X1 + Y1)^2
    var b = this.x.redAdd(this.y).redSqr();
    // C = X1^2
    var c = this.x.redSqr();
    // D = Y1^2
    var d = this.y.redSqr();
    var nx;
    var ny;
    var nz;
    var e;
    var h;
    var j;
    if (this.curve.twisted) {
        // E = a * C
        e = this.curve._mulA(c);
        // F = E + D
        var f = e.redAdd(d);
        if (this.zOne) {
            // X3 = (B - C - D) * (F - 2)
            nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
            // Y3 = F * (E - D)
            ny = f.redMul(e.redSub(d));
            // Z3 = F^2 - 2 * F
            nz = f.redSqr().redSub(f).redSub(f);
        } else {
            // H = Z1^2
            h = this.z.redSqr();
            // J = F - 2 * H
            j = f.redSub(h).redISub(h);
            // X3 = (B-C-D)*J
            nx = b.redSub(c).redISub(d).redMul(j);
            // Y3 = F * (E - D)
            ny = f.redMul(e.redSub(d));
            // Z3 = F * J
            nz = f.redMul(j);
        }
    } else {
        // E = C + D
        e = c.redAdd(d);
        // H = (c * Z1)^2
        h = this.curve._mulC(this.z).redSqr();
        // J = E - 2 * H
        j = e.redSub(h).redSub(h);
        // X3 = c * (B - E) * J
        nx = this.curve._mulC(b.redISub(e)).redMul(j);
        // Y3 = c * E * (C - D)
        ny = this.curve._mulC(e).redMul(c.redISub(d));
        // Z3 = E * J
        nz = e.redMul(j);
    }
    return this.curve.point(nx, ny, nz);
};
$4b900ce77e431c3e$var$Point.prototype.dbl = function dbl() {
    if (this.isInfinity()) return this;
    // Double in extended coordinates
    if (this.curve.extended) return this._extDbl();
    else return this._projDbl();
};
$4b900ce77e431c3e$var$Point.prototype._extAdd = function _extAdd(p) {
    // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     #addition-add-2008-hwcd-3
    // 8M
    // A = (Y1 - X1) * (Y2 - X2)
    var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
    // B = (Y1 + X1) * (Y2 + X2)
    var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
    // C = T1 * k * T2
    var c = this.t.redMul(this.curve.dd).redMul(p.t);
    // D = Z1 * 2 * Z2
    var d = this.z.redMul(p.z.redAdd(p.z));
    // E = B - A
    var e = b.redSub(a);
    // F = D - C
    var f = d.redSub(c);
    // G = D + C
    var g = d.redAdd(c);
    // H = B + A
    var h = b.redAdd(a);
    // X3 = E * F
    var nx = e.redMul(f);
    // Y3 = G * H
    var ny = g.redMul(h);
    // T3 = E * H
    var nt = e.redMul(h);
    // Z3 = F * G
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
};
$4b900ce77e431c3e$var$Point.prototype._projAdd = function _projAdd(p) {
    // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     #addition-add-2008-bbjlp
    //     #addition-add-2007-bl
    // 10M + 1S
    // A = Z1 * Z2
    var a = this.z.redMul(p.z);
    // B = A^2
    var b = a.redSqr();
    // C = X1 * X2
    var c = this.x.redMul(p.x);
    // D = Y1 * Y2
    var d = this.y.redMul(p.y);
    // E = d * C * D
    var e = this.curve.d.redMul(c).redMul(d);
    // F = B - E
    var f = b.redSub(e);
    // G = B + E
    var g = b.redAdd(e);
    // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
    var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
    var nx = a.redMul(f).redMul(tmp);
    var ny;
    var nz;
    if (this.curve.twisted) {
        // Y3 = A * G * (D - a * C)
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        // Z3 = F * G
        nz = f.redMul(g);
    } else {
        // Y3 = A * G * (D - C)
        ny = a.redMul(g).redMul(d.redSub(c));
        // Z3 = c * F * G
        nz = this.curve._mulC(f).redMul(g);
    }
    return this.curve.point(nx, ny, nz);
};
$4b900ce77e431c3e$var$Point.prototype.add = function add(p) {
    if (this.isInfinity()) return p;
    if (p.isInfinity()) return this;
    if (this.curve.extended) return this._extAdd(p);
    else return this._projAdd(p);
};
$4b900ce77e431c3e$var$Point.prototype.mul = function mul(k) {
    if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);
    else return this.curve._wnafMul(this, k);
};
$4b900ce77e431c3e$var$Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [
        this,
        p
    ], [
        k1,
        k2
    ], 2, false);
};
$4b900ce77e431c3e$var$Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [
        this,
        p
    ], [
        k1,
        k2
    ], 2, true);
};
$4b900ce77e431c3e$var$Point.prototype.normalize = function normalize() {
    if (this.zOne) return this;
    // Normalize coordinates
    var zi = this.z.redInvm();
    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);
    if (this.t) this.t = this.t.redMul(zi);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
};
$4b900ce77e431c3e$var$Point.prototype.neg = function neg() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
};
$4b900ce77e431c3e$var$Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
};
$4b900ce77e431c3e$var$Point.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
};
$4b900ce77e431c3e$var$Point.prototype.eq = function eq(other) {
    return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
};
$4b900ce77e431c3e$var$Point.prototype.eqXToP = function eqXToP(x) {
    var rx = x.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0) return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(this.z);
    for(;;){
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0) return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0) return true;
    }
};
// Compatibility with BaseCurve
$4b900ce77e431c3e$var$Point.prototype.toP = $4b900ce77e431c3e$var$Point.prototype.normalize;
$4b900ce77e431c3e$var$Point.prototype.mixedAdd = $4b900ce77e431c3e$var$Point.prototype.add;

});


parcelRequire.register("h9Ptd", function(module, exports) {
"use strict";
var $c7db33d9fc04dba6$var$curves = module.exports;

var $gnkvn = parcelRequire("gnkvn");

var $eyNRW = parcelRequire("eyNRW");

var $jQJy0 = parcelRequire("jQJy0");
var $c7db33d9fc04dba6$var$assert = $jQJy0.assert;
function $c7db33d9fc04dba6$var$PresetCurve(options) {
    if (options.type === "short") this.curve = new $eyNRW.short(options);
    else if (options.type === "edwards") this.curve = new $eyNRW.edwards(options);
    else this.curve = new $eyNRW.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    $c7db33d9fc04dba6$var$assert(this.g.validate(), "Invalid curve");
    $c7db33d9fc04dba6$var$assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
}
$c7db33d9fc04dba6$var$curves.PresetCurve = $c7db33d9fc04dba6$var$PresetCurve;
function $c7db33d9fc04dba6$var$defineCurve(name, options) {
    Object.defineProperty($c7db33d9fc04dba6$var$curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
            var curve = new $c7db33d9fc04dba6$var$PresetCurve(options);
            Object.defineProperty($c7db33d9fc04dba6$var$curves, name, {
                configurable: true,
                enumerable: true,
                value: curve
            });
            return curve;
        }
    });
}
$c7db33d9fc04dba6$var$defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: $gnkvn.sha256,
    gRed: false,
    g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
});
$c7db33d9fc04dba6$var$defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: $gnkvn.sha256,
    gRed: false,
    g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
});
$c7db33d9fc04dba6$var$defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: $gnkvn.sha256,
    gRed: false,
    g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
});
$c7db33d9fc04dba6$var$defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: $gnkvn.sha384,
    gRed: false,
    g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
});
$c7db33d9fc04dba6$var$defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: $gnkvn.sha512,
    gRed: false,
    g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
});
$c7db33d9fc04dba6$var$defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: $gnkvn.sha256,
    gRed: false,
    g: [
        "9"
    ]
});
$c7db33d9fc04dba6$var$defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: $gnkvn.sha256,
    gRed: false,
    g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
    ]
});
var $c7db33d9fc04dba6$var$pre;

try {
    $c7db33d9fc04dba6$var$pre = (parcelRequire("6GYzO"));
} catch (e) {
    $c7db33d9fc04dba6$var$pre = undefined;
}
$c7db33d9fc04dba6$var$defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: $gnkvn.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
        {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
        }
    ],
    gRed: false,
    g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        $c7db33d9fc04dba6$var$pre
    ]
});

});
parcelRequire.register("gnkvn", function(module, exports) {
var $bebeb3363609e542$var$hash = module.exports;

$bebeb3363609e542$var$hash.utils = (parcelRequire("f6hkv"));

$bebeb3363609e542$var$hash.common = (parcelRequire("ifopx"));

$bebeb3363609e542$var$hash.sha = (parcelRequire("ijnj3"));

$bebeb3363609e542$var$hash.ripemd = (parcelRequire("fA9Jz"));

$bebeb3363609e542$var$hash.hmac = (parcelRequire("lHUXq"));
// Proxy hash functions to the main object
$bebeb3363609e542$var$hash.sha1 = $bebeb3363609e542$var$hash.sha.sha1;
$bebeb3363609e542$var$hash.sha256 = $bebeb3363609e542$var$hash.sha.sha256;
$bebeb3363609e542$var$hash.sha224 = $bebeb3363609e542$var$hash.sha.sha224;
$bebeb3363609e542$var$hash.sha384 = $bebeb3363609e542$var$hash.sha.sha384;
$bebeb3363609e542$var$hash.sha512 = $bebeb3363609e542$var$hash.sha.sha512;
$bebeb3363609e542$var$hash.ripemd160 = $bebeb3363609e542$var$hash.ripemd.ripemd160;

});
parcelRequire.register("f6hkv", function(module, exports) {

$parcel$export(module.exports, "inherits", () => $afe4dbdbdac4d054$export$69f1b2dcda23c5f8, (v) => $afe4dbdbdac4d054$export$69f1b2dcda23c5f8 = v);
$parcel$export(module.exports, "toArray", () => $afe4dbdbdac4d054$export$45b10814cc054894, (v) => $afe4dbdbdac4d054$export$45b10814cc054894 = v);
$parcel$export(module.exports, "toHex", () => $afe4dbdbdac4d054$export$7ea66e3774a60b67, (v) => $afe4dbdbdac4d054$export$7ea66e3774a60b67 = v);
$parcel$export(module.exports, "htonl", () => $afe4dbdbdac4d054$export$34a52f00f601f6f1, (v) => $afe4dbdbdac4d054$export$34a52f00f601f6f1 = v);
$parcel$export(module.exports, "toHex32", () => $afe4dbdbdac4d054$export$812b0cbd5e8a72ab, (v) => $afe4dbdbdac4d054$export$812b0cbd5e8a72ab = v);
$parcel$export(module.exports, "zero2", () => $afe4dbdbdac4d054$export$f24f9e11d63bb314, (v) => $afe4dbdbdac4d054$export$f24f9e11d63bb314 = v);
$parcel$export(module.exports, "zero8", () => $afe4dbdbdac4d054$export$b71357c7e07ca1f1, (v) => $afe4dbdbdac4d054$export$b71357c7e07ca1f1 = v);
$parcel$export(module.exports, "join32", () => $afe4dbdbdac4d054$export$2e58a4b541fdcbe8, (v) => $afe4dbdbdac4d054$export$2e58a4b541fdcbe8 = v);
$parcel$export(module.exports, "split32", () => $afe4dbdbdac4d054$export$183b950bde9faab8, (v) => $afe4dbdbdac4d054$export$183b950bde9faab8 = v);
$parcel$export(module.exports, "rotr32", () => $afe4dbdbdac4d054$export$4785c77169fea59e, (v) => $afe4dbdbdac4d054$export$4785c77169fea59e = v);
$parcel$export(module.exports, "rotl32", () => $afe4dbdbdac4d054$export$242a185dfcffac5b, (v) => $afe4dbdbdac4d054$export$242a185dfcffac5b = v);
$parcel$export(module.exports, "sum32", () => $afe4dbdbdac4d054$export$58c04ae0ae31877d, (v) => $afe4dbdbdac4d054$export$58c04ae0ae31877d = v);
$parcel$export(module.exports, "sum32_3", () => $afe4dbdbdac4d054$export$d058ca695f8c6f11, (v) => $afe4dbdbdac4d054$export$d058ca695f8c6f11 = v);
$parcel$export(module.exports, "sum32_4", () => $afe4dbdbdac4d054$export$a1efd7fc3e986367, (v) => $afe4dbdbdac4d054$export$a1efd7fc3e986367 = v);
$parcel$export(module.exports, "sum32_5", () => $afe4dbdbdac4d054$export$bbfea4a2b5abaab4, (v) => $afe4dbdbdac4d054$export$bbfea4a2b5abaab4 = v);
$parcel$export(module.exports, "sum64", () => $afe4dbdbdac4d054$export$97ad4afc7de86152, (v) => $afe4dbdbdac4d054$export$97ad4afc7de86152 = v);
$parcel$export(module.exports, "sum64_hi", () => $afe4dbdbdac4d054$export$ce4673d9a79f6a4b, (v) => $afe4dbdbdac4d054$export$ce4673d9a79f6a4b = v);
$parcel$export(module.exports, "sum64_lo", () => $afe4dbdbdac4d054$export$786cc99fc6eedc0b, (v) => $afe4dbdbdac4d054$export$786cc99fc6eedc0b = v);
$parcel$export(module.exports, "sum64_4_hi", () => $afe4dbdbdac4d054$export$45c59b9a1848dd0, (v) => $afe4dbdbdac4d054$export$45c59b9a1848dd0 = v);
$parcel$export(module.exports, "sum64_4_lo", () => $afe4dbdbdac4d054$export$50d8f613e76d3034, (v) => $afe4dbdbdac4d054$export$50d8f613e76d3034 = v);
$parcel$export(module.exports, "sum64_5_hi", () => $afe4dbdbdac4d054$export$b8e83683c60ee162, (v) => $afe4dbdbdac4d054$export$b8e83683c60ee162 = v);
$parcel$export(module.exports, "sum64_5_lo", () => $afe4dbdbdac4d054$export$aeeb51790d1bcc4a, (v) => $afe4dbdbdac4d054$export$aeeb51790d1bcc4a = v);
$parcel$export(module.exports, "rotr64_hi", () => $afe4dbdbdac4d054$export$bb7c616f719ad9c, (v) => $afe4dbdbdac4d054$export$bb7c616f719ad9c = v);
$parcel$export(module.exports, "rotr64_lo", () => $afe4dbdbdac4d054$export$4d63290824f9d7df, (v) => $afe4dbdbdac4d054$export$4d63290824f9d7df = v);
$parcel$export(module.exports, "shr64_hi", () => $afe4dbdbdac4d054$export$2f64ceb90ef28ea1, (v) => $afe4dbdbdac4d054$export$2f64ceb90ef28ea1 = v);
$parcel$export(module.exports, "shr64_lo", () => $afe4dbdbdac4d054$export$8d2089d465f6d10d, (v) => $afe4dbdbdac4d054$export$8d2089d465f6d10d = v);
var $afe4dbdbdac4d054$export$69f1b2dcda23c5f8;
var $afe4dbdbdac4d054$export$45b10814cc054894;
var $afe4dbdbdac4d054$export$7ea66e3774a60b67;
var $afe4dbdbdac4d054$export$34a52f00f601f6f1;
var $afe4dbdbdac4d054$export$812b0cbd5e8a72ab;
var $afe4dbdbdac4d054$export$f24f9e11d63bb314;
var $afe4dbdbdac4d054$export$b71357c7e07ca1f1;
var $afe4dbdbdac4d054$export$2e58a4b541fdcbe8;
var $afe4dbdbdac4d054$export$183b950bde9faab8;
var $afe4dbdbdac4d054$export$4785c77169fea59e;
var $afe4dbdbdac4d054$export$242a185dfcffac5b;
var $afe4dbdbdac4d054$export$58c04ae0ae31877d;
var $afe4dbdbdac4d054$export$d058ca695f8c6f11;
var $afe4dbdbdac4d054$export$a1efd7fc3e986367;
var $afe4dbdbdac4d054$export$bbfea4a2b5abaab4;
var $afe4dbdbdac4d054$export$97ad4afc7de86152;
var $afe4dbdbdac4d054$export$ce4673d9a79f6a4b;
var $afe4dbdbdac4d054$export$786cc99fc6eedc0b;
var $afe4dbdbdac4d054$export$45c59b9a1848dd0;
var $afe4dbdbdac4d054$export$50d8f613e76d3034;
var $afe4dbdbdac4d054$export$b8e83683c60ee162;
var $afe4dbdbdac4d054$export$aeeb51790d1bcc4a;
var $afe4dbdbdac4d054$export$bb7c616f719ad9c;
var $afe4dbdbdac4d054$export$4d63290824f9d7df;
var $afe4dbdbdac4d054$export$2f64ceb90ef28ea1;
var $afe4dbdbdac4d054$export$8d2089d465f6d10d;
"use strict";

var $lBpFJ = parcelRequire("lBpFJ");

var $hP1iE = parcelRequire("hP1iE");
$afe4dbdbdac4d054$export$69f1b2dcda23c5f8 = $hP1iE;
function $afe4dbdbdac4d054$var$isSurrogatePair(msg, i) {
    if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) return false;
    if (i < 0 || i + 1 >= msg.length) return false;
    return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}
function $afe4dbdbdac4d054$var$toArray(msg, enc) {
    if (Array.isArray(msg)) return msg.slice();
    if (!msg) return [];
    var res = [];
    if (typeof msg === "string") {
        if (!enc) {
            // Inspired by stringToUtf8ByteArray() in closure-library by Google
            // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
            // Apache License 2.0
            // https://github.com/google/closure-library/blob/master/LICENSE
            var p = 0;
            for(var i = 0; i < msg.length; i++){
                var c = msg.charCodeAt(i);
                if (c < 128) res[p++] = c;
                else if (c < 2048) {
                    res[p++] = c >> 6 | 192;
                    res[p++] = c & 63 | 128;
                } else if ($afe4dbdbdac4d054$var$isSurrogatePair(msg, i)) {
                    c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
                    res[p++] = c >> 18 | 240;
                    res[p++] = c >> 12 & 63 | 128;
                    res[p++] = c >> 6 & 63 | 128;
                    res[p++] = c & 63 | 128;
                } else {
                    res[p++] = c >> 12 | 224;
                    res[p++] = c >> 6 & 63 | 128;
                    res[p++] = c & 63 | 128;
                }
            }
        } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0) msg = "0" + msg;
            for(i = 0; i < msg.length; i += 2)res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
    } else for(i = 0; i < msg.length; i++)res[i] = msg[i] | 0;
    return res;
}
$afe4dbdbdac4d054$export$45b10814cc054894 = $afe4dbdbdac4d054$var$toArray;
function $afe4dbdbdac4d054$var$toHex(msg) {
    var res = "";
    for(var i = 0; i < msg.length; i++)res += $afe4dbdbdac4d054$var$zero2(msg[i].toString(16));
    return res;
}
$afe4dbdbdac4d054$export$7ea66e3774a60b67 = $afe4dbdbdac4d054$var$toHex;
function $afe4dbdbdac4d054$var$htonl(w) {
    var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;
    return res >>> 0;
}
$afe4dbdbdac4d054$export$34a52f00f601f6f1 = $afe4dbdbdac4d054$var$htonl;
function $afe4dbdbdac4d054$var$toHex32(msg, endian) {
    var res = "";
    for(var i = 0; i < msg.length; i++){
        var w = msg[i];
        if (endian === "little") w = $afe4dbdbdac4d054$var$htonl(w);
        res += $afe4dbdbdac4d054$var$zero8(w.toString(16));
    }
    return res;
}
$afe4dbdbdac4d054$export$812b0cbd5e8a72ab = $afe4dbdbdac4d054$var$toHex32;
function $afe4dbdbdac4d054$var$zero2(word) {
    if (word.length === 1) return "0" + word;
    else return word;
}
$afe4dbdbdac4d054$export$f24f9e11d63bb314 = $afe4dbdbdac4d054$var$zero2;
function $afe4dbdbdac4d054$var$zero8(word) {
    if (word.length === 7) return "0" + word;
    else if (word.length === 6) return "00" + word;
    else if (word.length === 5) return "000" + word;
    else if (word.length === 4) return "0000" + word;
    else if (word.length === 3) return "00000" + word;
    else if (word.length === 2) return "000000" + word;
    else if (word.length === 1) return "0000000" + word;
    else return word;
}
$afe4dbdbdac4d054$export$b71357c7e07ca1f1 = $afe4dbdbdac4d054$var$zero8;
function $afe4dbdbdac4d054$var$join32(msg, start, end, endian) {
    var len = end - start;
    $lBpFJ(len % 4 === 0);
    var res = new Array(len / 4);
    for(var i = 0, k = start; i < res.length; i++, k += 4){
        var w;
        if (endian === "big") w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
    }
    return res;
}
$afe4dbdbdac4d054$export$2e58a4b541fdcbe8 = $afe4dbdbdac4d054$var$join32;
function $afe4dbdbdac4d054$var$split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for(var i = 0, k = 0; i < msg.length; i++, k += 4){
        var m = msg[i];
        if (endian === "big") {
            res[k] = m >>> 24;
            res[k + 1] = m >>> 16 & 0xff;
            res[k + 2] = m >>> 8 & 0xff;
            res[k + 3] = m & 0xff;
        } else {
            res[k + 3] = m >>> 24;
            res[k + 2] = m >>> 16 & 0xff;
            res[k + 1] = m >>> 8 & 0xff;
            res[k] = m & 0xff;
        }
    }
    return res;
}
$afe4dbdbdac4d054$export$183b950bde9faab8 = $afe4dbdbdac4d054$var$split32;
function $afe4dbdbdac4d054$var$rotr32(w, b) {
    return w >>> b | w << 32 - b;
}
$afe4dbdbdac4d054$export$4785c77169fea59e = $afe4dbdbdac4d054$var$rotr32;
function $afe4dbdbdac4d054$var$rotl32(w, b) {
    return w << b | w >>> 32 - b;
}
$afe4dbdbdac4d054$export$242a185dfcffac5b = $afe4dbdbdac4d054$var$rotl32;
function $afe4dbdbdac4d054$var$sum32(a, b) {
    return a + b >>> 0;
}
$afe4dbdbdac4d054$export$58c04ae0ae31877d = $afe4dbdbdac4d054$var$sum32;
function $afe4dbdbdac4d054$var$sum32_3(a, b, c) {
    return a + b + c >>> 0;
}
$afe4dbdbdac4d054$export$d058ca695f8c6f11 = $afe4dbdbdac4d054$var$sum32_3;
function $afe4dbdbdac4d054$var$sum32_4(a, b, c, d) {
    return a + b + c + d >>> 0;
}
$afe4dbdbdac4d054$export$a1efd7fc3e986367 = $afe4dbdbdac4d054$var$sum32_4;
function $afe4dbdbdac4d054$var$sum32_5(a, b, c, d, e) {
    return a + b + c + d + e >>> 0;
}
$afe4dbdbdac4d054$export$bbfea4a2b5abaab4 = $afe4dbdbdac4d054$var$sum32_5;
function $afe4dbdbdac4d054$var$sum64(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
}
$afe4dbdbdac4d054$export$97ad4afc7de86152 = $afe4dbdbdac4d054$var$sum64;
function $afe4dbdbdac4d054$var$sum64_hi(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
}
$afe4dbdbdac4d054$export$ce4673d9a79f6a4b = $afe4dbdbdac4d054$var$sum64_hi;
function $afe4dbdbdac4d054$var$sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
}
$afe4dbdbdac4d054$export$786cc99fc6eedc0b = $afe4dbdbdac4d054$var$sum64_lo;
function $afe4dbdbdac4d054$var$sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
}
$afe4dbdbdac4d054$export$45c59b9a1848dd0 = $afe4dbdbdac4d054$var$sum64_4_hi;
function $afe4dbdbdac4d054$var$sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
}
$afe4dbdbdac4d054$export$50d8f613e76d3034 = $afe4dbdbdac4d054$var$sum64_4_lo;
function $afe4dbdbdac4d054$var$sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
}
$afe4dbdbdac4d054$export$b8e83683c60ee162 = $afe4dbdbdac4d054$var$sum64_5_hi;
function $afe4dbdbdac4d054$var$sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
}
$afe4dbdbdac4d054$export$aeeb51790d1bcc4a = $afe4dbdbdac4d054$var$sum64_5_lo;
function $afe4dbdbdac4d054$var$rotr64_hi(ah, al, num) {
    var r = al << 32 - num | ah >>> num;
    return r >>> 0;
}
$afe4dbdbdac4d054$export$bb7c616f719ad9c = $afe4dbdbdac4d054$var$rotr64_hi;
function $afe4dbdbdac4d054$var$rotr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
}
$afe4dbdbdac4d054$export$4d63290824f9d7df = $afe4dbdbdac4d054$var$rotr64_lo;
function $afe4dbdbdac4d054$var$shr64_hi(ah, al, num) {
    return ah >>> num;
}
$afe4dbdbdac4d054$export$2f64ceb90ef28ea1 = $afe4dbdbdac4d054$var$shr64_hi;
function $afe4dbdbdac4d054$var$shr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
}
$afe4dbdbdac4d054$export$8d2089d465f6d10d = $afe4dbdbdac4d054$var$shr64_lo;

});

parcelRequire.register("ifopx", function(module, exports) {

$parcel$export(module.exports, "BlockHash", () => $d48c9039a784aef5$export$8687658379b577e6, (v) => $d48c9039a784aef5$export$8687658379b577e6 = v);
var $d48c9039a784aef5$export$8687658379b577e6;
"use strict";

var $f6hkv = parcelRequire("f6hkv");

var $lBpFJ = parcelRequire("lBpFJ");
function $d48c9039a784aef5$var$BlockHash() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = "big";
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
}
$d48c9039a784aef5$export$8687658379b577e6 = $d48c9039a784aef5$var$BlockHash;
$d48c9039a784aef5$var$BlockHash.prototype.update = function update(msg, enc) {
    // Convert message to array, pad it, and join into 32bit blocks
    msg = $f6hkv.toArray(msg, enc);
    if (!this.pending) this.pending = msg;
    else this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    // Enough data, try updating
    if (this.pending.length >= this._delta8) {
        msg = this.pending;
        // Process pending data in blocks
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0) this.pending = null;
        msg = $f6hkv.join32(msg, 0, msg.length - r, this.endian);
        for(var i = 0; i < msg.length; i += this._delta32)this._update(msg, i, i + this._delta32);
    }
    return this;
};
$d48c9039a784aef5$var$BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    $lBpFJ(this.pending === null);
    return this._digest(enc);
};
$d48c9039a784aef5$var$BlockHash.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - (len + this.padLength) % bytes;
    var res = new Array(k + this.padLength);
    res[0] = 0x80;
    for(var i = 1; i < k; i++)res[i] = 0;
    // Append length
    len <<= 3;
    if (this.endian === "big") {
        for(var t = 8; t < this.padLength; t++)res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 0xff;
        res[i++] = len >>> 16 & 0xff;
        res[i++] = len >>> 8 & 0xff;
        res[i++] = len & 0xff;
    } else {
        res[i++] = len & 0xff;
        res[i++] = len >>> 8 & 0xff;
        res[i++] = len >>> 16 & 0xff;
        res[i++] = len >>> 24 & 0xff;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for(t = 8; t < this.padLength; t++)res[i++] = 0;
    }
    return res;
};

});

parcelRequire.register("ijnj3", function(module, exports) {

$parcel$export(module.exports, "sha1", () => $d54c147d20008557$export$5091bdda49ba90f5, (v) => $d54c147d20008557$export$5091bdda49ba90f5 = v);
$parcel$export(module.exports, "sha224", () => $d54c147d20008557$export$97b70509d4e397ea, (v) => $d54c147d20008557$export$97b70509d4e397ea = v);
$parcel$export(module.exports, "sha256", () => $d54c147d20008557$export$bced8d2aada2d1c9, (v) => $d54c147d20008557$export$bced8d2aada2d1c9 = v);
$parcel$export(module.exports, "sha384", () => $d54c147d20008557$export$612d47d55dedde45, (v) => $d54c147d20008557$export$612d47d55dedde45 = v);
$parcel$export(module.exports, "sha512", () => $d54c147d20008557$export$a888d2532e6dc7bb, (v) => $d54c147d20008557$export$a888d2532e6dc7bb = v);
var $d54c147d20008557$export$5091bdda49ba90f5;
var $d54c147d20008557$export$97b70509d4e397ea;
var $d54c147d20008557$export$bced8d2aada2d1c9;
var $d54c147d20008557$export$612d47d55dedde45;
var $d54c147d20008557$export$a888d2532e6dc7bb;
"use strict";

$d54c147d20008557$export$5091bdda49ba90f5 = (parcelRequire("ji9wA"));

$d54c147d20008557$export$97b70509d4e397ea = (parcelRequire("9kEoB"));

$d54c147d20008557$export$bced8d2aada2d1c9 = (parcelRequire("dFtPH"));

$d54c147d20008557$export$612d47d55dedde45 = (parcelRequire("c1afd"));

$d54c147d20008557$export$a888d2532e6dc7bb = (parcelRequire("hCiAi"));

});
parcelRequire.register("ji9wA", function(module, exports) {
"use strict";

var $f6hkv = parcelRequire("f6hkv");

var $ifopx = parcelRequire("ifopx");

var $gO3sA = parcelRequire("gO3sA");
var $e0b71627eb296b3a$var$rotl32 = $f6hkv.rotl32;
var $e0b71627eb296b3a$var$sum32 = $f6hkv.sum32;
var $e0b71627eb296b3a$var$sum32_5 = $f6hkv.sum32_5;
var $e0b71627eb296b3a$var$ft_1 = $gO3sA.ft_1;
var $e0b71627eb296b3a$var$BlockHash = $ifopx.BlockHash;
var $e0b71627eb296b3a$var$sha1_K = [
    0x5A827999,
    0x6ED9EBA1,
    0x8F1BBCDC,
    0xCA62C1D6
];
function $e0b71627eb296b3a$var$SHA1() {
    if (!(this instanceof $e0b71627eb296b3a$var$SHA1)) return new $e0b71627eb296b3a$var$SHA1();
    $e0b71627eb296b3a$var$BlockHash.call(this);
    this.h = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
        0xc3d2e1f0
    ];
    this.W = new Array(80);
}
$f6hkv.inherits($e0b71627eb296b3a$var$SHA1, $e0b71627eb296b3a$var$BlockHash);
module.exports = $e0b71627eb296b3a$var$SHA1;
$e0b71627eb296b3a$var$SHA1.blockSize = 512;
$e0b71627eb296b3a$var$SHA1.outSize = 160;
$e0b71627eb296b3a$var$SHA1.hmacStrength = 80;
$e0b71627eb296b3a$var$SHA1.padLength = 64;
$e0b71627eb296b3a$var$SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for(var i = 0; i < 16; i++)W[i] = msg[start + i];
    for(; i < W.length; i++)W[i] = $e0b71627eb296b3a$var$rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for(i = 0; i < W.length; i++){
        var s = ~~(i / 20);
        var t = $e0b71627eb296b3a$var$sum32_5($e0b71627eb296b3a$var$rotl32(a, 5), $e0b71627eb296b3a$var$ft_1(s, b, c, d), e, W[i], $e0b71627eb296b3a$var$sha1_K[s]);
        e = d;
        d = c;
        c = $e0b71627eb296b3a$var$rotl32(b, 30);
        b = a;
        a = t;
    }
    this.h[0] = $e0b71627eb296b3a$var$sum32(this.h[0], a);
    this.h[1] = $e0b71627eb296b3a$var$sum32(this.h[1], b);
    this.h[2] = $e0b71627eb296b3a$var$sum32(this.h[2], c);
    this.h[3] = $e0b71627eb296b3a$var$sum32(this.h[3], d);
    this.h[4] = $e0b71627eb296b3a$var$sum32(this.h[4], e);
};
$e0b71627eb296b3a$var$SHA1.prototype._digest = function digest(enc) {
    if (enc === "hex") return $f6hkv.toHex32(this.h, "big");
    else return $f6hkv.split32(this.h, "big");
};

});
parcelRequire.register("gO3sA", function(module, exports) {

$parcel$export(module.exports, "ft_1", () => $c3c3fff9f18caa08$export$5a92649d7ddb9f63, (v) => $c3c3fff9f18caa08$export$5a92649d7ddb9f63 = v);
$parcel$export(module.exports, "ch32", () => $c3c3fff9f18caa08$export$c6d0d020c3a6269, (v) => $c3c3fff9f18caa08$export$c6d0d020c3a6269 = v);
$parcel$export(module.exports, "maj32", () => $c3c3fff9f18caa08$export$eb90c27fca05f956, (v) => $c3c3fff9f18caa08$export$eb90c27fca05f956 = v);
$parcel$export(module.exports, "s0_256", () => $c3c3fff9f18caa08$export$14a4a98e063b1999, (v) => $c3c3fff9f18caa08$export$14a4a98e063b1999 = v);
$parcel$export(module.exports, "s1_256", () => $c3c3fff9f18caa08$export$d20cecfa1564c686, (v) => $c3c3fff9f18caa08$export$d20cecfa1564c686 = v);
$parcel$export(module.exports, "g0_256", () => $c3c3fff9f18caa08$export$44fd472a12fc6db, (v) => $c3c3fff9f18caa08$export$44fd472a12fc6db = v);
$parcel$export(module.exports, "g1_256", () => $c3c3fff9f18caa08$export$1ed238bb6ea1dd47, (v) => $c3c3fff9f18caa08$export$1ed238bb6ea1dd47 = v);
var $c3c3fff9f18caa08$export$5a92649d7ddb9f63;
var $c3c3fff9f18caa08$export$c6d0d020c3a6269;
var $c3c3fff9f18caa08$export$eb90c27fca05f956;
var $c3c3fff9f18caa08$export$cc992891a14496a1;
var $c3c3fff9f18caa08$export$14a4a98e063b1999;
var $c3c3fff9f18caa08$export$d20cecfa1564c686;
var $c3c3fff9f18caa08$export$44fd472a12fc6db;
var $c3c3fff9f18caa08$export$1ed238bb6ea1dd47;
"use strict";

var $f6hkv = parcelRequire("f6hkv");
var $c3c3fff9f18caa08$var$rotr32 = $f6hkv.rotr32;
function $c3c3fff9f18caa08$var$ft_1(s, x, y, z) {
    if (s === 0) return $c3c3fff9f18caa08$var$ch32(x, y, z);
    if (s === 1 || s === 3) return $c3c3fff9f18caa08$var$p32(x, y, z);
    if (s === 2) return $c3c3fff9f18caa08$var$maj32(x, y, z);
}
$c3c3fff9f18caa08$export$5a92649d7ddb9f63 = $c3c3fff9f18caa08$var$ft_1;
function $c3c3fff9f18caa08$var$ch32(x, y, z) {
    return x & y ^ ~x & z;
}
$c3c3fff9f18caa08$export$c6d0d020c3a6269 = $c3c3fff9f18caa08$var$ch32;
function $c3c3fff9f18caa08$var$maj32(x, y, z) {
    return x & y ^ x & z ^ y & z;
}
$c3c3fff9f18caa08$export$eb90c27fca05f956 = $c3c3fff9f18caa08$var$maj32;
function $c3c3fff9f18caa08$var$p32(x, y, z) {
    return x ^ y ^ z;
}
$c3c3fff9f18caa08$export$cc992891a14496a1 = $c3c3fff9f18caa08$var$p32;
function $c3c3fff9f18caa08$var$s0_256(x) {
    return $c3c3fff9f18caa08$var$rotr32(x, 2) ^ $c3c3fff9f18caa08$var$rotr32(x, 13) ^ $c3c3fff9f18caa08$var$rotr32(x, 22);
}
$c3c3fff9f18caa08$export$14a4a98e063b1999 = $c3c3fff9f18caa08$var$s0_256;
function $c3c3fff9f18caa08$var$s1_256(x) {
    return $c3c3fff9f18caa08$var$rotr32(x, 6) ^ $c3c3fff9f18caa08$var$rotr32(x, 11) ^ $c3c3fff9f18caa08$var$rotr32(x, 25);
}
$c3c3fff9f18caa08$export$d20cecfa1564c686 = $c3c3fff9f18caa08$var$s1_256;
function $c3c3fff9f18caa08$var$g0_256(x) {
    return $c3c3fff9f18caa08$var$rotr32(x, 7) ^ $c3c3fff9f18caa08$var$rotr32(x, 18) ^ x >>> 3;
}
$c3c3fff9f18caa08$export$44fd472a12fc6db = $c3c3fff9f18caa08$var$g0_256;
function $c3c3fff9f18caa08$var$g1_256(x) {
    return $c3c3fff9f18caa08$var$rotr32(x, 17) ^ $c3c3fff9f18caa08$var$rotr32(x, 19) ^ x >>> 10;
}
$c3c3fff9f18caa08$export$1ed238bb6ea1dd47 = $c3c3fff9f18caa08$var$g1_256;

});


parcelRequire.register("9kEoB", function(module, exports) {
"use strict";

var $f6hkv = parcelRequire("f6hkv");

var $dFtPH = parcelRequire("dFtPH");
function $6cb5511641f63c6e$var$SHA224() {
    if (!(this instanceof $6cb5511641f63c6e$var$SHA224)) return new $6cb5511641f63c6e$var$SHA224();
    $dFtPH.call(this);
    this.h = [
        0xc1059ed8,
        0x367cd507,
        0x3070dd17,
        0xf70e5939,
        0xffc00b31,
        0x68581511,
        0x64f98fa7,
        0xbefa4fa4
    ];
}
$f6hkv.inherits($6cb5511641f63c6e$var$SHA224, $dFtPH);
module.exports = $6cb5511641f63c6e$var$SHA224;
$6cb5511641f63c6e$var$SHA224.blockSize = 512;
$6cb5511641f63c6e$var$SHA224.outSize = 224;
$6cb5511641f63c6e$var$SHA224.hmacStrength = 192;
$6cb5511641f63c6e$var$SHA224.padLength = 64;
$6cb5511641f63c6e$var$SHA224.prototype._digest = function digest(enc) {
    // Just truncate output
    if (enc === "hex") return $f6hkv.toHex32(this.h.slice(0, 7), "big");
    else return $f6hkv.split32(this.h.slice(0, 7), "big");
};

});
parcelRequire.register("dFtPH", function(module, exports) {
"use strict";

var $f6hkv = parcelRequire("f6hkv");

var $ifopx = parcelRequire("ifopx");

var $gO3sA = parcelRequire("gO3sA");

var $lBpFJ = parcelRequire("lBpFJ");
var $9f363ee2f23b3dd0$var$sum32 = $f6hkv.sum32;
var $9f363ee2f23b3dd0$var$sum32_4 = $f6hkv.sum32_4;
var $9f363ee2f23b3dd0$var$sum32_5 = $f6hkv.sum32_5;
var $9f363ee2f23b3dd0$var$ch32 = $gO3sA.ch32;
var $9f363ee2f23b3dd0$var$maj32 = $gO3sA.maj32;
var $9f363ee2f23b3dd0$var$s0_256 = $gO3sA.s0_256;
var $9f363ee2f23b3dd0$var$s1_256 = $gO3sA.s1_256;
var $9f363ee2f23b3dd0$var$g0_256 = $gO3sA.g0_256;
var $9f363ee2f23b3dd0$var$g1_256 = $gO3sA.g1_256;
var $9f363ee2f23b3dd0$var$BlockHash = $ifopx.BlockHash;
var $9f363ee2f23b3dd0$var$sha256_K = [
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
];
function $9f363ee2f23b3dd0$var$SHA256() {
    if (!(this instanceof $9f363ee2f23b3dd0$var$SHA256)) return new $9f363ee2f23b3dd0$var$SHA256();
    $9f363ee2f23b3dd0$var$BlockHash.call(this);
    this.h = [
        0x6a09e667,
        0xbb67ae85,
        0x3c6ef372,
        0xa54ff53a,
        0x510e527f,
        0x9b05688c,
        0x1f83d9ab,
        0x5be0cd19
    ];
    this.k = $9f363ee2f23b3dd0$var$sha256_K;
    this.W = new Array(64);
}
$f6hkv.inherits($9f363ee2f23b3dd0$var$SHA256, $9f363ee2f23b3dd0$var$BlockHash);
module.exports = $9f363ee2f23b3dd0$var$SHA256;
$9f363ee2f23b3dd0$var$SHA256.blockSize = 512;
$9f363ee2f23b3dd0$var$SHA256.outSize = 256;
$9f363ee2f23b3dd0$var$SHA256.hmacStrength = 192;
$9f363ee2f23b3dd0$var$SHA256.padLength = 64;
$9f363ee2f23b3dd0$var$SHA256.prototype._update = function _update(msg, start) {
    var W = this.W;
    for(var i = 0; i < 16; i++)W[i] = msg[start + i];
    for(; i < W.length; i++)W[i] = $9f363ee2f23b3dd0$var$sum32_4($9f363ee2f23b3dd0$var$g1_256(W[i - 2]), W[i - 7], $9f363ee2f23b3dd0$var$g0_256(W[i - 15]), W[i - 16]);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    $lBpFJ(this.k.length === W.length);
    for(i = 0; i < W.length; i++){
        var T1 = $9f363ee2f23b3dd0$var$sum32_5(h, $9f363ee2f23b3dd0$var$s1_256(e), $9f363ee2f23b3dd0$var$ch32(e, f, g), this.k[i], W[i]);
        var T2 = $9f363ee2f23b3dd0$var$sum32($9f363ee2f23b3dd0$var$s0_256(a), $9f363ee2f23b3dd0$var$maj32(a, b, c));
        h = g;
        g = f;
        f = e;
        e = $9f363ee2f23b3dd0$var$sum32(d, T1);
        d = c;
        c = b;
        b = a;
        a = $9f363ee2f23b3dd0$var$sum32(T1, T2);
    }
    this.h[0] = $9f363ee2f23b3dd0$var$sum32(this.h[0], a);
    this.h[1] = $9f363ee2f23b3dd0$var$sum32(this.h[1], b);
    this.h[2] = $9f363ee2f23b3dd0$var$sum32(this.h[2], c);
    this.h[3] = $9f363ee2f23b3dd0$var$sum32(this.h[3], d);
    this.h[4] = $9f363ee2f23b3dd0$var$sum32(this.h[4], e);
    this.h[5] = $9f363ee2f23b3dd0$var$sum32(this.h[5], f);
    this.h[6] = $9f363ee2f23b3dd0$var$sum32(this.h[6], g);
    this.h[7] = $9f363ee2f23b3dd0$var$sum32(this.h[7], h);
};
$9f363ee2f23b3dd0$var$SHA256.prototype._digest = function digest(enc) {
    if (enc === "hex") return $f6hkv.toHex32(this.h, "big");
    else return $f6hkv.split32(this.h, "big");
};

});


parcelRequire.register("c1afd", function(module, exports) {
"use strict";

var $f6hkv = parcelRequire("f6hkv");

var $hCiAi = parcelRequire("hCiAi");
function $8bfd8659fb5cff68$var$SHA384() {
    if (!(this instanceof $8bfd8659fb5cff68$var$SHA384)) return new $8bfd8659fb5cff68$var$SHA384();
    $hCiAi.call(this);
    this.h = [
        0xcbbb9d5d,
        0xc1059ed8,
        0x629a292a,
        0x367cd507,
        0x9159015a,
        0x3070dd17,
        0x152fecd8,
        0xf70e5939,
        0x67332667,
        0xffc00b31,
        0x8eb44a87,
        0x68581511,
        0xdb0c2e0d,
        0x64f98fa7,
        0x47b5481d,
        0xbefa4fa4
    ];
}
$f6hkv.inherits($8bfd8659fb5cff68$var$SHA384, $hCiAi);
module.exports = $8bfd8659fb5cff68$var$SHA384;
$8bfd8659fb5cff68$var$SHA384.blockSize = 1024;
$8bfd8659fb5cff68$var$SHA384.outSize = 384;
$8bfd8659fb5cff68$var$SHA384.hmacStrength = 192;
$8bfd8659fb5cff68$var$SHA384.padLength = 128;
$8bfd8659fb5cff68$var$SHA384.prototype._digest = function digest(enc) {
    if (enc === "hex") return $f6hkv.toHex32(this.h.slice(0, 12), "big");
    else return $f6hkv.split32(this.h.slice(0, 12), "big");
};

});
parcelRequire.register("hCiAi", function(module, exports) {
"use strict";

var $f6hkv = parcelRequire("f6hkv");

var $ifopx = parcelRequire("ifopx");

var $lBpFJ = parcelRequire("lBpFJ");
var $cd3466bf759bf2d9$var$rotr64_hi = $f6hkv.rotr64_hi;
var $cd3466bf759bf2d9$var$rotr64_lo = $f6hkv.rotr64_lo;
var $cd3466bf759bf2d9$var$shr64_hi = $f6hkv.shr64_hi;
var $cd3466bf759bf2d9$var$shr64_lo = $f6hkv.shr64_lo;
var $cd3466bf759bf2d9$var$sum64 = $f6hkv.sum64;
var $cd3466bf759bf2d9$var$sum64_hi = $f6hkv.sum64_hi;
var $cd3466bf759bf2d9$var$sum64_lo = $f6hkv.sum64_lo;
var $cd3466bf759bf2d9$var$sum64_4_hi = $f6hkv.sum64_4_hi;
var $cd3466bf759bf2d9$var$sum64_4_lo = $f6hkv.sum64_4_lo;
var $cd3466bf759bf2d9$var$sum64_5_hi = $f6hkv.sum64_5_hi;
var $cd3466bf759bf2d9$var$sum64_5_lo = $f6hkv.sum64_5_lo;
var $cd3466bf759bf2d9$var$BlockHash = $ifopx.BlockHash;
var $cd3466bf759bf2d9$var$sha512_K = [
    0x428a2f98,
    0xd728ae22,
    0x71374491,
    0x23ef65cd,
    0xb5c0fbcf,
    0xec4d3b2f,
    0xe9b5dba5,
    0x8189dbbc,
    0x3956c25b,
    0xf348b538,
    0x59f111f1,
    0xb605d019,
    0x923f82a4,
    0xaf194f9b,
    0xab1c5ed5,
    0xda6d8118,
    0xd807aa98,
    0xa3030242,
    0x12835b01,
    0x45706fbe,
    0x243185be,
    0x4ee4b28c,
    0x550c7dc3,
    0xd5ffb4e2,
    0x72be5d74,
    0xf27b896f,
    0x80deb1fe,
    0x3b1696b1,
    0x9bdc06a7,
    0x25c71235,
    0xc19bf174,
    0xcf692694,
    0xe49b69c1,
    0x9ef14ad2,
    0xefbe4786,
    0x384f25e3,
    0x0fc19dc6,
    0x8b8cd5b5,
    0x240ca1cc,
    0x77ac9c65,
    0x2de92c6f,
    0x592b0275,
    0x4a7484aa,
    0x6ea6e483,
    0x5cb0a9dc,
    0xbd41fbd4,
    0x76f988da,
    0x831153b5,
    0x983e5152,
    0xee66dfab,
    0xa831c66d,
    0x2db43210,
    0xb00327c8,
    0x98fb213f,
    0xbf597fc7,
    0xbeef0ee4,
    0xc6e00bf3,
    0x3da88fc2,
    0xd5a79147,
    0x930aa725,
    0x06ca6351,
    0xe003826f,
    0x14292967,
    0x0a0e6e70,
    0x27b70a85,
    0x46d22ffc,
    0x2e1b2138,
    0x5c26c926,
    0x4d2c6dfc,
    0x5ac42aed,
    0x53380d13,
    0x9d95b3df,
    0x650a7354,
    0x8baf63de,
    0x766a0abb,
    0x3c77b2a8,
    0x81c2c92e,
    0x47edaee6,
    0x92722c85,
    0x1482353b,
    0xa2bfe8a1,
    0x4cf10364,
    0xa81a664b,
    0xbc423001,
    0xc24b8b70,
    0xd0f89791,
    0xc76c51a3,
    0x0654be30,
    0xd192e819,
    0xd6ef5218,
    0xd6990624,
    0x5565a910,
    0xf40e3585,
    0x5771202a,
    0x106aa070,
    0x32bbd1b8,
    0x19a4c116,
    0xb8d2d0c8,
    0x1e376c08,
    0x5141ab53,
    0x2748774c,
    0xdf8eeb99,
    0x34b0bcb5,
    0xe19b48a8,
    0x391c0cb3,
    0xc5c95a63,
    0x4ed8aa4a,
    0xe3418acb,
    0x5b9cca4f,
    0x7763e373,
    0x682e6ff3,
    0xd6b2b8a3,
    0x748f82ee,
    0x5defb2fc,
    0x78a5636f,
    0x43172f60,
    0x84c87814,
    0xa1f0ab72,
    0x8cc70208,
    0x1a6439ec,
    0x90befffa,
    0x23631e28,
    0xa4506ceb,
    0xde82bde9,
    0xbef9a3f7,
    0xb2c67915,
    0xc67178f2,
    0xe372532b,
    0xca273ece,
    0xea26619c,
    0xd186b8c7,
    0x21c0c207,
    0xeada7dd6,
    0xcde0eb1e,
    0xf57d4f7f,
    0xee6ed178,
    0x06f067aa,
    0x72176fba,
    0x0a637dc5,
    0xa2c898a6,
    0x113f9804,
    0xbef90dae,
    0x1b710b35,
    0x131c471b,
    0x28db77f5,
    0x23047d84,
    0x32caab7b,
    0x40c72493,
    0x3c9ebe0a,
    0x15c9bebc,
    0x431d67c4,
    0x9c100d4c,
    0x4cc5d4be,
    0xcb3e42b6,
    0x597f299c,
    0xfc657e2a,
    0x5fcb6fab,
    0x3ad6faec,
    0x6c44198c,
    0x4a475817
];
function $cd3466bf759bf2d9$var$SHA512() {
    if (!(this instanceof $cd3466bf759bf2d9$var$SHA512)) return new $cd3466bf759bf2d9$var$SHA512();
    $cd3466bf759bf2d9$var$BlockHash.call(this);
    this.h = [
        0x6a09e667,
        0xf3bcc908,
        0xbb67ae85,
        0x84caa73b,
        0x3c6ef372,
        0xfe94f82b,
        0xa54ff53a,
        0x5f1d36f1,
        0x510e527f,
        0xade682d1,
        0x9b05688c,
        0x2b3e6c1f,
        0x1f83d9ab,
        0xfb41bd6b,
        0x5be0cd19,
        0x137e2179
    ];
    this.k = $cd3466bf759bf2d9$var$sha512_K;
    this.W = new Array(160);
}
$f6hkv.inherits($cd3466bf759bf2d9$var$SHA512, $cd3466bf759bf2d9$var$BlockHash);
module.exports = $cd3466bf759bf2d9$var$SHA512;
$cd3466bf759bf2d9$var$SHA512.blockSize = 1024;
$cd3466bf759bf2d9$var$SHA512.outSize = 512;
$cd3466bf759bf2d9$var$SHA512.hmacStrength = 192;
$cd3466bf759bf2d9$var$SHA512.padLength = 128;
$cd3466bf759bf2d9$var$SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    // 32 x 32bit words
    for(var i = 0; i < 32; i++)W[i] = msg[start + i];
    for(; i < W.length; i += 2){
        var c0_hi = $cd3466bf759bf2d9$var$g1_512_hi(W[i - 4], W[i - 3]); // i - 2
        var c0_lo = $cd3466bf759bf2d9$var$g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14]; // i - 7
        var c1_lo = W[i - 13];
        var c2_hi = $cd3466bf759bf2d9$var$g0_512_hi(W[i - 30], W[i - 29]); // i - 15
        var c2_lo = $cd3466bf759bf2d9$var$g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32]; // i - 16
        var c3_lo = W[i - 31];
        W[i] = $cd3466bf759bf2d9$var$sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        W[i + 1] = $cd3466bf759bf2d9$var$sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    }
};
$cd3466bf759bf2d9$var$SHA512.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    $lBpFJ(this.k.length === W.length);
    for(var i = 0; i < W.length; i += 2){
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = $cd3466bf759bf2d9$var$s1_512_hi(eh, el);
        var c1_lo = $cd3466bf759bf2d9$var$s1_512_lo(eh, el);
        var c2_hi = $cd3466bf759bf2d9$var$ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = $cd3466bf759bf2d9$var$ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = $cd3466bf759bf2d9$var$sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        var T1_lo = $cd3466bf759bf2d9$var$sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        c0_hi = $cd3466bf759bf2d9$var$s0_512_hi(ah, al);
        c0_lo = $cd3466bf759bf2d9$var$s0_512_lo(ah, al);
        c1_hi = $cd3466bf759bf2d9$var$maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = $cd3466bf759bf2d9$var$maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = $cd3466bf759bf2d9$var$sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = $cd3466bf759bf2d9$var$sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = $cd3466bf759bf2d9$var$sum64_hi(dh, dl, T1_hi, T1_lo);
        el = $cd3466bf759bf2d9$var$sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = $cd3466bf759bf2d9$var$sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = $cd3466bf759bf2d9$var$sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    $cd3466bf759bf2d9$var$sum64(this.h, 0, ah, al);
    $cd3466bf759bf2d9$var$sum64(this.h, 2, bh, bl);
    $cd3466bf759bf2d9$var$sum64(this.h, 4, ch, cl);
    $cd3466bf759bf2d9$var$sum64(this.h, 6, dh, dl);
    $cd3466bf759bf2d9$var$sum64(this.h, 8, eh, el);
    $cd3466bf759bf2d9$var$sum64(this.h, 10, fh, fl);
    $cd3466bf759bf2d9$var$sum64(this.h, 12, gh, gl);
    $cd3466bf759bf2d9$var$sum64(this.h, 14, hh, hl);
};
$cd3466bf759bf2d9$var$SHA512.prototype._digest = function digest(enc) {
    if (enc === "hex") return $f6hkv.toHex32(this.h, "big");
    else return $f6hkv.split32(this.h, "big");
};
function $cd3466bf759bf2d9$var$ch64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ ~xh & zh;
    if (r < 0) r += 0x100000000;
    return r;
}
function $cd3466bf759bf2d9$var$ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ ~xl & zl;
    if (r < 0) r += 0x100000000;
    return r;
}
function $cd3466bf759bf2d9$var$maj64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ xh & zh ^ yh & zh;
    if (r < 0) r += 0x100000000;
    return r;
}
function $cd3466bf759bf2d9$var$maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ xl & zl ^ yl & zl;
    if (r < 0) r += 0x100000000;
    return r;
}
function $cd3466bf759bf2d9$var$s0_512_hi(xh, xl) {
    var c0_hi = $cd3466bf759bf2d9$var$rotr64_hi(xh, xl, 28);
    var c1_hi = $cd3466bf759bf2d9$var$rotr64_hi(xl, xh, 2); // 34
    var c2_hi = $cd3466bf759bf2d9$var$rotr64_hi(xl, xh, 7); // 39
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function $cd3466bf759bf2d9$var$s0_512_lo(xh, xl) {
    var c0_lo = $cd3466bf759bf2d9$var$rotr64_lo(xh, xl, 28);
    var c1_lo = $cd3466bf759bf2d9$var$rotr64_lo(xl, xh, 2); // 34
    var c2_lo = $cd3466bf759bf2d9$var$rotr64_lo(xl, xh, 7); // 39
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function $cd3466bf759bf2d9$var$s1_512_hi(xh, xl) {
    var c0_hi = $cd3466bf759bf2d9$var$rotr64_hi(xh, xl, 14);
    var c1_hi = $cd3466bf759bf2d9$var$rotr64_hi(xh, xl, 18);
    var c2_hi = $cd3466bf759bf2d9$var$rotr64_hi(xl, xh, 9); // 41
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function $cd3466bf759bf2d9$var$s1_512_lo(xh, xl) {
    var c0_lo = $cd3466bf759bf2d9$var$rotr64_lo(xh, xl, 14);
    var c1_lo = $cd3466bf759bf2d9$var$rotr64_lo(xh, xl, 18);
    var c2_lo = $cd3466bf759bf2d9$var$rotr64_lo(xl, xh, 9); // 41
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function $cd3466bf759bf2d9$var$g0_512_hi(xh, xl) {
    var c0_hi = $cd3466bf759bf2d9$var$rotr64_hi(xh, xl, 1);
    var c1_hi = $cd3466bf759bf2d9$var$rotr64_hi(xh, xl, 8);
    var c2_hi = $cd3466bf759bf2d9$var$shr64_hi(xh, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function $cd3466bf759bf2d9$var$g0_512_lo(xh, xl) {
    var c0_lo = $cd3466bf759bf2d9$var$rotr64_lo(xh, xl, 1);
    var c1_lo = $cd3466bf759bf2d9$var$rotr64_lo(xh, xl, 8);
    var c2_lo = $cd3466bf759bf2d9$var$shr64_lo(xh, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function $cd3466bf759bf2d9$var$g1_512_hi(xh, xl) {
    var c0_hi = $cd3466bf759bf2d9$var$rotr64_hi(xh, xl, 19);
    var c1_hi = $cd3466bf759bf2d9$var$rotr64_hi(xl, xh, 29); // 61
    var c2_hi = $cd3466bf759bf2d9$var$shr64_hi(xh, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function $cd3466bf759bf2d9$var$g1_512_lo(xh, xl) {
    var c0_lo = $cd3466bf759bf2d9$var$rotr64_lo(xh, xl, 19);
    var c1_lo = $cd3466bf759bf2d9$var$rotr64_lo(xl, xh, 29); // 61
    var c2_lo = $cd3466bf759bf2d9$var$shr64_lo(xh, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}

});



parcelRequire.register("fA9Jz", function(module, exports) {

$parcel$export(module.exports, "ripemd160", () => $b581c4c921625495$export$d1cea0ee4e3f0d3e, (v) => $b581c4c921625495$export$d1cea0ee4e3f0d3e = v);
var $b581c4c921625495$export$d1cea0ee4e3f0d3e;
"use strict";

var $f6hkv = parcelRequire("f6hkv");

var $ifopx = parcelRequire("ifopx");
var $b581c4c921625495$var$rotl32 = $f6hkv.rotl32;
var $b581c4c921625495$var$sum32 = $f6hkv.sum32;
var $b581c4c921625495$var$sum32_3 = $f6hkv.sum32_3;
var $b581c4c921625495$var$sum32_4 = $f6hkv.sum32_4;
var $b581c4c921625495$var$BlockHash = $ifopx.BlockHash;
function $b581c4c921625495$var$RIPEMD160() {
    if (!(this instanceof $b581c4c921625495$var$RIPEMD160)) return new $b581c4c921625495$var$RIPEMD160();
    $b581c4c921625495$var$BlockHash.call(this);
    this.h = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
        0xc3d2e1f0
    ];
    this.endian = "little";
}
$f6hkv.inherits($b581c4c921625495$var$RIPEMD160, $b581c4c921625495$var$BlockHash);
$b581c4c921625495$export$d1cea0ee4e3f0d3e = $b581c4c921625495$var$RIPEMD160;
$b581c4c921625495$var$RIPEMD160.blockSize = 512;
$b581c4c921625495$var$RIPEMD160.outSize = 160;
$b581c4c921625495$var$RIPEMD160.hmacStrength = 192;
$b581c4c921625495$var$RIPEMD160.padLength = 64;
$b581c4c921625495$var$RIPEMD160.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;
    for(var j = 0; j < 80; j++){
        var T = $b581c4c921625495$var$sum32($b581c4c921625495$var$rotl32($b581c4c921625495$var$sum32_4(A, $b581c4c921625495$var$f(j, B, C, D), msg[$b581c4c921625495$var$r[j] + start], $b581c4c921625495$var$K(j)), $b581c4c921625495$var$s[j]), E);
        A = E;
        E = D;
        D = $b581c4c921625495$var$rotl32(C, 10);
        C = B;
        B = T;
        T = $b581c4c921625495$var$sum32($b581c4c921625495$var$rotl32($b581c4c921625495$var$sum32_4(Ah, $b581c4c921625495$var$f(79 - j, Bh, Ch, Dh), msg[$b581c4c921625495$var$rh[j] + start], $b581c4c921625495$var$Kh(j)), $b581c4c921625495$var$sh[j]), Eh);
        Ah = Eh;
        Eh = Dh;
        Dh = $b581c4c921625495$var$rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
    }
    T = $b581c4c921625495$var$sum32_3(this.h[1], C, Dh);
    this.h[1] = $b581c4c921625495$var$sum32_3(this.h[2], D, Eh);
    this.h[2] = $b581c4c921625495$var$sum32_3(this.h[3], E, Ah);
    this.h[3] = $b581c4c921625495$var$sum32_3(this.h[4], A, Bh);
    this.h[4] = $b581c4c921625495$var$sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
};
$b581c4c921625495$var$RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === "hex") return $f6hkv.toHex32(this.h, "little");
    else return $f6hkv.split32(this.h, "little");
};
function $b581c4c921625495$var$f(j, x, y, z) {
    if (j <= 15) return x ^ y ^ z;
    else if (j <= 31) return x & y | ~x & z;
    else if (j <= 47) return (x | ~y) ^ z;
    else if (j <= 63) return x & z | y & ~z;
    else return x ^ (y | ~z);
}
function $b581c4c921625495$var$K(j) {
    if (j <= 15) return 0x00000000;
    else if (j <= 31) return 0x5a827999;
    else if (j <= 47) return 0x6ed9eba1;
    else if (j <= 63) return 0x8f1bbcdc;
    else return 0xa953fd4e;
}
function $b581c4c921625495$var$Kh(j) {
    if (j <= 15) return 0x50a28be6;
    else if (j <= 31) return 0x5c4dd124;
    else if (j <= 47) return 0x6d703ef3;
    else if (j <= 63) return 0x7a6d76e9;
    else return 0x00000000;
}
var $b581c4c921625495$var$r = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
];
var $b581c4c921625495$var$rh = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
];
var $b581c4c921625495$var$s = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
];
var $b581c4c921625495$var$sh = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
];

});

parcelRequire.register("lHUXq", function(module, exports) {
"use strict";

var $f6hkv = parcelRequire("f6hkv");

var $lBpFJ = parcelRequire("lBpFJ");
function $fcd9cbb5cfdd6e84$var$Hmac(hash, key, enc) {
    if (!(this instanceof $fcd9cbb5cfdd6e84$var$Hmac)) return new $fcd9cbb5cfdd6e84$var$Hmac(hash, key, enc);
    this.Hash = hash;
    this.blockSize = hash.blockSize / 8;
    this.outSize = hash.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init($f6hkv.toArray(key, enc));
}
module.exports = $fcd9cbb5cfdd6e84$var$Hmac;
$fcd9cbb5cfdd6e84$var$Hmac.prototype._init = function init(key) {
    // Shorten key, if needed
    if (key.length > this.blockSize) key = new this.Hash().update(key).digest();
    $lBpFJ(key.length <= this.blockSize);
    // Add padding to key
    for(var i = key.length; i < this.blockSize; i++)key.push(0);
    for(i = 0; i < key.length; i++)key[i] ^= 0x36;
    this.inner = new this.Hash().update(key);
    // 0x36 ^ 0x5c = 0x6a
    for(i = 0; i < key.length; i++)key[i] ^= 0x6a;
    this.outer = new this.Hash().update(key);
};
$fcd9cbb5cfdd6e84$var$Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
};
$fcd9cbb5cfdd6e84$var$Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
};

});


parcelRequire.register("6GYzO", function(module, exports) {
module.exports = {
    doubles: {
        step: 4,
        points: [
            [
                "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
                "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
            ],
            [
                "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
                "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
            ],
            [
                "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
                "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
            ],
            [
                "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
                "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
            ],
            [
                "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
                "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
            ],
            [
                "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
                "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
            ],
            [
                "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
                "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
            ],
            [
                "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
                "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
            ],
            [
                "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
                "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
            ],
            [
                "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
                "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
            ],
            [
                "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
                "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
            ],
            [
                "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
                "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
            ],
            [
                "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
                "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
            ],
            [
                "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
                "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
            ],
            [
                "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
                "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
            ],
            [
                "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
                "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
            ],
            [
                "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
                "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
            ],
            [
                "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
                "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
            ],
            [
                "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
                "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
            ],
            [
                "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
                "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
            ],
            [
                "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
                "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
            ],
            [
                "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
                "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
            ],
            [
                "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
                "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
            ],
            [
                "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
                "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
            ],
            [
                "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
                "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
            ],
            [
                "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
                "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
            ],
            [
                "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
                "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
            ],
            [
                "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
                "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
            ],
            [
                "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
                "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
            ],
            [
                "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
                "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
            ],
            [
                "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
                "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
            ],
            [
                "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
                "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
            ],
            [
                "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
                "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
            ],
            [
                "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
                "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
            ],
            [
                "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
                "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
            ],
            [
                "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
                "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
            ],
            [
                "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
                "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
            ],
            [
                "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
                "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
            ],
            [
                "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
                "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
            ],
            [
                "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
                "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
            ],
            [
                "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
                "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
            ],
            [
                "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
                "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
            ],
            [
                "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
                "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
            ],
            [
                "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
                "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
            ],
            [
                "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
                "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
            ],
            [
                "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
                "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
            ],
            [
                "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
                "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
            ],
            [
                "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
                "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
            ],
            [
                "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
                "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
            ],
            [
                "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
                "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
            ],
            [
                "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
                "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
            ],
            [
                "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
                "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
            ],
            [
                "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
                "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
            ],
            [
                "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
                "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
            ],
            [
                "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
                "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
            ],
            [
                "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
                "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
            ],
            [
                "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
                "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
            ],
            [
                "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
                "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
            ],
            [
                "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
                "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
            ],
            [
                "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
                "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
            ],
            [
                "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
                "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
            ],
            [
                "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
                "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
            ],
            [
                "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
                "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
            ],
            [
                "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
                "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
            ],
            [
                "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
                "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
            ]
        ]
    },
    naf: {
        wnd: 7,
        points: [
            [
                "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
                "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
            ],
            [
                "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
                "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
            ],
            [
                "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
                "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
            ],
            [
                "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
                "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
            ],
            [
                "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
                "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
            ],
            [
                "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
                "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
            ],
            [
                "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
                "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
            ],
            [
                "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
                "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
            ],
            [
                "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
                "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
            ],
            [
                "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
                "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
            ],
            [
                "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
                "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
            ],
            [
                "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
                "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
            ],
            [
                "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
                "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
            ],
            [
                "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
                "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
            ],
            [
                "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
                "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
            ],
            [
                "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
                "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
            ],
            [
                "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
                "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
            ],
            [
                "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
                "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
            ],
            [
                "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
                "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
            ],
            [
                "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
                "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
            ],
            [
                "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
                "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
            ],
            [
                "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
                "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
            ],
            [
                "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
                "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
            ],
            [
                "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
                "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
            ],
            [
                "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
                "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
            ],
            [
                "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
                "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
            ],
            [
                "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
                "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
            ],
            [
                "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
                "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
            ],
            [
                "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
                "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
            ],
            [
                "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
                "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
            ],
            [
                "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
                "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
            ],
            [
                "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
                "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
            ],
            [
                "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
                "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
            ],
            [
                "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
                "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
            ],
            [
                "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
                "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
            ],
            [
                "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
                "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
            ],
            [
                "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
                "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
            ],
            [
                "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
                "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
            ],
            [
                "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
                "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
            ],
            [
                "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
                "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
            ],
            [
                "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
                "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
            ],
            [
                "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
                "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
            ],
            [
                "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
                "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
            ],
            [
                "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
                "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
            ],
            [
                "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
                "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
            ],
            [
                "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
                "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
            ],
            [
                "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
                "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
            ],
            [
                "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
                "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
            ],
            [
                "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
                "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
            ],
            [
                "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
                "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
            ],
            [
                "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
                "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
            ],
            [
                "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
                "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
            ],
            [
                "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
                "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
            ],
            [
                "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
                "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
            ],
            [
                "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
                "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
            ],
            [
                "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
                "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
            ],
            [
                "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
                "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
            ],
            [
                "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
                "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
            ],
            [
                "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
                "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
            ],
            [
                "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
                "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
            ],
            [
                "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
                "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
            ],
            [
                "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
                "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
            ],
            [
                "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
                "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
            ],
            [
                "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
                "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
            ],
            [
                "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
                "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
            ],
            [
                "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
                "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
            ],
            [
                "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
                "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
            ],
            [
                "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
                "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
            ],
            [
                "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
                "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
            ],
            [
                "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
                "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
            ],
            [
                "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
                "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
            ],
            [
                "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
                "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
            ],
            [
                "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
                "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
            ],
            [
                "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
                "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
            ],
            [
                "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
                "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
            ],
            [
                "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
                "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
            ],
            [
                "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
                "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
            ],
            [
                "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
                "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
            ],
            [
                "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
                "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
            ],
            [
                "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
                "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
            ],
            [
                "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
                "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
            ],
            [
                "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
                "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
            ],
            [
                "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
                "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
            ],
            [
                "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
                "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
            ],
            [
                "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
                "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
            ],
            [
                "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
                "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
            ],
            [
                "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
                "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
            ],
            [
                "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
                "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
            ],
            [
                "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
                "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
            ],
            [
                "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
                "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
            ],
            [
                "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
                "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
            ],
            [
                "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
                "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
            ],
            [
                "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
                "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
            ],
            [
                "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
                "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
            ],
            [
                "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
                "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
            ],
            [
                "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
                "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
            ],
            [
                "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
                "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
            ],
            [
                "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
                "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
            ],
            [
                "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
                "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
            ],
            [
                "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
                "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
            ],
            [
                "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
                "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
            ],
            [
                "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
                "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
            ],
            [
                "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
                "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
            ],
            [
                "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
                "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
            ],
            [
                "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
                "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
            ],
            [
                "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
                "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
            ],
            [
                "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
                "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
            ],
            [
                "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
                "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
            ],
            [
                "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
                "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
            ],
            [
                "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
                "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
            ],
            [
                "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
                "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
            ],
            [
                "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
                "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
            ],
            [
                "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
                "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
            ],
            [
                "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
                "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
            ],
            [
                "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
                "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
            ],
            [
                "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
                "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
            ],
            [
                "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
                "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
            ],
            [
                "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
                "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
            ],
            [
                "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
                "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
            ],
            [
                "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
                "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
            ],
            [
                "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
                "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
            ],
            [
                "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
                "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
            ],
            [
                "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
                "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
            ],
            [
                "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
                "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
            ],
            [
                "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
                "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
            ],
            [
                "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
                "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
            ],
            [
                "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
                "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
            ]
        ]
    }
};

});


parcelRequire.register("ic6Nr", function(module, exports) {
"use strict";

var $kcp1M = parcelRequire("kcp1M");

var $5iiUd = parcelRequire("5iiUd");

var $jQJy0 = parcelRequire("jQJy0");

var $h9Ptd = parcelRequire("h9Ptd");

var $aXpSo = parcelRequire("aXpSo");
var $d3ee9ea20b439b39$var$assert = $jQJy0.assert;

var $7u2ms = parcelRequire("7u2ms");

var $h1ZNp = parcelRequire("h1ZNp");
function $d3ee9ea20b439b39$var$EC(options) {
    if (!(this instanceof $d3ee9ea20b439b39$var$EC)) return new $d3ee9ea20b439b39$var$EC(options);
    // Shortcut `elliptic.ec(curve-name)`
    if (typeof options === "string") {
        $d3ee9ea20b439b39$var$assert(Object.prototype.hasOwnProperty.call($h9Ptd, options), "Unknown curve " + options);
        options = $h9Ptd[options];
    }
    // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
    if (options instanceof $h9Ptd.PresetCurve) options = {
        curve: options
    };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    // Point on curve
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    // Hash for function for DRBG
    this.hash = options.hash || options.curve.hash;
}
module.exports = $d3ee9ea20b439b39$var$EC;
$d3ee9ea20b439b39$var$EC.prototype.keyPair = function keyPair(options) {
    return new $7u2ms(this, options);
};
$d3ee9ea20b439b39$var$EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return $7u2ms.fromPrivate(this, priv, enc);
};
$d3ee9ea20b439b39$var$EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return $7u2ms.fromPublic(this, pub, enc);
};
$d3ee9ea20b439b39$var$EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options) options = {};
    // Instantiate Hmac_DRBG
    var drbg = new $5iiUd({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || $aXpSo(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
    });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new $kcp1M(2));
    for(;;){
        var priv = new $kcp1M(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0) continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
    }
};
$d3ee9ea20b439b39$var$EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0) msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);
    else return msg;
};
$d3ee9ea20b439b39$var$EC.prototype.sign = function sign(msg, key, enc, options) {
    if (typeof enc === "object") {
        options = enc;
        enc = null;
    }
    if (!options) options = {};
    key = this.keyFromPrivate(key, enc);
    msg = this._truncateToN(new $kcp1M(msg, 16));
    // Zero-extend key to provide enough entropy
    var bytes = this.n.byteLength();
    var bkey = key.getPrivate().toArray("be", bytes);
    // Zero-extend nonce to have the same byte size as N
    var nonce = msg.toArray("be", bytes);
    // Instantiate Hmac_DRBG
    var drbg = new $5iiUd({
        hash: this.hash,
        entropy: bkey,
        nonce: nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
    });
    // Number of bytes to generate
    var ns1 = this.n.sub(new $kcp1M(1));
    for(var iter = 0;; iter++){
        var k = options.k ? options.k(iter) : new $kcp1M(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity()) continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0) continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0) continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        // Use complement of `s`, if it is > `n / 2`
        if (options.canonical && s.cmp(this.nh) > 0) {
            s = this.n.sub(s);
            recoveryParam ^= 1;
        }
        return new $h1ZNp({
            r: r,
            s: s,
            recoveryParam: recoveryParam
        });
    }
};
$d3ee9ea20b439b39$var$EC.prototype.verify = function verify(msg, signature, key, enc) {
    msg = this._truncateToN(new $kcp1M(msg, 16));
    key = this.keyFromPublic(key, enc);
    signature = new $h1ZNp(signature, "hex");
    // Perform primitive values validation
    var r = signature.r;
    var s = signature.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false;
    // Validate signature
    var sinv = s.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r).umod(this.n);
    var p;
    if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity()) return false;
        return p.getX().umod(this.n).cmp(r) === 0;
    }
    // NOTE: Greg Maxwell's trick, inspired by:
    // https://git.io/vad3K
    p = this.g.jmulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity()) return false;
    // Compare `p.x` of Jacobian point with `r`,
    // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
    // inverse of `p.z^2`
    return p.eqXToP(r);
};
$d3ee9ea20b439b39$var$EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
    $d3ee9ea20b439b39$var$assert((3 & j) === j, "The recovery param is more than two bits");
    signature = new $h1ZNp(signature, enc);
    var n = this.n;
    var e = new $kcp1M(msg);
    var r = signature.r;
    var s = signature.s;
    // A set LSB signifies that the y-coordinate is odd
    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error("Unable to find sencond key candinate");
    // 1.1. Let x = r + jn.
    if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
    else r = this.curve.pointFromX(r, isYOdd);
    var rInv = signature.r.invm(n);
    var s1 = n.sub(e).mul(rInv).umod(n);
    var s2 = s.mul(rInv).umod(n);
    // 1.6.1 Compute Q = r^-1 (sR -  eG)
    //               Q = r^-1 (sR + -eG)
    return this.g.mulAdd(s1, r, s2);
};
$d3ee9ea20b439b39$var$EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
    signature = new $h1ZNp(signature, enc);
    if (signature.recoveryParam !== null) return signature.recoveryParam;
    for(var i = 0; i < 4; i++){
        var Qprime;
        try {
            Qprime = this.recoverPubKey(e, signature, i);
        } catch (e1) {
            continue;
        }
        if (Qprime.eq(Q)) return i;
    }
    throw new Error("Unable to find valid recovery factor");
};

});
parcelRequire.register("5iiUd", function(module, exports) {
"use strict";

var $gnkvn = parcelRequire("gnkvn");

var $kXo4G = parcelRequire("kXo4G");

var $lBpFJ = parcelRequire("lBpFJ");
function $3dad4c7b9c379fb1$var$HmacDRBG(options) {
    if (!(this instanceof $3dad4c7b9c379fb1$var$HmacDRBG)) return new $3dad4c7b9c379fb1$var$HmacDRBG(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = $kXo4G.toArray(options.entropy, options.entropyEnc || "hex");
    var nonce = $kXo4G.toArray(options.nonce, options.nonceEnc || "hex");
    var pers = $kXo4G.toArray(options.pers, options.persEnc || "hex");
    $lBpFJ(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._init(entropy, nonce, pers);
}
module.exports = $3dad4c7b9c379fb1$var$HmacDRBG;
$3dad4c7b9c379fb1$var$HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for(var i = 0; i < this.V.length; i++){
        this.K[i] = 0x00;
        this.V[i] = 0x01;
    }
    this._update(seed);
    this._reseed = 1;
    this.reseedInterval = 0x1000000000000; // 2^48
};
$3dad4c7b9c379fb1$var$HmacDRBG.prototype._hmac = function hmac() {
    return new $gnkvn.hmac(this.hash, this.K);
};
$3dad4c7b9c379fb1$var$HmacDRBG.prototype._update = function update(seed) {
    var kmac = this._hmac().update(this.V).update([
        0x00
    ]);
    if (seed) kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed) return;
    this.K = this._hmac().update(this.V).update([
        0x01
    ]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
};
$3dad4c7b9c379fb1$var$HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    // Optional entropy enc
    if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
    }
    entropy = $kXo4G.toArray(entropy, entropyEnc);
    add = $kXo4G.toArray(add, addEnc);
    $lBpFJ(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._update(entropy.concat(add || []));
    this._reseed = 1;
};
$3dad4c7b9c379fb1$var$HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
    if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
    // Optional encoding
    if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
    }
    // Optional additional data
    if (add) {
        add = $kXo4G.toArray(add, addEnc || "hex");
        this._update(add);
    }
    var temp = [];
    while(temp.length < len){
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len);
    this._update(add);
    this._reseed++;
    return $kXo4G.encode(res, enc);
};

});

parcelRequire.register("7u2ms", function(module, exports) {
"use strict";

var $kcp1M = parcelRequire("kcp1M");

var $jQJy0 = parcelRequire("jQJy0");
var $572d2aa2e8ed6478$var$assert = $jQJy0.assert;
function $572d2aa2e8ed6478$var$KeyPair(ec, options) {
    this.ec = ec;
    this.priv = null;
    this.pub = null;
    // KeyPair(ec, { priv: ..., pub: ... })
    if (options.priv) this._importPrivate(options.priv, options.privEnc);
    if (options.pub) this._importPublic(options.pub, options.pubEnc);
}
module.exports = $572d2aa2e8ed6478$var$KeyPair;
$572d2aa2e8ed6478$var$KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
    if (pub instanceof $572d2aa2e8ed6478$var$KeyPair) return pub;
    return new $572d2aa2e8ed6478$var$KeyPair(ec, {
        pub: pub,
        pubEnc: enc
    });
};
$572d2aa2e8ed6478$var$KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
    if (priv instanceof $572d2aa2e8ed6478$var$KeyPair) return priv;
    return new $572d2aa2e8ed6478$var$KeyPair(ec, {
        priv: priv,
        privEnc: enc
    });
};
$572d2aa2e8ed6478$var$KeyPair.prototype.validate = function validate() {
    var pub = this.getPublic();
    if (pub.isInfinity()) return {
        result: false,
        reason: "Invalid public key"
    };
    if (!pub.validate()) return {
        result: false,
        reason: "Public key is not a point"
    };
    if (!pub.mul(this.ec.curve.n).isInfinity()) return {
        result: false,
        reason: "Public key * N != O"
    };
    return {
        result: true,
        reason: null
    };
};
$572d2aa2e8ed6478$var$KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    // compact is optional argument
    if (typeof compact === "string") {
        enc = compact;
        compact = null;
    }
    if (!this.pub) this.pub = this.ec.g.mul(this.priv);
    if (!enc) return this.pub;
    return this.pub.encode(enc, compact);
};
$572d2aa2e8ed6478$var$KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === "hex") return this.priv.toString(16, 2);
    else return this.priv;
};
$572d2aa2e8ed6478$var$KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
    this.priv = new $kcp1M(key, enc || 16);
    // Ensure that the priv won't be bigger than n, otherwise we may fail
    // in fixed multiplication method
    this.priv = this.priv.umod(this.ec.curve.n);
};
$572d2aa2e8ed6478$var$KeyPair.prototype._importPublic = function _importPublic(key, enc) {
    if (key.x || key.y) {
        // Montgomery points only have an `x` coordinate.
        // Weierstrass/Edwards points on the other hand have both `x` and
        // `y` coordinates.
        if (this.ec.curve.type === "mont") $572d2aa2e8ed6478$var$assert(key.x, "Need x coordinate");
        else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") $572d2aa2e8ed6478$var$assert(key.x && key.y, "Need both x and y coordinate");
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
    }
    this.pub = this.ec.curve.decodePoint(key, enc);
};
// ECDH
$572d2aa2e8ed6478$var$KeyPair.prototype.derive = function derive(pub) {
    if (!pub.validate()) $572d2aa2e8ed6478$var$assert(pub.validate(), "public point not validated");
    return pub.mul(this.priv).getX();
};
// ECDSA
$572d2aa2e8ed6478$var$KeyPair.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
};
$572d2aa2e8ed6478$var$KeyPair.prototype.verify = function verify(msg, signature) {
    return this.ec.verify(msg, signature, this);
};
$572d2aa2e8ed6478$var$KeyPair.prototype.inspect = function inspect() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};

});

parcelRequire.register("h1ZNp", function(module, exports) {
"use strict";

var $kcp1M = parcelRequire("kcp1M");

var $jQJy0 = parcelRequire("jQJy0");
var $c66277089bf11bcd$var$assert = $jQJy0.assert;
function $c66277089bf11bcd$var$Signature(options, enc) {
    if (options instanceof $c66277089bf11bcd$var$Signature) return options;
    if (this._importDER(options, enc)) return;
    $c66277089bf11bcd$var$assert(options.r && options.s, "Signature without r or s");
    this.r = new $kcp1M(options.r, 16);
    this.s = new $kcp1M(options.s, 16);
    if (options.recoveryParam === undefined) this.recoveryParam = null;
    else this.recoveryParam = options.recoveryParam;
}
module.exports = $c66277089bf11bcd$var$Signature;
function $c66277089bf11bcd$var$Position() {
    this.place = 0;
}
function $c66277089bf11bcd$var$getLength(buf, p) {
    var initial = buf[p.place++];
    if (!(initial & 0x80)) return initial;
    var octetLen = initial & 0xf;
    // Indefinite length or overflow
    if (octetLen === 0 || octetLen > 4) return false;
    var val = 0;
    for(var i = 0, off = p.place; i < octetLen; i++, off++){
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
    }
    // Leading zeroes
    if (val <= 0x7f) return false;
    p.place = off;
    return val;
}
function $c66277089bf11bcd$var$rmPadding(buf) {
    var i = 0;
    var len = buf.length - 1;
    while(!buf[i] && !(buf[i + 1] & 0x80) && i < len)i++;
    if (i === 0) return buf;
    return buf.slice(i);
}
$c66277089bf11bcd$var$Signature.prototype._importDER = function _importDER(data, enc) {
    data = $jQJy0.toArray(data, enc);
    var p = new $c66277089bf11bcd$var$Position();
    if (data[p.place++] !== 0x30) return false;
    var len = $c66277089bf11bcd$var$getLength(data, p);
    if (len === false) return false;
    if (len + p.place !== data.length) return false;
    if (data[p.place++] !== 0x02) return false;
    var rlen = $c66277089bf11bcd$var$getLength(data, p);
    if (rlen === false) return false;
    var r = data.slice(p.place, rlen + p.place);
    p.place += rlen;
    if (data[p.place++] !== 0x02) return false;
    var slen = $c66277089bf11bcd$var$getLength(data, p);
    if (slen === false) return false;
    if (data.length !== slen + p.place) return false;
    var s = data.slice(p.place, slen + p.place);
    if (r[0] === 0) {
        if (r[1] & 0x80) r = r.slice(1);
        else // Leading zeroes
        return false;
    }
    if (s[0] === 0) {
        if (s[1] & 0x80) s = s.slice(1);
        else // Leading zeroes
        return false;
    }
    this.r = new $kcp1M(r);
    this.s = new $kcp1M(s);
    this.recoveryParam = null;
    return true;
};
function $c66277089bf11bcd$var$constructLength(arr, len) {
    if (len < 0x80) {
        arr.push(len);
        return;
    }
    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 0x80);
    while(--octets)arr.push(len >>> (octets << 3) & 0xff);
    arr.push(len);
}
$c66277089bf11bcd$var$Signature.prototype.toDER = function toDER(enc) {
    var r = this.r.toArray();
    var s = this.s.toArray();
    // Pad values
    if (r[0] & 0x80) r = [
        0
    ].concat(r);
    // Pad values
    if (s[0] & 0x80) s = [
        0
    ].concat(s);
    r = $c66277089bf11bcd$var$rmPadding(r);
    s = $c66277089bf11bcd$var$rmPadding(s);
    while(!s[0] && !(s[1] & 0x80))s = s.slice(1);
    var arr = [
        0x02
    ];
    $c66277089bf11bcd$var$constructLength(arr, r.length);
    arr = arr.concat(r);
    arr.push(0x02);
    $c66277089bf11bcd$var$constructLength(arr, s.length);
    var backHalf = arr.concat(s);
    var res = [
        0x30
    ];
    $c66277089bf11bcd$var$constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return $jQJy0.encode(res, enc);
};

});


parcelRequire.register("5ThYo", function(module, exports) {
"use strict";

var $gnkvn = parcelRequire("gnkvn");

var $h9Ptd = parcelRequire("h9Ptd");

var $jQJy0 = parcelRequire("jQJy0");
var $44a007e1a4045e3f$var$assert = $jQJy0.assert;
var $44a007e1a4045e3f$var$parseBytes = $jQJy0.parseBytes;

var $4lvgC = parcelRequire("4lvgC");

var $5qf7t = parcelRequire("5qf7t");
function $44a007e1a4045e3f$var$EDDSA(curve) {
    $44a007e1a4045e3f$var$assert(curve === "ed25519", "only tested with ed25519 so far");
    if (!(this instanceof $44a007e1a4045e3f$var$EDDSA)) return new $44a007e1a4045e3f$var$EDDSA(curve);
    curve = $h9Ptd[curve].curve;
    this.curve = curve;
    this.g = curve.g;
    this.g.precompute(curve.n.bitLength() + 1);
    this.pointClass = curve.point().constructor;
    this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
    this.hash = $gnkvn.sha512;
}
module.exports = $44a007e1a4045e3f$var$EDDSA;
/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/ $44a007e1a4045e3f$var$EDDSA.prototype.sign = function sign(message, secret) {
    message = $44a007e1a4045e3f$var$parseBytes(message);
    var key = this.keyFromSecret(secret);
    var r = this.hashInt(key.messagePrefix(), message);
    var R = this.g.mul(r);
    var Rencoded = this.encodePoint(R);
    var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
    var S = r.add(s_).umod(this.curve.n);
    return this.makeSignature({
        R: R,
        S: S,
        Rencoded: Rencoded
    });
};
/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/ $44a007e1a4045e3f$var$EDDSA.prototype.verify = function verify(message, sig, pub) {
    message = $44a007e1a4045e3f$var$parseBytes(message);
    sig = this.makeSignature(sig);
    var key = this.keyFromPublic(pub);
    var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key.pub().mul(h));
    return RplusAh.eq(SG);
};
$44a007e1a4045e3f$var$EDDSA.prototype.hashInt = function hashInt() {
    var hash = this.hash();
    for(var i = 0; i < arguments.length; i++)hash.update(arguments[i]);
    return $jQJy0.intFromLE(hash.digest()).umod(this.curve.n);
};
$44a007e1a4045e3f$var$EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    return $4lvgC.fromPublic(this, pub);
};
$44a007e1a4045e3f$var$EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    return $4lvgC.fromSecret(this, secret);
};
$44a007e1a4045e3f$var$EDDSA.prototype.makeSignature = function makeSignature(sig) {
    if (sig instanceof $5qf7t) return sig;
    return new $5qf7t(this, sig);
};
/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/ $44a007e1a4045e3f$var$EDDSA.prototype.encodePoint = function encodePoint(point) {
    var enc = point.getY().toArray("le", this.encodingLength);
    enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
    return enc;
};
$44a007e1a4045e3f$var$EDDSA.prototype.decodePoint = function decodePoint(bytes) {
    bytes = $jQJy0.parseBytes(bytes);
    var lastIx = bytes.length - 1;
    var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & -129);
    var xIsOdd = (bytes[lastIx] & 0x80) !== 0;
    var y = $jQJy0.intFromLE(normed);
    return this.curve.pointFromY(y, xIsOdd);
};
$44a007e1a4045e3f$var$EDDSA.prototype.encodeInt = function encodeInt(num) {
    return num.toArray("le", this.encodingLength);
};
$44a007e1a4045e3f$var$EDDSA.prototype.decodeInt = function decodeInt(bytes) {
    return $jQJy0.intFromLE(bytes);
};
$44a007e1a4045e3f$var$EDDSA.prototype.isPoint = function isPoint(val) {
    return val instanceof this.pointClass;
};

});
parcelRequire.register("4lvgC", function(module, exports) {
"use strict";

var $jQJy0 = parcelRequire("jQJy0");
var $32a160971b42ca19$var$assert = $jQJy0.assert;
var $32a160971b42ca19$var$parseBytes = $jQJy0.parseBytes;
var $32a160971b42ca19$var$cachedProperty = $jQJy0.cachedProperty;
/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/ function $32a160971b42ca19$var$KeyPair(eddsa, params) {
    this.eddsa = eddsa;
    this._secret = $32a160971b42ca19$var$parseBytes(params.secret);
    if (eddsa.isPoint(params.pub)) this._pub = params.pub;
    else this._pubBytes = $32a160971b42ca19$var$parseBytes(params.pub);
}
$32a160971b42ca19$var$KeyPair.fromPublic = function fromPublic(eddsa, pub) {
    if (pub instanceof $32a160971b42ca19$var$KeyPair) return pub;
    return new $32a160971b42ca19$var$KeyPair(eddsa, {
        pub: pub
    });
};
$32a160971b42ca19$var$KeyPair.fromSecret = function fromSecret(eddsa, secret) {
    if (secret instanceof $32a160971b42ca19$var$KeyPair) return secret;
    return new $32a160971b42ca19$var$KeyPair(eddsa, {
        secret: secret
    });
};
$32a160971b42ca19$var$KeyPair.prototype.secret = function secret() {
    return this._secret;
};
$32a160971b42ca19$var$cachedProperty($32a160971b42ca19$var$KeyPair, "pubBytes", function pubBytes() {
    return this.eddsa.encodePoint(this.pub());
});
$32a160971b42ca19$var$cachedProperty($32a160971b42ca19$var$KeyPair, "pub", function pub() {
    if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
});
$32a160971b42ca19$var$cachedProperty($32a160971b42ca19$var$KeyPair, "privBytes", function privBytes() {
    var eddsa = this.eddsa;
    var hash = this.hash();
    var lastIx = eddsa.encodingLength - 1;
    var a = hash.slice(0, eddsa.encodingLength);
    a[0] &= 248;
    a[lastIx] &= 127;
    a[lastIx] |= 64;
    return a;
});
$32a160971b42ca19$var$cachedProperty($32a160971b42ca19$var$KeyPair, "priv", function priv() {
    return this.eddsa.decodeInt(this.privBytes());
});
$32a160971b42ca19$var$cachedProperty($32a160971b42ca19$var$KeyPair, "hash", function hash() {
    return this.eddsa.hash().update(this.secret()).digest();
});
$32a160971b42ca19$var$cachedProperty($32a160971b42ca19$var$KeyPair, "messagePrefix", function messagePrefix() {
    return this.hash().slice(this.eddsa.encodingLength);
});
$32a160971b42ca19$var$KeyPair.prototype.sign = function sign(message) {
    $32a160971b42ca19$var$assert(this._secret, "KeyPair can only verify");
    return this.eddsa.sign(message, this);
};
$32a160971b42ca19$var$KeyPair.prototype.verify = function verify(message, sig) {
    return this.eddsa.verify(message, sig, this);
};
$32a160971b42ca19$var$KeyPair.prototype.getSecret = function getSecret(enc) {
    $32a160971b42ca19$var$assert(this._secret, "KeyPair is public only");
    return $jQJy0.encode(this.secret(), enc);
};
$32a160971b42ca19$var$KeyPair.prototype.getPublic = function getPublic(enc) {
    return $jQJy0.encode(this.pubBytes(), enc);
};
module.exports = $32a160971b42ca19$var$KeyPair;

});

parcelRequire.register("5qf7t", function(module, exports) {
"use strict";

var $kcp1M = parcelRequire("kcp1M");

var $jQJy0 = parcelRequire("jQJy0");
var $3f2b1be70e411e92$var$assert = $jQJy0.assert;
var $3f2b1be70e411e92$var$cachedProperty = $jQJy0.cachedProperty;
var $3f2b1be70e411e92$var$parseBytes = $jQJy0.parseBytes;
/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/ function $3f2b1be70e411e92$var$Signature(eddsa, sig) {
    this.eddsa = eddsa;
    if (typeof sig !== "object") sig = $3f2b1be70e411e92$var$parseBytes(sig);
    if (Array.isArray(sig)) sig = {
        R: sig.slice(0, eddsa.encodingLength),
        S: sig.slice(eddsa.encodingLength)
    };
    $3f2b1be70e411e92$var$assert(sig.R && sig.S, "Signature without R or S");
    if (eddsa.isPoint(sig.R)) this._R = sig.R;
    if (sig.S instanceof $kcp1M) this._S = sig.S;
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}
$3f2b1be70e411e92$var$cachedProperty($3f2b1be70e411e92$var$Signature, "S", function S() {
    return this.eddsa.decodeInt(this.Sencoded());
});
$3f2b1be70e411e92$var$cachedProperty($3f2b1be70e411e92$var$Signature, "R", function R() {
    return this.eddsa.decodePoint(this.Rencoded());
});
$3f2b1be70e411e92$var$cachedProperty($3f2b1be70e411e92$var$Signature, "Rencoded", function Rencoded() {
    return this.eddsa.encodePoint(this.R());
});
$3f2b1be70e411e92$var$cachedProperty($3f2b1be70e411e92$var$Signature, "Sencoded", function Sencoded() {
    return this.eddsa.encodeInt(this.S());
});
$3f2b1be70e411e92$var$Signature.prototype.toBytes = function toBytes() {
    return this.Rencoded().concat(this.Sencoded());
};
$3f2b1be70e411e92$var$Signature.prototype.toHex = function toHex() {
    return $jQJy0.encode(this.toBytes(), "hex").toUpperCase();
};
module.exports = $3f2b1be70e411e92$var$Signature;

});




parcelRequire.register("217RI", function(module, exports) {

var $1781c6a55725cdc8$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $iDkJI = parcelRequire("iDkJI");

var $jk7hO = parcelRequire("jk7hO");

var $2EPYC = parcelRequire("2EPYC");

var $aYsCb = parcelRequire("aYsCb");
var $1781c6a55725cdc8$var$Signature = function r(e, t) {
    if (!(this instanceof r)) return new r(e, t);
    if (e instanceof $iDkJI) this.set({
        r: e,
        s: t
    });
    else if (e) {
        var n = e;
        this.set(n);
    }
};
$1781c6a55725cdc8$var$Signature.prototype.set = function(r) {
    return this.r = r.r || this.r || void 0, this.s = r.s || this.s || void 0, this.i = void 0 !== r.i ? r.i : this.i, this.compressed = void 0 !== r.compressed ? r.compressed : this.compressed, this.nhashtype = r.nhashtype || this.nhashtype || void 0, this;
}, $1781c6a55725cdc8$var$Signature.fromCompact = function(r) {
    $2EPYC.checkArgument($1781c6a55725cdc8$require$Buffer.isBuffer(r), "Argument is expected to be a Buffer");
    var e = new $1781c6a55725cdc8$var$Signature, t = !0, n = r.slice(0, 1)[0] - 27 - 4;
    n < 0 && (t = !1, n += 4);
    var i = r.slice(1, 33), u = r.slice(33, 65);
    return $2EPYC.checkArgument(0 === n || 1 === n || 2 === n || 3 === n, new Error("i must be 0, 1, 2, or 3")), $2EPYC.checkArgument(32 === i.length, new Error("r must be 32 bytes")), $2EPYC.checkArgument(32 === u.length, new Error("s must be 32 bytes")), e.compressed = t, e.i = n, e.r = $iDkJI.fromBuffer(i), e.s = $iDkJI.fromBuffer(u), e;
}, $1781c6a55725cdc8$var$Signature.fromDER = $1781c6a55725cdc8$var$Signature.fromBuffer = function(r, e) {
    var t = $1781c6a55725cdc8$var$Signature.parseDER(r, e), n = new $1781c6a55725cdc8$var$Signature;
    return n.r = t.r, n.s = t.s, n;
}, $1781c6a55725cdc8$var$Signature.fromTxFormat = function(r) {
    var e = r.readUInt8(r.length - 1), t = r.slice(0, r.length - 1), n = $1781c6a55725cdc8$var$Signature.fromDER(t, !1);
    return n.nhashtype = e, n;
}, $1781c6a55725cdc8$var$Signature.fromString = function(r) {
    var e = $1781c6a55725cdc8$require$Buffer.from(r, "hex");
    return $1781c6a55725cdc8$var$Signature.fromDER(e);
}, $1781c6a55725cdc8$var$Signature.parseDER = function(r, e) {
    $2EPYC.checkArgument($1781c6a55725cdc8$require$Buffer.isBuffer(r), new Error("DER formatted signature should be a buffer")), $jk7hO.isUndefined(e) && (e = !0);
    var t = r[0];
    $2EPYC.checkArgument(48 === t, new Error("Header byte should be 0x30"));
    var n = r[1], i = r.slice(2).length;
    $2EPYC.checkArgument(!e || n === i, new Error("Length byte should length of what follows")), n = n < i ? n : i;
    var u = r[2];
    $2EPYC.checkArgument(2 === u, new Error("Integer byte for r should be 0x02"));
    var o = r[3], f = r.slice(4, 4 + o), s = $iDkJI.fromBuffer(f), a = 0 === r[4];
    $2EPYC.checkArgument(o === f.length, new Error("Length of r incorrect"));
    var h = r[4 + o + 0];
    $2EPYC.checkArgument(2 === h, new Error("Integer byte for s should be 0x02"));
    var c = r[4 + o + 1], g = r.slice(4 + o + 2, 4 + o + 2 + c), S = $iDkJI.fromBuffer(g), m = 0 === r[4 + o + 2 + 2];
    $2EPYC.checkArgument(c === g.length, new Error("Length of s incorrect"));
    var l = 4 + o + 2 + c;
    return $2EPYC.checkArgument(n === l - 2, new Error("Length of signature incorrect")), {
        header: t,
        length: n,
        rheader: u,
        rlength: o,
        rneg: a,
        rbuf: f,
        r: s,
        sheader: h,
        slength: c,
        sneg: m,
        sbuf: g,
        s: S
    };
}, $1781c6a55725cdc8$var$Signature.prototype.toCompact = function(r, e) {
    if (r = "number" == typeof r ? r : this.i, e = "boolean" == typeof e ? e : this.compressed, 0 !== r && 1 !== r && 2 !== r && 3 !== r) throw new Error("i must be equal to 0, 1, 2, or 3");
    var t = r + 27 + 4;
    !1 === e && (t -= 4);
    var n = $1781c6a55725cdc8$require$Buffer.from([
        t
    ]), i = this.r.toBuffer({
        size: 32
    }), u = this.s.toBuffer({
        size: 32
    });
    return $1781c6a55725cdc8$require$Buffer.concat([
        n,
        i,
        u
    ]);
}, $1781c6a55725cdc8$var$Signature.prototype.toBuffer = $1781c6a55725cdc8$var$Signature.prototype.toDER = function() {
    var r = this.r.toBuffer(), e = this.s.toBuffer(), t = !!(128 & r[0]), n = !!(128 & e[0]), i = t ? $1781c6a55725cdc8$require$Buffer.concat([
        $1781c6a55725cdc8$require$Buffer.from([
            0
        ]),
        r
    ]) : r, u = n ? $1781c6a55725cdc8$require$Buffer.concat([
        $1781c6a55725cdc8$require$Buffer.from([
            0
        ]),
        e
    ]) : e, o = i.length, f = u.length, s = 2 + o + 2 + f;
    return $1781c6a55725cdc8$require$Buffer.concat([
        $1781c6a55725cdc8$require$Buffer.from([
            48,
            s,
            2,
            o
        ]),
        i,
        $1781c6a55725cdc8$require$Buffer.from([
            2,
            f
        ]),
        u
    ]);
}, $1781c6a55725cdc8$var$Signature.prototype.toString = function() {
    return this.toDER().toString("hex");
}, $1781c6a55725cdc8$var$Signature.isTxDER = function(r) {
    if (r.length < 9) return !1;
    if (r.length > 73) return !1;
    if (48 !== r[0]) return !1;
    if (r[1] !== r.length - 3) return !1;
    var e = r[3];
    if (5 + e >= r.length) return !1;
    var t = r[5 + e];
    if (e + t + 7 !== r.length) return !1;
    var n = r.slice(4);
    if (2 !== r[2]) return !1;
    if (0 === e) return !1;
    if (128 & n[0]) return !1;
    if (e > 1 && 0 === n[0] && !(128 & n[1])) return !1;
    var i = r.slice(6 + e);
    return !(2 !== r[6 + e - 2] || 0 === t || 128 & i[0] || t > 1 && 0 === i[0] && !(128 & i[1]));
}, $1781c6a55725cdc8$var$Signature.prototype.hasLowS = function() {
    return !this.s.lt(new $iDkJI(1)) && !this.s.gt(new $iDkJI("7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0", "hex"));
}, $1781c6a55725cdc8$var$Signature.prototype.hasDefinedHashtype = function() {
    if (!$aYsCb.isNaturalNumber(this.nhashtype)) return !1;
    var r = 31 & this.nhashtype;
    return !(r < $1781c6a55725cdc8$var$Signature.SIGHASH_ALL || r > $1781c6a55725cdc8$var$Signature.SIGHASH_SINGLE);
}, $1781c6a55725cdc8$var$Signature.prototype.toTxFormat = function() {
    var r = this.toDER(), e = $1781c6a55725cdc8$require$Buffer.alloc(1);
    return e.writeUInt8(this.nhashtype, 0), $1781c6a55725cdc8$require$Buffer.concat([
        r,
        e
    ]);
}, $1781c6a55725cdc8$var$Signature.SIGHASH_ALL = 1, $1781c6a55725cdc8$var$Signature.SIGHASH_NONE = 2, $1781c6a55725cdc8$var$Signature.SIGHASH_SINGLE = 3, $1781c6a55725cdc8$var$Signature.SIGHASH_FORKID = 64, $1781c6a55725cdc8$var$Signature.SIGHASH_ANYONECANPAY = 128, module.exports = $1781c6a55725cdc8$var$Signature;

});
parcelRequire.register("aYsCb", function(module, exports) {

var $7fd5b44c73d00b79$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $jk7hO = parcelRequire("jk7hO");

var $2EPYC = parcelRequire("2EPYC");
var $7fd5b44c73d00b79$var$isHexa = function(e) {
    return !!$jk7hO.isString(e) && /^[0-9a-fA-F]+$/.test(e);
};
module.exports = {
    isValidJSON: function(e) {
        var r;
        if (!$jk7hO.isString(e)) return !1;
        try {
            r = JSON.parse(e);
        } catch (e1) {
            return !1;
        }
        return "object" == typeof r;
    },
    isHexa: $7fd5b44c73d00b79$var$isHexa,
    isHexaString: $7fd5b44c73d00b79$var$isHexa,
    defineImmutable: function(e, r) {
        return Object.keys(r).forEach(function(t) {
            Object.defineProperty(e, t, {
                configurable: !1,
                enumerable: !0,
                value: r[t]
            });
        }), e;
    },
    isNaturalNumber: function(e) {
        return "number" == typeof e && isFinite(e) && Math.floor(e) === e && e >= 0;
    },
    integerAsBuffer: function(e) {
        $2EPYC.checkArgumentType(e, "number", "integer");
        const r = $7fd5b44c73d00b79$require$Buffer.allocUnsafe(4);
        return r.writeUInt32BE(e, 0), r;
    }
};

});


parcelRequire.register("2OQpG", function(module, exports) {

var $20d8e8780a08e6d4$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $iDkJI = parcelRequire("iDkJI");

var $eEHbt = parcelRequire("eEHbt");

var $626sY = parcelRequire("626sY");

var $aYsCb = parcelRequire("aYsCb");

var $cg9De = parcelRequire("cg9De");

var $jk7hO = parcelRequire("jk7hO");

var $2EPYC = parcelRequire("2EPYC");
function $20d8e8780a08e6d4$var$PublicKey(e, r) {
    if (!(this instanceof $20d8e8780a08e6d4$var$PublicKey)) return new $20d8e8780a08e6d4$var$PublicKey(e, r);
    if ($2EPYC.checkArgument(e, "First argument is required, please include public key data."), e instanceof $20d8e8780a08e6d4$var$PublicKey) return e;
    r = r || {};
    var t = this._classifyArgs(e, r);
    return t.point.validate(), $aYsCb.defineImmutable(this, {
        point: t.point,
        compressed: t.compressed,
        network: t.network || $cg9De.defaultNetwork
    }), this;
}


$20d8e8780a08e6d4$var$PublicKey.prototype._classifyArgs = function(e, r) {
    var t = {
        compressed: $jk7hO.isUndefined(r.compressed) || r.compressed
    };
    if (e instanceof $eEHbt) t.point = e;
    else if (e.x && e.y) t = $20d8e8780a08e6d4$var$PublicKey._transformObject(e);
    else if ("string" == typeof e) t = $20d8e8780a08e6d4$var$PublicKey._transformDER($20d8e8780a08e6d4$require$Buffer.from(e, "hex"));
    else if ($20d8e8780a08e6d4$var$PublicKey._isBuffer(e)) t = $20d8e8780a08e6d4$var$PublicKey._transformDER(e);
    else {
        if (!$20d8e8780a08e6d4$var$PublicKey._isPrivateKey(e)) throw new TypeError("First argument is an unrecognized data format.");
        t = $20d8e8780a08e6d4$var$PublicKey._transformPrivateKey(e);
    }
    return t.network || (t.network = $jk7hO.isUndefined(r.network) ? void 0 : $cg9De.get(r.network)), t;
}, $20d8e8780a08e6d4$var$PublicKey._isPrivateKey = function(e) {
    return e instanceof (parcelRequire("9jEuU"));
}, $20d8e8780a08e6d4$var$PublicKey._isBuffer = function(e) {
    return e instanceof $20d8e8780a08e6d4$require$Buffer || e instanceof Uint8Array;
}, $20d8e8780a08e6d4$var$PublicKey._transformPrivateKey = function(e) {
    $2EPYC.checkArgument($20d8e8780a08e6d4$var$PublicKey._isPrivateKey(e), "Must be an instance of PrivateKey");
    var r = {};
    return r.point = $eEHbt.getG().mul(e.bn), r.compressed = e.compressed, r.network = e.network, r;
}, $20d8e8780a08e6d4$var$PublicKey._transformDER = function(e, r) {
    $2EPYC.checkArgument($20d8e8780a08e6d4$var$PublicKey._isBuffer(e), "Must be a buffer of DER encoded public key");
    var t, i, n, o, u = {};
    if (r = !!$jk7hO.isUndefined(r) || r, 4 !== e[0] && (r || 6 !== e[0] && 7 !== e[0])) {
        if (3 === e[0]) n = e.slice(1), t = new $iDkJI(n), (u = $20d8e8780a08e6d4$var$PublicKey._transformX(!0, t)).compressed = !0;
        else {
            if (2 !== e[0]) throw new TypeError("Invalid DER format public key");
            n = e.slice(1), t = new $iDkJI(n), (u = $20d8e8780a08e6d4$var$PublicKey._transformX(!1, t)).compressed = !0;
        }
    } else {
        if (n = e.slice(1, 33), o = e.slice(33, 65), 32 !== n.length || 32 !== o.length || 65 !== e.length) throw new TypeError("Length of x and y must be 32 bytes");
        t = new $iDkJI(n), i = new $iDkJI(o), u.point = new $eEHbt(t, i), u.compressed = !1;
    }
    return u;
}, $20d8e8780a08e6d4$var$PublicKey._transformX = function(e, r) {
    $2EPYC.checkArgument("boolean" == typeof e, "Must specify whether y is odd or not (true or false)");
    var t = {};
    return t.point = $eEHbt.fromX(e, r), t;
}, $20d8e8780a08e6d4$var$PublicKey._transformObject = function(e) {
    var r = new $iDkJI(e.x, "hex"), t = new $iDkJI(e.y, "hex");
    return new $20d8e8780a08e6d4$var$PublicKey(new $eEHbt(r, t), {
        compressed: e.compressed
    });
}, $20d8e8780a08e6d4$var$PublicKey.fromPrivateKey = function(e) {
    $2EPYC.checkArgument($20d8e8780a08e6d4$var$PublicKey._isPrivateKey(e), "Must be an instance of PrivateKey");
    var r = $20d8e8780a08e6d4$var$PublicKey._transformPrivateKey(e);
    return new $20d8e8780a08e6d4$var$PublicKey(r.point, {
        compressed: r.compressed,
        network: r.network
    });
}, $20d8e8780a08e6d4$var$PublicKey.fromDER = $20d8e8780a08e6d4$var$PublicKey.fromBuffer = function(e, r) {
    $2EPYC.checkArgument($20d8e8780a08e6d4$var$PublicKey._isBuffer(e), "Must be a buffer of DER encoded public key");
    var t = $20d8e8780a08e6d4$var$PublicKey._transformDER(e, r);
    return new $20d8e8780a08e6d4$var$PublicKey(t.point, {
        compressed: t.compressed
    });
}, $20d8e8780a08e6d4$var$PublicKey.fromPoint = function(e, r) {
    return $2EPYC.checkArgument(e instanceof $eEHbt, "First argument must be an instance of Point."), new $20d8e8780a08e6d4$var$PublicKey(e, {
        compressed: r
    });
}, $20d8e8780a08e6d4$var$PublicKey.fromHex = $20d8e8780a08e6d4$var$PublicKey.fromString = function(e, r) {
    var t = $20d8e8780a08e6d4$require$Buffer.from(e, r || "hex"), i = $20d8e8780a08e6d4$var$PublicKey._transformDER(t);
    return new $20d8e8780a08e6d4$var$PublicKey(i.point, {
        compressed: i.compressed
    });
}, $20d8e8780a08e6d4$var$PublicKey.fromX = function(e, r) {
    var t = $20d8e8780a08e6d4$var$PublicKey._transformX(e, r);
    return new $20d8e8780a08e6d4$var$PublicKey(t.point, {
        compressed: t.compressed
    });
}, $20d8e8780a08e6d4$var$PublicKey.getValidationError = function(e) {
    var r;
    try {
        new $20d8e8780a08e6d4$var$PublicKey(e);
    } catch (e1) {
        r = e1;
    }
    return r;
}, $20d8e8780a08e6d4$var$PublicKey.isValid = function(e) {
    return !$20d8e8780a08e6d4$var$PublicKey.getValidationError(e);
}, $20d8e8780a08e6d4$var$PublicKey.prototype.toObject = $20d8e8780a08e6d4$var$PublicKey.prototype.toJSON = function() {
    return {
        x: this.point.getX().toString("hex", 2),
        y: this.point.getY().toString("hex", 2),
        compressed: this.compressed
    };
}, $20d8e8780a08e6d4$var$PublicKey.prototype.toBuffer = $20d8e8780a08e6d4$var$PublicKey.prototype.toDER = function() {
    var e, r = this.point.getX(), t = this.point.getY(), i = r.toBuffer({
        size: 32
    }), n = t.toBuffer({
        size: 32
    });
    return this.compressed ? (e = n[n.length - 1] % 2 ? $20d8e8780a08e6d4$require$Buffer.from([
        3
    ]) : $20d8e8780a08e6d4$require$Buffer.from([
        2
    ]), $20d8e8780a08e6d4$require$Buffer.concat([
        e,
        i
    ])) : (e = $20d8e8780a08e6d4$require$Buffer.from([
        4
    ]), $20d8e8780a08e6d4$require$Buffer.concat([
        e,
        i,
        n
    ]));
}, $20d8e8780a08e6d4$var$PublicKey.prototype._getID = function() {
    return $626sY.sha256ripemd160(this.toBuffer());
}, $20d8e8780a08e6d4$var$PublicKey.prototype.toAddress = function(e) {
    return (parcelRequire("bM62Y")).fromPublicKey(this, e || this.network);
}, $20d8e8780a08e6d4$var$PublicKey.prototype.toString = $20d8e8780a08e6d4$var$PublicKey.prototype.toHex = function() {
    return this.toDER().toString("hex");
}, $20d8e8780a08e6d4$var$PublicKey.prototype.inspect = function() {
    return "<PublicKey: " + this.toHex() + (this.compressed ? "" : ", uncompressed") + ">";
}, module.exports = $20d8e8780a08e6d4$var$PublicKey;

});
parcelRequire.register("626sY", function(module, exports) {

module.exports = (parcelRequire("6ncXr"));

});
parcelRequire.register("6ncXr", function(module, exports) {

var $4a3ef12ee0c71777$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $gnkvn = parcelRequire("gnkvn");

var $2EPYC = parcelRequire("2EPYC");
var $4a3ef12ee0c71777$var$Hash = module.exports;
$4a3ef12ee0c71777$var$Hash.sha1 = function(e) {
    return $2EPYC.checkArgument($4a3ef12ee0c71777$require$Buffer.isBuffer(e)), $4a3ef12ee0c71777$require$Buffer.from($gnkvn.sha1().update(e).digest("hex"), "hex");
}, $4a3ef12ee0c71777$var$Hash.sha1.blocksize = 512, $4a3ef12ee0c71777$var$Hash.sha256 = function(e) {
    return $2EPYC.checkArgument($4a3ef12ee0c71777$require$Buffer.isBuffer(e)), $4a3ef12ee0c71777$require$Buffer.from($gnkvn.sha256().update(e).digest("hex"), "hex");
}, $4a3ef12ee0c71777$var$Hash.sha256.blocksize = 512, $4a3ef12ee0c71777$var$Hash.sha256sha256 = function(e) {
    return $2EPYC.checkArgument($4a3ef12ee0c71777$require$Buffer.isBuffer(e)), $4a3ef12ee0c71777$var$Hash.sha256($4a3ef12ee0c71777$var$Hash.sha256(e));
}, $4a3ef12ee0c71777$var$Hash.ripemd160 = function(e) {
    return $2EPYC.checkArgument($4a3ef12ee0c71777$require$Buffer.isBuffer(e)), $4a3ef12ee0c71777$require$Buffer.from($gnkvn.ripemd160().update(e).digest("hex"), "hex");
}, $4a3ef12ee0c71777$var$Hash.sha256ripemd160 = function(e) {
    return $2EPYC.checkArgument($4a3ef12ee0c71777$require$Buffer.isBuffer(e)), $4a3ef12ee0c71777$var$Hash.ripemd160($4a3ef12ee0c71777$var$Hash.sha256(e));
}, $4a3ef12ee0c71777$var$Hash.sha512 = function(e) {
    return $2EPYC.checkArgument($4a3ef12ee0c71777$require$Buffer.isBuffer(e)), $4a3ef12ee0c71777$require$Buffer.from($gnkvn.sha512().update(e).digest("hex"), "hex");
}, $4a3ef12ee0c71777$var$Hash.sha512.blocksize = 1024, $4a3ef12ee0c71777$var$Hash.hmac = function(e, r, h) {
    $2EPYC.checkArgument($4a3ef12ee0c71777$require$Buffer.isBuffer(r)), $2EPYC.checkArgument($4a3ef12ee0c71777$require$Buffer.isBuffer(h)), $2EPYC.checkArgument(e.blocksize);
    var f = e.blocksize / 8;
    if (h.length > f) h = e(h);
    else if (h < f) {
        var s = $4a3ef12ee0c71777$require$Buffer.alloc(f);
        s.fill(0), h.copy(s), h = s;
    }
    var a = $4a3ef12ee0c71777$require$Buffer.alloc(f);
    a.fill(92);
    var u = $4a3ef12ee0c71777$require$Buffer.alloc(f);
    u.fill(54);
    for(var c = $4a3ef12ee0c71777$require$Buffer.alloc(f), t = $4a3ef12ee0c71777$require$Buffer.alloc(f), i = 0; i < f; i++)c[i] = a[i] ^ h[i], t[i] = u[i] ^ h[i];
    return e($4a3ef12ee0c71777$require$Buffer.concat([
        c,
        e($4a3ef12ee0c71777$require$Buffer.concat([
            t,
            r
        ]))
    ]));
}, $4a3ef12ee0c71777$var$Hash.sha256hmac = function(e, r) {
    return $4a3ef12ee0c71777$var$Hash.hmac($4a3ef12ee0c71777$var$Hash.sha256, e, r);
}, $4a3ef12ee0c71777$var$Hash.sha512hmac = function(e, r) {
    return $4a3ef12ee0c71777$var$Hash.hmac($4a3ef12ee0c71777$var$Hash.sha512, e, r);
};

});


parcelRequire.register("cg9De", function(module, exports) {
"use strict";

var $jk7hO = parcelRequire("jk7hO");

var $aYsCb = parcelRequire("aYsCb");
var $8ece73521c97ad81$var$networks = [], $8ece73521c97ad81$var$networkMaps = {};
function $8ece73521c97ad81$var$Network() {}
function $8ece73521c97ad81$var$get(e, t) {
    if (~$8ece73521c97ad81$var$networks.indexOf(e)) return e;
    if (!t) return $8ece73521c97ad81$var$networkMaps[e];
    $jk7hO.isArray(t) || (t = [
        t
    ]);
    for(var r = 0; r < $8ece73521c97ad81$var$networks.length; r++){
        var n = $8ece73521c97ad81$var$networks[r], s = $jk7hO.pick(n, t);
        if (~$jk7hO.values(s).indexOf(e)) return n;
    }
}
function $8ece73521c97ad81$var$cashAddrPrefixToArray(e) {
    for(var t = [], r = 0; r < e.length; r++)t.push(31 & e.charCodeAt(r));
    return t;
}
function $8ece73521c97ad81$var$addNetwork(e) {
    var t = new $8ece73521c97ad81$var$Network;
    $aYsCb.defineImmutable(t, {
        name: e.name,
        alias: e.alias,
        pubkeyhash: e.pubkeyhash,
        privatekey: e.privatekey,
        scripthash: e.scripthash,
        xpubkey: e.xpubkey,
        xprivkey: e.xprivkey
    });
    var r = e.indexBy || Object.keys(e);
    return e.cashAddrPrefix && $jk7hO.extend(t, {
        cashAddrPrefix: e.cashAddrPrefix,
        cashAddrPrefixArray: $8ece73521c97ad81$var$cashAddrPrefixToArray(e.cashAddrPrefix)
    }), e.networkMagic && $jk7hO.extend(t, {
        networkMagic: $aYsCb.integerAsBuffer(e.networkMagic)
    }), e.port && $jk7hO.extend(t, {
        port: e.port
    }), e.dnsSeeds && $jk7hO.extend(t, {
        dnsSeeds: e.dnsSeeds
    }), $8ece73521c97ad81$var$networks.push(t), $8ece73521c97ad81$var$indexNetworkBy(t, r), t;
}
function $8ece73521c97ad81$var$indexNetworkBy(e, t) {
    for(var r = 0; r < t.length; r++){
        var n = e[t[r]];
        $jk7hO.isUndefined(n) || $jk7hO.isObject(n) || ($8ece73521c97ad81$var$networkMaps[n] = e);
    }
}
function $8ece73521c97ad81$var$unindexNetworkBy(e, t) {
    for(var r = 0; r < t.length; r++){
        var n = t[r];
        $8ece73521c97ad81$var$networkMaps[n] === e && delete $8ece73521c97ad81$var$networkMaps[n];
    }
}
function $8ece73521c97ad81$var$removeNetwork(e) {
    for(var t = 0; t < $8ece73521c97ad81$var$networks.length; t++)$8ece73521c97ad81$var$networks[t] === e && $8ece73521c97ad81$var$networks.splice(t, 1);
    $8ece73521c97ad81$var$unindexNetworkBy(e, Object.keys($8ece73521c97ad81$var$networkMaps));
}
$8ece73521c97ad81$var$Network.prototype.toString = function() {
    return this.name;
};
var $8ece73521c97ad81$var$networkMagic = {
    livenet: 3823236072,
    testnet: 4108710900,
    regtest: 3669344250,
    stn: 4224632057
}, $8ece73521c97ad81$var$dnsSeeds = [
    "seed.bitcoinsv.org",
    "seed.bitcoinunlimited.info"
], $8ece73521c97ad81$var$TESTNET = {
    PORT: 18333,
    NETWORK_MAGIC: $8ece73521c97ad81$var$networkMagic.testnet,
    DNS_SEEDS: $8ece73521c97ad81$var$dnsSeeds,
    PREFIX: "testnet",
    CASHADDRPREFIX: "bchtest"
}, $8ece73521c97ad81$var$REGTEST = {
    PORT: 18444,
    NETWORK_MAGIC: $8ece73521c97ad81$var$networkMagic.regtest,
    DNS_SEEDS: [],
    PREFIX: "regtest",
    CASHADDRPREFIX: "bchreg"
}, $8ece73521c97ad81$var$STN = {
    PORT: 9333,
    NETWORK_MAGIC: $8ece73521c97ad81$var$networkMagic.stn,
    DNS_SEEDS: [
        "stn-seed.bitcoinsv.io"
    ],
    PREFIX: "stn",
    CASHADDRPREFIX: "bsvstn"
}, $8ece73521c97ad81$var$liveNetwork = {
    name: "livenet",
    alias: "mainnet",
    prefix: "bitcoin",
    cashAddrPrefix: "bitcoincash",
    pubkeyhash: 0,
    privatekey: 128,
    scripthash: 5,
    xpubkey: 76067358,
    xprivkey: 76066276,
    networkMagic: $8ece73521c97ad81$var$networkMagic.livenet,
    port: 8333,
    dnsSeeds: $8ece73521c97ad81$var$dnsSeeds
}, $8ece73521c97ad81$var$testNetwork = {
    name: "testnet",
    prefix: $8ece73521c97ad81$var$TESTNET.PREFIX,
    cashAddrPrefix: $8ece73521c97ad81$var$TESTNET.CASHADDRPREFIX,
    pubkeyhash: 111,
    privatekey: 239,
    scripthash: 196,
    xpubkey: 70617039,
    xprivkey: 70615956,
    networkMagic: $8ece73521c97ad81$var$TESTNET.NETWORK_MAGIC
}, $8ece73521c97ad81$var$regtestNetwork = {
    name: "regtest",
    prefix: $8ece73521c97ad81$var$REGTEST.PREFIX,
    cashAddrPrefix: $8ece73521c97ad81$var$REGTEST.CASHADDRPREFIX,
    pubkeyhash: 111,
    privatekey: 239,
    scripthash: 196,
    xpubkey: 70617039,
    xprivkey: 70615956,
    networkMagic: $8ece73521c97ad81$var$REGTEST.NETWORK_MAGIC,
    port: $8ece73521c97ad81$var$REGTEST.PORT,
    dnsSeeds: [],
    indexBy: [
        "port",
        "name",
        "cashAddrPrefix",
        "networkMagic"
    ]
}, $8ece73521c97ad81$var$stnNetwork = {
    name: "stn",
    prefix: $8ece73521c97ad81$var$STN.PREFIX,
    cashAddrPrefix: $8ece73521c97ad81$var$STN.CASHADDRPREFIX,
    pubkeyhash: 111,
    privatekey: 239,
    scripthash: 196,
    xpubkey: 70617039,
    xprivkey: 70615956,
    networkMagic: $8ece73521c97ad81$var$STN.NETWORK_MAGIC,
    indexBy: [
        "port",
        "name",
        "cashAddrPrefix",
        "networkMagic"
    ]
};
$8ece73521c97ad81$var$addNetwork($8ece73521c97ad81$var$testNetwork), $8ece73521c97ad81$var$addNetwork($8ece73521c97ad81$var$stnNetwork), $8ece73521c97ad81$var$addNetwork($8ece73521c97ad81$var$regtestNetwork), $8ece73521c97ad81$var$addNetwork($8ece73521c97ad81$var$liveNetwork);
var $8ece73521c97ad81$var$livenet = $8ece73521c97ad81$var$get("livenet"), $8ece73521c97ad81$var$regtest = $8ece73521c97ad81$var$get("regtest"), $8ece73521c97ad81$var$testnet = $8ece73521c97ad81$var$get("testnet"), $8ece73521c97ad81$var$stn = $8ece73521c97ad81$var$get("stn");
function $8ece73521c97ad81$var$enableRegtest() {
    $8ece73521c97ad81$var$testnet.regtestEnabled = !0;
}
function $8ece73521c97ad81$var$disableRegtest() {
    $8ece73521c97ad81$var$testnet.regtestEnabled = !1;
}
function $8ece73521c97ad81$var$enableStn() {
    $8ece73521c97ad81$var$testnet.stnEnabled = !0;
}
function $8ece73521c97ad81$var$disableStn() {
    $8ece73521c97ad81$var$testnet.stnEnabled = !1;
}
Object.defineProperty($8ece73521c97ad81$var$testnet, "port", {
    enumerable: !0,
    configurable: !1,
    get: function() {
        return this.regtestEnabled ? $8ece73521c97ad81$var$REGTEST.PORT : this.stnEnabled ? $8ece73521c97ad81$var$STN.PORT : $8ece73521c97ad81$var$TESTNET.PORT;
    }
}), Object.defineProperty($8ece73521c97ad81$var$testnet, "networkMagic", {
    enumerable: !0,
    configurable: !1,
    get: function() {
        return this.regtestEnabled ? $aYsCb.integerAsBuffer($8ece73521c97ad81$var$REGTEST.NETWORK_MAGIC) : this.stnEnabled ? $aYsCb.integerAsBuffer($8ece73521c97ad81$var$STN.NETWORK_MAGIC) : $aYsCb.integerAsBuffer($8ece73521c97ad81$var$TESTNET.NETWORK_MAGIC);
    }
}), Object.defineProperty($8ece73521c97ad81$var$testnet, "dnsSeeds", {
    enumerable: !0,
    configurable: !1,
    get: function() {
        return this.regtestEnabled ? $8ece73521c97ad81$var$REGTEST.DNS_SEEDS : this.stnEnabled ? $8ece73521c97ad81$var$STN.DNS_SEEDS : $8ece73521c97ad81$var$TESTNET.DNS_SEEDS;
    }
}), Object.defineProperty($8ece73521c97ad81$var$testnet, "cashAddrPrefix", {
    enumerable: !0,
    configurable: !1,
    get: function() {
        return this.regtestEnabled ? $8ece73521c97ad81$var$REGTEST.CASHADDRPREFIX : this.stnEnabled ? $8ece73521c97ad81$var$STN.CASHADDRPREFIX : $8ece73521c97ad81$var$TESTNET.CASHADDRPREFIX;
    }
}), Object.defineProperty($8ece73521c97ad81$var$testnet, "cashAddrPrefixArray", {
    enumerable: !0,
    configurable: !1,
    get: function() {
        return this.regtestEnabled ? $8ece73521c97ad81$var$cashAddrPrefixToArray($8ece73521c97ad81$var$REGTEST.CASHADDRPREFIX) : this.stnEnabled ? $8ece73521c97ad81$var$STN.cashAddrPrefixToArray($8ece73521c97ad81$var$STN.CASHADDRPREFIX) : $8ece73521c97ad81$var$cashAddrPrefixToArray($8ece73521c97ad81$var$TESTNET.CASHADDRPREFIX);
    }
}), module.exports = {
    add: $8ece73521c97ad81$var$addNetwork,
    remove: $8ece73521c97ad81$var$removeNetwork,
    defaultNetwork: $8ece73521c97ad81$var$livenet,
    livenet: $8ece73521c97ad81$var$livenet,
    mainnet: $8ece73521c97ad81$var$livenet,
    testnet: $8ece73521c97ad81$var$testnet,
    regtest: $8ece73521c97ad81$var$regtest,
    stn: $8ece73521c97ad81$var$stn,
    get: $8ece73521c97ad81$var$get,
    enableRegtest: $8ece73521c97ad81$var$enableRegtest,
    disableRegtest: $8ece73521c97ad81$var$disableRegtest,
    enableStn: $8ece73521c97ad81$var$enableStn,
    disableStn: $8ece73521c97ad81$var$disableStn
};

});

parcelRequire.register("9jEuU", function(module, exports) {

var $6c854d5b0da5dfd6$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $jk7hO = parcelRequire("jk7hO");

var $bM62Y = parcelRequire("bM62Y");

var $jDRhN = parcelRequire("jDRhN");

var $iDkJI = parcelRequire("iDkJI");

var $aYsCb = parcelRequire("aYsCb");

var $cg9De = parcelRequire("cg9De");

var $eEHbt = parcelRequire("eEHbt");

var $2OQpG = parcelRequire("2OQpG");

var $7Ri8i = parcelRequire("7Ri8i");

var $2EPYC = parcelRequire("2EPYC");
function $6c854d5b0da5dfd6$var$PrivateKey(e, r) {
    if (!(this instanceof $6c854d5b0da5dfd6$var$PrivateKey)) return new $6c854d5b0da5dfd6$var$PrivateKey(e, r);
    if (e instanceof $6c854d5b0da5dfd6$var$PrivateKey) return e;
    var t = this._classifyArguments(e, r);
    if (!t.bn || 0 === t.bn.cmp(new $iDkJI(0))) throw new TypeError("Number can not be equal to zero, undefined, null or false");
    if (!t.bn.lt($eEHbt.getN())) throw new TypeError("Number must be less than N");
    if (void 0 === t.network) throw new TypeError('Must specify the network ("livenet" or "testnet")');
    return $aYsCb.defineImmutable(this, {
        bn: t.bn,
        compressed: t.compressed,
        network: t.network
    }), Object.defineProperty(this, "publicKey", {
        configurable: !1,
        enumerable: !0,
        get: this.toPublicKey.bind(this)
    }), this;
}
$6c854d5b0da5dfd6$var$PrivateKey.prototype._classifyArguments = function(e, r) {
    var t = {
        compressed: !0,
        network: r ? $cg9De.get(r) : $cg9De.defaultNetwork
    };
    if ($jk7hO.isUndefined(e) || $jk7hO.isNull(e)) t.bn = $6c854d5b0da5dfd6$var$PrivateKey._getRandomBN();
    else if (e instanceof $iDkJI) t.bn = e;
    else if (e instanceof $6c854d5b0da5dfd6$require$Buffer || e instanceof Uint8Array) t = $6c854d5b0da5dfd6$var$PrivateKey._transformBuffer(e, r);
    else if (e.bn && e.network) t = $6c854d5b0da5dfd6$var$PrivateKey._transformObject(e);
    else if (!r && $cg9De.get(e)) t.bn = $6c854d5b0da5dfd6$var$PrivateKey._getRandomBN(), t.network = $cg9De.get(e);
    else {
        if ("string" != typeof e) throw new TypeError("First argument is an unrecognized data type.");
        $aYsCb.isHexa(e) ? t.bn = new $iDkJI($6c854d5b0da5dfd6$require$Buffer.from(e, "hex")) : t = $6c854d5b0da5dfd6$var$PrivateKey._transformWIF(e, r);
    }
    return t;
}, $6c854d5b0da5dfd6$var$PrivateKey._getRandomBN = function() {
    var e, r;
    do {
        var t = $7Ri8i.getRandomBuffer(32);
        e = (r = $iDkJI.fromBuffer(t)).lt($eEHbt.getN());
    }while (!e);
    return r;
}, $6c854d5b0da5dfd6$var$PrivateKey._transformBuffer = function(e, r) {
    var t = {};
    if (32 === e.length) return $6c854d5b0da5dfd6$var$PrivateKey._transformBNBuffer(e, r);
    if (t.network = $cg9De.get(e[0], "privatekey"), !t.network) throw new Error("Invalid network");
    if (r && t.network !== $cg9De.get(r)) throw new TypeError("Private key network mismatch");
    if (34 === e.length && 1 === e[33]) t.compressed = !0;
    else {
        if (33 !== e.length) throw new Error("Length of buffer must be 33 (uncompressed) or 34 (compressed)");
        t.compressed = !1;
    }
    return t.bn = $iDkJI.fromBuffer(e.slice(1, 33)), t;
}, $6c854d5b0da5dfd6$var$PrivateKey._transformBNBuffer = function(e, r) {
    var t = {};
    return t.network = $cg9De.get(r) || $cg9De.defaultNetwork, t.bn = $iDkJI.fromBuffer(e), t.compressed = !1, t;
}, $6c854d5b0da5dfd6$var$PrivateKey._transformWIF = function(e, r) {
    return $6c854d5b0da5dfd6$var$PrivateKey._transformBuffer($jDRhN.decode(e), r);
}, $6c854d5b0da5dfd6$var$PrivateKey.fromBuffer = function(e, r) {
    return new $6c854d5b0da5dfd6$var$PrivateKey(e, r);
}, $6c854d5b0da5dfd6$var$PrivateKey.fromHex = function(e, r) {
    return $6c854d5b0da5dfd6$var$PrivateKey.fromBuffer($6c854d5b0da5dfd6$require$Buffer.from(e, "hex"), r);
}, $6c854d5b0da5dfd6$var$PrivateKey._transformObject = function(e) {
    return {
        bn: new $iDkJI(e.bn, "hex"),
        network: $cg9De.get(e.network),
        compressed: e.compressed
    };
}, $6c854d5b0da5dfd6$var$PrivateKey.fromString = $6c854d5b0da5dfd6$var$PrivateKey.fromWIF = function(e) {
    return $2EPYC.checkArgument($jk7hO.isString(e), "First argument is expected to be a string."), new $6c854d5b0da5dfd6$var$PrivateKey(e);
}, $6c854d5b0da5dfd6$var$PrivateKey.fromObject = $6c854d5b0da5dfd6$var$PrivateKey.fromJSON = function(e) {
    return $2EPYC.checkArgument($jk7hO.isObject(e), "First argument is expected to be an object."), new $6c854d5b0da5dfd6$var$PrivateKey(e);
}, $6c854d5b0da5dfd6$var$PrivateKey.fromRandom = function(e) {
    var r = $6c854d5b0da5dfd6$var$PrivateKey._getRandomBN();
    return new $6c854d5b0da5dfd6$var$PrivateKey(r, e);
}, $6c854d5b0da5dfd6$var$PrivateKey.getValidationError = function(e, r) {
    var t;
    try {
        new $6c854d5b0da5dfd6$var$PrivateKey(e, r);
    } catch (e1) {
        t = e1;
    }
    return t;
}, $6c854d5b0da5dfd6$var$PrivateKey.isValid = function(e, r) {
    return !!e && !$6c854d5b0da5dfd6$var$PrivateKey.getValidationError(e, r);
}, $6c854d5b0da5dfd6$var$PrivateKey.prototype.toString = function() {
    return this.toWIF();
}, $6c854d5b0da5dfd6$var$PrivateKey.prototype.toWIF = function() {
    var e, r = this.network;
    return e = this.compressed ? $6c854d5b0da5dfd6$require$Buffer.concat([
        $6c854d5b0da5dfd6$require$Buffer.from([
            r.privatekey
        ]),
        this.bn.toBuffer({
            size: 32
        }),
        $6c854d5b0da5dfd6$require$Buffer.from([
            1
        ])
    ]) : $6c854d5b0da5dfd6$require$Buffer.concat([
        $6c854d5b0da5dfd6$require$Buffer.from([
            r.privatekey
        ]),
        this.bn.toBuffer({
            size: 32
        })
    ]), $jDRhN.encode(e);
}, $6c854d5b0da5dfd6$var$PrivateKey.prototype.toBigNumber = function() {
    return this.bn;
}, $6c854d5b0da5dfd6$var$PrivateKey.prototype.toBuffer = function() {
    return this.bn.toBuffer({
        size: 32
    });
}, $6c854d5b0da5dfd6$var$PrivateKey.prototype.toHex = function() {
    return this.toBuffer().toString("hex");
}, $6c854d5b0da5dfd6$var$PrivateKey.prototype.toPublicKey = function() {
    return this._pubkey || (this._pubkey = $2OQpG.fromPrivateKey(this)), this._pubkey;
}, $6c854d5b0da5dfd6$var$PrivateKey.prototype.toAddress = function(e) {
    var r = this.toPublicKey();
    return $bM62Y.fromPublicKey(r, e || this.network);
}, $6c854d5b0da5dfd6$var$PrivateKey.prototype.toObject = $6c854d5b0da5dfd6$var$PrivateKey.prototype.toJSON = function() {
    return {
        bn: this.bn.toString("hex"),
        compressed: this.compressed,
        network: this.network.toString()
    };
}, $6c854d5b0da5dfd6$var$PrivateKey.prototype.inspect = function() {
    var e = this.compressed ? "" : ", uncompressed";
    return "<PrivateKey: " + this.toHex() + ", network: " + this.network + e + ">";
}, module.exports = $6c854d5b0da5dfd6$var$PrivateKey;

});
parcelRequire.register("bM62Y", function(module, exports) {

var $8928de39f63a7b3e$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $jk7hO = parcelRequire("jk7hO");

var $2EPYC = parcelRequire("2EPYC");

var $7Wzz9 = parcelRequire("7Wzz9");

var $jDRhN = parcelRequire("jDRhN");

var $cg9De = parcelRequire("cg9De");

var $626sY = parcelRequire("626sY");

var $aYsCb = parcelRequire("aYsCb");

var $2OQpG = parcelRequire("2OQpG");
function $8928de39f63a7b3e$var$Address(r, e, t) {
    if (!(this instanceof $8928de39f63a7b3e$var$Address)) return new $8928de39f63a7b3e$var$Address(r, e, t);
    if ($jk7hO.isArray(r) && $jk7hO.isNumber(e)) return $8928de39f63a7b3e$var$Address.createMultisig(r, e, t);
    if (r instanceof $8928de39f63a7b3e$var$Address) return r;
    if ($2EPYC.checkArgument(r, "First argument is required, please include address data.", "guide/address.html"), e && !$cg9De.get(e)) throw new TypeError('Second argument must be "livenet", "testnet", or "regtest".');
    if (t && t !== $8928de39f63a7b3e$var$Address.PayToPublicKeyHash && t !== $8928de39f63a7b3e$var$Address.PayToScriptHash) throw new TypeError('Third argument must be "pubkeyhash" or "scripthash".');
    var s = this._classifyArguments(r, e, t);
    return s.network = s.network || $cg9De.get(e) || $cg9De.defaultNetwork, s.type = s.type || t || $8928de39f63a7b3e$var$Address.PayToPublicKeyHash, $aYsCb.defineImmutable(this, {
        hashBuffer: s.hashBuffer,
        network: s.network,
        type: s.type
    }), this;
}
$8928de39f63a7b3e$var$Address.prototype._classifyArguments = function(r, e, t) {
    if ((r instanceof $8928de39f63a7b3e$require$Buffer || r instanceof Uint8Array) && 20 === r.length) return $8928de39f63a7b3e$var$Address._transformHash(r);
    if ((r instanceof $8928de39f63a7b3e$require$Buffer || r instanceof Uint8Array) && 21 === r.length) return $8928de39f63a7b3e$var$Address._transformBuffer(r, e, t);
    if (r instanceof $2OQpG) return $8928de39f63a7b3e$var$Address._transformPublicKey(r);
    if (r instanceof $51Dlk) return $8928de39f63a7b3e$var$Address._transformScript(r, e);
    if ("string" == typeof r) return $8928de39f63a7b3e$var$Address._transformString(r, e, t);
    if ($jk7hO.isObject(r)) return $8928de39f63a7b3e$var$Address._transformObject(r);
    throw new TypeError("First argument is an unrecognized data format.");
}, $8928de39f63a7b3e$var$Address.PayToPublicKeyHash = "pubkeyhash", $8928de39f63a7b3e$var$Address.PayToScriptHash = "scripthash", $8928de39f63a7b3e$var$Address._transformHash = function(r) {
    var e = {};
    if (!(r instanceof $8928de39f63a7b3e$require$Buffer || r instanceof Uint8Array)) throw new TypeError("Address supplied is not a buffer.");
    if (20 !== r.length) throw new TypeError("Address hashbuffers must be exactly 20 bytes.");
    return e.hashBuffer = r, e;
}, $8928de39f63a7b3e$var$Address._transformObject = function(r) {
    return $2EPYC.checkArgument(r.hash || r.hashBuffer, "Must provide a `hash` or `hashBuffer` property"), $2EPYC.checkArgument(r.type, "Must provide a `type` property"), {
        hashBuffer: r.hash ? $8928de39f63a7b3e$require$Buffer.from(r.hash, "hex") : r.hashBuffer,
        network: $cg9De.get(r.network) || $cg9De.defaultNetwork,
        type: r.type
    };
}, $8928de39f63a7b3e$var$Address._classifyFromVersion = function(r) {
    var e = {}, t = $cg9De.get(r[0], "pubkeyhash"), s = $cg9De.get(r[0], "scripthash");
    return t ? (e.network = t, e.type = $8928de39f63a7b3e$var$Address.PayToPublicKeyHash) : s && (e.network = s, e.type = $8928de39f63a7b3e$var$Address.PayToScriptHash), e;
}, $8928de39f63a7b3e$var$Address._transformBuffer = function(r, e, t) {
    var s = {};
    if (!(r instanceof $8928de39f63a7b3e$require$Buffer || r instanceof Uint8Array)) throw new TypeError("Address supplied is not a buffer.");
    if (21 !== r.length) throw new TypeError("Address buffers must be exactly 21 bytes.");
    var n = $cg9De.get(e), o = $8928de39f63a7b3e$var$Address._classifyFromVersion(r);
    if (e && !n) throw new TypeError("Unknown network");
    if (!o.network || n && n !== o.network) throw new TypeError("Address has mismatched network type.");
    if (!o.type || t && t !== o.type) throw new TypeError("Address has mismatched type.");
    return s.hashBuffer = r.slice(1), s.network = o.network, s.type = o.type, s;
}, $8928de39f63a7b3e$var$Address._transformPublicKey = function(r) {
    var e = {};
    if (!(r instanceof $2OQpG)) throw new TypeError("Address must be an instance of PublicKey.");
    return e.hashBuffer = $626sY.sha256ripemd160(r.toBuffer()), e.type = $8928de39f63a7b3e$var$Address.PayToPublicKeyHash, e;
}, $8928de39f63a7b3e$var$Address._transformScript = function(r, e) {
    $2EPYC.checkArgument(r instanceof $51Dlk, "script must be a Script instance");
    var t = r.getAddressInfo(e);
    if (!t) throw new $7Wzz9.Script.CantDeriveAddress(r);
    return t;
}, $8928de39f63a7b3e$var$Address.createMultisig = function(r, e, t) {
    return t = t || r[0].network || $cg9De.defaultNetwork, $8928de39f63a7b3e$var$Address.payingTo($51Dlk.buildMultisigOut(r, e), t);
}, $8928de39f63a7b3e$var$Address._transformString = function(r, e, t) {
    if ("string" != typeof r) throw new TypeError("data parameter supplied is not a string.");
    if (r.length < 27) throw new Error("Invalid Address string provided");
    r = r.trim();
    var s = $cg9De.get(e);
    if (e && !s) throw new TypeError("Unknown network");
    var n = $jDRhN.decode(r);
    return $8928de39f63a7b3e$var$Address._transformBuffer(n, e, t);
}, $8928de39f63a7b3e$var$Address.fromPublicKey = function(r, e) {
    var t = $8928de39f63a7b3e$var$Address._transformPublicKey(r);
    return e = e || $cg9De.defaultNetwork, new $8928de39f63a7b3e$var$Address(t.hashBuffer, e, t.type);
}, $8928de39f63a7b3e$var$Address.fromPrivateKey = function(r, e) {
    let t = $2OQpG.fromPrivateKey(r);
    return e = e || r.network || $cg9De.defaultNetwork, $8928de39f63a7b3e$var$Address.fromPublicKey(t, e);
}, $8928de39f63a7b3e$var$Address.fromPublicKeyHash = function(r, e) {
    var t = $8928de39f63a7b3e$var$Address._transformHash(r);
    return new $8928de39f63a7b3e$var$Address(t.hashBuffer, e, $8928de39f63a7b3e$var$Address.PayToPublicKeyHash);
}, $8928de39f63a7b3e$var$Address.fromScriptHash = function(r, e) {
    $2EPYC.checkArgument(r, "hash parameter is required");
    var t = $8928de39f63a7b3e$var$Address._transformHash(r);
    return new $8928de39f63a7b3e$var$Address(t.hashBuffer, e, $8928de39f63a7b3e$var$Address.PayToScriptHash);
}, $8928de39f63a7b3e$var$Address.payingTo = function(r, e) {
    return $2EPYC.checkArgument(r, "script is required"), $2EPYC.checkArgument(r instanceof $51Dlk, "script must be instance of Script"), $8928de39f63a7b3e$var$Address.fromScriptHash($626sY.sha256ripemd160(r.toBuffer()), e);
}, $8928de39f63a7b3e$var$Address.fromScript = function(r, e) {
    $2EPYC.checkArgument(r instanceof $51Dlk, "script must be a Script instance");
    var t = $8928de39f63a7b3e$var$Address._transformScript(r, e);
    return new $8928de39f63a7b3e$var$Address(t.hashBuffer, e, t.type);
}, $8928de39f63a7b3e$var$Address.fromBuffer = function(r, e, t) {
    var s = $8928de39f63a7b3e$var$Address._transformBuffer(r, e, t);
    return new $8928de39f63a7b3e$var$Address(s.hashBuffer, s.network, s.type);
}, $8928de39f63a7b3e$var$Address.fromHex = function(r, e, t) {
    return $8928de39f63a7b3e$var$Address.fromBuffer($8928de39f63a7b3e$require$Buffer.from(r, "hex"), e, t);
}, $8928de39f63a7b3e$var$Address.fromString = function(r, e, t) {
    var s = $8928de39f63a7b3e$var$Address._transformString(r, e, t);
    return new $8928de39f63a7b3e$var$Address(s.hashBuffer, s.network, s.type);
}, $8928de39f63a7b3e$var$Address.fromObject = function(r) {
    return $2EPYC.checkState($aYsCb.isHexa(r.hash), 'Unexpected hash property, "' + r.hash + '", expected to be hex.'), new $8928de39f63a7b3e$var$Address($8928de39f63a7b3e$require$Buffer.from(r.hash, "hex"), r.network, r.type);
}, $8928de39f63a7b3e$var$Address.getValidationError = function(r, e, t) {
    var s;
    try {
        new $8928de39f63a7b3e$var$Address(r, e, t);
    } catch (r1) {
        s = r1;
    }
    return s;
}, $8928de39f63a7b3e$var$Address.isValid = function(r, e, t) {
    return !$8928de39f63a7b3e$var$Address.getValidationError(r, e, t);
}, $8928de39f63a7b3e$var$Address.prototype.isPayToPublicKeyHash = function() {
    return this.type === $8928de39f63a7b3e$var$Address.PayToPublicKeyHash;
}, $8928de39f63a7b3e$var$Address.prototype.isPayToScriptHash = function() {
    return this.type === $8928de39f63a7b3e$var$Address.PayToScriptHash;
}, $8928de39f63a7b3e$var$Address.prototype.toBuffer = function() {
    var r = $8928de39f63a7b3e$require$Buffer.from([
        this.network[this.type]
    ]);
    return $8928de39f63a7b3e$require$Buffer.concat([
        r,
        this.hashBuffer
    ]);
}, $8928de39f63a7b3e$var$Address.prototype.toHex = function() {
    return this.toBuffer().toString("hex");
}, $8928de39f63a7b3e$var$Address.prototype.toObject = $8928de39f63a7b3e$var$Address.prototype.toJSON = function() {
    return {
        hash: this.hashBuffer.toString("hex"),
        type: this.type,
        network: this.network.toString()
    };
}, $8928de39f63a7b3e$var$Address.prototype.inspect = function() {
    return "<Address: " + this.toString() + ", type: " + this.type + ", network: " + this.network + ">";
}, $8928de39f63a7b3e$var$Address.prototype.toString = function() {
    return $jDRhN.encode(this.toBuffer());
}, module.exports = $8928de39f63a7b3e$var$Address;

var $51Dlk = parcelRequire("51Dlk");

});
parcelRequire.register("jDRhN", function(module, exports) {

var $e4cafe5b863cb2b4$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $jk7hO = parcelRequire("jk7hO");

var $4NRZk = parcelRequire("4NRZk");


var $626sY = parcelRequire("626sY");
var $e4cafe5b863cb2b4$require$sha256sha256 = $626sY.sha256sha256;
var $e4cafe5b863cb2b4$var$Base58Check = function e(r) {
    if (!(this instanceof e)) return new e(r);
    if ($e4cafe5b863cb2b4$require$Buffer.isBuffer(r)) {
        var t = r;
        this.fromBuffer(t);
    } else if ("string" == typeof r) {
        var f = r;
        this.fromString(f);
    }
};
$e4cafe5b863cb2b4$var$Base58Check.prototype.set = function(e) {
    return this.buf = e.buf || this.buf || void 0, this;
}, $e4cafe5b863cb2b4$var$Base58Check.validChecksum = function(e, r) {
    return $jk7hO.isString(e) && (e = $hiCjL$buffer.Buffer.from($4NRZk.decode(e))), $jk7hO.isString(r) && (r = $hiCjL$buffer.Buffer.from($4NRZk.decode(r))), r || (r = e.slice(-4), e = e.slice(0, -4)), $e4cafe5b863cb2b4$var$Base58Check.checksum(e).toString("hex") === r.toString("hex");
}, $e4cafe5b863cb2b4$var$Base58Check.decode = function(e) {
    if ("string" != typeof e) throw new Error("Input must be a string");
    var r = $e4cafe5b863cb2b4$require$Buffer.from($4NRZk.decode(e));
    if (r.length < 4) throw new Error("Input string too short");
    var t = r.slice(0, -4), f = r.slice(-4), s = $e4cafe5b863cb2b4$require$sha256sha256(t).slice(0, 4);
    if (f.toString("hex") !== s.toString("hex")) throw new Error("Checksum mismatch");
    return t;
}, $e4cafe5b863cb2b4$var$Base58Check.checksum = function(e) {
    return $e4cafe5b863cb2b4$require$sha256sha256(e).slice(0, 4);
}, $e4cafe5b863cb2b4$var$Base58Check.encode = function(e) {
    if (!$e4cafe5b863cb2b4$require$Buffer.isBuffer(e)) throw new Error("Input must be a buffer");
    var r = $e4cafe5b863cb2b4$require$Buffer.alloc(e.length + 4), t = $e4cafe5b863cb2b4$var$Base58Check.checksum(e);
    return e.copy(r), t.copy(r, e.length), $4NRZk.encode(r);
}, $e4cafe5b863cb2b4$var$Base58Check.prototype.fromBuffer = function(e) {
    return this.buf = e, this;
}, $e4cafe5b863cb2b4$var$Base58Check.fromBuffer = function(e) {
    return (new $e4cafe5b863cb2b4$var$Base58Check).fromBuffer(e);
}, $e4cafe5b863cb2b4$var$Base58Check.fromHex = function(e) {
    return $e4cafe5b863cb2b4$var$Base58Check.fromBuffer($e4cafe5b863cb2b4$require$Buffer.from(e, "hex"));
}, $e4cafe5b863cb2b4$var$Base58Check.prototype.fromString = function(e) {
    var r = $e4cafe5b863cb2b4$var$Base58Check.decode(e);
    return this.buf = r, this;
}, $e4cafe5b863cb2b4$var$Base58Check.fromString = function(e) {
    var r = $e4cafe5b863cb2b4$var$Base58Check.decode(e);
    return new $4NRZk(r);
}, $e4cafe5b863cb2b4$var$Base58Check.prototype.toBuffer = function() {
    return this.buf;
}, $e4cafe5b863cb2b4$var$Base58Check.prototype.toHex = function() {
    return this.toBuffer().toString("hex");
}, $e4cafe5b863cb2b4$var$Base58Check.prototype.toString = function() {
    return $e4cafe5b863cb2b4$var$Base58Check.encode(this.buf);
}, module.exports = $e4cafe5b863cb2b4$var$Base58Check;

});
parcelRequire.register("4NRZk", function(module, exports) {

var $37f59df2ab403058$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $jk7hO = parcelRequire("jk7hO");

var $5XtJa = parcelRequire("5XtJa");

var $37f59df2ab403058$var$ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".split(""), $37f59df2ab403058$var$Base58 = function e(r) {
    if (!(this instanceof e)) return new e(r);
    if ($37f59df2ab403058$require$Buffer.isBuffer(r)) {
        var t = r;
        this.fromBuffer(t);
    } else if ("string" == typeof r) {
        var f = r;
        this.fromString(f);
    }
};
$37f59df2ab403058$var$Base58.validCharacters = function(e) {
    return $hiCjL$buffer.Buffer.isBuffer(e) && (e = e.toString()), $jk7hO.every($jk7hO.map(e, function(e) {
        return $jk7hO.includes($37f59df2ab403058$var$ALPHABET, e);
    }));
}, $37f59df2ab403058$var$Base58.prototype.set = function(e) {
    return this.buf = e.buf || this.buf || void 0, this;
}, $37f59df2ab403058$var$Base58.encode = function(e) {
    if (!$hiCjL$buffer.Buffer.isBuffer(e)) throw new Error("Input should be a buffer");
    return $5XtJa.encode(e);
}, $37f59df2ab403058$var$Base58.decode = function(e) {
    if ("string" != typeof e) throw new Error("Input should be a string");
    return $37f59df2ab403058$require$Buffer.from($5XtJa.decode(e));
}, $37f59df2ab403058$var$Base58.prototype.fromBuffer = function(e) {
    return this.buf = e, this;
}, $37f59df2ab403058$var$Base58.fromBuffer = function(e) {
    return (new $37f59df2ab403058$var$Base58).fromBuffer(e);
}, $37f59df2ab403058$var$Base58.fromHex = function(e) {
    return $37f59df2ab403058$var$Base58.fromBuffer($37f59df2ab403058$require$Buffer.from(e, "hex"));
}, $37f59df2ab403058$var$Base58.prototype.fromString = function(e) {
    var r = $37f59df2ab403058$var$Base58.decode(e);
    return this.buf = r, this;
}, $37f59df2ab403058$var$Base58.fromString = function(e) {
    return (new $37f59df2ab403058$var$Base58).fromString(e);
}, $37f59df2ab403058$var$Base58.prototype.toBuffer = function() {
    return this.buf;
}, $37f59df2ab403058$var$Base58.prototype.toHex = function() {
    return this.toBuffer().toString("hex");
}, $37f59df2ab403058$var$Base58.prototype.toString = function() {
    return $37f59df2ab403058$var$Base58.encode(this.buf);
}, module.exports = $37f59df2ab403058$var$Base58;

});
parcelRequire.register("5XtJa", function(module, exports) {

var $18KGq = parcelRequire("18KGq");
const $456985b843b9472e$var$ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
module.exports = $18KGq($456985b843b9472e$var$ALPHABET);

});
parcelRequire.register("18KGq", function(module, exports) {
"use strict";
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
function $0d4ac01ca4880653$var$base(ALPHABET) {
    if (ALPHABET.length >= 255) throw new TypeError("Alphabet too long");
    var BASE_MAP = new Uint8Array(256);
    for(var j = 0; j < BASE_MAP.length; j++)BASE_MAP[j] = 255;
    for(var i = 0; i < ALPHABET.length; i++){
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) throw new TypeError(x + " is ambiguous");
        BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
    ;
    var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
    ;
    function encode(source) {
        if (source instanceof Uint8Array) ;
        else if (ArrayBuffer.isView(source)) source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        else if (Array.isArray(source)) source = Uint8Array.from(source);
        if (!(source instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (source.length === 0) return "";
        // Skip & count leading zeroes.
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while(pbegin !== pend && source[pbegin] === 0){
            pbegin++;
            zeroes++;
        }
        // Allocate enough space in big-endian base58 representation.
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        // Process the bytes.
        while(pbegin !== pend){
            var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
            var i = 0;
            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){
                carry += 256 * b58[it1] >>> 0;
                b58[it1] = carry % BASE >>> 0;
                carry = carry / BASE >>> 0;
            }
            if (carry !== 0) throw new Error("Non-zero carry");
            length = i;
            pbegin++;
        }
        // Skip leading zeroes in base58 result.
        var it2 = size - length;
        while(it2 !== size && b58[it2] === 0)it2++;
        // Translate the result into a string.
        var str = LEADER.repeat(zeroes);
        for(; it2 < size; ++it2)str += ALPHABET.charAt(b58[it2]);
        return str;
    }
    function decodeUnsafe(source) {
        if (typeof source !== "string") throw new TypeError("Expected String");
        if (source.length === 0) return new Uint8Array();
        var psz = 0;
        // Skip and count leading '1's.
        var zeroes = 0;
        var length = 0;
        while(source[psz] === LEADER){
            zeroes++;
            psz++;
        }
        // Allocate enough space in big-endian base256 representation.
        var size = (source.length - psz) * FACTOR + 1 >>> 0 // log(58) / log(256), rounded up.
        ;
        var b256 = new Uint8Array(size);
        // Process the characters.
        while(source[psz]){
            // Decode character
            var carry = BASE_MAP[source.charCodeAt(psz)];
            // Invalid character
            if (carry === 255) return;
            var i = 0;
            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){
                carry += BASE * b256[it3] >>> 0;
                b256[it3] = carry % 256 >>> 0;
                carry = carry / 256 >>> 0;
            }
            if (carry !== 0) throw new Error("Non-zero carry");
            length = i;
            psz++;
        }
        // Skip leading zeroes in b256.
        var it4 = size - length;
        while(it4 !== size && b256[it4] === 0)it4++;
        var vch = new Uint8Array(zeroes + (size - it4));
        var j = zeroes;
        while(it4 !== size)vch[j++] = b256[it4++];
        return vch;
    }
    function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) return buffer;
        throw new Error("Non-base" + BASE + " character");
    }
    return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
    };
}
module.exports = $0d4ac01ca4880653$var$base;

});




parcelRequire.register("51Dlk", function(module, exports) {


module.exports = (parcelRequire("aPyB5")), module.exports.Interpreter = (parcelRequire("j50Xb"));

});
parcelRequire.register("aPyB5", function(module, exports) {

var $7e29810e9b674d4d$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $bM62Y = parcelRequire("bM62Y");

var $3vHUG = parcelRequire("3vHUG");

var $i6ihF = parcelRequire("i6ihF");

var $626sY = parcelRequire("626sY");

var $bs6mg = parcelRequire("bs6mg");

var $2OQpG = parcelRequire("2OQpG");

var $217RI = parcelRequire("217RI");

var $cg9De = parcelRequire("cg9De");

var $2EPYC = parcelRequire("2EPYC");

var $jk7hO = parcelRequire("jk7hO");

var $7Wzz9 = parcelRequire("7Wzz9");


var $aYsCb = parcelRequire("aYsCb");
var $7e29810e9b674d4d$var$Script = function t(e) {
    return this instanceof t ? (this.chunks = [], $7e29810e9b674d4d$require$Buffer.isBuffer(e) ? t.fromBuffer(e) : e instanceof $bM62Y ? t.fromAddress(e) : e instanceof t ? t.fromBuffer(e.toBuffer()) : $jk7hO.isString(e) ? t.fromString(e) : void ($jk7hO.isObject(e) && $jk7hO.isArray(e.chunks) && this.set(e))) : new t(e);
};
$7e29810e9b674d4d$var$Script.prototype.set = function(t) {
    return $2EPYC.checkArgument($jk7hO.isObject(t)), $2EPYC.checkArgument($jk7hO.isArray(t.chunks)), this.chunks = t.chunks, this;
}, $7e29810e9b674d4d$var$Script.fromBuffer = function(t) {
    var e = new $7e29810e9b674d4d$var$Script;
    e.chunks = [];
    for(var r = new $3vHUG(t); !r.finished();)try {
        var i, n, u = r.readUInt8();
        u > 0 && u < $bs6mg.OP_PUSHDATA1 ? (i = u, e.chunks.push({
            buf: r.read(i),
            len: i,
            opcodenum: u
        })) : u === $bs6mg.OP_PUSHDATA1 ? (i = r.readUInt8(), n = r.read(i), e.chunks.push({
            buf: n,
            len: i,
            opcodenum: u
        })) : u === $bs6mg.OP_PUSHDATA2 ? (i = r.readUInt16LE(), n = r.read(i), e.chunks.push({
            buf: n,
            len: i,
            opcodenum: u
        })) : u === $bs6mg.OP_PUSHDATA4 ? (i = r.readUInt32LE(), n = r.read(i), e.chunks.push({
            buf: n,
            len: i,
            opcodenum: u
        })) : e.chunks.push({
            opcodenum: u
        });
    } catch (e1) {
        if (e1 instanceof RangeError) throw new $7Wzz9.Script.InvalidBuffer(t.toString("hex"));
        throw e1;
    }
    return e;
}, $7e29810e9b674d4d$var$Script.prototype.toBuffer = function() {
    for(var t = new $i6ihF, e = 0; e < this.chunks.length; e++){
        var r = this.chunks[e], i = r.opcodenum;
        t.writeUInt8(r.opcodenum), r.buf && (i < $bs6mg.OP_PUSHDATA1 ? t.write(r.buf) : i === $bs6mg.OP_PUSHDATA1 ? (t.writeUInt8(r.len), t.write(r.buf)) : i === $bs6mg.OP_PUSHDATA2 ? (t.writeUInt16LE(r.len), t.write(r.buf)) : i === $bs6mg.OP_PUSHDATA4 && (t.writeUInt32LE(r.len), t.write(r.buf)));
    }
    return t.concat();
}, $7e29810e9b674d4d$var$Script.fromASM = function(t) {
    var e = new $7e29810e9b674d4d$var$Script;
    e.chunks = [];
    for(var r = t.split(" "), i = 0; i < r.length;){
        var n = r[i], u = $bs6mg(n).toNumber();
        if ("0" === n) u = 0, e.chunks.push({
            opcodenum: u
        }), i += 1;
        else if ("-1" === n) u = $bs6mg.OP_1NEGATE, e.chunks.push({
            opcodenum: u
        }), i += 1;
        else if ($jk7hO.isUndefined(u)) {
            var s = $7e29810e9b674d4d$require$Buffer.from(r[i], "hex");
            if (s.toString("hex") !== r[i]) throw new Error("invalid hex string in script");
            var c = s.length;
            c >= 0 && c < $bs6mg.OP_PUSHDATA1 ? u = c : c < Math.pow(2, 8) ? u = $bs6mg.OP_PUSHDATA1 : c < Math.pow(2, 16) ? u = $bs6mg.OP_PUSHDATA2 : c < Math.pow(2, 32) && (u = $bs6mg.OP_PUSHDATA4), e.chunks.push({
                buf: s,
                len: s.length,
                opcodenum: u
            }), i += 1;
        } else e.chunks.push({
            opcodenum: u
        }), i += 1;
    }
    return e;
}, $7e29810e9b674d4d$var$Script.fromHex = function(t) {
    return new $7e29810e9b674d4d$var$Script($hiCjL$buffer.Buffer.from(t, "hex"));
}, $7e29810e9b674d4d$var$Script.fromString = function(t) {
    if ($aYsCb.isHexa(t) || 0 === t.length) return new $7e29810e9b674d4d$var$Script($hiCjL$buffer.Buffer.from(t, "hex"));
    var e = new $7e29810e9b674d4d$var$Script;
    e.chunks = [];
    for(var r = t.split(" "), i = 0; i < r.length;){
        var n = r[i], u = $bs6mg(n).toNumber();
        if ($jk7hO.isUndefined(u)) {
            if (!((u = parseInt(n)) > 0 && u < $bs6mg.OP_PUSHDATA1)) throw new Error("Invalid script: " + JSON.stringify(t));
            e.chunks.push({
                buf: $7e29810e9b674d4d$require$Buffer.from(r[i + 1].slice(2), "hex"),
                len: u,
                opcodenum: u
            }), i += 2;
        } else if (u === $bs6mg.OP_PUSHDATA1 || u === $bs6mg.OP_PUSHDATA2 || u === $bs6mg.OP_PUSHDATA4) {
            if ("0x" !== r[i + 2].slice(0, 2)) throw new Error("Pushdata data must start with 0x");
            e.chunks.push({
                buf: $7e29810e9b674d4d$require$Buffer.from(r[i + 2].slice(2), "hex"),
                len: parseInt(r[i + 1]),
                opcodenum: u
            }), i += 3;
        } else e.chunks.push({
            opcodenum: u
        }), i += 1;
    }
    return e;
}, $7e29810e9b674d4d$var$Script.prototype._chunkToString = function(t, e) {
    var r = t.opcodenum, i = "asm" === e, n = "";
    if (t.buf) i || r !== $bs6mg.OP_PUSHDATA1 && r !== $bs6mg.OP_PUSHDATA2 && r !== $bs6mg.OP_PUSHDATA4 || (n = n + " " + $bs6mg(r).toString()), t.len > 0 && (n = i ? n + " " + t.buf.toString("hex") : n + " " + t.len + " 0x" + t.buf.toString("hex"));
    else if (void 0 !== $bs6mg.reverseMap[r]) i ? 0 === r ? n += " 0" : 79 === r ? n += " -1" : n = n + " " + $bs6mg(r).toString() : n = n + " " + $bs6mg(r).toString();
    else {
        var u = r.toString(16);
        u.length % 2 != 0 && (u = "0" + u), n = i ? n + " " + u : n + " 0x" + u;
    }
    return n;
}, $7e29810e9b674d4d$var$Script.prototype.toASM = function() {
    for(var t = "", e = 0; e < this.chunks.length; e++){
        var r = this.chunks[e];
        t += this._chunkToString(r, "asm");
    }
    return t.substr(1);
}, $7e29810e9b674d4d$var$Script.prototype.toString = function() {
    for(var t = "", e = 0; e < this.chunks.length; e++){
        var r = this.chunks[e];
        t += this._chunkToString(r);
    }
    return t.substr(1);
}, $7e29810e9b674d4d$var$Script.prototype.toHex = function() {
    return this.toBuffer().toString("hex");
}, $7e29810e9b674d4d$var$Script.prototype.inspect = function() {
    return "<Script: " + this.toString() + ">";
}, $7e29810e9b674d4d$var$Script.prototype.isPublicKeyHashOut = function() {
    return !(5 !== this.chunks.length || this.chunks[0].opcodenum !== $bs6mg.OP_DUP || this.chunks[1].opcodenum !== $bs6mg.OP_HASH160 || !this.chunks[2].buf || 20 !== this.chunks[2].buf.length || this.chunks[3].opcodenum !== $bs6mg.OP_EQUALVERIFY || this.chunks[4].opcodenum !== $bs6mg.OP_CHECKSIG);
}, $7e29810e9b674d4d$var$Script.prototype.isPublicKeyHashIn = function() {
    if (2 === this.chunks.length) {
        var t = this.chunks[0].buf, e = this.chunks[1].buf;
        if (t && t.length && 48 === t[0] && e && e.length) {
            var r = e[0];
            if ((4 === r || 6 === r || 7 === r) && 65 === e.length) return !0;
            if ((3 === r || 2 === r) && 33 === e.length) return !0;
        }
    }
    return !1;
}, $7e29810e9b674d4d$var$Script.prototype.getPublicKey = function() {
    return $2EPYC.checkState(this.isPublicKeyOut(), "Can't retrieve PublicKey from a non-PK output"), this.chunks[0].buf;
}, $7e29810e9b674d4d$var$Script.prototype.getPublicKeyHash = function() {
    return $2EPYC.checkState(this.isPublicKeyHashOut(), "Can't retrieve PublicKeyHash from a non-PKH output"), this.chunks[2].buf;
}, $7e29810e9b674d4d$var$Script.prototype.isPublicKeyOut = function() {
    if (2 === this.chunks.length && this.chunks[0].buf && this.chunks[0].buf.length && this.chunks[1].opcodenum === $bs6mg.OP_CHECKSIG) {
        var t = this.chunks[0].buf, e = t[0], r = !1;
        if ((4 !== e && 6 !== e && 7 !== e || 65 !== t.length) && (3 !== e && 2 !== e || 33 !== t.length) || (r = !0), r) return $2OQpG.isValid(t);
    }
    return !1;
}, $7e29810e9b674d4d$var$Script.prototype.isPublicKeyIn = function() {
    if (1 === this.chunks.length) {
        var t = this.chunks[0].buf;
        if (t && t.length && 48 === t[0]) return !0;
    }
    return !1;
}, $7e29810e9b674d4d$var$Script.prototype.isScriptHashOut = function() {
    var t = this.toBuffer();
    return 23 === t.length && t[0] === $bs6mg.OP_HASH160 && 20 === t[1] && t[t.length - 1] === $bs6mg.OP_EQUAL;
}, $7e29810e9b674d4d$var$Script.prototype.isScriptHashIn = function() {
    if (this.chunks.length <= 1) return !1;
    var t, e = this.chunks[this.chunks.length - 1].buf;
    if (!e) return !1;
    try {
        t = $7e29810e9b674d4d$var$Script.fromBuffer(e);
    } catch (t1) {
        if (t1 instanceof $7Wzz9.Script.InvalidBuffer) return !1;
        throw t1;
    }
    return t.classify() !== $7e29810e9b674d4d$var$Script.types.UNKNOWN;
}, $7e29810e9b674d4d$var$Script.prototype.isMultisigOut = function() {
    return this.chunks.length > 3 && $bs6mg.isSmallIntOp(this.chunks[0].opcodenum) && this.chunks.slice(1, this.chunks.length - 2).every(function(t) {
        return t.buf && $7e29810e9b674d4d$require$Buffer.isBuffer(t.buf);
    }) && $bs6mg.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) && this.chunks[this.chunks.length - 1].opcodenum === $bs6mg.OP_CHECKMULTISIG;
}, $7e29810e9b674d4d$var$Script.prototype.isMultisigIn = function() {
    return this.chunks.length >= 2 && 0 === this.chunks[0].opcodenum && this.chunks.slice(1, this.chunks.length).every(function(t) {
        return t.buf && $7e29810e9b674d4d$require$Buffer.isBuffer(t.buf) && $217RI.isTxDER(t.buf);
    });
}, $7e29810e9b674d4d$var$Script.prototype.isDataOut = function() {
    if (!(this.chunks.length >= 1 && this.chunks[0].opcodenum === $bs6mg.OP_RETURN)) return !1;
    var t = this.chunks.slice(1);
    return new $7e29810e9b674d4d$var$Script({
        chunks: t
    }).isPushOnly();
}, $7e29810e9b674d4d$var$Script.prototype.isSafeDataOut = function() {
    if (this.chunks.length < 2) return !1;
    if (this.chunks[0].opcodenum !== $bs6mg.OP_FALSE) return !1;
    var t = this.chunks.slice(1);
    return new $7e29810e9b674d4d$var$Script({
        chunks: t
    }).isDataOut();
}, $7e29810e9b674d4d$var$Script.prototype.getData = function() {
    if (this.isSafeDataOut()) return this.chunks.slice(2).map((t)=>t.buf);
    if (this.isDataOut() || this.isScriptHashOut()) return $jk7hO.isUndefined(this.chunks[1]) ? $7e29810e9b674d4d$require$Buffer.alloc(0) : $7e29810e9b674d4d$require$Buffer.from(this.chunks[1].buf);
    if (this.isPublicKeyHashOut()) return $7e29810e9b674d4d$require$Buffer.from(this.chunks[2].buf);
    throw new Error("Unrecognized script type to get data from");
}, $7e29810e9b674d4d$var$Script.prototype.isPushOnly = function() {
    return $jk7hO.every(this.chunks, function(t) {
        return t.opcodenum <= $bs6mg.OP_16 || t.opcodenum === $bs6mg.OP_PUSHDATA1 || t.opcodenum === $bs6mg.OP_PUSHDATA2 || t.opcodenum === $bs6mg.OP_PUSHDATA4;
    });
}, $7e29810e9b674d4d$var$Script.types = {}, $7e29810e9b674d4d$var$Script.types.UNKNOWN = "Unknown", $7e29810e9b674d4d$var$Script.types.PUBKEY_OUT = "Pay to public key", $7e29810e9b674d4d$var$Script.types.PUBKEY_IN = "Spend from public key", $7e29810e9b674d4d$var$Script.types.PUBKEYHASH_OUT = "Pay to public key hash", $7e29810e9b674d4d$var$Script.types.PUBKEYHASH_IN = "Spend from public key hash", $7e29810e9b674d4d$var$Script.types.SCRIPTHASH_OUT = "Pay to script hash", $7e29810e9b674d4d$var$Script.types.SCRIPTHASH_IN = "Spend from script hash", $7e29810e9b674d4d$var$Script.types.MULTISIG_OUT = "Pay to multisig", $7e29810e9b674d4d$var$Script.types.MULTISIG_IN = "Spend from multisig", $7e29810e9b674d4d$var$Script.types.DATA_OUT = "Data push", $7e29810e9b674d4d$var$Script.types.SAFE_DATA_OUT = "Safe data push", $7e29810e9b674d4d$var$Script.OP_RETURN_STANDARD_SIZE = 220, $7e29810e9b674d4d$var$Script.prototype.classify = function() {
    if (this._isInput) return this.classifyInput();
    if (this._isOutput) return this.classifyOutput();
    var t = this.classifyOutput();
    return t !== $7e29810e9b674d4d$var$Script.types.UNKNOWN ? t : this.classifyInput();
}, $7e29810e9b674d4d$var$Script.outputIdentifiers = {}, $7e29810e9b674d4d$var$Script.outputIdentifiers.PUBKEY_OUT = $7e29810e9b674d4d$var$Script.prototype.isPublicKeyOut, $7e29810e9b674d4d$var$Script.outputIdentifiers.PUBKEYHASH_OUT = $7e29810e9b674d4d$var$Script.prototype.isPublicKeyHashOut, $7e29810e9b674d4d$var$Script.outputIdentifiers.MULTISIG_OUT = $7e29810e9b674d4d$var$Script.prototype.isMultisigOut, $7e29810e9b674d4d$var$Script.outputIdentifiers.SCRIPTHASH_OUT = $7e29810e9b674d4d$var$Script.prototype.isScriptHashOut, $7e29810e9b674d4d$var$Script.outputIdentifiers.DATA_OUT = $7e29810e9b674d4d$var$Script.prototype.isDataOut, $7e29810e9b674d4d$var$Script.outputIdentifiers.SAFE_DATA_OUT = $7e29810e9b674d4d$var$Script.prototype.isSafeDataOut, $7e29810e9b674d4d$var$Script.prototype.classifyOutput = function() {
    for(var t in $7e29810e9b674d4d$var$Script.outputIdentifiers)if ($7e29810e9b674d4d$var$Script.outputIdentifiers[t].bind(this)()) return $7e29810e9b674d4d$var$Script.types[t];
    return $7e29810e9b674d4d$var$Script.types.UNKNOWN;
}, $7e29810e9b674d4d$var$Script.inputIdentifiers = {}, $7e29810e9b674d4d$var$Script.inputIdentifiers.PUBKEY_IN = $7e29810e9b674d4d$var$Script.prototype.isPublicKeyIn, $7e29810e9b674d4d$var$Script.inputIdentifiers.PUBKEYHASH_IN = $7e29810e9b674d4d$var$Script.prototype.isPublicKeyHashIn, $7e29810e9b674d4d$var$Script.inputIdentifiers.MULTISIG_IN = $7e29810e9b674d4d$var$Script.prototype.isMultisigIn, $7e29810e9b674d4d$var$Script.inputIdentifiers.SCRIPTHASH_IN = $7e29810e9b674d4d$var$Script.prototype.isScriptHashIn, $7e29810e9b674d4d$var$Script.prototype.classifyInput = function() {
    for(var t in $7e29810e9b674d4d$var$Script.inputIdentifiers)if ($7e29810e9b674d4d$var$Script.inputIdentifiers[t].bind(this)()) return $7e29810e9b674d4d$var$Script.types[t];
    return $7e29810e9b674d4d$var$Script.types.UNKNOWN;
}, $7e29810e9b674d4d$var$Script.prototype.isStandard = function() {
    return this.classify() !== $7e29810e9b674d4d$var$Script.types.UNKNOWN;
}, $7e29810e9b674d4d$var$Script.prototype.prepend = function(t) {
    return this._addByType(t, !0), this;
}, $7e29810e9b674d4d$var$Script.prototype.equals = function(t) {
    if ($2EPYC.checkState(t instanceof $7e29810e9b674d4d$var$Script, "Must provide another script"), this.chunks.length !== t.chunks.length) return !1;
    var e;
    for(e = 0; e < this.chunks.length; e++){
        if ($7e29810e9b674d4d$require$Buffer.isBuffer(this.chunks[e].buf) && !$7e29810e9b674d4d$require$Buffer.isBuffer(t.chunks[e].buf)) return !1;
        if ($7e29810e9b674d4d$require$Buffer.isBuffer(this.chunks[e].buf) && !this.chunks[e].buf.equals(t.chunks[e].buf)) return !1;
        if (this.chunks[e].opcodenum !== t.chunks[e].opcodenum) return !1;
    }
    return !0;
}, $7e29810e9b674d4d$var$Script.prototype.add = function(t) {
    return this._addByType(t, !1), this;
}, $7e29810e9b674d4d$var$Script.prototype._addByType = function(t, e) {
    if ("string" == typeof t) this._addOpcode(t, e);
    else if ("number" == typeof t) this._addOpcode(t, e);
    else if (t instanceof $bs6mg) this._addOpcode(t, e);
    else if ($7e29810e9b674d4d$require$Buffer.isBuffer(t)) this._addBuffer(t, e);
    else if (t instanceof $7e29810e9b674d4d$var$Script) this.chunks = this.chunks.concat(t.chunks);
    else {
        if ("object" != typeof t) throw new Error("Invalid script chunk");
        this._insertAtPosition(t, e);
    }
}, $7e29810e9b674d4d$var$Script.prototype._insertAtPosition = function(t, e) {
    e ? this.chunks.unshift(t) : this.chunks.push(t);
}, $7e29810e9b674d4d$var$Script.prototype._addOpcode = function(t, e) {
    var r;
    return r = "number" == typeof t ? t : t instanceof $bs6mg ? t.toNumber() : $bs6mg(t).toNumber(), this._insertAtPosition({
        opcodenum: r
    }, e), this;
}, $7e29810e9b674d4d$var$Script.prototype._addBuffer = function(t, e) {
    var r, i = t.length;
    if (i >= 0 && i < $bs6mg.OP_PUSHDATA1) r = i;
    else if (i < Math.pow(2, 8)) r = $bs6mg.OP_PUSHDATA1;
    else if (i < Math.pow(2, 16)) r = $bs6mg.OP_PUSHDATA2;
    else {
        if (!(i < Math.pow(2, 32))) throw new Error("You can't push that much data");
        r = $bs6mg.OP_PUSHDATA4;
    }
    return this._insertAtPosition({
        buf: t,
        len: i,
        opcodenum: r
    }, e), this;
}, $7e29810e9b674d4d$var$Script.prototype.removeCodeseparators = function() {
    for(var t = [], e = 0; e < this.chunks.length; e++)this.chunks[e].opcodenum !== $bs6mg.OP_CODESEPARATOR && t.push(this.chunks[e]);
    return this.chunks = t, this;
}, $7e29810e9b674d4d$var$Script.buildMultisigOut = function(t, e, r) {
    $2EPYC.checkArgument(e <= t.length, "Number of required signatures must be less than or equal to the number of public keys"), r = r || {};
    var i = new $7e29810e9b674d4d$var$Script;
    i.add($bs6mg.smallInt(e));
    var n = t = $jk7hO.map(t, $2OQpG);
    r.noSorting || (n = t.map((t)=>t.toString("hex")).sort().map((t)=>new $2OQpG(t)));
    for(var u = 0; u < n.length; u++){
        var s = n[u];
        i.add(s.toBuffer());
    }
    return i.add($bs6mg.smallInt(t.length)), i.add($bs6mg.OP_CHECKMULTISIG), i;
}, $7e29810e9b674d4d$var$Script.buildMultisigIn = function(t, e, r) {
    $2EPYC.checkArgument($jk7hO.isArray(t)), $2EPYC.checkArgument($jk7hO.isNumber(e)), $2EPYC.checkArgument($jk7hO.isArray(r));
    var i = new $7e29810e9b674d4d$var$Script;
    return i.add($bs6mg.OP_0), $jk7hO.each(r, function(t) {
        $2EPYC.checkArgument($7e29810e9b674d4d$require$Buffer.isBuffer(t), "Signatures must be an array of Buffers"), i.add(t);
    }), i;
}, $7e29810e9b674d4d$var$Script.buildP2SHMultisigIn = function(t, e, r, i) {
    $2EPYC.checkArgument($jk7hO.isArray(t)), $2EPYC.checkArgument($jk7hO.isNumber(e)), $2EPYC.checkArgument($jk7hO.isArray(r)), i = i || {};
    var n = new $7e29810e9b674d4d$var$Script;
    return n.add($bs6mg.OP_0), $jk7hO.each(r, function(t) {
        $2EPYC.checkArgument($7e29810e9b674d4d$require$Buffer.isBuffer(t), "Signatures must be an array of Buffers"), n.add(t);
    }), n.add((i.cachedMultisig || $7e29810e9b674d4d$var$Script.buildMultisigOut(t, e, i)).toBuffer()), n;
}, $7e29810e9b674d4d$var$Script.buildPublicKeyHashOut = function(t) {
    $2EPYC.checkArgument(!$jk7hO.isUndefined(t)), $2EPYC.checkArgument(t instanceof $2OQpG || t instanceof $bM62Y || $jk7hO.isString(t)), t instanceof $2OQpG ? t = t.toAddress() : $jk7hO.isString(t) && (t = new $bM62Y(t));
    var e = new $7e29810e9b674d4d$var$Script;
    return e.add($bs6mg.OP_DUP).add($bs6mg.OP_HASH160).add(t.hashBuffer).add($bs6mg.OP_EQUALVERIFY).add($bs6mg.OP_CHECKSIG), e._network = t.network, e;
}, $7e29810e9b674d4d$var$Script.buildPublicKeyOut = function(t) {
    $2EPYC.checkArgument(t instanceof $2OQpG);
    var e = new $7e29810e9b674d4d$var$Script;
    return e.add(t.toBuffer()).add($bs6mg.OP_CHECKSIG), e;
}, $7e29810e9b674d4d$var$Script.buildDataOut = function(t, e) {
    $2EPYC.checkArgument($jk7hO.isUndefined(t) || $jk7hO.isString(t) || $jk7hO.isArray(t) || $7e29810e9b674d4d$require$Buffer.isBuffer(t));
    var r = t;
    $jk7hO.isArray(r) || (r = [
        t
    ]);
    var i = new $7e29810e9b674d4d$var$Script;
    i.add($bs6mg.OP_RETURN);
    for (let t1 of r)$2EPYC.checkArgument($jk7hO.isUndefined(t1) || $jk7hO.isString(t1) || $7e29810e9b674d4d$require$Buffer.isBuffer(t1)), $jk7hO.isString(t1) && (t1 = $7e29810e9b674d4d$require$Buffer.from(t1, e)), $jk7hO.isUndefined(t1) || i.add(t1);
    return i;
}, $7e29810e9b674d4d$var$Script.buildSafeDataOut = function(t, e) {
    var r = $7e29810e9b674d4d$var$Script.buildDataOut(t, e), i = new $7e29810e9b674d4d$var$Script;
    return i.add($bs6mg.OP_FALSE), i.add(r), i;
}, $7e29810e9b674d4d$var$Script.buildScriptHashOut = function(t) {
    $2EPYC.checkArgument(t instanceof $7e29810e9b674d4d$var$Script || t instanceof $bM62Y && t.isPayToScriptHash());
    var e = new $7e29810e9b674d4d$var$Script;
    return e.add($bs6mg.OP_HASH160).add(t instanceof $bM62Y ? t.hashBuffer : $626sY.sha256ripemd160(t.toBuffer())).add($bs6mg.OP_EQUAL), e._network = t._network || t.network, e;
}, $7e29810e9b674d4d$var$Script.buildPublicKeyIn = function(t, e) {
    $2EPYC.checkArgument(t instanceof $217RI || $7e29810e9b674d4d$require$Buffer.isBuffer(t)), $2EPYC.checkArgument($jk7hO.isUndefined(e) || $jk7hO.isNumber(e)), t instanceof $217RI && (t = t.toBuffer());
    var r = new $7e29810e9b674d4d$var$Script;
    return r.add($7e29810e9b674d4d$require$Buffer.concat([
        t,
        $7e29810e9b674d4d$require$Buffer.from([
            255 & (e || $217RI.SIGHASH_ALL)
        ])
    ])), r;
}, $7e29810e9b674d4d$var$Script.buildPublicKeyHashIn = function(t, e, r) {
    return $2EPYC.checkArgument(e instanceof $217RI || $7e29810e9b674d4d$require$Buffer.isBuffer(e)), $2EPYC.checkArgument($jk7hO.isUndefined(r) || $jk7hO.isNumber(r)), e instanceof $217RI && (e = e.toBuffer()), (new $7e29810e9b674d4d$var$Script).add($7e29810e9b674d4d$require$Buffer.concat([
        e,
        $7e29810e9b674d4d$require$Buffer.from([
            255 & (r || $217RI.SIGHASH_ALL)
        ])
    ])).add(new $2OQpG(t).toBuffer());
}, $7e29810e9b674d4d$var$Script.empty = function() {
    return new $7e29810e9b674d4d$var$Script;
}, $7e29810e9b674d4d$var$Script.prototype.toScriptHashOut = function() {
    return $7e29810e9b674d4d$var$Script.buildScriptHashOut(this);
}, $7e29810e9b674d4d$var$Script.fromAddress = function(t) {
    if ((t = $bM62Y(t)).isPayToScriptHash()) return $7e29810e9b674d4d$var$Script.buildScriptHashOut(t);
    if (t.isPayToPublicKeyHash()) return $7e29810e9b674d4d$var$Script.buildPublicKeyHashOut(t);
    throw new $7Wzz9.Script.UnrecognizedAddress(t);
}, $7e29810e9b674d4d$var$Script.prototype.getAddressInfo = function() {
    return this._isInput ? this._getInputAddressInfo() : this._isOutput ? this._getOutputAddressInfo() : this._getOutputAddressInfo() || this._getInputAddressInfo();
}, $7e29810e9b674d4d$var$Script.prototype._getOutputAddressInfo = function() {
    var t = {};
    if (this.isScriptHashOut()) t.hashBuffer = this.getData(), t.type = $bM62Y.PayToScriptHash;
    else {
        if (!this.isPublicKeyHashOut()) return !1;
        t.hashBuffer = this.getData(), t.type = $bM62Y.PayToPublicKeyHash;
    }
    return t;
}, $7e29810e9b674d4d$var$Script.prototype._getInputAddressInfo = function() {
    var t = {};
    if (this.isPublicKeyHashIn()) t.hashBuffer = $626sY.sha256ripemd160(this.chunks[1].buf), t.type = $bM62Y.PayToPublicKeyHash;
    else {
        if (!this.isScriptHashIn()) return !1;
        t.hashBuffer = $626sY.sha256ripemd160(this.chunks[this.chunks.length - 1].buf), t.type = $bM62Y.PayToScriptHash;
    }
    return t;
}, $7e29810e9b674d4d$var$Script.prototype.toAddress = function(t) {
    var e = this.getAddressInfo();
    return !!e && (e.network = $cg9De.get(t) || this._network || $cg9De.defaultNetwork, new $bM62Y(e));
}, $7e29810e9b674d4d$var$Script.prototype.findAndDelete = function(t) {
    for(var e = t.toBuffer().toString("hex"), r = 0; r < this.chunks.length; r++)e === $7e29810e9b674d4d$var$Script({
        chunks: [
            this.chunks[r]
        ]
    }).toBuffer().toString("hex") && this.chunks.splice(r, 1);
    return this;
}, $7e29810e9b674d4d$var$Script.prototype.checkMinimalPush = function(t) {
    var e = this.chunks[t], r = e.buf, i = e.opcodenum;
    return !(r && (0 === r.length ? i !== $bs6mg.OP_0 : 1 === r.length && r[0] >= 1 && r[0] <= 16 ? i !== $bs6mg.OP_1 + (r[0] - 1) : 1 === r.length && 129 === r[0] ? i !== $bs6mg.OP_1NEGATE : r.length <= 75 ? i !== r.length : r.length <= 255 ? i !== $bs6mg.OP_PUSHDATA1 : r.length <= 65535 && i !== $bs6mg.OP_PUSHDATA2));
}, $7e29810e9b674d4d$var$Script.prototype._decodeOP_N = function(t) {
    if (t === $bs6mg.OP_0) return 0;
    if (t >= $bs6mg.OP_1 && t <= $bs6mg.OP_16) return t - ($bs6mg.OP_1 - 1);
    throw new Error("Invalid opcode: " + JSON.stringify(t));
}, $7e29810e9b674d4d$var$Script.prototype.getSignatureOperationsCount = function(t) {
    t = !!$jk7hO.isUndefined(t) || t;
    var e = this, r = 0, i = $bs6mg.OP_INVALIDOPCODE;
    return $jk7hO.each(e.chunks, function(n) {
        var u = n.opcodenum;
        u === $bs6mg.OP_CHECKSIG || u === $bs6mg.OP_CHECKSIGVERIFY ? r++ : u !== $bs6mg.OP_CHECKMULTISIG && u !== $bs6mg.OP_CHECKMULTISIGVERIFY || (t && i >= $bs6mg.OP_1 && i <= $bs6mg.OP_16 ? r += e._decodeOP_N(i) : r += 20), i = u;
    }), r;
}, module.exports = $7e29810e9b674d4d$var$Script;

});
parcelRequire.register("3vHUG", function(module, exports) {

var $28e6549827d49c5b$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $jk7hO = parcelRequire("jk7hO");

var $2EPYC = parcelRequire("2EPYC");

var $iDkJI = parcelRequire("iDkJI");
var $28e6549827d49c5b$var$BufferReader = function e(t) {
    if (!(this instanceof e)) return new e(t);
    if (!$jk7hO.isUndefined(t)) {
        if ($28e6549827d49c5b$require$Buffer.isBuffer(t)) this.set({
            buf: t
        });
        else if ($jk7hO.isString(t)) {
            var r = $28e6549827d49c5b$require$Buffer.from(t, "hex");
            if (2 * r.length !== t.length) throw new TypeError("Invalid hex string");
            this.set({
                buf: r
            });
        } else {
            if (!$jk7hO.isObject(t)) throw new TypeError("Unrecognized argument for BufferReader");
            var s = t;
            this.set(s);
        }
    }
};
$28e6549827d49c5b$var$BufferReader.prototype.set = function(e) {
    return this.buf = e.buf || this.buf || void 0, this.pos = e.pos || this.pos || 0, this;
}, $28e6549827d49c5b$var$BufferReader.prototype.eof = function() {
    return this.pos >= this.buf.length;
}, $28e6549827d49c5b$var$BufferReader.prototype.finished = $28e6549827d49c5b$var$BufferReader.prototype.eof, $28e6549827d49c5b$var$BufferReader.prototype.read = function(e) {
    $2EPYC.checkArgument(!$jk7hO.isUndefined(e), "Must specify a length");
    var t = this.buf.slice(this.pos, this.pos + e);
    return this.pos = this.pos + e, t;
}, $28e6549827d49c5b$var$BufferReader.prototype.readAll = function() {
    var e = this.buf.slice(this.pos, this.buf.length);
    return this.pos = this.buf.length, e;
}, $28e6549827d49c5b$var$BufferReader.prototype.readUInt8 = function() {
    var e = this.buf.readUInt8(this.pos);
    return this.pos = this.pos + 1, e;
}, $28e6549827d49c5b$var$BufferReader.prototype.readUInt16BE = function() {
    var e = this.buf.readUInt16BE(this.pos);
    return this.pos = this.pos + 2, e;
}, $28e6549827d49c5b$var$BufferReader.prototype.readUInt16LE = function() {
    var e = this.buf.readUInt16LE(this.pos);
    return this.pos = this.pos + 2, e;
}, $28e6549827d49c5b$var$BufferReader.prototype.readUInt32BE = function() {
    var e = this.buf.readUInt32BE(this.pos);
    return this.pos = this.pos + 4, e;
}, $28e6549827d49c5b$var$BufferReader.prototype.readUInt32LE = function() {
    var e = this.buf.readUInt32LE(this.pos);
    return this.pos = this.pos + 4, e;
}, $28e6549827d49c5b$var$BufferReader.prototype.readInt32LE = function() {
    var e = this.buf.readInt32LE(this.pos);
    return this.pos = this.pos + 4, e;
}, $28e6549827d49c5b$var$BufferReader.prototype.readUInt64BEBN = function() {
    var e = this.buf.slice(this.pos, this.pos + 8), t = $iDkJI.fromBuffer(e);
    return this.pos = this.pos + 8, t;
}, $28e6549827d49c5b$var$BufferReader.prototype.readUInt64LEBN = function() {
    var e, t = this.buf.readUInt32LE(this.pos), r = 4294967296 * this.buf.readUInt32LE(this.pos + 4) + t;
    if (r <= 9007199254740991) e = new $iDkJI(r);
    else {
        var s = Array.prototype.slice.call(this.buf, this.pos, this.pos + 8);
        e = new $iDkJI(s, 10, "le");
    }
    return this.pos = this.pos + 8, e;
}, $28e6549827d49c5b$var$BufferReader.prototype.readVarintNum = function() {
    var e = this.readUInt8();
    switch(e){
        case 253:
            return this.readUInt16LE();
        case 254:
            return this.readUInt32LE();
        case 255:
            var t = this.readUInt64LEBN().toNumber();
            if (t <= Math.pow(2, 53)) return t;
            throw new Error("number too large to retain precision - use readVarintBN");
        default:
            return e;
    }
}, $28e6549827d49c5b$var$BufferReader.prototype.readVarLengthBuffer = function() {
    var e = this.readVarintNum(), t = this.read(e);
    return $2EPYC.checkState(t.length === e, "Invalid length while reading varlength buffer. Expected to read: " + e + " and read " + t.length), t;
}, $28e6549827d49c5b$var$BufferReader.prototype.readVarintBuf = function() {
    switch(this.buf.readUInt8(this.pos)){
        case 253:
            return this.read(3);
        case 254:
            return this.read(5);
        case 255:
            return this.read(9);
        default:
            return this.read(1);
    }
}, $28e6549827d49c5b$var$BufferReader.prototype.readVarintBN = function() {
    var e = this.readUInt8();
    switch(e){
        case 253:
            return new $iDkJI(this.readUInt16LE());
        case 254:
            return new $iDkJI(this.readUInt32LE());
        case 255:
            return this.readUInt64LEBN();
        default:
            return new $iDkJI(e);
    }
}, $28e6549827d49c5b$var$BufferReader.prototype.reverse = function() {
    for(var e = $28e6549827d49c5b$require$Buffer.alloc(this.buf.length), t = 0; t < e.length; t++)e[t] = this.buf[this.buf.length - 1 - t];
    return this.buf = e, this;
}, $28e6549827d49c5b$var$BufferReader.prototype.readReverse = function(e) {
    $jk7hO.isUndefined(e) && (e = this.buf.length);
    var t = this.buf.slice(this.pos, this.pos + e);
    return this.pos = this.pos + e, $28e6549827d49c5b$require$Buffer.from(t).reverse();
}, module.exports = $28e6549827d49c5b$var$BufferReader;

});

parcelRequire.register("i6ihF", function(module, exports) {

var $d2d6f85b8d588b3a$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $d2d6f85b8d588b3a$var$BufferWriter = function t(r) {
    if (!(this instanceof t)) return new t(r);
    this.bufLen = 0, r ? this.set(r) : this.bufs = [];
};
$d2d6f85b8d588b3a$var$BufferWriter.prototype.set = function(t) {
    return this.bufs = t.bufs || this.bufs || [], this.bufLen = this.bufs.reduce(function(t, r) {
        return t + r.length;
    }, 0), this;
}, $d2d6f85b8d588b3a$var$BufferWriter.prototype.toBuffer = function() {
    return this.concat();
}, $d2d6f85b8d588b3a$var$BufferWriter.prototype.concat = function() {
    return $d2d6f85b8d588b3a$require$Buffer.concat(this.bufs, this.bufLen);
}, $d2d6f85b8d588b3a$var$BufferWriter.prototype.write = function(t) {
    return $hiCjL$assert($d2d6f85b8d588b3a$require$Buffer.isBuffer(t)), this.bufs.push(t), this.bufLen += t.length, this;
}, $d2d6f85b8d588b3a$var$BufferWriter.prototype.writeReverse = function(t) {
    return $hiCjL$assert($d2d6f85b8d588b3a$require$Buffer.isBuffer(t)), this.bufs.push($d2d6f85b8d588b3a$require$Buffer.from(t).reverse()), this.bufLen += t.length, this;
}, $d2d6f85b8d588b3a$var$BufferWriter.prototype.writeUInt8 = function(t) {
    var r = $d2d6f85b8d588b3a$require$Buffer.alloc(1);
    return r.writeUInt8(t, 0), this.write(r), this;
}, $d2d6f85b8d588b3a$var$BufferWriter.prototype.writeUInt16BE = function(t) {
    var r = $d2d6f85b8d588b3a$require$Buffer.alloc(2);
    return r.writeUInt16BE(t, 0), this.write(r), this;
}, $d2d6f85b8d588b3a$var$BufferWriter.prototype.writeUInt16LE = function(t) {
    var r = $d2d6f85b8d588b3a$require$Buffer.alloc(2);
    return r.writeUInt16LE(t, 0), this.write(r), this;
}, $d2d6f85b8d588b3a$var$BufferWriter.prototype.writeUInt32BE = function(t) {
    var r = $d2d6f85b8d588b3a$require$Buffer.alloc(4);
    return r.writeUInt32BE(t, 0), this.write(r), this;
}, $d2d6f85b8d588b3a$var$BufferWriter.prototype.writeInt32LE = function(t) {
    var r = $d2d6f85b8d588b3a$require$Buffer.alloc(4);
    return r.writeInt32LE(t, 0), this.write(r), this;
}, $d2d6f85b8d588b3a$var$BufferWriter.prototype.writeUInt32LE = function(t) {
    var r = $d2d6f85b8d588b3a$require$Buffer.alloc(4);
    return r.writeUInt32LE(t, 0), this.write(r), this;
}, $d2d6f85b8d588b3a$var$BufferWriter.prototype.writeUInt64BEBN = function(t) {
    var r = t.toBuffer({
        size: 8
    });
    return this.write(r), this;
}, $d2d6f85b8d588b3a$var$BufferWriter.prototype.writeUInt64LEBN = function(t) {
    var r = t.toBuffer({
        size: 8
    });
    return this.writeReverse(r), this;
}, $d2d6f85b8d588b3a$var$BufferWriter.prototype.writeVarintNum = function(t) {
    var r = $d2d6f85b8d588b3a$var$BufferWriter.varintBufNum(t);
    return this.write(r), this;
}, $d2d6f85b8d588b3a$var$BufferWriter.prototype.writeVarintBN = function(t) {
    var r = $d2d6f85b8d588b3a$var$BufferWriter.varintBufBN(t);
    return this.write(r), this;
}, $d2d6f85b8d588b3a$var$BufferWriter.varintBufNum = function(t) {
    var r;
    return t < 253 ? (r = $d2d6f85b8d588b3a$require$Buffer.alloc(1)).writeUInt8(t, 0) : t < 65536 ? ((r = $d2d6f85b8d588b3a$require$Buffer.alloc(3)).writeUInt8(253, 0), r.writeUInt16LE(t, 1)) : t < 4294967296 ? ((r = $d2d6f85b8d588b3a$require$Buffer.alloc(5)).writeUInt8(254, 0), r.writeUInt32LE(t, 1)) : ((r = $d2d6f85b8d588b3a$require$Buffer.alloc(9)).writeUInt8(255, 0), r.writeInt32LE(-1 & t, 1), r.writeUInt32LE(Math.floor(t / 4294967296), 5)), r;
}, $d2d6f85b8d588b3a$var$BufferWriter.varintBufBN = function(t) {
    var r, e = t.toNumber();
    if (e < 253) (r = $d2d6f85b8d588b3a$require$Buffer.alloc(1)).writeUInt8(e, 0);
    else if (e < 65536) (r = $d2d6f85b8d588b3a$require$Buffer.alloc(3)).writeUInt8(253, 0), r.writeUInt16LE(e, 1);
    else if (e < 4294967296) (r = $d2d6f85b8d588b3a$require$Buffer.alloc(5)).writeUInt8(254, 0), r.writeUInt32LE(e, 1);
    else {
        var i = new $d2d6f85b8d588b3a$var$BufferWriter;
        i.writeUInt8(255), i.writeUInt64LEBN(t), r = i.concat();
    }
    return r;
}, module.exports = $d2d6f85b8d588b3a$var$BufferWriter;

});

parcelRequire.register("bs6mg", function(module, exports) {

var $85673dd7eabfd945$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $jk7hO = parcelRequire("jk7hO");

var $2EPYC = parcelRequire("2EPYC");

var $aYsCb = parcelRequire("aYsCb");
function $85673dd7eabfd945$var$Opcode(O) {
    if (!(this instanceof $85673dd7eabfd945$var$Opcode)) return new $85673dd7eabfd945$var$Opcode(O);
    var P;
    if ($jk7hO.isNumber(O)) P = O;
    else {
        if (!$jk7hO.isString(O)) throw new TypeError('Unrecognized num type: "' + typeof O + '" for Opcode');
        P = $85673dd7eabfd945$var$Opcode.map[O];
    }
    return $aYsCb.defineImmutable(this, {
        num: P
    }), this;
}
for(var $85673dd7eabfd945$var$k in $85673dd7eabfd945$var$Opcode.fromBuffer = function(O) {
    return $2EPYC.checkArgument($85673dd7eabfd945$require$Buffer.isBuffer(O)), new $85673dd7eabfd945$var$Opcode(Number("0x" + O.toString("hex")));
}, $85673dd7eabfd945$var$Opcode.fromNumber = function(O) {
    return $2EPYC.checkArgument($jk7hO.isNumber(O)), new $85673dd7eabfd945$var$Opcode(O);
}, $85673dd7eabfd945$var$Opcode.fromString = function(O) {
    $2EPYC.checkArgument($jk7hO.isString(O));
    var P = $85673dd7eabfd945$var$Opcode.map[O];
    if (void 0 === P) throw new TypeError("Invalid opcodestr");
    return new $85673dd7eabfd945$var$Opcode(P);
}, $85673dd7eabfd945$var$Opcode.prototype.toHex = function() {
    return this.num.toString(16);
}, $85673dd7eabfd945$var$Opcode.prototype.toBuffer = function() {
    return $85673dd7eabfd945$require$Buffer.from(this.toHex(), "hex");
}, $85673dd7eabfd945$var$Opcode.prototype.toNumber = function() {
    return this.num;
}, $85673dd7eabfd945$var$Opcode.prototype.toString = function() {
    var O = $85673dd7eabfd945$var$Opcode.reverseMap[this.num];
    if (void 0 === O) throw new Error("Opcode does not have a string representation");
    return O;
}, $85673dd7eabfd945$var$Opcode.smallInt = function(O) {
    return $2EPYC.checkArgument($jk7hO.isNumber(O), "Invalid Argument: n should be number"), $2EPYC.checkArgument(O >= 0 && O <= 16, "Invalid Argument: n must be between 0 and 16"), 0 === O ? $85673dd7eabfd945$var$Opcode("OP_0") : new $85673dd7eabfd945$var$Opcode($85673dd7eabfd945$var$Opcode.map.OP_1 + O - 1);
}, $85673dd7eabfd945$var$Opcode.map = {
    OP_FALSE: 0,
    OP_0: 0,
    OP_PUSHDATA1: 76,
    OP_PUSHDATA2: 77,
    OP_PUSHDATA4: 78,
    OP_1NEGATE: 79,
    OP_RESERVED: 80,
    OP_TRUE: 81,
    OP_1: 81,
    OP_2: 82,
    OP_3: 83,
    OP_4: 84,
    OP_5: 85,
    OP_6: 86,
    OP_7: 87,
    OP_8: 88,
    OP_9: 89,
    OP_10: 90,
    OP_11: 91,
    OP_12: 92,
    OP_13: 93,
    OP_14: 94,
    OP_15: 95,
    OP_16: 96,
    OP_NOP: 97,
    OP_VER: 98,
    OP_IF: 99,
    OP_NOTIF: 100,
    OP_VERIF: 101,
    OP_VERNOTIF: 102,
    OP_ELSE: 103,
    OP_ENDIF: 104,
    OP_VERIFY: 105,
    OP_RETURN: 106,
    OP_TOALTSTACK: 107,
    OP_FROMALTSTACK: 108,
    OP_2DROP: 109,
    OP_2DUP: 110,
    OP_3DUP: 111,
    OP_2OVER: 112,
    OP_2ROT: 113,
    OP_2SWAP: 114,
    OP_IFDUP: 115,
    OP_DEPTH: 116,
    OP_DROP: 117,
    OP_DUP: 118,
    OP_NIP: 119,
    OP_OVER: 120,
    OP_PICK: 121,
    OP_ROLL: 122,
    OP_ROT: 123,
    OP_SWAP: 124,
    OP_TUCK: 125,
    OP_CAT: 126,
    OP_SPLIT: 127,
    OP_NUM2BIN: 128,
    OP_BIN2NUM: 129,
    OP_SIZE: 130,
    OP_INVERT: 131,
    OP_AND: 132,
    OP_OR: 133,
    OP_XOR: 134,
    OP_EQUAL: 135,
    OP_EQUALVERIFY: 136,
    OP_RESERVED1: 137,
    OP_RESERVED2: 138,
    OP_1ADD: 139,
    OP_1SUB: 140,
    OP_2MUL: 141,
    OP_2DIV: 142,
    OP_NEGATE: 143,
    OP_ABS: 144,
    OP_NOT: 145,
    OP_0NOTEQUAL: 146,
    OP_ADD: 147,
    OP_SUB: 148,
    OP_MUL: 149,
    OP_DIV: 150,
    OP_MOD: 151,
    OP_LSHIFT: 152,
    OP_RSHIFT: 153,
    OP_BOOLAND: 154,
    OP_BOOLOR: 155,
    OP_NUMEQUAL: 156,
    OP_NUMEQUALVERIFY: 157,
    OP_NUMNOTEQUAL: 158,
    OP_LESSTHAN: 159,
    OP_GREATERTHAN: 160,
    OP_LESSTHANOREQUAL: 161,
    OP_GREATERTHANOREQUAL: 162,
    OP_MIN: 163,
    OP_MAX: 164,
    OP_WITHIN: 165,
    OP_RIPEMD160: 166,
    OP_SHA1: 167,
    OP_SHA256: 168,
    OP_HASH160: 169,
    OP_HASH256: 170,
    OP_CODESEPARATOR: 171,
    OP_CHECKSIG: 172,
    OP_CHECKSIGVERIFY: 173,
    OP_CHECKMULTISIG: 174,
    OP_CHECKMULTISIGVERIFY: 175,
    OP_CHECKLOCKTIMEVERIFY: 177,
    OP_CHECKSEQUENCEVERIFY: 178,
    OP_NOP1: 176,
    OP_NOP2: 177,
    OP_NOP3: 178,
    OP_NOP4: 179,
    OP_NOP5: 180,
    OP_NOP6: 181,
    OP_NOP7: 182,
    OP_NOP8: 183,
    OP_NOP9: 184,
    OP_NOP10: 185,
    OP_PUBKEYHASH: 253,
    OP_PUBKEY: 254,
    OP_INVALIDOPCODE: 255
}, $85673dd7eabfd945$var$Opcode.reverseMap = [], $85673dd7eabfd945$var$Opcode.map)$85673dd7eabfd945$var$Opcode.reverseMap[$85673dd7eabfd945$var$Opcode.map[$85673dd7eabfd945$var$k]] = $85673dd7eabfd945$var$k;
$jk7hO.extend($85673dd7eabfd945$var$Opcode, $85673dd7eabfd945$var$Opcode.map), $85673dd7eabfd945$var$Opcode.isSmallIntOp = function(O) {
    return O instanceof $85673dd7eabfd945$var$Opcode && (O = O.toNumber()), O === $85673dd7eabfd945$var$Opcode.map.OP_0 || O >= $85673dd7eabfd945$var$Opcode.map.OP_1 && O <= $85673dd7eabfd945$var$Opcode.map.OP_16;
}, $85673dd7eabfd945$var$Opcode.prototype.inspect = function() {
    return "<Opcode: " + this.toString() + ", hex: " + this.toHex() + ", decimal: " + this.num + ">";
}, module.exports = $85673dd7eabfd945$var$Opcode;

});


parcelRequire.register("j50Xb", function(module, exports) {

var $de3f395522167bc0$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $jk7hO = parcelRequire("jk7hO");

var $aPyB5 = parcelRequire("aPyB5");

var $bs6mg = parcelRequire("bs6mg");

var $iDkJI = parcelRequire("iDkJI");

var $626sY = parcelRequire("626sY");

var $217RI = parcelRequire("217RI");

var $2OQpG = parcelRequire("2OQpG");

var $4qF1g = parcelRequire("4qF1g");
var $de3f395522167bc0$var$Interpreter = function e(t) {
    if (!(this instanceof e)) return new e(t);
    t ? (this.initialize(), this.set(t)) : this.initialize();
};
function $de3f395522167bc0$var$padBufferToSize(e, t) {
    let r = e;
    for(; r.length < t;)r = $de3f395522167bc0$require$Buffer.concat([
        $de3f395522167bc0$require$Buffer.from([
            0
        ]),
        r
    ]);
    return r;
}

$de3f395522167bc0$var$Interpreter.prototype.verify = function(e, t, r, s, i, c) {
    var I, h = (parcelRequire("iOIbA"));
    if ($jk7hO.isUndefined(r) && (r = new h), $jk7hO.isUndefined(s) && (s = 0), $jk7hO.isUndefined(i) && (i = 0), i & $de3f395522167bc0$var$Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID && (i |= $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_STRICTENC, !c)) throw new Error("internal error - need satoshisBN to verify FORKID transactions");
    if (this.set({
        script: e,
        tx: r,
        nin: s,
        flags: i,
        satoshisBN: c
    }), 0 != (i & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) && !e.isPushOnly()) return this.errstr = "SCRIPT_ERR_SIG_PUSHONLY", !1;
    if (!this.evaluate()) return !1;
    i & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_P2SH && (I = this.stack.slice());
    var n = this.stack;
    if (this.initialize(), this.set({
        script: t,
        stack: n,
        tx: r,
        nin: s,
        flags: i,
        satoshisBN: c
    }), !this.evaluate()) return !1;
    if (0 === this.stack.length) return this.errstr = "SCRIPT_ERR_EVAL_FALSE_NO_RESULT", !1;
    var O = this.stack[this.stack.length - 1];
    if (!$de3f395522167bc0$var$Interpreter.castToBool(O)) return this.errstr = "SCRIPT_ERR_EVAL_FALSE_IN_STACK", !1;
    if (i & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_P2SH && t.isScriptHashOut()) {
        if (!e.isPushOnly()) return this.errstr = "SCRIPT_ERR_SIG_PUSHONLY", !1;
        if (0 === I.length) throw new Error("internal error - stack copy empty");
        var a = I[I.length - 1], R = $aPyB5.fromBuffer(a);
        if (I.pop(), this.initialize(), this.set({
            script: R,
            stack: I,
            tx: r,
            nin: s,
            flags: i,
            satoshisBN: c
        }), !this.evaluate()) return !1;
        if (0 === I.length) return this.errstr = "SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK", !1;
        if (!$de3f395522167bc0$var$Interpreter.castToBool(I[I.length - 1])) return this.errstr = "SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK", !1;
    }
    if (0 != (i & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_CLEANSTACK)) {
        if (0 == (i & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_P2SH)) throw new Error("internal error - CLEANSTACK without P2SH");
        if (1 !== I.length) return this.errstr = "SCRIPT_ERR_CLEANSTACK", !1;
    }
    return !0;
}, module.exports = $de3f395522167bc0$var$Interpreter, $de3f395522167bc0$var$Interpreter.prototype.initialize = function() {
    this.stack = [], this.altstack = [], this.pc = 0, this.pbegincodehash = 0, this.nOpCount = 0, this.vfExec = [], this.errstr = "", this.flags = 0;
}, $de3f395522167bc0$var$Interpreter.prototype.set = function(e) {
    this.script = e.script || this.script, this.tx = e.tx || this.tx, this.nin = void 0 !== e.nin ? e.nin : this.nin, this.satoshisBN = e.satoshisBN || this.satoshisBN, this.stack = e.stack || this.stack, this.altstack = e.altstack || this.altstack, this.pc = void 0 !== e.pc ? e.pc : this.pc, this.pbegincodehash = void 0 !== e.pbegincodehash ? e.pbegincodehash : this.pbegincodehash, this.nOpCount = void 0 !== e.nOpCount ? e.nOpCount : this.nOpCount, this.vfExec = e.vfExec || this.vfExec, this.errstr = e.errstr || this.errstr, this.flags = void 0 !== e.flags ? e.flags : this.flags;
}, $de3f395522167bc0$var$Interpreter.true = $de3f395522167bc0$require$Buffer.from([
    1
]), $de3f395522167bc0$var$Interpreter.false = $de3f395522167bc0$require$Buffer.from([]), $de3f395522167bc0$var$Interpreter.MAX_SCRIPT_ELEMENT_SIZE = 520, $de3f395522167bc0$var$Interpreter.MAXIMUM_ELEMENT_SIZE = 4, $de3f395522167bc0$var$Interpreter.LOCKTIME_THRESHOLD = 5e8, $de3f395522167bc0$var$Interpreter.LOCKTIME_THRESHOLD_BN = new $iDkJI($de3f395522167bc0$var$Interpreter.LOCKTIME_THRESHOLD), $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_NONE = 0, $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_P2SH = 1, $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_STRICTENC = 2, $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_DERSIG = 4, $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_LOW_S = 8, $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_NULLDUMMY = 16, $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_SIGPUSHONLY = 32, $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_MINIMALDATA = 64, $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 128, $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_CLEANSTACK = 256, $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = 512, $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = 1024, $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_MINIMALIF = 8192, $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_NULLFAIL = 16384, $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_COMPRESSED_PUBKEYTYPE = 32768, $de3f395522167bc0$var$Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID = 65536, $de3f395522167bc0$var$Interpreter.SCRIPT_ENABLE_REPLAY_PROTECTION = 131072, $de3f395522167bc0$var$Interpreter.SCRIPT_ENABLE_MONOLITH_OPCODES = 262144, $de3f395522167bc0$var$Interpreter.SCRIPT_ENABLE_MAGNETIC_OPCODES = 524288, $de3f395522167bc0$var$Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG = -2147483648, $de3f395522167bc0$var$Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG = 4194304, $de3f395522167bc0$var$Interpreter.SEQUENCE_LOCKTIME_MASK = 65535, $de3f395522167bc0$var$Interpreter.castToBool = function(e) {
    for(var t = 0; t < e.length; t++)if (0 !== e[t]) return t !== e.length - 1 || 128 !== e[t];
    return !1;
}, $de3f395522167bc0$var$Interpreter.prototype.checkSignatureEncoding = function(e) {
    var t;
    if (0 === e.length) return !0;
    if (0 != (this.flags & ($de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_DERSIG | $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_LOW_S | $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_STRICTENC)) && !$217RI.isTxDER(e)) return this.errstr = "SCRIPT_ERR_SIG_DER_INVALID_FORMAT", !1;
    if (0 != (this.flags & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_LOW_S)) {
        if (!(t = $217RI.fromTxFormat(e)).hasLowS()) return this.errstr = "SCRIPT_ERR_SIG_DER_HIGH_S", !1;
    } else if (0 != (this.flags & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_STRICTENC)) {
        if (!(t = $217RI.fromTxFormat(e)).hasDefinedHashtype()) return this.errstr = "SCRIPT_ERR_SIG_HASHTYPE", !1;
        if (!(this.flags & $de3f395522167bc0$var$Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID) && t.nhashtype & $217RI.SIGHASH_FORKID) return this.errstr = "SCRIPT_ERR_ILLEGAL_FORKID", !1;
        if (this.flags & $de3f395522167bc0$var$Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID && !(t.nhashtype & $217RI.SIGHASH_FORKID)) return this.errstr = "SCRIPT_ERR_MUST_USE_FORKID", !1;
    }
    return !0;
}, $de3f395522167bc0$var$Interpreter.prototype.checkPubkeyEncoding = function(e) {
    return !(0 != (this.flags & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_STRICTENC) && !$2OQpG.isValid(e) && (this.errstr = "SCRIPT_ERR_PUBKEYTYPE", 1));
}, $de3f395522167bc0$var$Interpreter._isMinimallyEncoded = function(e, t) {
    return t = t || $de3f395522167bc0$var$Interpreter.MAXIMUM_ELEMENT_SIZE, !(e.length > t || e.length > 0 && 0 == (127 & e[e.length - 1]) && (e.length <= 1 || 0 == (128 & e[e.length - 2])));
}, $de3f395522167bc0$var$Interpreter._minimallyEncode = function(e) {
    if (0 === e.length) return e;
    var t = e[e.length - 1];
    if (127 & t) return e;
    if (1 === e.length) return $de3f395522167bc0$require$Buffer.from("");
    if (128 & e[e.length - 2]) return e;
    for(var r = e.length - 1; r > 0; r--)if (0 !== e[r - 1]) return 128 & e[r - 1] ? e[r++] = t : e[r - 1] |= t, e.slice(0, r);
    return $de3f395522167bc0$require$Buffer.from("");
}, $de3f395522167bc0$var$Interpreter.prototype.evaluate = function() {
    if (this.script.toBuffer().length > 1e4) return this.errstr = "SCRIPT_ERR_SCRIPT_SIZE", !1;
    try {
        for(; this.pc < this.script.chunks.length;){
            let e = {
                pc: this.pc,
                opcode: $bs6mg.fromNumber(this.script.chunks[this.pc].opcodenum)
            };
            if (!this.step()) return !1;
            this._callbackStep(e);
        }
        if (this.stack.length + this.altstack.length > 1e3) return this.errstr = "SCRIPT_ERR_STACK_SIZE", !1;
    } catch (e1) {
        return this.errstr = "SCRIPT_ERR_UNKNOWN_ERROR: " + e1, !1;
    }
    return !(this.vfExec.length > 0 && (this.errstr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL", 1));
}, $de3f395522167bc0$var$Interpreter.prototype._callbackStep = function(e) {
    if ("function" == typeof this.stepListener) try {
        this.stepListener(e, $4qF1g(this.stack, !0), $4qF1g(this.altstack, !0));
    } catch (e1) {
        console.log(`Error in Step callback:${e1}`);
    }
}, $de3f395522167bc0$var$Interpreter.prototype.checkLockTime = function(e) {
    return !!(this.tx.nLockTime < $de3f395522167bc0$var$Interpreter.LOCKTIME_THRESHOLD && e.lt($de3f395522167bc0$var$Interpreter.LOCKTIME_THRESHOLD_BN) || this.tx.nLockTime >= $de3f395522167bc0$var$Interpreter.LOCKTIME_THRESHOLD && e.gte($de3f395522167bc0$var$Interpreter.LOCKTIME_THRESHOLD_BN)) && !e.gt(new $iDkJI(this.tx.nLockTime)) && !this.tx.inputs[this.nin].isFinal();
}, $de3f395522167bc0$var$Interpreter.prototype.checkSequence = function(e) {
    var t = this.tx.inputs[this.nin].sequenceNumber;
    if (this.tx.version < 2) return !1;
    if (t & $de3f395522167bc0$var$Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) return !1;
    var r = $de3f395522167bc0$var$Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG | $de3f395522167bc0$var$Interpreter.SEQUENCE_LOCKTIME_MASK, s = new $iDkJI(t & r), i = e.and(r), c = new $iDkJI($de3f395522167bc0$var$Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG);
    return !!(s.lt(c) && i.lt(c) || s.gte(c) && i.gte(c)) && !i.gt(s);
}, $de3f395522167bc0$var$Interpreter.prototype.step = function() {
    var e = this;
    function t(t) {
        return e.stack[e.stack.length + t];
    }
    var r, s, i, c, I, h, n, O, a, R, p, E, P, o, S, T, f, N = 0 != (this.flags & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_MINIMALDATA), u = -1 === this.vfExec.indexOf(!1), C = this.script.chunks[this.pc];
    this.pc++;
    var A = C.opcodenum;
    if ($jk7hO.isUndefined(A)) return this.errstr = "SCRIPT_ERR_UNDEFINED_OPCODE", !1;
    if (C.buf && C.buf.length > $de3f395522167bc0$var$Interpreter.MAX_SCRIPT_ELEMENT_SIZE) return this.errstr = "SCRIPT_ERR_PUSH_SIZE", !1;
    if (A > $bs6mg.OP_16 && ++this.nOpCount > 201) return this.errstr = "SCRIPT_ERR_OP_COUNT", !1;
    if (function(t) {
        switch(t){
            case $bs6mg.OP_2MUL:
            case $bs6mg.OP_2DIV:
                return !0;
            case $bs6mg.OP_INVERT:
            case $bs6mg.OP_MUL:
            case $bs6mg.OP_LSHIFT:
            case $bs6mg.OP_RSHIFT:
                if (0 == (e.flags & $de3f395522167bc0$var$Interpreter.SCRIPT_ENABLE_MAGNETIC_OPCODES)) return !0;
                break;
            case $bs6mg.OP_DIV:
            case $bs6mg.OP_MOD:
            case $bs6mg.OP_SPLIT:
            case $bs6mg.OP_CAT:
            case $bs6mg.OP_AND:
            case $bs6mg.OP_OR:
            case $bs6mg.OP_XOR:
            case $bs6mg.OP_BIN2NUM:
            case $bs6mg.OP_NUM2BIN:
                if (0 == (e.flags & $de3f395522167bc0$var$Interpreter.SCRIPT_ENABLE_MONOLITH_OPCODES)) return !0;
        }
        return !1;
    }(A)) return this.errstr = "SCRIPT_ERR_DISABLED_OPCODE", !1;
    if (u && A >= 0 && A <= $bs6mg.OP_PUSHDATA4) {
        if (N && !this.script.checkMinimalPush(this.pc - 1)) return this.errstr = "SCRIPT_ERR_MINIMALDATA", !1;
        if (C.buf) {
            if (C.len !== C.buf.length) throw new Error(`Length of push value not equal to length of data (${C.len},${C.buf.length})`);
            this.stack.push(C.buf);
        } else this.stack.push($de3f395522167bc0$var$Interpreter.false);
    } else if (u || $bs6mg.OP_IF <= A && A <= $bs6mg.OP_ENDIF) switch(A){
        case $bs6mg.OP_1NEGATE:
        case $bs6mg.OP_1:
        case $bs6mg.OP_2:
        case $bs6mg.OP_3:
        case $bs6mg.OP_4:
        case $bs6mg.OP_5:
        case $bs6mg.OP_6:
        case $bs6mg.OP_7:
        case $bs6mg.OP_8:
        case $bs6mg.OP_9:
        case $bs6mg.OP_10:
        case $bs6mg.OP_11:
        case $bs6mg.OP_12:
        case $bs6mg.OP_13:
        case $bs6mg.OP_14:
        case $bs6mg.OP_15:
        case $bs6mg.OP_16:
            I = A - ($bs6mg.OP_1 - 1), r = new $iDkJI(I).toScriptNumBuffer(), this.stack.push(r);
            break;
        case $bs6mg.OP_NOP:
            break;
        case $bs6mg.OP_NOP2:
        case $bs6mg.OP_CHECKLOCKTIMEVERIFY:
            if (!(this.flags & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {
                if (this.flags & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) return this.errstr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS", !1;
                break;
            }
            if (this.stack.length < 1) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            var k = $iDkJI.fromScriptNumBuffer(this.stack[this.stack.length - 1], N, 5);
            if (k.lt(new $iDkJI(0))) return this.errstr = "SCRIPT_ERR_NEGATIVE_LOCKTIME", !1;
            if (!this.checkLockTime(k)) return this.errstr = "SCRIPT_ERR_UNSATISFIED_LOCKTIME", !1;
            break;
        case $bs6mg.OP_NOP3:
        case $bs6mg.OP_CHECKSEQUENCEVERIFY:
            if (!(this.flags & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {
                if (this.flags & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) return this.errstr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS", !1;
                break;
            }
            if (this.stack.length < 1) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            var l = $iDkJI.fromScriptNumBuffer(t(-1), N, 5);
            if (l.lt(new $iDkJI(0))) return this.errstr = "SCRIPT_ERR_NEGATIVE_LOCKTIME", !1;
            if (0 != (l & $de3f395522167bc0$var$Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG)) break;
            if (!this.checkSequence(l)) return this.errstr = "SCRIPT_ERR_UNSATISFIED_LOCKTIME", !1;
            break;
        case $bs6mg.OP_NOP1:
        case $bs6mg.OP_NOP4:
        case $bs6mg.OP_NOP5:
        case $bs6mg.OP_NOP6:
        case $bs6mg.OP_NOP7:
        case $bs6mg.OP_NOP8:
        case $bs6mg.OP_NOP9:
        case $bs6mg.OP_NOP10:
            if (this.flags & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) return this.errstr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS", !1;
            break;
        case $bs6mg.OP_IF:
        case $bs6mg.OP_NOTIF:
            if (T = !1, u) {
                if (this.stack.length < 1) return this.errstr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL", !1;
                if (r = t(-1), this.flags & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_MINIMALIF) {
                    if (r.length > 1) return this.errstr = "SCRIPT_ERR_MINIMALIF", !1;
                    if (1 === r.length && 1 !== r[0]) return this.errstr = "SCRIPT_ERR_MINIMALIF", !1;
                }
                T = $de3f395522167bc0$var$Interpreter.castToBool(r), A === $bs6mg.OP_NOTIF && (T = !T), this.stack.pop();
            }
            this.vfExec.push(T);
            break;
        case $bs6mg.OP_ELSE:
            if (0 === this.vfExec.length) return this.errstr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL", !1;
            this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];
            break;
        case $bs6mg.OP_ENDIF:
            if (0 === this.vfExec.length) return this.errstr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL", !1;
            this.vfExec.pop();
            break;
        case $bs6mg.OP_VERIFY:
            if (this.stack.length < 1) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            if (r = t(-1), !(T = $de3f395522167bc0$var$Interpreter.castToBool(r))) return this.errstr = "SCRIPT_ERR_VERIFY", !1;
            this.stack.pop();
            break;
        case $bs6mg.OP_RETURN:
            return this.errstr = "SCRIPT_ERR_OP_RETURN", !1;
        case $bs6mg.OP_TOALTSTACK:
            if (this.stack.length < 1) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            this.altstack.push(this.stack.pop());
            break;
        case $bs6mg.OP_FROMALTSTACK:
            if (this.altstack.length < 1) return this.errstr = "SCRIPT_ERR_INVALID_ALTSTACK_OPERATION", !1;
            this.stack.push(this.altstack.pop());
            break;
        case $bs6mg.OP_2DROP:
            if (this.stack.length < 2) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            this.stack.pop(), this.stack.pop();
            break;
        case $bs6mg.OP_2DUP:
            if (this.stack.length < 2) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            s = t(-2), i = t(-1), this.stack.push($de3f395522167bc0$require$Buffer.from(s)), this.stack.push($de3f395522167bc0$require$Buffer.from(i));
            break;
        case $bs6mg.OP_3DUP:
            if (this.stack.length < 3) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            s = t(-3), i = t(-2);
            var d = t(-1);
            this.stack.push($de3f395522167bc0$require$Buffer.from(s)), this.stack.push($de3f395522167bc0$require$Buffer.from(i)), this.stack.push($de3f395522167bc0$require$Buffer.from(d));
            break;
        case $bs6mg.OP_2OVER:
            if (this.stack.length < 4) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            s = t(-4), i = t(-3), this.stack.push($de3f395522167bc0$require$Buffer.from(s)), this.stack.push($de3f395522167bc0$require$Buffer.from(i));
            break;
        case $bs6mg.OP_2ROT:
            if (this.stack.length < 6) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            c = this.stack.splice(this.stack.length - 6, 2), this.stack.push(c[0]), this.stack.push(c[1]);
            break;
        case $bs6mg.OP_2SWAP:
            if (this.stack.length < 4) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            c = this.stack.splice(this.stack.length - 4, 2), this.stack.push(c[0]), this.stack.push(c[1]);
            break;
        case $bs6mg.OP_IFDUP:
            if (this.stack.length < 1) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            r = t(-1), (T = $de3f395522167bc0$var$Interpreter.castToBool(r)) && this.stack.push($de3f395522167bc0$require$Buffer.from(r));
            break;
        case $bs6mg.OP_DEPTH:
            r = new $iDkJI(this.stack.length).toScriptNumBuffer(), this.stack.push(r);
            break;
        case $bs6mg.OP_DROP:
            if (this.stack.length < 1) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            this.stack.pop();
            break;
        case $bs6mg.OP_DUP:
            if (this.stack.length < 1) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            this.stack.push($de3f395522167bc0$require$Buffer.from(t(-1)));
            break;
        case $bs6mg.OP_NIP:
            if (this.stack.length < 2) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            this.stack.splice(this.stack.length - 2, 1);
            break;
        case $bs6mg.OP_OVER:
            if (this.stack.length < 2) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            this.stack.push($de3f395522167bc0$require$Buffer.from(t(-2)));
            break;
        case $bs6mg.OP_PICK:
        case $bs6mg.OP_ROLL:
            if (this.stack.length < 2) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            if (r = t(-1), I = (O = $iDkJI.fromScriptNumBuffer(r, N)).toNumber(), this.stack.pop(), I < 0 || I >= this.stack.length) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            r = t(-I - 1), A === $bs6mg.OP_ROLL && this.stack.splice(this.stack.length - I - 1, 1), this.stack.push($de3f395522167bc0$require$Buffer.from(r));
            break;
        case $bs6mg.OP_ROT:
            if (this.stack.length < 3) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            h = t(-3), n = t(-2);
            var L = t(-1);
            this.stack[this.stack.length - 3] = n, this.stack[this.stack.length - 2] = L, this.stack[this.stack.length - 1] = h;
            break;
        case $bs6mg.OP_SWAP:
            if (this.stack.length < 2) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            h = t(-2), n = t(-1), this.stack[this.stack.length - 2] = n, this.stack[this.stack.length - 1] = h;
            break;
        case $bs6mg.OP_TUCK:
            if (this.stack.length < 2) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            this.stack.splice(this.stack.length - 2, 0, $de3f395522167bc0$require$Buffer.from(t(-1)));
            break;
        case $bs6mg.OP_SIZE:
            if (this.stack.length < 1) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            O = new $iDkJI(t(-1).length), this.stack.push(O.toScriptNumBuffer());
            break;
        case $bs6mg.OP_AND:
        case $bs6mg.OP_OR:
        case $bs6mg.OP_XOR:
            if (this.stack.length < 2) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            if (s = t(-2), i = t(-1), s.length !== i.length) return this.errstr = "SCRIPT_ERR_INVALID_OPERAND_SIZE", !1;
            switch(A){
                case $bs6mg.OP_AND:
                    for(let e1 = 0; e1 < s.length; e1++)s[e1] &= i[e1];
                    break;
                case $bs6mg.OP_OR:
                    for(let e2 = 0; e2 < s.length; e2++)s[e2] |= i[e2];
                    break;
                case $bs6mg.OP_XOR:
                    for(let e3 = 0; e3 < s.length; e3++)s[e3] ^= i[e3];
            }
            this.stack.pop();
            break;
        case $bs6mg.OP_INVERT:
            this.stack.length < 1 && (this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION"), r = t(-1);
            for(let e4 = 0; e4 < r.length; e4++)r[e4] = ~r[e4];
            break;
        case $bs6mg.OP_LSHIFT:
        case $bs6mg.OP_RSHIFT:
            if (this.stack.length < 2) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            if (0 === (s = t(-2)).length) this.stack.pop();
            else {
                if (a = new $iDkJI(s), (I = (R = $iDkJI.fromScriptNumBuffer(t(-1), N)).toNumber()) < 0) return this.errstr = "SCRIPT_ERR_INVALID_NUMBER_RANGE", !1;
                let e5;
                this.stack.pop(), this.stack.pop(), A === $bs6mg.OP_LSHIFT && (e5 = a.ushln(I)), A === $bs6mg.OP_RSHIFT && (e5 = a.ushrn(I));
                let r1 = $de3f395522167bc0$var$padBufferToSize($de3f395522167bc0$require$Buffer.from(e5.toArray().slice(-1 * s.length)), s.length);
                this.stack.push(r1);
            }
            break;
        case $bs6mg.OP_EQUAL:
        case $bs6mg.OP_EQUALVERIFY:
            if (this.stack.length < 2) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            s = t(-2), i = t(-1);
            var g = s.toString("hex") === i.toString("hex");
            if (this.stack.pop(), this.stack.pop(), this.stack.push(g ? $de3f395522167bc0$var$Interpreter.true : $de3f395522167bc0$var$Interpreter.false), A === $bs6mg.OP_EQUALVERIFY) {
                if (!g) return this.errstr = "SCRIPT_ERR_EQUALVERIFY", !1;
                this.stack.pop();
            }
            break;
        case $bs6mg.OP_1ADD:
        case $bs6mg.OP_1SUB:
        case $bs6mg.OP_NEGATE:
        case $bs6mg.OP_ABS:
        case $bs6mg.OP_NOT:
        case $bs6mg.OP_0NOTEQUAL:
            if (this.stack.length < 1) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            switch(r = t(-1), O = $iDkJI.fromScriptNumBuffer(r, N), A){
                case $bs6mg.OP_1ADD:
                    O = O.add($iDkJI.One);
                    break;
                case $bs6mg.OP_1SUB:
                    O = O.sub($iDkJI.One);
                    break;
                case $bs6mg.OP_NEGATE:
                    O = O.neg();
                    break;
                case $bs6mg.OP_ABS:
                    O.cmp($iDkJI.Zero) < 0 && (O = O.neg());
                    break;
                case $bs6mg.OP_NOT:
                    O = new $iDkJI((0 === O.cmp($iDkJI.Zero)) + 0);
                    break;
                case $bs6mg.OP_0NOTEQUAL:
                    O = new $iDkJI((0 !== O.cmp($iDkJI.Zero)) + 0);
            }
            this.stack.pop(), this.stack.push(O.toScriptNumBuffer());
            break;
        case $bs6mg.OP_ADD:
        case $bs6mg.OP_SUB:
        case $bs6mg.OP_MUL:
        case $bs6mg.OP_MOD:
        case $bs6mg.OP_DIV:
        case $bs6mg.OP_BOOLAND:
        case $bs6mg.OP_BOOLOR:
        case $bs6mg.OP_NUMEQUAL:
        case $bs6mg.OP_NUMEQUALVERIFY:
        case $bs6mg.OP_NUMNOTEQUAL:
        case $bs6mg.OP_LESSTHAN:
        case $bs6mg.OP_GREATERTHAN:
        case $bs6mg.OP_LESSTHANOREQUAL:
        case $bs6mg.OP_GREATERTHANOREQUAL:
        case $bs6mg.OP_MIN:
        case $bs6mg.OP_MAX:
            if (this.stack.length < 2) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            switch(a = $iDkJI.fromScriptNumBuffer(t(-2), N), R = $iDkJI.fromScriptNumBuffer(t(-1), N), O = new $iDkJI(0), A){
                case $bs6mg.OP_ADD:
                    O = a.add(R);
                    break;
                case $bs6mg.OP_SUB:
                    O = a.sub(R);
                    break;
                case $bs6mg.OP_MUL:
                    O = a.mul(R);
                    break;
                case $bs6mg.OP_DIV:
                    if (0 === R) return this.errstr = "SCRIPT_ERR_DIV_BY_ZERO", !1;
                    O = a.div(R);
                    break;
                case $bs6mg.OP_MOD:
                    if (0 === R) return this.errstr = "SCRIPT_ERR_DIV_BY_ZERO", !1;
                    O = a.mod(R);
                    break;
                case $bs6mg.OP_BOOLAND:
                    O = new $iDkJI((0 !== a.cmp($iDkJI.Zero) && 0 !== R.cmp($iDkJI.Zero)) + 0);
                    break;
                case $bs6mg.OP_BOOLOR:
                    O = new $iDkJI((0 !== a.cmp($iDkJI.Zero) || 0 !== R.cmp($iDkJI.Zero)) + 0);
                    break;
                case $bs6mg.OP_NUMEQUAL:
                case $bs6mg.OP_NUMEQUALVERIFY:
                    O = new $iDkJI((0 === a.cmp(R)) + 0);
                    break;
                case $bs6mg.OP_NUMNOTEQUAL:
                    O = new $iDkJI((0 !== a.cmp(R)) + 0);
                    break;
                case $bs6mg.OP_LESSTHAN:
                    O = new $iDkJI((a.cmp(R) < 0) + 0);
                    break;
                case $bs6mg.OP_GREATERTHAN:
                    O = new $iDkJI((a.cmp(R) > 0) + 0);
                    break;
                case $bs6mg.OP_LESSTHANOREQUAL:
                    O = new $iDkJI((a.cmp(R) <= 0) + 0);
                    break;
                case $bs6mg.OP_GREATERTHANOREQUAL:
                    O = new $iDkJI((a.cmp(R) >= 0) + 0);
                    break;
                case $bs6mg.OP_MIN:
                    O = a.cmp(R) < 0 ? a : R;
                    break;
                case $bs6mg.OP_MAX:
                    O = a.cmp(R) > 0 ? a : R;
            }
            if (this.stack.pop(), this.stack.pop(), this.stack.push(O.toScriptNumBuffer()), A === $bs6mg.OP_NUMEQUALVERIFY) {
                if (!$de3f395522167bc0$var$Interpreter.castToBool(t(-1))) return this.errstr = "SCRIPT_ERR_NUMEQUALVERIFY", !1;
                this.stack.pop();
            }
            break;
        case $bs6mg.OP_WITHIN:
            if (this.stack.length < 3) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            a = $iDkJI.fromScriptNumBuffer(t(-3), N), R = $iDkJI.fromScriptNumBuffer(t(-2), N);
            var B = $iDkJI.fromScriptNumBuffer(t(-1), N);
            T = R.cmp(a) <= 0 && a.cmp(B) < 0, this.stack.pop(), this.stack.pop(), this.stack.pop(), this.stack.push(T ? $de3f395522167bc0$var$Interpreter.true : $de3f395522167bc0$var$Interpreter.false);
            break;
        case $bs6mg.OP_RIPEMD160:
        case $bs6mg.OP_SHA1:
        case $bs6mg.OP_SHA256:
        case $bs6mg.OP_HASH160:
        case $bs6mg.OP_HASH256:
            if (this.stack.length < 1) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            var D;
            r = t(-1), A === $bs6mg.OP_RIPEMD160 ? D = $626sY.ripemd160(r) : A === $bs6mg.OP_SHA1 ? D = $626sY.sha1(r) : A === $bs6mg.OP_SHA256 ? D = $626sY.sha256(r) : A === $bs6mg.OP_HASH160 ? D = $626sY.sha256ripemd160(r) : A === $bs6mg.OP_HASH256 && (D = $626sY.sha256sha256(r)), this.stack.pop(), this.stack.push(D);
            break;
        case $bs6mg.OP_CODESEPARATOR:
            this.pbegincodehash = this.pc;
            break;
        case $bs6mg.OP_CHECKSIG:
        case $bs6mg.OP_CHECKSIGVERIFY:
            if (this.stack.length < 2) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            if (p = t(-2), E = t(-1), !this.checkSignatureEncoding(p) || !this.checkPubkeyEncoding(E)) return !1;
            P = (new $aPyB5).set({
                chunks: this.script.chunks.slice(this.pbegincodehash)
            });
            var U = (new $aPyB5).add(p);
            P.findAndDelete(U);
            try {
                o = $217RI.fromTxFormat(p), S = $2OQpG.fromBuffer(E, !1), f = this.tx.verifySignature(o, S, this.nin, P, this.satoshisBN, this.flags);
            } catch (e6) {
                f = !1;
            }
            if (!f && this.flags & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_NULLFAIL && p.length) return this.errstr = "SCRIPT_ERR_NULLFAIL", !1;
            if (this.stack.pop(), this.stack.pop(), this.stack.push(f ? $de3f395522167bc0$var$Interpreter.true : $de3f395522167bc0$var$Interpreter.false), A === $bs6mg.OP_CHECKSIGVERIFY) {
                if (!f) return this.errstr = "SCRIPT_ERR_CHECKSIGVERIFY", !1;
                this.stack.pop();
            }
            break;
        case $bs6mg.OP_CHECKMULTISIG:
        case $bs6mg.OP_CHECKMULTISIGVERIFY:
            var V = 1;
            if (this.stack.length < V) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            var m = $iDkJI.fromScriptNumBuffer(t(-V), N).toNumber();
            if (m < 0 || m > 20) return this.errstr = "SCRIPT_ERR_PUBKEY_COUNT", !1;
            if (this.nOpCount += m, this.nOpCount > 201) return this.errstr = "SCRIPT_ERR_OP_COUNT", !1;
            var F = ++V;
            V += m;
            var K = m + 2;
            if (this.stack.length < V) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            var b = $iDkJI.fromScriptNumBuffer(t(-V), N).toNumber();
            if (b < 0 || b > m) return this.errstr = "SCRIPT_ERR_SIG_COUNT", !1;
            var M = ++V;
            if (V += b, this.stack.length < V) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            P = (new $aPyB5).set({
                chunks: this.script.chunks.slice(this.pbegincodehash)
            });
            for(var H = 0; H < b; H++)p = t(-M - H), P.findAndDelete((new $aPyB5).add(p));
            for(f = !0; f && b > 0;){
                if (p = t(-M), E = t(-F), !this.checkSignatureEncoding(p) || !this.checkPubkeyEncoding(E)) return !1;
                var Y;
                try {
                    o = $217RI.fromTxFormat(p), S = $2OQpG.fromBuffer(E, !1), Y = this.tx.verifySignature(o, S, this.nin, P, this.satoshisBN, this.flags);
                } catch (e7) {
                    Y = !1;
                }
                Y && (M++, b--), F++, b > --m && (f = !1);
            }
            for(; V-- > 1;){
                if (!f && this.flags & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_NULLFAIL && !K && t(-1).length) return this.errstr = "SCRIPT_ERR_NULLFAIL", !1;
                K > 0 && K--, this.stack.pop();
            }
            if (this.stack.length < 1) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            if (this.flags & $de3f395522167bc0$var$Interpreter.SCRIPT_VERIFY_NULLDUMMY && t(-1).length) return this.errstr = "SCRIPT_ERR_SIG_NULLDUMMY", !1;
            if (this.stack.pop(), this.stack.push(f ? $de3f395522167bc0$var$Interpreter.true : $de3f395522167bc0$var$Interpreter.false), A === $bs6mg.OP_CHECKMULTISIGVERIFY) {
                if (!f) return this.errstr = "SCRIPT_ERR_CHECKMULTISIGVERIFY", !1;
                this.stack.pop();
            }
            break;
        case $bs6mg.OP_CAT:
            if (this.stack.length < 2) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            if (s = t(-2), i = t(-1), s.length + i.length > $de3f395522167bc0$var$Interpreter.MAX_SCRIPT_ELEMENT_SIZE) return this.errstr = "SCRIPT_ERR_PUSH_SIZE", !1;
            this.stack[this.stack.length - 2] = $de3f395522167bc0$require$Buffer.concat([
                s,
                i
            ]), this.stack.pop();
            break;
        case $bs6mg.OP_SPLIT:
            if (this.stack.length < 2) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            s = t(-2);
            var v = $iDkJI.fromScriptNumBuffer(t(-1), N).toNumber();
            if (v < 0 || v > s.length) return this.errstr = "SCRIPT_ERR_INVALID_SPLIT_RANGE", !1;
            var G = $de3f395522167bc0$require$Buffer.from(s);
            this.stack[this.stack.length - 2] = G.slice(0, v), this.stack[this.stack.length - 1] = G.slice(v);
            break;
        case $bs6mg.OP_NUM2BIN:
            if (this.stack.length < 2) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            var y = $iDkJI.fromScriptNumBuffer(t(-1), N).toNumber();
            if (y > $de3f395522167bc0$var$Interpreter.MAX_SCRIPT_ELEMENT_SIZE) return this.errstr = "SCRIPT_ERR_PUSH_SIZE", !1;
            this.stack.pop();
            var w = t(-1);
            if ((w = $de3f395522167bc0$var$Interpreter._minimallyEncode(w)).length > y) return this.errstr = "SCRIPT_ERR_IMPOSSIBLE_ENCODING", !1;
            if (w.length === y) {
                this.stack[this.stack.length - 1] = w;
                break;
            }
            var x = 0;
            w.length > 0 && (x = 128 & w[w.length - 1], w[w.length - 1] &= 127);
            var Q = $de3f395522167bc0$require$Buffer.alloc(y);
            w.copy(Q, 0);
            for(var Z = w.length - 1; Z++ < y - 2;)Q[Z] = 0;
            Q[Z] = x, this.stack[this.stack.length - 1] = Q;
            break;
        case $bs6mg.OP_BIN2NUM:
            if (this.stack.length < 1) return this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
            if (s = t(-1), i = $de3f395522167bc0$var$Interpreter._minimallyEncode(s), this.stack[this.stack.length - 1] = i, !$de3f395522167bc0$var$Interpreter._isMinimallyEncoded(i)) return this.errstr = "SCRIPT_ERR_INVALID_NUMBER_RANGE", !1;
            break;
        default:
            return this.errstr = "SCRIPT_ERR_BAD_OPCODE", !1;
    }
    return !0;
};

});
parcelRequire.register("4qF1g", function(module, exports) {
"use strict";

var $eXOXZ = parcelRequire("eXOXZ");

var $28Q8f = parcelRequire("28Q8f");

var $kyyVO = parcelRequire("kyyVO");
function $339968bd9a971c45$var$cloneDeep(val, instanceClone) {
    switch($28Q8f(val)){
        case "object":
            return $339968bd9a971c45$var$cloneObjectDeep(val, instanceClone);
        case "array":
            return $339968bd9a971c45$var$cloneArrayDeep(val, instanceClone);
        default:
            return $eXOXZ(val);
    }
}
function $339968bd9a971c45$var$cloneObjectDeep(val, instanceClone) {
    if (typeof instanceClone === "function") return instanceClone(val);
    if (instanceClone || $kyyVO(val)) {
        const res = new val.constructor();
        for(let key in val)res[key] = $339968bd9a971c45$var$cloneDeep(val[key], instanceClone);
        return res;
    }
    return val;
}
function $339968bd9a971c45$var$cloneArrayDeep(val, instanceClone) {
    const res = new val.constructor(val.length);
    for(let i = 0; i < val.length; i++)res[i] = $339968bd9a971c45$var$cloneDeep(val[i], instanceClone);
    return res;
}
/**
 * Expose `cloneDeep`
 */ module.exports = $339968bd9a971c45$var$cloneDeep;

});
parcelRequire.register("eXOXZ", function(module, exports) {
/*!
 * shallow-clone <https://github.com/jonschlinkert/shallow-clone>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */ 
var $ae4e1c4bd41c1f67$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";
const $ae4e1c4bd41c1f67$var$valueOf = Symbol.prototype.valueOf;

var $28Q8f = parcelRequire("28Q8f");
function $ae4e1c4bd41c1f67$var$clone(val, deep) {
    switch($28Q8f(val)){
        case "array":
            return val.slice();
        case "object":
            return Object.assign({}, val);
        case "date":
            return new val.constructor(Number(val));
        case "map":
            return new Map(val);
        case "set":
            return new Set(val);
        case "buffer":
            return $ae4e1c4bd41c1f67$var$cloneBuffer(val);
        case "symbol":
            return $ae4e1c4bd41c1f67$var$cloneSymbol(val);
        case "arraybuffer":
            return $ae4e1c4bd41c1f67$var$cloneArrayBuffer(val);
        case "float32array":
        case "float64array":
        case "int16array":
        case "int32array":
        case "int8array":
        case "uint16array":
        case "uint32array":
        case "uint8clampedarray":
        case "uint8array":
            return $ae4e1c4bd41c1f67$var$cloneTypedArray(val);
        case "regexp":
            return $ae4e1c4bd41c1f67$var$cloneRegExp(val);
        case "error":
            return Object.create(val);
        default:
            return val;
    }
}
function $ae4e1c4bd41c1f67$var$cloneRegExp(val) {
    const flags = val.flags !== void 0 ? val.flags : /\w+$/.exec(val) || void 0;
    const re = new val.constructor(val.source, flags);
    re.lastIndex = val.lastIndex;
    return re;
}
function $ae4e1c4bd41c1f67$var$cloneArrayBuffer(val) {
    const res = new val.constructor(val.byteLength);
    new Uint8Array(res).set(new Uint8Array(val));
    return res;
}
function $ae4e1c4bd41c1f67$var$cloneTypedArray(val, deep) {
    return new val.constructor(val.buffer, val.byteOffset, val.length);
}
function $ae4e1c4bd41c1f67$var$cloneBuffer(val) {
    const len = val.length;
    const buf = $ae4e1c4bd41c1f67$require$Buffer.allocUnsafe ? $ae4e1c4bd41c1f67$require$Buffer.allocUnsafe(len) : $ae4e1c4bd41c1f67$require$Buffer.from(len);
    val.copy(buf);
    return buf;
}
function $ae4e1c4bd41c1f67$var$cloneSymbol(val) {
    return $ae4e1c4bd41c1f67$var$valueOf ? Object($ae4e1c4bd41c1f67$var$valueOf.call(val)) : {};
}
/**
 * Expose `clone`
 */ module.exports = $ae4e1c4bd41c1f67$var$clone;

});
parcelRequire.register("28Q8f", function(module, exports) {
var $18f4c473ecb0f722$var$toString = Object.prototype.toString;
module.exports = function kindOf(val) {
    if (val === void 0) return "undefined";
    if (val === null) return "null";
    var type = typeof val;
    if (type === "boolean") return "boolean";
    if (type === "string") return "string";
    if (type === "number") return "number";
    if (type === "symbol") return "symbol";
    if (type === "function") return $18f4c473ecb0f722$var$isGeneratorFn(val) ? "generatorfunction" : "function";
    if ($18f4c473ecb0f722$var$isArray(val)) return "array";
    if ($18f4c473ecb0f722$var$isBuffer(val)) return "buffer";
    if ($18f4c473ecb0f722$var$isArguments(val)) return "arguments";
    if ($18f4c473ecb0f722$var$isDate(val)) return "date";
    if ($18f4c473ecb0f722$var$isError(val)) return "error";
    if ($18f4c473ecb0f722$var$isRegexp(val)) return "regexp";
    switch($18f4c473ecb0f722$var$ctorName(val)){
        case "Symbol":
            return "symbol";
        case "Promise":
            return "promise";
        // Set, Map, WeakSet, WeakMap
        case "WeakMap":
            return "weakmap";
        case "WeakSet":
            return "weakset";
        case "Map":
            return "map";
        case "Set":
            return "set";
        // 8-bit typed arrays
        case "Int8Array":
            return "int8array";
        case "Uint8Array":
            return "uint8array";
        case "Uint8ClampedArray":
            return "uint8clampedarray";
        // 16-bit typed arrays
        case "Int16Array":
            return "int16array";
        case "Uint16Array":
            return "uint16array";
        // 32-bit typed arrays
        case "Int32Array":
            return "int32array";
        case "Uint32Array":
            return "uint32array";
        case "Float32Array":
            return "float32array";
        case "Float64Array":
            return "float64array";
    }
    if ($18f4c473ecb0f722$var$isGeneratorObj(val)) return "generator";
    // Non-plain objects
    type = $18f4c473ecb0f722$var$toString.call(val);
    switch(type){
        case "[object Object]":
            return "object";
        // iterators
        case "[object Map Iterator]":
            return "mapiterator";
        case "[object Set Iterator]":
            return "setiterator";
        case "[object String Iterator]":
            return "stringiterator";
        case "[object Array Iterator]":
            return "arrayiterator";
    }
    // other
    return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
};
function $18f4c473ecb0f722$var$ctorName(val) {
    return typeof val.constructor === "function" ? val.constructor.name : null;
}
function $18f4c473ecb0f722$var$isArray(val) {
    if (Array.isArray) return Array.isArray(val);
    return val instanceof Array;
}
function $18f4c473ecb0f722$var$isError(val) {
    return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function $18f4c473ecb0f722$var$isDate(val) {
    if (val instanceof Date) return true;
    return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function $18f4c473ecb0f722$var$isRegexp(val) {
    if (val instanceof RegExp) return true;
    return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
}
function $18f4c473ecb0f722$var$isGeneratorFn(name, val) {
    return $18f4c473ecb0f722$var$ctorName(name) === "GeneratorFunction";
}
function $18f4c473ecb0f722$var$isGeneratorObj(val) {
    return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
}
function $18f4c473ecb0f722$var$isArguments(val) {
    try {
        if (typeof val.length === "number" && typeof val.callee === "function") return true;
    } catch (err) {
        if (err.message.indexOf("callee") !== -1) return true;
    }
    return false;
}
/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */ function $18f4c473ecb0f722$var$isBuffer(val) {
    if (val.constructor && typeof val.constructor.isBuffer === "function") return val.constructor.isBuffer(val);
    return false;
}

});


parcelRequire.register("kyyVO", function(module, exports) {
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */ "use strict";

var $j49wy = parcelRequire("j49wy");
function $ef72144c87c38e30$var$isObjectObject(o) {
    return $j49wy(o) === true && Object.prototype.toString.call(o) === "[object Object]";
}
module.exports = function isPlainObject(o) {
    var ctor, prot;
    if ($ef72144c87c38e30$var$isObjectObject(o) === false) return false;
    // If has modified constructor
    ctor = o.constructor;
    if (typeof ctor !== "function") return false;
    // If has modified prototype
    prot = ctor.prototype;
    if ($ef72144c87c38e30$var$isObjectObject(prot) === false) return false;
    // If constructor does not have an Object-specific method
    if (prot.hasOwnProperty("isPrototypeOf") === false) return false;
    // Most likely a plain Object
    return true;
};

});
parcelRequire.register("j49wy", function(module, exports) {
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */ "use strict";
module.exports = function isObject(val) {
    return val != null && typeof val === "object" && Array.isArray(val) === false;
};

});



parcelRequire.register("iOIbA", function(module, exports) {






module.exports = (parcelRequire("lVHxO")), module.exports.Input = (parcelRequire("gJlWw")), module.exports.Output = (parcelRequire("5DwX3")), module.exports.UnspentOutput = (parcelRequire("gzMxy")), module.exports.Signature = (parcelRequire("5hdrK")), module.exports.Sighash = (parcelRequire("77Bxe"));

});
parcelRequire.register("lVHxO", function(module, exports) {

var $ff70b2d893cbd26a$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $jk7hO = parcelRequire("jk7hO");

var $2EPYC = parcelRequire("2EPYC");


var $7Wzz9 = parcelRequire("7Wzz9");

var $aYsCb = parcelRequire("aYsCb");

var $3vHUG = parcelRequire("3vHUG");

var $i6ihF = parcelRequire("i6ihF");

var $3fWN4 = parcelRequire("3fWN4");

var $626sY = parcelRequire("626sY");

var $217RI = parcelRequire("217RI");

var $77Bxe = parcelRequire("77Bxe");

var $bM62Y = parcelRequire("bM62Y");

var $gzMxy = parcelRequire("gzMxy");

var $gJlWw = parcelRequire("gJlWw");
var $ff70b2d893cbd26a$var$PublicKeyHashInput = $gJlWw.PublicKeyHash, $ff70b2d893cbd26a$var$PublicKeyInput = $gJlWw.PublicKey, $ff70b2d893cbd26a$var$MultiSigScriptHashInput = $gJlWw.MultiSigScriptHash, $ff70b2d893cbd26a$var$MultiSigInput = $gJlWw.MultiSig;

var $5DwX3 = parcelRequire("5DwX3");

var $51Dlk = parcelRequire("51Dlk");

var $9jEuU = parcelRequire("9jEuU");

var $iDkJI = parcelRequire("iDkJI");
function $ff70b2d893cbd26a$var$Transaction(t) {
    if (!(this instanceof $ff70b2d893cbd26a$var$Transaction)) return new $ff70b2d893cbd26a$var$Transaction(t);
    if (this.inputs = [], this.outputs = [], this._inputAmount = void 0, this._outputAmount = void 0, t) {
        if (t instanceof $ff70b2d893cbd26a$var$Transaction) return $ff70b2d893cbd26a$var$Transaction.shallowCopy(t);
        if ($aYsCb.isHexa(t)) this.fromString(t);
        else if ($ff70b2d893cbd26a$require$Buffer.isBuffer(t)) this.fromBuffer(t);
        else {
            if (!$jk7hO.isObject(t)) throw new $7Wzz9.InvalidArgument("Must provide an object or string to deserialize a transaction");
            this.fromObject(t);
        }
    } else this._newTransaction();
}
var $ff70b2d893cbd26a$var$CURRENT_VERSION = 1, $ff70b2d893cbd26a$var$DEFAULT_NLOCKTIME = 0, $ff70b2d893cbd26a$var$MAX_BLOCK_SIZE = 1e6;
$ff70b2d893cbd26a$var$Transaction.DUST_AMOUNT = 546, $ff70b2d893cbd26a$var$Transaction.FEE_SECURITY_MARGIN = 150, $ff70b2d893cbd26a$var$Transaction.MAX_MONEY = 21e14, $ff70b2d893cbd26a$var$Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT = 5e8, $ff70b2d893cbd26a$var$Transaction.NLOCKTIME_MAX_VALUE = 4294967295, $ff70b2d893cbd26a$var$Transaction.FEE_PER_KB = 500, $ff70b2d893cbd26a$var$Transaction.CHANGE_OUTPUT_MAX_SIZE = 62, $ff70b2d893cbd26a$var$Transaction.shallowCopy = function(t) {
    return new $ff70b2d893cbd26a$var$Transaction(t.toBuffer());
};
var $ff70b2d893cbd26a$var$hashProperty = {
    configurable: !1,
    enumerable: !0,
    get: function() {
        return this._hash = new $3vHUG(this._getHash()).readReverse().toString("hex"), this._hash;
    }
};
Object.defineProperty($ff70b2d893cbd26a$var$Transaction.prototype, "hash", $ff70b2d893cbd26a$var$hashProperty), Object.defineProperty($ff70b2d893cbd26a$var$Transaction.prototype, "id", $ff70b2d893cbd26a$var$hashProperty);
var $ff70b2d893cbd26a$var$ioProperty = {
    configurable: !1,
    enumerable: !0,
    get: function() {
        return this._getInputAmount();
    }
};
Object.defineProperty($ff70b2d893cbd26a$var$Transaction.prototype, "inputAmount", $ff70b2d893cbd26a$var$ioProperty), $ff70b2d893cbd26a$var$ioProperty.get = function() {
    return this._getOutputAmount();
}, Object.defineProperty($ff70b2d893cbd26a$var$Transaction.prototype, "outputAmount", $ff70b2d893cbd26a$var$ioProperty), $ff70b2d893cbd26a$var$Transaction.prototype._getHash = function() {
    return $626sY.sha256sha256(this.toBuffer());
}, $ff70b2d893cbd26a$var$Transaction.prototype.serialize = function(t) {
    return !0 === t || t && t.disableAll ? this.uncheckedSerialize() : this.checkedSerialize(t);
}, $ff70b2d893cbd26a$var$Transaction.prototype.uncheckedSerialize = $ff70b2d893cbd26a$var$Transaction.prototype.toString = function() {
    return this.toBuffer().toString("hex");
}, $ff70b2d893cbd26a$var$Transaction.prototype.checkedSerialize = function(t) {
    var n = this.getSerializationError(t);
    if (n) throw n.message += " - For more information please see: https://bsv.io/api/lib/transaction#serialization-checks", n;
    return this.uncheckedSerialize();
}, $ff70b2d893cbd26a$var$Transaction.prototype.invalidSatoshis = function() {
    for(var t = !1, n = 0; n < this.outputs.length; n++)this.outputs[n].invalidSatoshis() && (t = !0);
    return t;
}, $ff70b2d893cbd26a$var$Transaction.prototype.getSerializationError = function(t) {
    if (t = t || {}, this.invalidSatoshis()) return new $7Wzz9.Transaction.InvalidSatoshis;
    var n, i = this._getUnspentValue();
    return i < 0 ? t.disableMoreOutputThanInput || (n = new $7Wzz9.Transaction.InvalidOutputAmountSum) : n = this._hasFeeError(t, i), n || this._hasDustOutputs(t) || this._isMissingSignatures(t);
}, $ff70b2d893cbd26a$var$Transaction.prototype._hasFeeError = function(t, n) {
    if (!$jk7hO.isUndefined(this._fee) && this._fee !== n) return new $7Wzz9.Transaction.FeeError.Different("Unspent value is " + n + " but specified fee is " + this._fee);
    if (!t.disableLargeFees) {
        var i = Math.floor($ff70b2d893cbd26a$var$Transaction.FEE_SECURITY_MARGIN * this._estimateFee());
        if (n > i) return this._missingChange() ? new $7Wzz9.Transaction.ChangeAddressMissing("Fee is too large and no change address was provided") : new $7Wzz9.Transaction.FeeError.TooLarge("expected less than " + i + " but got " + n);
    }
}, $ff70b2d893cbd26a$var$Transaction.prototype._missingChange = function() {
    return !this._changeScript;
}, $ff70b2d893cbd26a$var$Transaction.prototype._hasDustOutputs = function(t) {
    var n, i;
    if (!t.disableDustOutputs) {
        for(n in this.outputs)if ((i = this.outputs[n]).satoshis < $ff70b2d893cbd26a$var$Transaction.DUST_AMOUNT && !i.script.isDataOut() && !i.script.isSafeDataOut()) return new $7Wzz9.Transaction.DustOutputs;
    }
}, $ff70b2d893cbd26a$var$Transaction.prototype._isMissingSignatures = function(t) {
    if (!t.disableIsFullySigned) return this.isFullySigned() ? void 0 : new $7Wzz9.Transaction.MissingSignatures;
}, $ff70b2d893cbd26a$var$Transaction.prototype.inspect = function() {
    return "<Transaction: " + this.uncheckedSerialize() + ">";
}, $ff70b2d893cbd26a$var$Transaction.prototype.toBuffer = function() {
    var t = new $i6ihF;
    return this.toBufferWriter(t).toBuffer();
}, $ff70b2d893cbd26a$var$Transaction.prototype.toBufferWriter = function(t) {
    return t.writeInt32LE(this.version), t.writeVarintNum(this.inputs.length), $jk7hO.each(this.inputs, function(n) {
        n.toBufferWriter(t);
    }), t.writeVarintNum(this.outputs.length), $jk7hO.each(this.outputs, function(n) {
        n.toBufferWriter(t);
    }), t.writeUInt32LE(this.nLockTime), t;
}, $ff70b2d893cbd26a$var$Transaction.prototype.fromBuffer = function(t) {
    var n = new $3vHUG(t);
    return this.fromBufferReader(n);
}, $ff70b2d893cbd26a$var$Transaction.prototype.fromBufferReader = function(t) {
    var n, i, e;
    for($2EPYC.checkArgument(!t.finished(), "No transaction data received"), this.version = t.readInt32LE(), i = t.readVarintNum(), n = 0; n < i; n++){
        var r = $gJlWw.fromBufferReader(t);
        this.inputs.push(r);
    }
    for(e = t.readVarintNum(), n = 0; n < e; n++)this.outputs.push($5DwX3.fromBufferReader(t));
    return this.nLockTime = t.readUInt32LE(), this;
}, $ff70b2d893cbd26a$var$Transaction.prototype.toObject = $ff70b2d893cbd26a$var$Transaction.prototype.toJSON = function() {
    var t = [];
    this.inputs.forEach(function(n) {
        t.push(n.toObject());
    });
    var n = [];
    this.outputs.forEach(function(t) {
        n.push(t.toObject());
    });
    var i = {
        hash: this.hash,
        version: this.version,
        inputs: t,
        outputs: n,
        nLockTime: this.nLockTime
    };
    return this._changeScript && (i.changeScript = this._changeScript.toString()), $jk7hO.isUndefined(this._changeIndex) || (i.changeIndex = this._changeIndex), $jk7hO.isUndefined(this._fee) || (i.fee = this._fee), i;
}, $ff70b2d893cbd26a$var$Transaction.prototype.fromObject = function(t) {
    $2EPYC.checkArgument($jk7hO.isObject(t) || t instanceof $ff70b2d893cbd26a$var$Transaction);
    var n, i = this;
    return n = t instanceof $ff70b2d893cbd26a$var$Transaction ? n.toObject() : t, $jk7hO.each(n.inputs, function(t) {
        if (t.output && t.output.script) {
            var n, e = new $51Dlk(t.output.script);
            if (e.isPublicKeyHashOut()) n = new $gJlWw.PublicKeyHash(t);
            else if (e.isScriptHashOut() && t.publicKeys && t.threshold) n = new $gJlWw.MultiSigScriptHash(t, t.publicKeys, t.threshold, t.signatures);
            else {
                if (!e.isPublicKeyOut()) throw new $7Wzz9.Transaction.Input.UnsupportedScript(t.output.script);
                n = new $gJlWw.PublicKey(t);
            }
            i.addInput(n);
        } else i.uncheckedAddInput(new $gJlWw(t));
    }), $jk7hO.each(n.outputs, function(t) {
        i.addOutput(new $5DwX3(t));
    }), n.changeIndex && (this._changeIndex = n.changeIndex), n.changeScript && (this._changeScript = new $51Dlk(n.changeScript)), n.fee && (this._fee = n.fee), this.nLockTime = n.nLockTime, this.version = n.version, this._checkConsistency(t), this;
}, $ff70b2d893cbd26a$var$Transaction.prototype._checkConsistency = function(t) {
    $jk7hO.isUndefined(this._changeIndex) || ($2EPYC.checkState(this._changeScript, "Change script is expected."), $2EPYC.checkState(this.outputs[this._changeIndex], "Change index points to undefined output."), $2EPYC.checkState(this.outputs[this._changeIndex].script.toString() === this._changeScript.toString(), "Change output has an unexpected script.")), t && t.hash && $2EPYC.checkState(t.hash === this.hash, "Hash in object does not match transaction hash.");
}, $ff70b2d893cbd26a$var$Transaction.prototype.lockUntilDate = function(t) {
    if ($2EPYC.checkArgument(t), $jk7hO.isNumber(t) && t < $ff70b2d893cbd26a$var$Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) throw new $7Wzz9.Transaction.LockTimeTooEarly;
    $jk7hO.isDate(t) && (t = t.getTime() / 1e3);
    for(var n = 0; n < this.inputs.length; n++)this.inputs[n].sequenceNumber === $gJlWw.DEFAULT_SEQNUMBER && (this.inputs[n].sequenceNumber = $gJlWw.DEFAULT_LOCKTIME_SEQNUMBER);
    return this.nLockTime = t, this;
}, $ff70b2d893cbd26a$var$Transaction.prototype.lockUntilBlockHeight = function(t) {
    if ($2EPYC.checkArgument($jk7hO.isNumber(t)), t >= $ff70b2d893cbd26a$var$Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) throw new $7Wzz9.Transaction.BlockHeightTooHigh;
    if (t < 0) throw new $7Wzz9.Transaction.NLockTimeOutOfRange;
    for(var n = 0; n < this.inputs.length; n++)this.inputs[n].sequenceNumber === $gJlWw.DEFAULT_SEQNUMBER && (this.inputs[n].sequenceNumber = $gJlWw.DEFAULT_LOCKTIME_SEQNUMBER);
    return this.nLockTime = t, this;
}, $ff70b2d893cbd26a$var$Transaction.prototype.getLockTime = function() {
    return this.nLockTime ? this.nLockTime < $ff70b2d893cbd26a$var$Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT ? this.nLockTime : new Date(1e3 * this.nLockTime) : null;
}, $ff70b2d893cbd26a$var$Transaction.prototype.fromString = function(t) {
    this.fromBuffer($hiCjL$buffer.Buffer.from(t, "hex"));
}, $ff70b2d893cbd26a$var$Transaction.prototype._newTransaction = function() {
    this.version = $ff70b2d893cbd26a$var$CURRENT_VERSION, this.nLockTime = $ff70b2d893cbd26a$var$DEFAULT_NLOCKTIME;
}, $ff70b2d893cbd26a$var$Transaction.prototype.from = function(t, n, i) {
    if ($jk7hO.isArray(t)) {
        var e = this;
        return $jk7hO.each(t, function(t) {
            e.from(t, n, i);
        }), this;
    }
    return $jk7hO.some(this.inputs, function(n) {
        return n.prevTxId.toString("hex") === t.txId && n.outputIndex === t.outputIndex;
    }) || (n && i ? this._fromMultisigUtxo(t, n, i) : this._fromNonP2SH(t)), this;
}, $ff70b2d893cbd26a$var$Transaction.prototype._fromNonP2SH = function(t) {
    var n;
    n = (t = new $gzMxy(t)).script.isPublicKeyHashOut() ? $ff70b2d893cbd26a$var$PublicKeyHashInput : t.script.isPublicKeyOut() ? $ff70b2d893cbd26a$var$PublicKeyInput : $gJlWw, this.addInput(new n({
        output: new $5DwX3({
            script: t.script,
            satoshis: t.satoshis
        }),
        prevTxId: t.txId,
        outputIndex: t.outputIndex,
        script: $51Dlk.empty()
    }));
}, $ff70b2d893cbd26a$var$Transaction.prototype._fromMultisigUtxo = function(t, n, i) {
    var e;
    if ($2EPYC.checkArgument(i <= n.length, "Number of required signatures must be greater than the number of public keys"), (t = new $gzMxy(t)).script.isMultisigOut()) e = $ff70b2d893cbd26a$var$MultiSigInput;
    else {
        if (!t.script.isScriptHashOut()) throw new Error("@TODO");
        e = $ff70b2d893cbd26a$var$MultiSigScriptHashInput;
    }
    this.addInput(new e({
        output: new $5DwX3({
            script: t.script,
            satoshis: t.satoshis
        }),
        prevTxId: t.txId,
        outputIndex: t.outputIndex,
        script: $51Dlk.empty()
    }, n, i));
}, $ff70b2d893cbd26a$var$Transaction.prototype.addInput = function(t, n, i) {
    if ($2EPYC.checkArgumentType(t, $gJlWw, "input"), !t.output && ($jk7hO.isUndefined(n) || $jk7hO.isUndefined(i))) throw new $7Wzz9.Transaction.NeedMoreInfo("Need information about the UTXO script and satoshis");
    return t.output || !n || $jk7hO.isUndefined(i) || (n = n instanceof $51Dlk ? n : new $51Dlk(n), $2EPYC.checkArgumentType(i, "number", "satoshis"), t.output = new $5DwX3({
        script: n,
        satoshis: i
    })), this.uncheckedAddInput(t);
}, $ff70b2d893cbd26a$var$Transaction.prototype.uncheckedAddInput = function(t) {
    return $2EPYC.checkArgumentType(t, $gJlWw, "input"), this.inputs.push(t), this._inputAmount = void 0, this._updateChangeOutput(), this;
}, $ff70b2d893cbd26a$var$Transaction.prototype.hasAllUtxoInfo = function() {
    return $jk7hO.every(this.inputs.map(function(t) {
        return !!t.output;
    }));
}, $ff70b2d893cbd26a$var$Transaction.prototype.fee = function(t) {
    return $2EPYC.checkArgument($jk7hO.isNumber(t), "amount must be a number"), this._fee = t, this._updateChangeOutput(), this;
}, $ff70b2d893cbd26a$var$Transaction.prototype.feePerKb = function(t) {
    return $2EPYC.checkArgument($jk7hO.isNumber(t), "amount must be a number"), this._feePerKb = t, this._updateChangeOutput(), this;
}, $ff70b2d893cbd26a$var$Transaction.prototype.change = function(t) {
    return $2EPYC.checkArgument(t, "address is required"), this._changeScript = $51Dlk.fromAddress(t), this._updateChangeOutput(), this;
}, $ff70b2d893cbd26a$var$Transaction.prototype.getChangeOutput = function() {
    return $jk7hO.isUndefined(this._changeIndex) ? null : this.outputs[this._changeIndex];
}, $ff70b2d893cbd26a$var$Transaction.prototype.to = function(t, n) {
    if ($jk7hO.isArray(t)) {
        var i = this;
        return $jk7hO.each(t, function(t) {
            i.to(t.address, t.satoshis);
        }), this;
    }
    return $2EPYC.checkArgument($aYsCb.isNaturalNumber(n), "Amount is expected to be a positive integer"), this.addOutput(new $5DwX3({
        script: $51Dlk(new $bM62Y(t)),
        satoshis: n
    })), this;
}, $ff70b2d893cbd26a$var$Transaction.prototype.addData = function(t) {
    return this.addOutput(new $5DwX3({
        script: $51Dlk.buildDataOut(t),
        satoshis: 0
    })), this;
}, $ff70b2d893cbd26a$var$Transaction.prototype.addSafeData = function(t) {
    return this.addOutput(new $5DwX3({
        script: $51Dlk.buildSafeDataOut(t),
        satoshis: 0
    })), this;
}, $ff70b2d893cbd26a$var$Transaction.prototype.addOutput = function(t) {
    return $2EPYC.checkArgumentType(t, $5DwX3, "output"), this._addOutput(t), this._updateChangeOutput(), this;
}, $ff70b2d893cbd26a$var$Transaction.prototype.clearOutputs = function() {
    return this.outputs = [], this._clearSignatures(), this._outputAmount = void 0, this._changeIndex = void 0, this._updateChangeOutput(), this;
}, $ff70b2d893cbd26a$var$Transaction.prototype._addOutput = function(t) {
    this.outputs.push(t), this._outputAmount = void 0;
}, $ff70b2d893cbd26a$var$Transaction.prototype._getOutputAmount = function() {
    if ($jk7hO.isUndefined(this._outputAmount)) {
        var t = this;
        this._outputAmount = 0, $jk7hO.each(this.outputs, function(n) {
            t._outputAmount += n.satoshis;
        });
    }
    return this._outputAmount;
}, $ff70b2d893cbd26a$var$Transaction.prototype._getInputAmount = function() {
    if ($jk7hO.isUndefined(this._inputAmount)) {
        var t = this;
        this._inputAmount = 0, $jk7hO.each(this.inputs, function(n) {
            if ($jk7hO.isUndefined(n.output)) throw new $7Wzz9.Transaction.Input.MissingPreviousOutput;
            t._inputAmount += n.output.satoshis;
        });
    }
    return this._inputAmount;
}, $ff70b2d893cbd26a$var$Transaction.prototype._updateChangeOutput = function() {
    if (this._changeScript) {
        this._clearSignatures(), $jk7hO.isUndefined(this._changeIndex) || this._removeOutput(this._changeIndex), this._changeIndex = this.outputs.length, this._addOutput(new $5DwX3({
            script: this._changeScript,
            satoshis: 0
        }));
        var t = this._getUnspentValue() - this.getFee();
        this._removeOutput(this._changeIndex), this._changeIndex = void 0, t >= $ff70b2d893cbd26a$var$Transaction.DUST_AMOUNT && (this._changeIndex = this.outputs.length, this._addOutput(new $5DwX3({
            script: this._changeScript,
            satoshis: t
        })));
    }
}, $ff70b2d893cbd26a$var$Transaction.prototype.getFee = function() {
    return this.isCoinbase() ? 0 : $jk7hO.isUndefined(this._fee) ? this._changeScript ? this._estimateFee() : this._getUnspentValue() : this._fee;
}, $ff70b2d893cbd26a$var$Transaction.prototype._estimateFee = function() {
    var t = this._estimateSize();
    return Math.ceil(t / 1e3 * (this._feePerKb || $ff70b2d893cbd26a$var$Transaction.FEE_PER_KB));
}, $ff70b2d893cbd26a$var$Transaction.prototype._getUnspentValue = function() {
    return this._getInputAmount() - this._getOutputAmount();
}, $ff70b2d893cbd26a$var$Transaction.prototype._clearSignatures = function() {
    $jk7hO.each(this.inputs, function(t) {
        t.clearSignatures();
    });
}, $ff70b2d893cbd26a$var$Transaction.prototype._estimateSize = function() {
    var t = 8;
    return t += $3fWN4(this.inputs.length).toBuffer().length, t += $3fWN4(this.outputs.length).toBuffer().length, $jk7hO.each(this.inputs, function(n) {
        t += n._estimateSize();
    }), $jk7hO.each(this.outputs, function(n) {
        t += n.getSize();
    }), t;
}, $ff70b2d893cbd26a$var$Transaction.prototype._removeOutput = function(t) {
    var n = this.outputs[t];
    this.outputs = $jk7hO.without(this.outputs, n), this._outputAmount = void 0;
}, $ff70b2d893cbd26a$var$Transaction.prototype.removeOutput = function(t) {
    this._removeOutput(t), this._updateChangeOutput();
}, $ff70b2d893cbd26a$var$Transaction.prototype.sort = function() {
    return this.sortInputs(function(t) {
        var n = Array.prototype.concat.apply([], t);
        return n.sort(function(t, n) {
            return t.prevTxId.compare(n.prevTxId) || t.outputIndex - n.outputIndex;
        }), n;
    }), this.sortOutputs(function(t) {
        var n = Array.prototype.concat.apply([], t);
        return n.sort(function(t, n) {
            return t.satoshis - n.satoshis || t.script.toBuffer().compare(n.script.toBuffer());
        }), n;
    }), this;
}, $ff70b2d893cbd26a$var$Transaction.prototype.shuffleOutputs = function() {
    return this.sortOutputs($jk7hO.shuffle);
}, $ff70b2d893cbd26a$var$Transaction.prototype.sortOutputs = function(t) {
    var n = t(this.outputs);
    return this._newOutputOrder(n);
}, $ff70b2d893cbd26a$var$Transaction.prototype.sortInputs = function(t) {
    return this.inputs = t(this.inputs), this._clearSignatures(), this;
}, $ff70b2d893cbd26a$var$Transaction.prototype._newOutputOrder = function(t) {
    if (this.outputs.length !== t.length || 0 !== $jk7hO.difference(this.outputs, t).length) throw new $7Wzz9.Transaction.InvalidSorting;
    if (!$jk7hO.isUndefined(this._changeIndex)) {
        var n = this.outputs[this._changeIndex];
        this._changeIndex = t.indexOf(n);
    }
    return this.outputs = t, this;
}, $ff70b2d893cbd26a$var$Transaction.prototype.removeInput = function(t, n) {
    var i;
    if (i = !n && $jk7hO.isNumber(t) ? t : $jk7hO.findIndex(this.inputs, function(i) {
        return i.prevTxId.toString("hex") === t && i.outputIndex === n;
    }), i < 0 || i >= this.inputs.length) throw new $7Wzz9.Transaction.InvalidIndex(i, this.inputs.length);
    var e = this.inputs[i];
    this.inputs = $jk7hO.without(this.inputs, e), this._inputAmount = void 0, this._updateChangeOutput();
}, $ff70b2d893cbd26a$var$Transaction.prototype.sign = function(t, n) {
    $2EPYC.checkState(this.hasAllUtxoInfo(), "Not all utxo information is available to sign the transaction.");
    var i = this;
    return $jk7hO.isArray(t) ? ($jk7hO.each(t, function(t) {
        i.sign(t, n);
    }), this) : ($jk7hO.each(this.getSignatures(t, n), function(t) {
        i.applySignature(t);
    }), this);
}, $ff70b2d893cbd26a$var$Transaction.prototype.getSignatures = function(t, n) {
    t = new $9jEuU(t), n = n || $217RI.SIGHASH_ALL | $217RI.SIGHASH_FORKID;
    var i = this, e = [], r = $626sY.sha256ripemd160(t.publicKey.toBuffer());
    return $jk7hO.each(this.inputs, function(s, u) {
        $jk7hO.each(s.getSignatures(i, t, u, n, r), function(t) {
            e.push(t);
        });
    }), e;
}, $ff70b2d893cbd26a$var$Transaction.prototype.applySignature = function(t) {
    return this.inputs[t.inputIndex].addSignature(this, t), this;
}, $ff70b2d893cbd26a$var$Transaction.prototype.isFullySigned = function() {
    return $jk7hO.each(this.inputs, function(t) {
        if (t.isFullySigned === $gJlWw.prototype.isFullySigned) throw new $7Wzz9.Transaction.UnableToVerifySignature("Unrecognized script kind, or not enough information to execute script.This usually happens when creating a transaction from a serialized transaction");
    }), $jk7hO.every($jk7hO.map(this.inputs, function(t) {
        return t.isFullySigned();
    }));
}, $ff70b2d893cbd26a$var$Transaction.prototype.isValidSignature = function(t) {
    if (this.inputs[t.inputIndex].isValidSignature === $gJlWw.prototype.isValidSignature) throw new $7Wzz9.Transaction.UnableToVerifySignature("Unrecognized script kind, or not enough information to execute script.This usually happens when creating a transaction from a serialized transaction");
    return this.inputs[t.inputIndex].isValidSignature(this, t);
}, $ff70b2d893cbd26a$var$Transaction.prototype.verifySignature = function(t, n, i, e, r, s) {
    return $77Bxe.verify(this, t, n, i, e, r, s);
}, $ff70b2d893cbd26a$var$Transaction.prototype.verify = function() {
    if (0 === this.inputs.length) return "transaction txins empty";
    if (0 === this.outputs.length) return "transaction txouts empty";
    for(var t = new $iDkJI(0), n = 0; n < this.outputs.length; n++){
        var i = this.outputs[n];
        if (i.invalidSatoshis()) return "transaction txout " + n + " satoshis is invalid";
        if (i._satoshisBN.gt(new $iDkJI($ff70b2d893cbd26a$var$Transaction.MAX_MONEY, 10))) return "transaction txout " + n + " greater than MAX_MONEY";
        if ((t = t.add(i._satoshisBN)).gt(new $iDkJI($ff70b2d893cbd26a$var$Transaction.MAX_MONEY))) return "transaction txout " + n + " total output greater than MAX_MONEY";
    }
    if (this.toBuffer().length > $ff70b2d893cbd26a$var$MAX_BLOCK_SIZE) return "transaction over the maximum block size";
    var e = {};
    for(n = 0; n < this.inputs.length; n++){
        var r = this.inputs[n], s = r.prevTxId + ":" + r.outputIndex;
        if (!$jk7hO.isUndefined(e[s])) return "transaction input " + n + " duplicate input";
        e[s] = !0;
    }
    if (this.isCoinbase()) {
        var u = this.inputs[0]._scriptBuffer;
        if (u.length < 2 || u.length > 100) return "coinbase transaction script size invalid";
    } else for(n = 0; n < this.inputs.length; n++)if (this.inputs[n].isNull()) return "transaction input " + n + " has null input";
    return !0;
}, $ff70b2d893cbd26a$var$Transaction.prototype.isCoinbase = function() {
    return 1 === this.inputs.length && this.inputs[0].isNull();
}, module.exports = $ff70b2d893cbd26a$var$Transaction;

});
parcelRequire.register("3fWN4", function(module, exports) {

var $25f060610ee3103a$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $i6ihF = parcelRequire("i6ihF");

var $3vHUG = parcelRequire("3vHUG");

var $iDkJI = parcelRequire("iDkJI");
var $25f060610ee3103a$var$Varint = function r(t) {
    if (!(this instanceof r)) return new r(t);
    if ($25f060610ee3103a$require$Buffer.isBuffer(t)) this.buf = t;
    else if ("number" == typeof t) {
        var e = t;
        this.fromNumber(e);
    } else if (t instanceof $iDkJI) {
        var i = t;
        this.fromBN(i);
    } else if (t) {
        var f = t;
        this.set(f);
    }
};
$25f060610ee3103a$var$Varint.prototype.set = function(r) {
    return this.buf = r.buf || this.buf, this;
}, $25f060610ee3103a$var$Varint.prototype.fromString = function(r) {
    return this.set({
        buf: $25f060610ee3103a$require$Buffer.from(r, "hex")
    }), this;
}, $25f060610ee3103a$var$Varint.prototype.toString = function() {
    return this.buf.toString("hex");
}, $25f060610ee3103a$var$Varint.prototype.fromBuffer = function(r) {
    return this.buf = r, this;
}, $25f060610ee3103a$var$Varint.prototype.fromBufferReader = function(r) {
    return this.buf = r.readVarintBuf(), this;
}, $25f060610ee3103a$var$Varint.prototype.fromBN = function(r) {
    return this.buf = $i6ihF().writeVarintBN(r).concat(), this;
}, $25f060610ee3103a$var$Varint.prototype.fromNumber = function(r) {
    return this.buf = $i6ihF().writeVarintNum(r).concat(), this;
}, $25f060610ee3103a$var$Varint.prototype.toBuffer = function() {
    return this.buf;
}, $25f060610ee3103a$var$Varint.prototype.toBN = function() {
    return $3vHUG(this.buf).readVarintBN();
}, $25f060610ee3103a$var$Varint.prototype.toNumber = function() {
    return $3vHUG(this.buf).readVarintNum();
}, module.exports = $25f060610ee3103a$var$Varint;

});

parcelRequire.register("77Bxe", function(module, exports) {

var $52f64d863bef9147$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";


var $217RI = parcelRequire("217RI");

var $51Dlk = parcelRequire("51Dlk");

var $5DwX3 = parcelRequire("5DwX3");

var $3vHUG = parcelRequire("3vHUG");

var $i6ihF = parcelRequire("i6ihF");

var $iDkJI = parcelRequire("iDkJI");

var $626sY = parcelRequire("626sY");

var $dNWce = parcelRequire("dNWce");

var $2EPYC = parcelRequire("2EPYC");

var $j50Xb = parcelRequire("j50Xb");

var $jk7hO = parcelRequire("jk7hO");
var $52f64d863bef9147$var$SIGHASH_SINGLE_BUG = $52f64d863bef9147$require$Buffer.from("0000000000000000000000000000000000000000000000000000000000000001", "hex"), $52f64d863bef9147$var$BITS_64_ON = "ffffffffffffffff", $52f64d863bef9147$var$DEFAULT_SIGN_FLAGS = $j50Xb.SCRIPT_ENABLE_SIGHASH_FORKID, $52f64d863bef9147$var$sighashPreimageForForkId = function(e, r, t, i, u) {
    var n = e.inputs[t];
    function f(e, r) {
        var t = new $i6ihF;
        $jk7hO.isUndefined(r) ? $jk7hO.each(e.outputs, function(e) {
            e.toBufferWriter(t);
        }) : e.outputs[r].toBufferWriter(t);
        var i = t.toBuffer();
        return $626sY.sha256sha256(i);
    }
    $2EPYC.checkArgument(u instanceof $iDkJI, "For ForkId=0 signatures, satoshis or complete input must be provided");
    var s = $52f64d863bef9147$require$Buffer.alloc(32), a = $52f64d863bef9147$require$Buffer.alloc(32), S = $52f64d863bef9147$require$Buffer.alloc(32);
    r & $217RI.SIGHASH_ANYONECANPAY || (s = function(e) {
        var r = new $i6ihF;
        $jk7hO.each(e.inputs, function(e) {
            r.writeReverse(e.prevTxId), r.writeUInt32LE(e.outputIndex);
        });
        var t = r.toBuffer();
        return $626sY.sha256sha256(t);
    }(e)), r & $217RI.SIGHASH_ANYONECANPAY || (31 & r) === $217RI.SIGHASH_SINGLE || (31 & r) === $217RI.SIGHASH_NONE || (a = function(e) {
        var r = new $i6ihF;
        $jk7hO.each(e.inputs, function(e) {
            r.writeUInt32LE(e.sequenceNumber);
        });
        var t = r.toBuffer();
        return $626sY.sha256sha256(t);
    }(e)), (31 & r) !== $217RI.SIGHASH_SINGLE && (31 & r) !== $217RI.SIGHASH_NONE ? S = f(e) : (31 & r) === $217RI.SIGHASH_SINGLE && t < e.outputs.length && (S = f(e, t));
    var o = new $i6ihF;
    o.writeInt32LE(e.version), o.write(s), o.write(a), o.writeReverse(n.prevTxId), o.writeUInt32LE(n.outputIndex), o.writeVarintNum(i.toBuffer().length), o.write(i.toBuffer()), o.writeUInt64LEBN(u);
    var h = n.sequenceNumber;
    return o.writeUInt32LE(h), o.write(S), o.writeUInt32LE(e.nLockTime), o.writeUInt32LE(r >>> 0), o.toBuffer();
};


var $52f64d863bef9147$var$sighashPreimage = function(e, r, t, i, u, n) {
    var f = (parcelRequire("lVHxO")), s = (parcelRequire("gJlWw"));
    $jk7hO.isUndefined(n) && (n = $52f64d863bef9147$var$DEFAULT_SIGN_FLAGS);
    var a, S = f.shallowCopy(e);
    if (i = new $51Dlk(i), n & $j50Xb.SCRIPT_ENABLE_REPLAY_PROTECTION && (r = (16711680 | 57005 ^ r >> 8) << 8 | 255 & r), r & $217RI.SIGHASH_FORKID && n & $j50Xb.SCRIPT_ENABLE_SIGHASH_FORKID) return $52f64d863bef9147$var$sighashPreimageForForkId(S, r, t, i, u);
    for(i.removeCodeseparators(), a = 0; a < S.inputs.length; a++)S.inputs[a] = new s(S.inputs[a]).setScript($51Dlk.empty());
    if (S.inputs[t] = new s(S.inputs[t]).setScript(i), (31 & r) === $217RI.SIGHASH_NONE || (31 & r) === $217RI.SIGHASH_SINGLE) for(a = 0; a < S.inputs.length; a++)a !== t && (S.inputs[a].sequenceNumber = 0);
    if ((31 & r) === $217RI.SIGHASH_NONE) S.outputs = [];
    else if ((31 & r) === $217RI.SIGHASH_SINGLE) {
        if (t >= S.outputs.length) return $52f64d863bef9147$var$SIGHASH_SINGLE_BUG;
        for(S.outputs.length = t + 1, a = 0; a < t; a++)S.outputs[a] = new $5DwX3({
            satoshis: $iDkJI.fromBuffer($hiCjL$buffer.Buffer.from($52f64d863bef9147$var$BITS_64_ON, "hex")),
            script: $51Dlk.empty()
        });
    }
    return r & $217RI.SIGHASH_ANYONECANPAY && (S.inputs = [
        S.inputs[t]
    ]), (new $i6ihF).write(S.toBuffer()).writeInt32LE(r).toBuffer();
}, $52f64d863bef9147$var$sighash = function(e, r, t, i, u, n) {
    var f = $52f64d863bef9147$var$sighashPreimage(e, r, t, i, u, n);
    if (0 === f.compare($52f64d863bef9147$var$SIGHASH_SINGLE_BUG)) return f;
    var s = $626sY.sha256sha256(f);
    return new $3vHUG(s).readReverse();
};
function $52f64d863bef9147$var$sign(e, r, t, i, u, n, f) {
    var s = $52f64d863bef9147$var$sighash(e, t, i, u, n, f);
    return $dNWce.sign(s, r, "little").set({
        nhashtype: t
    });
}
function $52f64d863bef9147$var$verify(e, r, t, i, u, n, f) {
    $2EPYC.checkArgument(!$jk7hO.isUndefined(e)), $2EPYC.checkArgument(!$jk7hO.isUndefined(r) && !$jk7hO.isUndefined(r.nhashtype));
    var s = $52f64d863bef9147$var$sighash(e, r.nhashtype, i, u, n, f);
    return $dNWce.verify(s, r, t, "little");
}
module.exports = {
    sighashPreimage: $52f64d863bef9147$var$sighashPreimage,
    sighash: $52f64d863bef9147$var$sighash,
    sign: $52f64d863bef9147$var$sign,
    verify: $52f64d863bef9147$var$verify
};

});
parcelRequire.register("5DwX3", function(module, exports) {

var $41aa27bbecb9d780$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $jk7hO = parcelRequire("jk7hO");

var $iDkJI = parcelRequire("iDkJI");


var $aYsCb = parcelRequire("aYsCb");

var $i6ihF = parcelRequire("i6ihF");

var $3fWN4 = parcelRequire("3fWN4");

var $51Dlk = parcelRequire("51Dlk");

var $2EPYC = parcelRequire("2EPYC");

var $7Wzz9 = parcelRequire("7Wzz9");
var $41aa27bbecb9d780$var$MAX_SAFE_INTEGER = 9007199254740991;
function $41aa27bbecb9d780$var$Output(t) {
    if (!(this instanceof $41aa27bbecb9d780$var$Output)) return new $41aa27bbecb9d780$var$Output(t);
    if (!$jk7hO.isObject(t)) throw new TypeError("Unrecognized argument for Output");
    var r;
    this.satoshis = t.satoshis, $41aa27bbecb9d780$require$Buffer.isBuffer(t.script) ? this._scriptBuffer = t.script : (r = $jk7hO.isString(t.script) && $aYsCb.isHexa(t.script) ? $hiCjL$buffer.Buffer.from(t.script, "hex") : t.script, this.setScript(r));
}
Object.defineProperty($41aa27bbecb9d780$var$Output.prototype, "script", {
    configurable: !1,
    enumerable: !0,
    get: function() {
        return this._script || this.setScriptFromBuffer(this._scriptBuffer), this._script;
    }
}), Object.defineProperty($41aa27bbecb9d780$var$Output.prototype, "satoshis", {
    configurable: !1,
    enumerable: !0,
    get: function() {
        return this._satoshis;
    },
    set: function(t) {
        t instanceof $iDkJI ? (this._satoshisBN = t, this._satoshis = t.toNumber()) : $jk7hO.isString(t) ? (this._satoshis = parseInt(t), this._satoshisBN = $iDkJI.fromNumber(this._satoshis)) : ($2EPYC.checkArgument($aYsCb.isNaturalNumber(t), "Output satoshis is not a natural number"), this._satoshisBN = $iDkJI.fromNumber(t), this._satoshis = t), $2EPYC.checkState($aYsCb.isNaturalNumber(this._satoshis), "Output satoshis is not a natural number");
    }
}), $41aa27bbecb9d780$var$Output.prototype.invalidSatoshis = function() {
    return this._satoshis > $41aa27bbecb9d780$var$MAX_SAFE_INTEGER ? "transaction txout satoshis greater than max safe integer" : this._satoshis !== this._satoshisBN.toNumber() ? "transaction txout satoshis has corrupted value" : this._satoshis < 0 && "transaction txout negative";
}, Object.defineProperty($41aa27bbecb9d780$var$Output.prototype, "satoshisBN", {
    configurable: !1,
    enumerable: !0,
    get: function() {
        return this._satoshisBN;
    },
    set: function(t) {
        this._satoshisBN = t, this._satoshis = t.toNumber(), $2EPYC.checkState($aYsCb.isNaturalNumber(this._satoshis), "Output satoshis is not a natural number");
    }
}), $41aa27bbecb9d780$var$Output.prototype.toObject = $41aa27bbecb9d780$var$Output.prototype.toJSON = function() {
    var t = {
        satoshis: this.satoshis
    };
    return t.script = this._scriptBuffer.toString("hex"), t;
}, $41aa27bbecb9d780$var$Output.fromObject = function(t) {
    return new $41aa27bbecb9d780$var$Output(t);
}, $41aa27bbecb9d780$var$Output.prototype.setScriptFromBuffer = function(t) {
    this._scriptBuffer = t;
    try {
        this._script = $51Dlk.fromBuffer(this._scriptBuffer), this._script._isOutput = !0;
    } catch (t1) {
        if (!(t1 instanceof $7Wzz9.Script.InvalidBuffer)) throw t1;
        this._script = null;
    }
}, $41aa27bbecb9d780$var$Output.prototype.setScript = function(t) {
    if (t instanceof $51Dlk) this._scriptBuffer = t.toBuffer(), this._script = t, this._script._isOutput = !0;
    else if ($jk7hO.isString(t)) this._script = $51Dlk.fromString(t), this._scriptBuffer = this._script.toBuffer(), this._script._isOutput = !0;
    else {
        if (!$41aa27bbecb9d780$require$Buffer.isBuffer(t)) throw new TypeError("Invalid argument type: script");
        this.setScriptFromBuffer(t);
    }
    return this;
}, $41aa27bbecb9d780$var$Output.prototype.inspect = function() {
    var t;
    return t = this.script ? this.script.inspect() : this._scriptBuffer.toString("hex"), "<Output (" + this.satoshis + " sats) " + t + ">";
}, $41aa27bbecb9d780$var$Output.fromBufferReader = function(t) {
    var r = {};
    r.satoshis = t.readUInt64LEBN();
    var i = t.readVarintNum();
    return r.script = 0 !== i ? t.read(i) : $hiCjL$buffer.Buffer.from([]), new $41aa27bbecb9d780$var$Output(r);
}, $41aa27bbecb9d780$var$Output.prototype.toBufferWriter = function(t) {
    t || (t = new $i6ihF), t.writeUInt64LEBN(this._satoshisBN);
    var r = this._scriptBuffer;
    return t.writeVarintNum(r.length), t.write(r), t;
}, $41aa27bbecb9d780$var$Output.prototype.getSize = function() {
    var t = this.script.toBuffer().length;
    return 8 + $3fWN4(t).toBuffer().length + t;
}, module.exports = $41aa27bbecb9d780$var$Output;

});

parcelRequire.register("gJlWw", function(module, exports) {





module.exports = (parcelRequire("1VbUU")), module.exports.PublicKey = (parcelRequire("ateqM")), module.exports.PublicKeyHash = (parcelRequire("1YiRE")), module.exports.MultiSig = (parcelRequire("3gOH4")), module.exports.MultiSigScriptHash = (parcelRequire("3gkDT"));

});
parcelRequire.register("1VbUU", function(module, exports) {

var $16645bc2ce0f9eaa$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $jk7hO = parcelRequire("jk7hO");

var $2EPYC = parcelRequire("2EPYC");

var $7Wzz9 = parcelRequire("7Wzz9");

var $i6ihF = parcelRequire("i6ihF");


var $aYsCb = parcelRequire("aYsCb");

var $51Dlk = parcelRequire("51Dlk");

var $77Bxe = parcelRequire("77Bxe");

var $5DwX3 = parcelRequire("5DwX3");
var $16645bc2ce0f9eaa$var$MAXINT = 4294967295, $16645bc2ce0f9eaa$var$DEFAULT_RBF_SEQNUMBER = $16645bc2ce0f9eaa$var$MAXINT - 2, $16645bc2ce0f9eaa$var$DEFAULT_SEQNUMBER = $16645bc2ce0f9eaa$var$MAXINT, $16645bc2ce0f9eaa$var$DEFAULT_LOCKTIME_SEQNUMBER = $16645bc2ce0f9eaa$var$MAXINT - 1;
function $16645bc2ce0f9eaa$var$Input(t) {
    return this instanceof $16645bc2ce0f9eaa$var$Input ? t ? this._fromObject(t) : void 0 : new $16645bc2ce0f9eaa$var$Input(t);
}
$16645bc2ce0f9eaa$var$Input.MAXINT = $16645bc2ce0f9eaa$var$MAXINT, $16645bc2ce0f9eaa$var$Input.DEFAULT_SEQNUMBER = $16645bc2ce0f9eaa$var$DEFAULT_SEQNUMBER, $16645bc2ce0f9eaa$var$Input.DEFAULT_LOCKTIME_SEQNUMBER = $16645bc2ce0f9eaa$var$DEFAULT_LOCKTIME_SEQNUMBER, $16645bc2ce0f9eaa$var$Input.DEFAULT_RBF_SEQNUMBER = $16645bc2ce0f9eaa$var$DEFAULT_RBF_SEQNUMBER, $16645bc2ce0f9eaa$var$Input.BASE_SIZE = 40, Object.defineProperty($16645bc2ce0f9eaa$var$Input.prototype, "script", {
    configurable: !1,
    enumerable: !0,
    get: function() {
        return this.isNull() ? null : (this._script || (this._script = new $51Dlk(this._scriptBuffer), this._script._isInput = !0), this._script);
    }
}), $16645bc2ce0f9eaa$var$Input.fromObject = function(t) {
    return $2EPYC.checkArgument($jk7hO.isObject(t)), (new $16645bc2ce0f9eaa$var$Input)._fromObject(t);
}, $16645bc2ce0f9eaa$var$Input.prototype._fromObject = function(t) {
    var e;
    if (e = $jk7hO.isString(t.prevTxId) && $aYsCb.isHexa(t.prevTxId) ? $hiCjL$buffer.Buffer.from(t.prevTxId, "hex") : t.prevTxId, this.output = t.output ? t.output instanceof $5DwX3 ? t.output : new $5DwX3(t.output) : void 0, this.prevTxId = e || t.txidbuf, this.outputIndex = $jk7hO.isUndefined(t.outputIndex) ? t.txoutnum : t.outputIndex, this.sequenceNumber = $jk7hO.isUndefined(t.sequenceNumber) ? $jk7hO.isUndefined(t.seqnum) ? $16645bc2ce0f9eaa$var$DEFAULT_SEQNUMBER : t.seqnum : t.sequenceNumber, $jk7hO.isUndefined(t.script) && $jk7hO.isUndefined(t.scriptBuffer)) throw new $7Wzz9.Transaction.Input.MissingScript;
    return this.setScript(t.scriptBuffer || t.script), this;
}, $16645bc2ce0f9eaa$var$Input.prototype.toObject = $16645bc2ce0f9eaa$var$Input.prototype.toJSON = function() {
    var t = {
        prevTxId: this.prevTxId.toString("hex"),
        outputIndex: this.outputIndex,
        sequenceNumber: this.sequenceNumber,
        script: this._scriptBuffer.toString("hex")
    };
    return this.script && (t.scriptString = this.script.toString()), this.output && (t.output = this.output.toObject()), t;
}, $16645bc2ce0f9eaa$var$Input.fromBufferReader = function(t) {
    var e = new $16645bc2ce0f9eaa$var$Input;
    return e.prevTxId = t.readReverse(32), e.outputIndex = t.readUInt32LE(), e._scriptBuffer = t.readVarLengthBuffer(), e.sequenceNumber = t.readUInt32LE(), e;
}, $16645bc2ce0f9eaa$var$Input.prototype.toBufferWriter = function(t) {
    t || (t = new $i6ihF), t.writeReverse(this.prevTxId), t.writeUInt32LE(this.outputIndex);
    var e = this._scriptBuffer;
    return t.writeVarintNum(e.length), t.write(e), t.writeUInt32LE(this.sequenceNumber), t;
}, $16645bc2ce0f9eaa$var$Input.prototype.setScript = function(t) {
    if (this._script = null, t instanceof $51Dlk) this._script = t, this._script._isInput = !0, this._scriptBuffer = t.toBuffer();
    else if (null === t) this._script = $51Dlk.empty(), this._script._isInput = !0, this._scriptBuffer = this._script.toBuffer();
    else if ($aYsCb.isHexa(t)) this._scriptBuffer = $hiCjL$buffer.Buffer.from(t, "hex");
    else if ($jk7hO.isString(t)) this._script = new $51Dlk(t), this._script._isInput = !0, this._scriptBuffer = this._script.toBuffer();
    else {
        if (!$16645bc2ce0f9eaa$require$Buffer.isBuffer(t)) throw new TypeError("Invalid argument type: script");
        this._scriptBuffer = $hiCjL$buffer.Buffer.from(t);
    }
    return this;
}, $16645bc2ce0f9eaa$var$Input.prototype.getSignatures = function() {
    throw new $7Wzz9.AbstractMethodInvoked("Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported) for input: " + JSON.stringify(this));
}, $16645bc2ce0f9eaa$var$Input.prototype.isFullySigned = function() {
    throw new $7Wzz9.AbstractMethodInvoked("Input#isFullySigned");
}, $16645bc2ce0f9eaa$var$Input.prototype.isFinal = function() {
    return this.sequenceNumber === $16645bc2ce0f9eaa$var$Input.MAXINT;
}, $16645bc2ce0f9eaa$var$Input.prototype.addSignature = function() {
    throw new $7Wzz9.AbstractMethodInvoked("Input#addSignature");
}, $16645bc2ce0f9eaa$var$Input.prototype.clearSignatures = function() {
    throw new $7Wzz9.AbstractMethodInvoked("Input#clearSignatures");
}, $16645bc2ce0f9eaa$var$Input.prototype.isValidSignature = function(t, e) {
    return e.signature.nhashtype = e.sigtype, $77Bxe.verify(t, e.signature, e.publicKey, e.inputIndex, this.output.script, this.output.satoshisBN);
}, $16645bc2ce0f9eaa$var$Input.prototype.isNull = function() {
    return "0000000000000000000000000000000000000000000000000000000000000000" === this.prevTxId.toString("hex") && 4294967295 === this.outputIndex;
}, $16645bc2ce0f9eaa$var$Input.prototype._estimateSize = function() {
    return this.toBufferWriter().toBuffer().length;
}, module.exports = $16645bc2ce0f9eaa$var$Input;

});

parcelRequire.register("ateqM", function(module, exports) {
"use strict";

var $hP1iE = parcelRequire("hP1iE");

var $2EPYC = parcelRequire("2EPYC");

var $1VbUU = parcelRequire("1VbUU");

var $5DwX3 = parcelRequire("5DwX3");

var $77Bxe = parcelRequire("77Bxe");

var $51Dlk = parcelRequire("51Dlk");

var $217RI = parcelRequire("217RI");

var $5hdrK = parcelRequire("5hdrK");
function $79f7ce7c86033859$var$PublicKeyInput() {
    $1VbUU.apply(this, arguments);
}
$hP1iE($79f7ce7c86033859$var$PublicKeyInput, $1VbUU), $79f7ce7c86033859$var$PublicKeyInput.prototype.getSignatures = function(t, i, u, e) {
    $2EPYC.checkState(this.output instanceof $5DwX3), e = e || $217RI.SIGHASH_ALL | $217RI.SIGHASH_FORKID;
    var r = i.toPublicKey();
    return r.toString() === this.output.script.getPublicKey().toString("hex") ? [
        new $5hdrK({
            publicKey: r,
            prevTxId: this.prevTxId,
            outputIndex: this.outputIndex,
            inputIndex: u,
            signature: $77Bxe.sign(t, i, e, u, this.output.script, this.output.satoshisBN),
            sigtype: e
        })
    ] : [];
}, $79f7ce7c86033859$var$PublicKeyInput.prototype.addSignature = function(t, i) {
    return $2EPYC.checkState(this.isValidSignature(t, i), "Signature is invalid"), this.setScript($51Dlk.buildPublicKeyIn(i.signature.toDER(), i.sigtype)), this;
}, $79f7ce7c86033859$var$PublicKeyInput.prototype.clearSignatures = function() {
    return this.setScript($51Dlk.empty()), this;
}, $79f7ce7c86033859$var$PublicKeyInput.prototype.isFullySigned = function() {
    return this.script.isPublicKeyIn();
}, $79f7ce7c86033859$var$PublicKeyInput.SCRIPT_MAX_SIZE = 74, $79f7ce7c86033859$var$PublicKeyInput.prototype._estimateSize = function() {
    return $1VbUU.BASE_SIZE + $79f7ce7c86033859$var$PublicKeyInput.SCRIPT_MAX_SIZE;
}, module.exports = $79f7ce7c86033859$var$PublicKeyInput;

});
parcelRequire.register("5hdrK", function(module, exports) {

var $3d78f87a12471161$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $jk7hO = parcelRequire("jk7hO");

var $2EPYC = parcelRequire("2EPYC");

var $hP1iE = parcelRequire("hP1iE");

var $aYsCb = parcelRequire("aYsCb");

var $2OQpG = parcelRequire("2OQpG");

var $7Wzz9 = parcelRequire("7Wzz9");

var $217RI = parcelRequire("217RI");
function $3d78f87a12471161$var$TransactionSignature(e) {
    if (!(this instanceof $3d78f87a12471161$var$TransactionSignature)) return new $3d78f87a12471161$var$TransactionSignature(e);
    if (e instanceof $3d78f87a12471161$var$TransactionSignature) return e;
    if ($jk7hO.isObject(e)) return this._fromObject(e);
    throw new $7Wzz9.InvalidArgument("TransactionSignatures must be instantiated from an object");
}
$hP1iE($3d78f87a12471161$var$TransactionSignature, $217RI), $3d78f87a12471161$var$TransactionSignature.prototype._fromObject = function(e) {
    return this._checkObjectArgs(e), this.publicKey = new $2OQpG(e.publicKey), this.prevTxId = $3d78f87a12471161$require$Buffer.isBuffer(e.prevTxId) ? e.prevTxId : $3d78f87a12471161$require$Buffer.from(e.prevTxId, "hex"), this.outputIndex = e.outputIndex, this.inputIndex = e.inputIndex, this.signature = e.signature instanceof $217RI ? e.signature : $3d78f87a12471161$require$Buffer.isBuffer(e.signature) ? $217RI.fromBuffer(e.signature) : $217RI.fromString(e.signature), this.sigtype = e.sigtype, this;
}, $3d78f87a12471161$var$TransactionSignature.prototype._checkObjectArgs = function(e) {
    $2EPYC.checkArgument($2OQpG(e.publicKey), "publicKey"), $2EPYC.checkArgument(!$jk7hO.isUndefined(e.inputIndex), "inputIndex"), $2EPYC.checkArgument(!$jk7hO.isUndefined(e.outputIndex), "outputIndex"), $2EPYC.checkState($jk7hO.isNumber(e.inputIndex), "inputIndex must be a number"), $2EPYC.checkState($jk7hO.isNumber(e.outputIndex), "outputIndex must be a number"), $2EPYC.checkArgument(e.signature, "signature"), $2EPYC.checkArgument(e.prevTxId, "prevTxId"), $2EPYC.checkState(e.signature instanceof $217RI || $3d78f87a12471161$require$Buffer.isBuffer(e.signature) || $aYsCb.isHexa(e.signature), "signature must be a buffer or hexa value"), $2EPYC.checkState($3d78f87a12471161$require$Buffer.isBuffer(e.prevTxId) || $aYsCb.isHexa(e.prevTxId), "prevTxId must be a buffer or hexa value"), $2EPYC.checkArgument(e.sigtype, "sigtype"), $2EPYC.checkState($jk7hO.isNumber(e.sigtype), "sigtype must be a number");
}, $3d78f87a12471161$var$TransactionSignature.prototype.toObject = $3d78f87a12471161$var$TransactionSignature.prototype.toJSON = function() {
    return {
        publicKey: this.publicKey.toString(),
        prevTxId: this.prevTxId.toString("hex"),
        outputIndex: this.outputIndex,
        inputIndex: this.inputIndex,
        signature: this.signature.toString(),
        sigtype: this.sigtype
    };
}, $3d78f87a12471161$var$TransactionSignature.fromObject = function(e) {
    return $2EPYC.checkArgument(e), new $3d78f87a12471161$var$TransactionSignature(e);
}, module.exports = $3d78f87a12471161$var$TransactionSignature;

});


parcelRequire.register("1YiRE", function(module, exports) {
"use strict";

var $hP1iE = parcelRequire("hP1iE");

var $2EPYC = parcelRequire("2EPYC");

var $626sY = parcelRequire("626sY");

var $1VbUU = parcelRequire("1VbUU");

var $5DwX3 = parcelRequire("5DwX3");

var $77Bxe = parcelRequire("77Bxe");

var $51Dlk = parcelRequire("51Dlk");

var $217RI = parcelRequire("217RI");

var $5hdrK = parcelRequire("5hdrK");
function $16fa071904d8ea3e$var$PublicKeyHashInput() {
    $1VbUU.apply(this, arguments);
}
$hP1iE($16fa071904d8ea3e$var$PublicKeyHashInput, $1VbUU), $16fa071904d8ea3e$var$PublicKeyHashInput.prototype.getSignatures = function(t, i, e, u, r) {
    return $2EPYC.checkState(this.output instanceof $5DwX3), r = r || $626sY.sha256ripemd160(i.publicKey.toBuffer()), u = u || $217RI.SIGHASH_ALL | $217RI.SIGHASH_FORKID, r.equals(this.output.script.getPublicKeyHash()) ? [
        new $5hdrK({
            publicKey: i.publicKey,
            prevTxId: this.prevTxId,
            outputIndex: this.outputIndex,
            inputIndex: e,
            signature: $77Bxe.sign(t, i, u, e, this.output.script, this.output.satoshisBN),
            sigtype: u
        })
    ] : [];
}, $16fa071904d8ea3e$var$PublicKeyHashInput.prototype.addSignature = function(t, i) {
    return $2EPYC.checkState(this.isValidSignature(t, i), "Signature is invalid"), this.setScript($51Dlk.buildPublicKeyHashIn(i.publicKey, i.signature.toDER(), i.sigtype)), this;
}, $16fa071904d8ea3e$var$PublicKeyHashInput.prototype.clearSignatures = function() {
    return this.setScript($51Dlk.empty()), this;
}, $16fa071904d8ea3e$var$PublicKeyHashInput.prototype.isFullySigned = function() {
    return this.script.isPublicKeyHashIn();
}, $16fa071904d8ea3e$var$PublicKeyHashInput.SCRIPT_MAX_SIZE = 108, $16fa071904d8ea3e$var$PublicKeyHashInput.prototype._estimateSize = function() {
    return $1VbUU.BASE_SIZE + $16fa071904d8ea3e$var$PublicKeyHashInput.SCRIPT_MAX_SIZE;
}, module.exports = $16fa071904d8ea3e$var$PublicKeyHashInput;

});

parcelRequire.register("3gOH4", function(module, exports) {

var $261a3073db8bb617$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $jk7hO = parcelRequire("jk7hO");

var $hP1iE = parcelRequire("hP1iE");

var $1VbUU = parcelRequire("1VbUU");

var $5DwX3 = parcelRequire("5DwX3");

var $2EPYC = parcelRequire("2EPYC");

var $51Dlk = parcelRequire("51Dlk");

var $217RI = parcelRequire("217RI");

var $77Bxe = parcelRequire("77Bxe");

var $5hdrK = parcelRequire("5hdrK");

var $2OQpG = parcelRequire("2OQpG");

var $3fWN4 = parcelRequire("3fWN4");
function $261a3073db8bb617$var$MultiSigInput(t, i, e, u) {
    $1VbUU.apply(this, arguments);
    var n = this;
    i = i || t.publicKeys, e = e || t.threshold, u = u || t.signatures, this.publicKeys = i.map((t)=>t.toString("hex")).sort().map((t)=>new $2OQpG(t)), $2EPYC.checkState($51Dlk.buildMultisigOut(this.publicKeys, e).equals(this.output.script), "Provided public keys don't match to the provided output script"), this.publicKeyIndex = {}, $jk7hO.each(this.publicKeys, function(t, i) {
        n.publicKeyIndex[t.toString()] = i;
    }), this.threshold = e, this.signatures = u ? this._deserializeSignatures(u) : new Array(this.publicKeys.length);
}
$hP1iE($261a3073db8bb617$var$MultiSigInput, $1VbUU), $261a3073db8bb617$var$MultiSigInput.prototype.toObject = function() {
    var t = $1VbUU.prototype.toObject.apply(this, arguments);
    return t.threshold = this.threshold, t.publicKeys = $jk7hO.map(this.publicKeys, function(t) {
        return t.toString();
    }), t.signatures = this._serializeSignatures(), t;
}, $261a3073db8bb617$var$MultiSigInput.prototype._deserializeSignatures = function(t) {
    return $jk7hO.map(t, function(t) {
        if (t) return new $5hdrK(t);
    });
}, $261a3073db8bb617$var$MultiSigInput.prototype._serializeSignatures = function() {
    return $jk7hO.map(this.signatures, function(t) {
        if (t) return t.toObject();
    });
}, $261a3073db8bb617$var$MultiSigInput.prototype.getSignatures = function(t, i, e, u) {
    $2EPYC.checkState(this.output instanceof $5DwX3), u = u || $217RI.SIGHASH_ALL | $217RI.SIGHASH_FORKID;
    var n = this, r = [];
    return $jk7hO.each(this.publicKeys, function(s) {
        s.toString() === i.publicKey.toString() && r.push(new $5hdrK({
            publicKey: i.publicKey,
            prevTxId: n.prevTxId,
            outputIndex: n.outputIndex,
            inputIndex: e,
            signature: $77Bxe.sign(t, i, u, e, n.output.script, n.output.satoshisBN),
            sigtype: u
        }));
    }), r;
}, $261a3073db8bb617$var$MultiSigInput.prototype.addSignature = function(t, i) {
    return $2EPYC.checkState(!this.isFullySigned(), "All needed signatures have already been added"), $2EPYC.checkArgument(!$jk7hO.isUndefined(this.publicKeyIndex[i.publicKey.toString()]), "Signature has no matching public key"), $2EPYC.checkState(this.isValidSignature(t, i)), this.signatures[this.publicKeyIndex[i.publicKey.toString()]] = i, this._updateScript(), this;
}, $261a3073db8bb617$var$MultiSigInput.prototype._updateScript = function() {
    return this.setScript($51Dlk.buildMultisigIn(this.publicKeys, this.threshold, this._createSignatures())), this;
}, $261a3073db8bb617$var$MultiSigInput.prototype._createSignatures = function() {
    return $jk7hO.map($jk7hO.filter(this.signatures, function(t) {
        return !$jk7hO.isUndefined(t);
    }), function(t) {
        return $261a3073db8bb617$require$Buffer.concat([
            t.signature.toDER(),
            $261a3073db8bb617$require$Buffer.from([
                255 & t.sigtype
            ])
        ]);
    });
}, $261a3073db8bb617$var$MultiSigInput.prototype.clearSignatures = function() {
    this.signatures = new Array(this.publicKeys.length), this._updateScript();
}, $261a3073db8bb617$var$MultiSigInput.prototype.isFullySigned = function() {
    return this.countSignatures() === this.threshold;
}, $261a3073db8bb617$var$MultiSigInput.prototype.countMissingSignatures = function() {
    return this.threshold - this.countSignatures();
}, $261a3073db8bb617$var$MultiSigInput.prototype.countSignatures = function() {
    return $jk7hO.reduce(this.signatures, function(t, i) {
        return t + !!i;
    }, 0);
}, $261a3073db8bb617$var$MultiSigInput.prototype.publicKeysWithoutSignature = function() {
    var t = this;
    return $jk7hO.filter(this.publicKeys, function(i) {
        return !t.signatures[t.publicKeyIndex[i.toString()]];
    });
}, $261a3073db8bb617$var$MultiSigInput.prototype.isValidSignature = function(t, i) {
    return i.signature.nhashtype = i.sigtype, $77Bxe.verify(t, i.signature, i.publicKey, i.inputIndex, this.output.script, this.output.satoshisBN);
}, $261a3073db8bb617$var$MultiSigInput.normalizeSignatures = function(t, i, e, u, n) {
    return n.map(function(n) {
        var r = null;
        return u = u.filter(function(u) {
            if (r) return !0;
            var s = new $5hdrK({
                signature: $217RI.fromTxFormat(u),
                publicKey: n,
                prevTxId: i.prevTxId,
                outputIndex: i.outputIndex,
                inputIndex: e,
                sigtype: $217RI.SIGHASH_ALL
            });
            return s.signature.nhashtype = s.sigtype, !$77Bxe.verify(t, s.signature, s.publicKey, s.inputIndex, i.output.script) || (r = s, !1);
        }), r || null;
    });
}, $261a3073db8bb617$var$MultiSigInput.SIGNATURE_SIZE = 73, $261a3073db8bb617$var$MultiSigInput.prototype._estimateSize = function() {
    var t = 1 + this.threshold * $261a3073db8bb617$var$MultiSigInput.SIGNATURE_SIZE;
    return $1VbUU.BASE_SIZE + $3fWN4(t).toBuffer().length + t;
}, module.exports = $261a3073db8bb617$var$MultiSigInput;

});

parcelRequire.register("3gkDT", function(module, exports) {

var $2602e0e4600315d4$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $jk7hO = parcelRequire("jk7hO");

var $hP1iE = parcelRequire("hP1iE");

var $1VbUU = parcelRequire("1VbUU");

var $5DwX3 = parcelRequire("5DwX3");

var $2EPYC = parcelRequire("2EPYC");

var $51Dlk = parcelRequire("51Dlk");

var $217RI = parcelRequire("217RI");

var $77Bxe = parcelRequire("77Bxe");

var $5hdrK = parcelRequire("5hdrK");

var $2OQpG = parcelRequire("2OQpG");

var $3fWN4 = parcelRequire("3fWN4");
function $2602e0e4600315d4$var$MultiSigScriptHashInput(t, i, e, u) {
    $1VbUU.apply(this, arguments);
    var r = this;
    i = i || t.publicKeys, e = e || t.threshold, u = u || t.signatures, this.publicKeys = i.map((t)=>t.toString("hex")).sort().map((t)=>new $2OQpG(t)), this.redeemScript = $51Dlk.buildMultisigOut(this.publicKeys, e), $2EPYC.checkState($51Dlk.buildScriptHashOut(this.redeemScript).equals(this.output.script), "Provided public keys don't hash to the provided output"), this.publicKeyIndex = {}, $jk7hO.each(this.publicKeys, function(t, i) {
        r.publicKeyIndex[t.toString()] = i;
    }), this.threshold = e, this.signatures = u ? this._deserializeSignatures(u) : new Array(this.publicKeys.length);
}
$hP1iE($2602e0e4600315d4$var$MultiSigScriptHashInput, $1VbUU), $2602e0e4600315d4$var$MultiSigScriptHashInput.prototype.toObject = function() {
    var t = $1VbUU.prototype.toObject.apply(this, arguments);
    return t.threshold = this.threshold, t.publicKeys = $jk7hO.map(this.publicKeys, function(t) {
        return t.toString();
    }), t.signatures = this._serializeSignatures(), t;
}, $2602e0e4600315d4$var$MultiSigScriptHashInput.prototype._deserializeSignatures = function(t) {
    return $jk7hO.map(t, function(t) {
        if (t) return new $5hdrK(t);
    });
}, $2602e0e4600315d4$var$MultiSigScriptHashInput.prototype._serializeSignatures = function() {
    return $jk7hO.map(this.signatures, function(t) {
        if (t) return t.toObject();
    });
}, $2602e0e4600315d4$var$MultiSigScriptHashInput.prototype.getSignatures = function(t, i, e, u) {
    $2EPYC.checkState(this.output instanceof $5DwX3), u = u || $217RI.SIGHASH_ALL | $217RI.SIGHASH_FORKID;
    var r = this, n = [];
    return $jk7hO.each(this.publicKeys, function(s) {
        s.toString() === i.publicKey.toString() && n.push(new $5hdrK({
            publicKey: i.publicKey,
            prevTxId: r.prevTxId,
            outputIndex: r.outputIndex,
            inputIndex: e,
            signature: $77Bxe.sign(t, i, u, e, r.redeemScript, r.output.satoshisBN),
            sigtype: u
        }));
    }), n;
}, $2602e0e4600315d4$var$MultiSigScriptHashInput.prototype.addSignature = function(t, i) {
    return $2EPYC.checkState(!this.isFullySigned(), "All needed signatures have already been added"), $2EPYC.checkArgument(!$jk7hO.isUndefined(this.publicKeyIndex[i.publicKey.toString()]), "Signature has no matching public key"), $2EPYC.checkState(this.isValidSignature(t, i)), this.signatures[this.publicKeyIndex[i.publicKey.toString()]] = i, this._updateScript(), this;
}, $2602e0e4600315d4$var$MultiSigScriptHashInput.prototype._updateScript = function() {
    return this.setScript($51Dlk.buildP2SHMultisigIn(this.publicKeys, this.threshold, this._createSignatures(), {
        cachedMultisig: this.redeemScript
    })), this;
}, $2602e0e4600315d4$var$MultiSigScriptHashInput.prototype._createSignatures = function() {
    return $jk7hO.map($jk7hO.filter(this.signatures, function(t) {
        return !$jk7hO.isUndefined(t);
    }), function(t) {
        return $2602e0e4600315d4$require$Buffer.concat([
            t.signature.toDER(),
            $2602e0e4600315d4$require$Buffer.from([
                255 & t.sigtype
            ])
        ]);
    });
}, $2602e0e4600315d4$var$MultiSigScriptHashInput.prototype.clearSignatures = function() {
    this.signatures = new Array(this.publicKeys.length), this._updateScript();
}, $2602e0e4600315d4$var$MultiSigScriptHashInput.prototype.isFullySigned = function() {
    return this.countSignatures() === this.threshold;
}, $2602e0e4600315d4$var$MultiSigScriptHashInput.prototype.countMissingSignatures = function() {
    return this.threshold - this.countSignatures();
}, $2602e0e4600315d4$var$MultiSigScriptHashInput.prototype.countSignatures = function() {
    return $jk7hO.reduce(this.signatures, function(t, i) {
        return t + !!i;
    }, 0);
}, $2602e0e4600315d4$var$MultiSigScriptHashInput.prototype.publicKeysWithoutSignature = function() {
    var t = this;
    return $jk7hO.filter(this.publicKeys, function(i) {
        return !t.signatures[t.publicKeyIndex[i.toString()]];
    });
}, $2602e0e4600315d4$var$MultiSigScriptHashInput.prototype.isValidSignature = function(t, i) {
    return i.signature.nhashtype = i.sigtype, $77Bxe.verify(t, i.signature, i.publicKey, i.inputIndex, this.redeemScript, this.output.satoshisBN);
}, $2602e0e4600315d4$var$MultiSigScriptHashInput.SIGNATURE_SIZE = 73, $2602e0e4600315d4$var$MultiSigScriptHashInput.PUBKEY_SIZE = 34, $2602e0e4600315d4$var$MultiSigScriptHashInput.prototype._estimateSize = function() {
    var t = 3 + this.publicKeys.length * $2602e0e4600315d4$var$MultiSigScriptHashInput.PUBKEY_SIZE, i = this.threshold * $2602e0e4600315d4$var$MultiSigScriptHashInput.SIGNATURE_SIZE + 1 + (t <= 75 ? 1 : t <= 255 ? 2 : 3) + t;
    return $1VbUU.BASE_SIZE + $3fWN4(i).toBuffer().length + i;
}, module.exports = $2602e0e4600315d4$var$MultiSigScriptHashInput;

});



parcelRequire.register("gzMxy", function(module, exports) {
"use strict";

var $jk7hO = parcelRequire("jk7hO");

var $2EPYC = parcelRequire("2EPYC");

var $aYsCb = parcelRequire("aYsCb");

var $51Dlk = parcelRequire("51Dlk");

var $bM62Y = parcelRequire("bM62Y");
function $c115914682225116$var$UnspentOutput(t) {
    if (!(this instanceof $c115914682225116$var$UnspentOutput)) return new $c115914682225116$var$UnspentOutput(t);
    $2EPYC.checkArgument($jk7hO.isObject(t), "Must provide an object from where to extract data");
    var e = t.address ? new $bM62Y(t.address) : void 0, s = t.txid ? t.txid : t.txId;
    if (!s || !$aYsCb.isHexaString(s) || s.length > 64) throw new Error("Invalid TXID in object", t);
    var i = $jk7hO.isUndefined(t.vout) ? t.outputIndex : t.vout;
    if (!$jk7hO.isNumber(i)) throw new Error("Invalid outputIndex, received " + i);
    $2EPYC.checkArgument(!$jk7hO.isUndefined(t.scriptPubKey) || !$jk7hO.isUndefined(t.script), "Must provide the scriptPubKey for that output!");
    var n = new $51Dlk(t.scriptPubKey || t.script);
    $2EPYC.checkArgument(!$jk7hO.isUndefined(t.amount) || !$jk7hO.isUndefined(t.satoshis), "Must provide an amount for the output");
    var r = $jk7hO.isUndefined(t.amount) ? t.satoshis : Math.round(1e8 * t.amount);
    $2EPYC.checkArgument($jk7hO.isNumber(r), "Amount must be a number"), $aYsCb.defineImmutable(this, {
        address: e,
        txId: s,
        outputIndex: i,
        script: n,
        satoshis: r
    });
}
$c115914682225116$var$UnspentOutput.prototype.inspect = function() {
    return "<UnspentOutput: " + this.txId + ":" + this.outputIndex + ", satoshis: " + this.satoshis + ", address: " + this.address + ">";
}, $c115914682225116$var$UnspentOutput.prototype.toString = function() {
    return this.txId + ":" + this.outputIndex;
}, $c115914682225116$var$UnspentOutput.fromObject = function(t) {
    return new $c115914682225116$var$UnspentOutput(t);
}, $c115914682225116$var$UnspentOutput.prototype.toObject = $c115914682225116$var$UnspentOutput.prototype.toJSON = function() {
    return {
        address: this.address ? this.address.toString() : void 0,
        txid: this.txId,
        vout: this.outputIndex,
        scriptPubKey: this.script.toBuffer().toString("hex"),
        amount: Number.parseFloat((this.satoshis / 1e8).toFixed(8))
    };
}, module.exports = $c115914682225116$var$UnspentOutput;

});






parcelRequire.register("7Ri8i", function(module, exports) {

var $5b8b8c72d28d4b30$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";
function $5b8b8c72d28d4b30$var$Random() {}

$5b8b8c72d28d4b30$var$Random.getRandomBuffer = function(o) {
    return $5b8b8c72d28d4b30$var$Random.getRandomBufferBrowser(o);
}, $5b8b8c72d28d4b30$var$Random.getRandomBufferNode = function(o) {
    return $hiCjL$crypto.randomBytes(o);
}, $5b8b8c72d28d4b30$var$Random.getRandomBufferBrowser = function(o) {
    if (!window.crypto && !window.msCrypto) throw new Error("window.crypto not available");
    var r;
    if (window.crypto && window.crypto.getRandomValues) r = window.crypto;
    else {
        if (!window.msCrypto || !window.msCrypto.getRandomValues) throw new Error("window.crypto.getRandomValues not available");
        r = window.msCrypto;
    }
    var n = new Uint8Array(o);
    return r.getRandomValues(n), $5b8b8c72d28d4b30$require$Buffer.from(n);
}, module.exports = $5b8b8c72d28d4b30$var$Random;

});




parcelRequire.register("6i5yx", function(module, exports) {

var $4948bbd58a869556$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";

var $jk7hO = parcelRequire("jk7hO");

var $iDkJI = parcelRequire("iDkJI");

var $3vHUG = parcelRequire("3vHUG");

var $i6ihF = parcelRequire("i6ihF");

var $626sY = parcelRequire("626sY");

var $2EPYC = parcelRequire("2EPYC");
var $4948bbd58a869556$var$GENESIS_BITS = 486604799, $4948bbd58a869556$var$BlockHeader = function e(r) {
    if (!(this instanceof e)) return new e(r);
    var t = e._from(r);
    return this.version = t.version, this.prevHash = t.prevHash, this.merkleRoot = t.merkleRoot, this.time = t.time, this.timestamp = t.time, this.bits = t.bits, this.nonce = t.nonce, t.hash && $2EPYC.checkState(this.hash === t.hash, "Argument object hash property does not match block hash."), this;
};
$4948bbd58a869556$var$BlockHeader._from = function(e) {
    var r = {};
    if ($4948bbd58a869556$require$Buffer.isBuffer(e)) r = $4948bbd58a869556$var$BlockHeader._fromBufferReader($3vHUG(e));
    else {
        if (!$jk7hO.isObject(e)) throw new TypeError("Unrecognized argument for BlockHeader");
        r = $4948bbd58a869556$var$BlockHeader._fromObject(e);
    }
    return r;
}, $4948bbd58a869556$var$BlockHeader._fromObject = function(e) {
    $2EPYC.checkArgument(e, "data is required");
    var r = e.prevHash, t = e.merkleRoot;
    return $jk7hO.isString(e.prevHash) && (r = $4948bbd58a869556$require$Buffer.from(e.prevHash, "hex").reverse()), $jk7hO.isString(e.merkleRoot) && (t = $4948bbd58a869556$require$Buffer.from(e.merkleRoot, "hex").reverse()), {
        hash: e.hash,
        version: e.version,
        prevHash: r,
        merkleRoot: t,
        time: e.time,
        timestamp: e.time,
        bits: e.bits,
        nonce: e.nonce
    };
}, $4948bbd58a869556$var$BlockHeader.fromObject = function(e) {
    var r = $4948bbd58a869556$var$BlockHeader._fromObject(e);
    return new $4948bbd58a869556$var$BlockHeader(r);
}, $4948bbd58a869556$var$BlockHeader.fromRawBlock = function(e) {
    $4948bbd58a869556$require$Buffer.isBuffer(e) || (e = $4948bbd58a869556$require$Buffer.from(e, "binary"));
    var r = $3vHUG(e);
    r.pos = $4948bbd58a869556$var$BlockHeader.Constants.START_OF_HEADER;
    var t = $4948bbd58a869556$var$BlockHeader._fromBufferReader(r);
    return new $4948bbd58a869556$var$BlockHeader(t);
}, $4948bbd58a869556$var$BlockHeader.fromBuffer = function(e) {
    var r = $4948bbd58a869556$var$BlockHeader._fromBufferReader($3vHUG(e));
    return new $4948bbd58a869556$var$BlockHeader(r);
}, $4948bbd58a869556$var$BlockHeader.fromString = function(e) {
    var r = $4948bbd58a869556$require$Buffer.from(e, "hex");
    return $4948bbd58a869556$var$BlockHeader.fromBuffer(r);
}, $4948bbd58a869556$var$BlockHeader._fromBufferReader = function(e) {
    var r = {};
    return r.version = e.readInt32LE(), r.prevHash = e.read(32), r.merkleRoot = e.read(32), r.time = e.readUInt32LE(), r.bits = e.readUInt32LE(), r.nonce = e.readUInt32LE(), r;
}, $4948bbd58a869556$var$BlockHeader.fromBufferReader = function(e) {
    var r = $4948bbd58a869556$var$BlockHeader._fromBufferReader(e);
    return new $4948bbd58a869556$var$BlockHeader(r);
}, $4948bbd58a869556$var$BlockHeader.prototype.toObject = $4948bbd58a869556$var$BlockHeader.prototype.toJSON = function() {
    return {
        hash: this.hash,
        version: this.version,
        prevHash: $4948bbd58a869556$require$Buffer.from(this.prevHash).reverse().toString("hex"),
        merkleRoot: $4948bbd58a869556$require$Buffer.from(this.merkleRoot).reverse().toString("hex"),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce
    };
}, $4948bbd58a869556$var$BlockHeader.prototype.toBuffer = function() {
    return this.toBufferWriter().concat();
}, $4948bbd58a869556$var$BlockHeader.prototype.toString = function() {
    return this.toBuffer().toString("hex");
}, $4948bbd58a869556$var$BlockHeader.prototype.toBufferWriter = function(e) {
    return e || (e = new $i6ihF), e.writeInt32LE(this.version), e.write(this.prevHash), e.write(this.merkleRoot), e.writeUInt32LE(this.time), e.writeUInt32LE(this.bits), e.writeUInt32LE(this.nonce), e;
}, $4948bbd58a869556$var$BlockHeader.prototype.getTargetDifficulty = function(e) {
    e = e || this.bits;
    for(var r = new $iDkJI(16777215 & e), t = 8 * ((e >>> 24) - 3); t-- > 0;)r = r.mul(new $iDkJI(2));
    return r;
}, $4948bbd58a869556$var$BlockHeader.prototype.getDifficulty = function() {
    var e = this.getTargetDifficulty($4948bbd58a869556$var$GENESIS_BITS).mul(new $iDkJI(Math.pow(10, 8))), r = this.getTargetDifficulty(), t = e.div(r).toString(10), o = t.length - 8;
    return t = t.slice(0, o) + "." + t.slice(o), parseFloat(t);
}, $4948bbd58a869556$var$BlockHeader.prototype._getHash = function() {
    var e = this.toBuffer();
    return $626sY.sha256sha256(e);
};
var $4948bbd58a869556$var$idProperty = {
    configurable: !1,
    enumerable: !0,
    get: function() {
        return this._id || (this._id = $3vHUG(this._getHash()).readReverse().toString("hex")), this._id;
    },
    set: $jk7hO.noop
};
Object.defineProperty($4948bbd58a869556$var$BlockHeader.prototype, "id", $4948bbd58a869556$var$idProperty), Object.defineProperty($4948bbd58a869556$var$BlockHeader.prototype, "hash", $4948bbd58a869556$var$idProperty), $4948bbd58a869556$var$BlockHeader.prototype.validTimestamp = function() {
    var e = Math.round((new Date).getTime() / 1e3);
    return !(this.time > e + $4948bbd58a869556$var$BlockHeader.Constants.MAX_TIME_OFFSET);
}, $4948bbd58a869556$var$BlockHeader.prototype.validProofOfWork = function() {
    var e = new $iDkJI(this.id, "hex"), r = this.getTargetDifficulty();
    return !(e.cmp(r) > 0);
}, $4948bbd58a869556$var$BlockHeader.prototype.inspect = function() {
    return "<BlockHeader " + this.id + ">";
}, $4948bbd58a869556$var$BlockHeader.Constants = {
    START_OF_HEADER: 8,
    MAX_TIME_OFFSET: 7200,
    LARGEST_HASH: new $iDkJI("10000000000000000000000000000000000000000000000000000000000000000", "hex")
}, module.exports = $4948bbd58a869556$var$BlockHeader;

});


parcelRequire.register("8bhzx", function(module, exports) {

var $5f4cfb43468aa2c1$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";
Object.defineProperty(module.exports, "__esModule", {
    value: true
});
module.exports.Proof = module.exports.pow_string = module.exports.meta = module.exports.Solution = module.exports.Puzzle = module.exports.PowString = void 0;

var $5St76 = parcelRequire("5St76");

var $c5i4c = parcelRequire("c5i4c");

var $7HMvJ = parcelRequire("7HMvJ");

var $3hHgz = parcelRequire("3hHgz");

var $7fdzx = parcelRequire("7fdzx");

var $3KCZ8 = parcelRequire("3KCZ8");

var $57aEL = parcelRequire("57aEL");

var $57aEL = parcelRequire("57aEL");
Object.defineProperty(module.exports, "PowString", {
    enumerable: true,
    get: function() {
        return $57aEL.PowString;
    }
});
// TODO the puzzle also needs to contain a Merkle branch but for Boost that is empty.
class $5f4cfb43468aa2c1$var$Puzzle {
    constructor(Category, Content, Difficulty, MetaBegin, MetaEnd, Mask){
        this.Category = Category;
        this.Content = Content;
        this.Difficulty = Difficulty;
        this.MetaBegin = MetaBegin;
        this.MetaEnd = MetaEnd;
        this.Mask = Mask;
    }
}
module.exports.Puzzle = $5f4cfb43468aa2c1$var$Puzzle;
class $5f4cfb43468aa2c1$var$Solution {
    constructor(Time, ExtraNonce1, ExtraNonce2, Nonce, GeneralPurposeBits){
        this.Time = Time;
        this.ExtraNonce1 = ExtraNonce1;
        this.ExtraNonce2 = ExtraNonce2;
        this.Nonce = Nonce;
        this.GeneralPurposeBits = GeneralPurposeBits;
    }
    toJSON() {
        let json = {
            share: {
                timestamp: this.Time.hex,
                nonce: this.Nonce.hex,
                extra_nonce_2: this.Nonce.hex
            },
            extra_nonce_1: this.ExtraNonce1.hex
        };
        if (this.GeneralPurposeBits) json.share["bits"] = this.GeneralPurposeBits.hex;
        return json;
    }
    static fromJSON(x) {
        if (!x.share || !x.extra_nonce_1 || !x.share.timestamp || !x.share.nonce || !x.share.extra_nonce_2 || typeof x.extra_nonce_1 !== "string" || typeof x.share.timestamp !== "string" || typeof x.share.nonce !== "string" || typeof x.share.extra_nonce_2 !== "string" || !!x.share.bits && typeof x.share.bits !== "string") return;
        let time = $7HMvJ.UInt32Little.fromHex(x.share.timestamp);
        if (time === undefined) return;
        let en1 = $3hHgz.UInt32Big.fromHex(x.extra_nonce_1);
        if (en1 === undefined) return;
        let en2 = $7fdzx.Bytes.fromHex(x.share.extra_nonce_2);
        if (en2 === undefined) return;
        let n = $7HMvJ.UInt32Little.fromHex(x.share.nonce);
        if (n === undefined) return;
        let gpr;
        if (!!x.share.bits) {
            gpr = $c5i4c.Int32Little.fromHex(x.share.bits);
            if (gpr === undefined) return;
        }
        return new $5f4cfb43468aa2c1$var$Solution(time, en1, en2, n, gpr);
    }
}
module.exports.Solution = $5f4cfb43468aa2c1$var$Solution;
function $5f4cfb43468aa2c1$var$meta(p, x) {
    return new $7fdzx.Bytes($5f4cfb43468aa2c1$require$Buffer.concat([
        p.MetaBegin.buffer,
        x.ExtraNonce1.buffer,
        x.ExtraNonce2.buffer,
        p.MetaEnd.buffer
    ]));
}
module.exports.meta = $5f4cfb43468aa2c1$var$meta;
function $5f4cfb43468aa2c1$var$pow_string(p, x) {
    var category;
    if (p.Mask) {
        var generalPurposeBits = x.GeneralPurposeBits;
        if (generalPurposeBits) category = $3KCZ8.Utils.writeInt32LE(p.Category.number & p.Mask.number | generalPurposeBits.number & ~p.Mask.number);
        else return;
    } else if (x.GeneralPurposeBits) return;
    else category = p.Category.buffer;
    const boostPowMetadataCoinbaseString = $5f4cfb43468aa2c1$var$meta(p, x);
    return new $57aEL.PowString($5St76.BlockHeader.fromBuffer($5f4cfb43468aa2c1$require$Buffer.concat([
        category,
        p.Content.buffer,
        boostPowMetadataCoinbaseString.hash256.buffer,
        x.Time.buffer,
        p.Difficulty.buffer,
        x.Nonce.buffer
    ])));
}
module.exports.pow_string = $5f4cfb43468aa2c1$var$pow_string;
// TODO the puzzle also needs to contain a Merkle branch but for Boost that is empty.
class $5f4cfb43468aa2c1$var$Proof {
    constructor(Puzzle, Solution){
        this.Puzzle = Puzzle;
        this.Solution = Solution;
    }
    metadata() {
        return $5f4cfb43468aa2c1$var$meta(this.Puzzle, this.Solution);
    }
    string() {
        return $5f4cfb43468aa2c1$var$pow_string(this.Puzzle, this.Solution);
    }
    valid() {
        let x = this.string();
        if (x) return x.valid();
        return false;
    }
}
module.exports.Proof = $5f4cfb43468aa2c1$var$Proof;

});
parcelRequire.register("c5i4c", function(module, exports) {

var $8cc3f759763b7a17$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";
Object.defineProperty(module.exports, "__esModule", {
    value: true
});
module.exports.Int32Little = void 0;

var $3KCZ8 = parcelRequire("3KCZ8");
class $8cc3f759763b7a17$var$Int32Little {
    constructor(data){
        this.data = data;
    }
    static fromNumber(num) {
        let data = $8cc3f759763b7a17$require$Buffer.alloc(4);
        if (num <= 2147483647 && num >= -2147483648) data.writeInt32LE(num);
        return new $8cc3f759763b7a17$var$Int32Little(data);
    }
    static fromHex(hex) {
        if (hex.length != 8) return;
        let data = $8cc3f759763b7a17$require$Buffer.from(hex, "hex");
        if (data.length != 4) return;
        return new $8cc3f759763b7a17$var$Int32Little(data);
    }
    get buffer() {
        return this.data;
    }
    get hex() {
        return this.buffer.toString("hex");
    }
    get number() {
        return this.buffer.readInt32LE();
    }
    get string() {
        return this.utf8;
    }
    get utf8() {
        return $3KCZ8.Utils.trimBufferString(this.buffer, true);
    }
}
module.exports.Int32Little = $8cc3f759763b7a17$var$Int32Little;

});
parcelRequire.register("3KCZ8", function(module, exports) {

var $2bb3e896b5ac32ef$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";
Object.defineProperty(module.exports, "__esModule", {
    value: true
});
module.exports.Utils = void 0;

var $5St76 = parcelRequire("5St76");
class $2bb3e896b5ac32ef$var$Utils {
    static getSha256(str, encoding = "utf8") {
        const hashed = $2bb3e896b5ac32ef$require$Buffer.from(str, encoding);
        const h = $5St76.crypto.Hash.sha256(hashed).toString("hex");
        return h;
    }
    static writeInt32LE(x) {
        if (x > 0x7fffffff) throw "number too big to be an int32.";
        if (x < -2147483648) throw "number too small to be an int32.";
        let b = $2bb3e896b5ac32ef$require$Buffer.alloc(4);
        b.writeInt32LE(x);
        return b;
    }
    static writeUInt32LE(x) {
        if (x > 0xffffffff) throw "number too big to be a uint32.";
        let b = $2bb3e896b5ac32ef$require$Buffer.alloc(4);
        b.writeUInt32LE(x);
        return b;
    }
    static trimBufferString(str, trimTrailingNulls = true) {
        const content = str.toString("utf8");
        if (trimTrailingNulls) return content.replace(/\0+$/g, "");
        else return content;
    }
    static maxBits() {
        return 0x2100ffff;
    }
    static minBits() {
        return 0x03000001;
    }
    static unitBits() {
        return 0x1d00ffff;
    }
    /**
     * Returns the target difficulty for this block
     * @param {Number} bits
     * @returns {BN} An instance of BN with the decoded difficulty bits
     */ static getTargetDifficulty(bits) {
        var target = new $5St76.crypto.BN(bits & 0xffffff);
        var mov = (bits >>> 24) - 3;
        while(mov-- > 0)target = target.mul(new $5St76.crypto.BN(256));
        return target;
    }
    // This function doesn't make much sense. It is a combinion of two functions
    // by Daniel and Attila which both purport to solve the same problem. They
    // each don't work quite right in different domains, but when they are
    // combined they result in a successful function. I don't really know why
    // it works this way, and it would be good if we had something simpler.
    // https://bitcoin.stackexchange.com/questions/30467/what-are-the-equations-to-convert-between-bits-and-difficulty
    /**
     * @link https://en.bitcoin.it/wiki/Difficulty
     * @return {Number}
     */ static difficulty(bits) {
        var difficulty1TargetBN = $2bb3e896b5ac32ef$var$Utils.getTargetDifficulty($2bb3e896b5ac32ef$var$Utils.unitBits());
        var currentTargetBN = $2bb3e896b5ac32ef$var$Utils.getTargetDifficulty(bits);
        if (currentTargetBN.gt(difficulty1TargetBN)) return parseFloat(difficulty1TargetBN.toString(10)) / parseFloat(currentTargetBN.toString(10));
        var difficultyString = difficulty1TargetBN.mul(new $5St76.crypto.BN(Math.pow(10, 8))).div(currentTargetBN).toString(10);
        var decimalPos = difficultyString.length - 8;
        difficultyString = difficultyString.slice(0, decimalPos) + "." + difficultyString.slice(decimalPos);
        return parseFloat(difficultyString);
    }
    static difficulty2bits(difficulty) {
        if (difficulty < 0) throw "difficulty cannot be negative";
        if (!isFinite(difficulty)) throw "difficulty cannot be infinite";
        var absolute = parseFloat($2bb3e896b5ac32ef$var$Utils.getTargetDifficulty($2bb3e896b5ac32ef$var$Utils.unitBits()).toString(10)) / difficulty;
        var exponent = 0;
        while(absolute > 1){
            absolute /= 256;
            exponent++;
        }
        if (exponent < 3) return $2bb3e896b5ac32ef$var$Utils.minBits();
        if (exponent > 32) return $2bb3e896b5ac32ef$var$Utils.maxBits();
        let word = Math.trunc(16777216 * absolute) & 0xffffff;
        if (word & 0x800000) {
            word >>= 8;
            exponent++;
        }
        return exponent << 24 | word;
    }
    static getTargetAsNumberBuffer(diff) {
        const i = $2bb3e896b5ac32ef$var$Utils.difficulty2bits(diff);
        return $2bb3e896b5ac32ef$require$Buffer.from(i.toString(16), "hex").reverse();
    }
    // creates a buffer from a string with an optional parameter
    // to determine the total length. The buffer will be padded with
    // zeros to achieve this length.
    static stringToBuffer(str, length) {
        if (!length) return $2bb3e896b5ac32ef$require$Buffer.from(str, "utf8");
        if (str.length > length) throw "string is too big";
        let buf = $2bb3e896b5ac32ef$require$Buffer.from(str, "utf8");
        let pad = $2bb3e896b5ac32ef$require$Buffer.alloc(length - str.length);
        return $2bb3e896b5ac32ef$require$Buffer.concat([
            buf,
            pad
        ]);
    }
    static fromOpCode(chunk) {
        if (chunk.opcodenum >= $5St76.Opcode.OP_1 && chunk.opcodenum <= $5St76.Opcode.OP_16) return $2bb3e896b5ac32ef$require$Buffer.from([
            chunk.opcodenum - $5St76.Opcode.OP_1 + 1
        ]);
        else if (chunk.opcodenum == $5St76.Opcode.OP_0) return $2bb3e896b5ac32ef$require$Buffer.from([]);
        else if (chunk.opcodenum == $5St76.Opcode.OP_1NEGATE) return $2bb3e896b5ac32ef$require$Buffer.from([
            0x81
        ]);
        else return chunk.buf;
    }
    static generalPurposeBitsMask() {
        // should be 0xE0001FFF but javascript won't read
        // this is a negative number.
        return -536862721;
    }
    static generalPurposeBits(category) {
        return ~this.generalPurposeBitsMask() & category >> 13;
    }
    static magicNumber(category) {
        return 0x00001FFF & category | (0xE0000000 & category) >> 16;
    }
    static version(category) {
        return this.generalPurposeBitsMask() & category;
    }
    static createBufferAndPad(buf, length, reverse = true) {
        if (!buf) {
            const emptyBuffer = $2bb3e896b5ac32ef$require$Buffer.alloc(length);
            emptyBuffer.fill(0);
            return emptyBuffer;
        }
        let paddedBuf;
        if ((typeof buf).toString() === "buffer") {
            if (buf.byteLength > length) throw new Error("The buffer is out of bounds: " + length + " bytes or small expected");
            paddedBuf = buf;
        } else {
            if (buf.length > length * 2) throw new Error("The buffer is out of bounds: " + length + " bytes expected");
            var re = /^([0-9A-Fa-f][0-9A-Fa-f])+$/g;
            if (!re.test(buf)) throw "not a hex string";
            else paddedBuf = $2bb3e896b5ac32ef$require$Buffer.from(buf, "hex");
        }
        if (paddedBuf.byteLength < length) {
            const emptyBuffer1 = $2bb3e896b5ac32ef$require$Buffer.alloc(length - paddedBuf.byteLength);
            emptyBuffer1.fill(0);
            return reverse ? $2bb3e896b5ac32ef$require$Buffer.concat([
                emptyBuffer1,
                paddedBuf
            ]).reverse() : $2bb3e896b5ac32ef$require$Buffer.concat([
                paddedBuf,
                emptyBuffer1
            ]);
        } else return reverse ? paddedBuf.reverse() : paddedBuf;
    }
}
module.exports.Utils = $2bb3e896b5ac32ef$var$Utils;

});


parcelRequire.register("7HMvJ", function(module, exports) {

var $59c22dc6b1f614be$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";
Object.defineProperty(module.exports, "__esModule", {
    value: true
});
module.exports.UInt32Little = void 0;

var $3KCZ8 = parcelRequire("3KCZ8");
class $59c22dc6b1f614be$var$UInt32Little {
    constructor(data){
        this.data = data;
        this.data = data;
    }
    static fromNumber(num) {
        let data = $59c22dc6b1f614be$require$Buffer.alloc(4);
        if (num <= 4294967295 && num >= 0) data.writeUInt32LE(num);
        return new $59c22dc6b1f614be$var$UInt32Little(data);
    }
    static fromHex(hex) {
        if (hex.length != 8) return;
        let data = $59c22dc6b1f614be$require$Buffer.from(hex, "hex");
        if (data.length != 4) return;
        return new $59c22dc6b1f614be$var$UInt32Little(data);
    }
    get hex() {
        return this.data.toString("hex");
    }
    get number() {
        return this.data.readUInt32LE();
    }
    get buffer() {
        return this.data;
    }
    get string() {
        return this.utf8;
    }
    get utf8() {
        return $3KCZ8.Utils.trimBufferString(this.data, true);
    }
}
module.exports.UInt32Little = $59c22dc6b1f614be$var$UInt32Little;

});

parcelRequire.register("3hHgz", function(module, exports) {

var $264485676542ae58$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";
Object.defineProperty(module.exports, "__esModule", {
    value: true
});
module.exports.UInt32Big = module.exports.InvalidUInt32Big = void 0;

var $3KCZ8 = parcelRequire("3KCZ8");
class $264485676542ae58$var$InvalidUInt32Big {
    constructor(){
        this.name = "InvalidUInt32Big";
        this.message = "Value must be between 0 and 4294967295";
    }
}
module.exports.InvalidUInt32Big = $264485676542ae58$var$InvalidUInt32Big;
class $264485676542ae58$var$UInt32Big {
    constructor(data){
        this.data = data;
    }
    static fromNumber(num) {
        let data = $264485676542ae58$require$Buffer.alloc(4);
        if (num > 4294967295 || num < 0) throw new $264485676542ae58$var$InvalidUInt32Big;
        data.writeUInt32BE(num);
        return new $264485676542ae58$var$UInt32Big(data);
    }
    static fromHex(hex) {
        if (hex.length != 8) return;
        let data = $264485676542ae58$require$Buffer.from(hex, "hex");
        if (data.length != 4) return;
        return new $264485676542ae58$var$UInt32Big(data);
    }
    get hex() {
        return this.data.toString("hex");
    }
    get number() {
        return this.data.readUInt32BE();
    }
    get buffer() {
        return this.data;
    }
    get string() {
        return this.utf8;
    }
    get utf8() {
        return $3KCZ8.Utils.trimBufferString(this.data, true);
    }
}
module.exports.UInt32Big = $264485676542ae58$var$UInt32Big;

});

parcelRequire.register("7fdzx", function(module, exports) {

var $546476433514e962$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";
Object.defineProperty(module.exports, "__esModule", {
    value: true
});
module.exports.Bytes = void 0;

var $5St76 = parcelRequire("5St76");

var $3KCZ8 = parcelRequire("3KCZ8");

var $iYsCg = parcelRequire("iYsCg");
class $546476433514e962$var$Bytes {
    constructor(data){
        this.data = data;
    }
    static fromHex(b) {
        return new $546476433514e962$var$Bytes($546476433514e962$require$Buffer.from(b, "hex"));
    }
    get buffer() {
        return this.data;
    }
    get hex() {
        return this.buffer.toString("hex");
    }
    get string() {
        return this.utf8;
    }
    get utf8() {
        return $3KCZ8.Utils.trimBufferString(this.buffer, true);
    }
    get hash256() {
        return new $iYsCg.Digest32($5St76.crypto.Hash.sha256sha256(this.buffer));
    }
    get length() {
        return this.data.length;
    }
}
module.exports.Bytes = $546476433514e962$var$Bytes;

});
parcelRequire.register("iYsCg", function(module, exports) {

var $dd0407303c1dcfc1$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";
Object.defineProperty(module.exports, "__esModule", {
    value: true
});
module.exports.Digest32 = void 0;

var $5St76 = parcelRequire("5St76");

var $3KCZ8 = parcelRequire("3KCZ8");
class $dd0407303c1dcfc1$var$Digest32 {
    constructor(data){
        this.data = data;
    }
    static fromHex(x) {
        return new $dd0407303c1dcfc1$var$Digest32($dd0407303c1dcfc1$require$Buffer.from(x, "hex").reverse());
    }
    // reverse because of a horrible convention that exists in Bitcoin
    // which got started due to stupid a bug long ago.
    get hex() {
        return $dd0407303c1dcfc1$require$Buffer.from(this.data).reverse().toString("hex");
    }
    get number() {
        return new $5St76.crypto.BN(this.hex, "hex", "be");
    }
    get buffer() {
        return this.data;
    }
    get string() {
        return this.utf8;
    }
    get utf8() {
        return $3KCZ8.Utils.trimBufferString(this.data, true);
    }
}
module.exports.Digest32 = $dd0407303c1dcfc1$var$Digest32;

});


parcelRequire.register("57aEL", function(module, exports) {

var $3b95df5b50dde250$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";
Object.defineProperty(module.exports, "__esModule", {
    value: true
});
module.exports.BoostPowString = module.exports.PowString = void 0;

var $5St76 = parcelRequire("5St76");

var $c5i4c = parcelRequire("c5i4c");

var $7HMvJ = parcelRequire("7HMvJ");

var $kmTqg = parcelRequire("kmTqg");

var $iYsCg = parcelRequire("iYsCg");

var $3KCZ8 = parcelRequire("3KCZ8");
class $3b95df5b50dde250$var$PowString {
    constructor(blockheader){
        this._blockheader = blockheader;
    }
    // Use boosthash(), hash() and id() to all be equal to the string
    // remember, the string itself is the data and proof of work identity.
    get boostHash() {
        return this.hash;
    }
    get hash() {
        return $iYsCg.Digest32.fromHex(this._blockheader.hash);
    }
    get id() {
        return this.hash;
    }
    get category() {
        return $c5i4c.Int32Little.fromNumber(this._blockheader.version);
    }
    get magicNumber() {
        return $kmTqg.UInt16Little.fromNumber($3KCZ8.Utils.magicNumber(this.category.number));
    }
    get content() {
        return new $iYsCg.Digest32($3b95df5b50dde250$require$Buffer.from(this.toObject().content, "hex").reverse());
    }
    get bits() {
        return $7HMvJ.UInt32Little.fromNumber(this._blockheader.toObject().bits);
    }
    get metadataHash() {
        return new $iYsCg.Digest32($3b95df5b50dde250$require$Buffer.from(this.toObject().metadataHash, "hex").reverse());
    }
    get nonce() {
        return $7HMvJ.UInt32Little.fromNumber(this._blockheader.nonce);
    }
    get time() {
        return $7HMvJ.UInt32Little.fromNumber(this._blockheader.time);
    }
    valid() {
        return this._blockheader.validProofOfWork();
    }
    static fromBuffer(buf) {
        return new $3b95df5b50dde250$var$PowString($5St76.BlockHeader.fromBuffer(buf));
    }
    static fromString(str) {
        var buf = $3b95df5b50dde250$require$Buffer.from(str, "hex");
        return new $3b95df5b50dde250$var$PowString($5St76.BlockHeader.fromBuffer(buf));
    }
    static fromHex(str) {
        var buf = $3b95df5b50dde250$require$Buffer.from(str, "hex");
        return new $3b95df5b50dde250$var$PowString($5St76.BlockHeader.fromBuffer(buf));
    }
    static fromObject(obj) {
        const spoofedObj = {
            prevHash: obj.content,
            bits: obj.bits,
            version: obj.category,
            merkleRoot: obj.metadataHash,
            time: obj.time,
            nonce: obj.nonce
        };
        return new $3b95df5b50dde250$var$PowString($5St76.BlockHeader.fromObject(spoofedObj));
    }
    toBuffer() {
        return this._blockheader.toBufferWriter().concat();
    }
    toString() {
        return this._blockheader.toBuffer().toString("hex");
    }
    toHex() {
        return this._blockheader.toBuffer().toString("hex");
    }
    toObject() {
        const blockheaderObj = this._blockheader.toObject();
        const boostheaderObj = {
            hash: blockheaderObj.hash,
            content: blockheaderObj.prevHash,
            bits: blockheaderObj.bits,
            difficulty: this.difficulty,
            category: blockheaderObj.version,
            metadataHash: blockheaderObj.merkleRoot,
            time: blockheaderObj.time,
            nonce: blockheaderObj.nonce
        };
        return boostheaderObj;
    }
    get difficulty() {
        return this._blockheader.getDifficulty();
    }
}
module.exports.PowString = $3b95df5b50dde250$var$PowString;
module.exports.BoostPowString = $3b95df5b50dde250$var$PowString;

});
parcelRequire.register("kmTqg", function(module, exports) {

var $ed40da7c0f6f882e$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";
Object.defineProperty(module.exports, "__esModule", {
    value: true
});
module.exports.UInt16Little = void 0;
class $ed40da7c0f6f882e$var$UInt16Little {
    constructor(data){
        this.data = data;
    }
    static fromNumber(num) {
        let data = $ed40da7c0f6f882e$require$Buffer.alloc(2);
        if (num <= 65536 && num >= 0) data.writeUInt16LE(num);
        return new $ed40da7c0f6f882e$var$UInt16Little(data);
    }
    get hex() {
        return this.data.toString("hex");
    }
    get number() {
        return this.data.readUInt16LE();
    }
    get buffer() {
        return this.data;
    }
    get string() {
        return this.hex;
    }
}
module.exports.UInt16Little = $ed40da7c0f6f882e$var$UInt16Little;

});



// import default protocols
var $239a085fc78b1aab$var$Bitcoin = function(t) {
    var e = {};
    function r(i) {
        if (e[i]) return e[i].exports;
        var n = e[i] = {
            i: i,
            l: !1,
            exports: {}
        };
        return t[i].call(n.exports, n, n.exports, r), n.l = !0, n.exports;
    }
    return r.m = t, r.c = e, r.d = function(t, e, i) {
        r.o(t, e) || Object.defineProperty(t, e, {
            enumerable: !0,
            get: i
        });
    }, r.r = function(t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        });
    }, r.t = function(t, e) {
        if (1 & e && (t = r(t)), 8 & e) return t;
        if (4 & e && "object" == typeof t && t && t.__esModule) return t;
        var i = Object.create(null);
        if (r.r(i), Object.defineProperty(i, "default", {
            enumerable: !0,
            value: t
        }), 2 & e && "string" != typeof t) for(var n in t)r.d(i, n, (function(e) {
            return t[e];
        }).bind(null, n));
        return i;
    }, r.n = function(t) {
        var e = t && t.__esModule ? function() {
            return t.default;
        } : function() {
            return t;
        };
        return r.d(e, "a", e), e;
    }, r.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e);
    }, r.p = "", r(r.s = 87);
}([
    function(t, e, r) {
        "use strict";
        r.d(e, "a", function() {
            return a;
        });
        var i, n = r(4);
        !function(t) {
            t[t.OP_FALSE = 0] = "OP_FALSE", t[t.OP_0 = 0] = "OP_0", t[t.OP_PUSHDATA1 = 76] = "OP_PUSHDATA1", t[t.OP_PUSHDATA2 = 77] = "OP_PUSHDATA2", t[t.OP_PUSHDATA4 = 78] = "OP_PUSHDATA4", t[t.OP_1NEGATE = 79] = "OP_1NEGATE", t[t.OP_RESERVED = 80] = "OP_RESERVED", t[t.OP_TRUE = 81] = "OP_TRUE", t[t.OP_1 = 81] = "OP_1", t[t.OP_2 = 82] = "OP_2", t[t.OP_3 = 83] = "OP_3", t[t.OP_4 = 84] = "OP_4", t[t.OP_5 = 85] = "OP_5", t[t.OP_6 = 86] = "OP_6", t[t.OP_7 = 87] = "OP_7", t[t.OP_8 = 88] = "OP_8", t[t.OP_9 = 89] = "OP_9", t[t.OP_10 = 90] = "OP_10", t[t.OP_11 = 91] = "OP_11", t[t.OP_12 = 92] = "OP_12", t[t.OP_13 = 93] = "OP_13", t[t.OP_14 = 94] = "OP_14", t[t.OP_15 = 95] = "OP_15", t[t.OP_16 = 96] = "OP_16", t[t.OP_NOP = 97] = "OP_NOP", t[t.OP_VER = 98] = "OP_VER", t[t.OP_IF = 99] = "OP_IF", t[t.OP_NOTIF = 100] = "OP_NOTIF", t[t.OP_VERIF = 101] = "OP_VERIF", t[t.OP_VERNOTIF = 102] = "OP_VERNOTIF", t[t.OP_ELSE = 103] = "OP_ELSE", t[t.OP_ENDIF = 104] = "OP_ENDIF", t[t.OP_VERIFY = 105] = "OP_VERIFY", t[t.OP_RETURN = 106] = "OP_RETURN", t[t.OP_TOALTSTACK = 107] = "OP_TOALTSTACK", t[t.OP_FROMALTSTACK = 108] = "OP_FROMALTSTACK", t[t.OP_2DROP = 109] = "OP_2DROP", t[t.OP_2DUP = 110] = "OP_2DUP", t[t.OP_3DUP = 111] = "OP_3DUP", t[t.OP_2OVER = 112] = "OP_2OVER", t[t.OP_2ROT = 113] = "OP_2ROT", t[t.OP_2SWAP = 114] = "OP_2SWAP", t[t.OP_IFDUP = 115] = "OP_IFDUP", t[t.OP_DEPTH = 116] = "OP_DEPTH", t[t.OP_DROP = 117] = "OP_DROP", t[t.OP_DUP = 118] = "OP_DUP", t[t.OP_NIP = 119] = "OP_NIP", t[t.OP_OVER = 120] = "OP_OVER", t[t.OP_PICK = 121] = "OP_PICK", t[t.OP_ROLL = 122] = "OP_ROLL", t[t.OP_ROT = 123] = "OP_ROT", t[t.OP_SWAP = 124] = "OP_SWAP", t[t.OP_TUCK = 125] = "OP_TUCK", t[t.OP_CAT = 126] = "OP_CAT", t[t.OP_SUBSTR = 127] = "OP_SUBSTR", t[t.OP_SPLIT = 127] = "OP_SPLIT", t[t.OP_LEFT = 128] = "OP_LEFT", t[t.OP_NUM2BIN = 128] = "OP_NUM2BIN", t[t.OP_RIGHT = 129] = "OP_RIGHT", t[t.OP_BIN2NUM = 129] = "OP_BIN2NUM", t[t.OP_SIZE = 130] = "OP_SIZE", t[t.OP_INVERT = 131] = "OP_INVERT", t[t.OP_AND = 132] = "OP_AND", t[t.OP_OR = 133] = "OP_OR", t[t.OP_XOR = 134] = "OP_XOR", t[t.OP_EQUAL = 135] = "OP_EQUAL", t[t.OP_EQUALVERIFY = 136] = "OP_EQUALVERIFY", t[t.OP_RESERVED1 = 137] = "OP_RESERVED1", t[t.OP_RESERVED2 = 138] = "OP_RESERVED2", t[t.OP_1ADD = 139] = "OP_1ADD", t[t.OP_1SUB = 140] = "OP_1SUB", t[t.OP_2MUL = 141] = "OP_2MUL", t[t.OP_2DIV = 142] = "OP_2DIV", t[t.OP_NEGATE = 143] = "OP_NEGATE", t[t.OP_ABS = 144] = "OP_ABS", t[t.OP_NOT = 145] = "OP_NOT", t[t.OP_0NOTEQUAL = 146] = "OP_0NOTEQUAL", t[t.OP_ADD = 147] = "OP_ADD", t[t.OP_SUB = 148] = "OP_SUB", t[t.OP_MUL = 149] = "OP_MUL", t[t.OP_DIV = 150] = "OP_DIV", t[t.OP_MOD = 151] = "OP_MOD", t[t.OP_LSHIFT = 152] = "OP_LSHIFT", t[t.OP_RSHIFT = 153] = "OP_RSHIFT", t[t.OP_BOOLAND = 154] = "OP_BOOLAND", t[t.OP_BOOLOR = 155] = "OP_BOOLOR", t[t.OP_NUMEQUAL = 156] = "OP_NUMEQUAL", t[t.OP_NUMEQUALVERIFY = 157] = "OP_NUMEQUALVERIFY", t[t.OP_NUMNOTEQUAL = 158] = "OP_NUMNOTEQUAL", t[t.OP_LESSTHAN = 159] = "OP_LESSTHAN", t[t.OP_GREATERTHAN = 160] = "OP_GREATERTHAN", t[t.OP_LESSTHANOREQUAL = 161] = "OP_LESSTHANOREQUAL", t[t.OP_GREATERTHANOREQUAL = 162] = "OP_GREATERTHANOREQUAL", t[t.OP_MIN = 163] = "OP_MIN", t[t.OP_MAX = 164] = "OP_MAX", t[t.OP_WITHIN = 165] = "OP_WITHIN", t[t.OP_RIPEMD160 = 166] = "OP_RIPEMD160", t[t.OP_SHA1 = 167] = "OP_SHA1", t[t.OP_SHA256 = 168] = "OP_SHA256", t[t.OP_HASH160 = 169] = "OP_HASH160", t[t.OP_HASH256 = 170] = "OP_HASH256", t[t.OP_CODESEPARATOR = 171] = "OP_CODESEPARATOR", t[t.OP_CHECKSIG = 172] = "OP_CHECKSIG", t[t.OP_CHECKSIGVERIFY = 173] = "OP_CHECKSIGVERIFY", t[t.OP_CHECKMULTISIG = 174] = "OP_CHECKMULTISIG", t[t.OP_CHECKMULTISIGVERIFY = 175] = "OP_CHECKMULTISIGVERIFY", t[t.OP_NOP1 = 176] = "OP_NOP1", t[t.OP_NOP2 = 177] = "OP_NOP2", t[t.OP_CHECKLOCKTIMEVERIFY = 177] = "OP_CHECKLOCKTIMEVERIFY", t[t.OP_NOP3 = 178] = "OP_NOP3", t[t.OP_CHECKSEQUENCEVERIFY = 178] = "OP_CHECKSEQUENCEVERIFY", t[t.OP_NOP4 = 179] = "OP_NOP4", t[t.OP_NOP5 = 180] = "OP_NOP5", t[t.OP_NOP6 = 181] = "OP_NOP6", t[t.OP_NOP7 = 182] = "OP_NOP7", t[t.OP_NOP8 = 183] = "OP_NOP8", t[t.OP_NOP9 = 184] = "OP_NOP9", t[t.OP_NOP10 = 185] = "OP_NOP10", t[t.OP_SMALLDATA = 249] = "OP_SMALLDATA", t[t.OP_SMALLINTEGER = 250] = "OP_SMALLINTEGER", t[t.OP_PUBKEYS = 251] = "OP_PUBKEYS", t[t.OP_PUBKEYHASH = 253] = "OP_PUBKEYHASH", t[t.OP_PUBKEY = 254] = "OP_PUBKEY", t[t.OP_INVALIDOPCODE = 255] = "OP_INVALIDOPCODE";
        }(i || (i = {}));
        class s extends n.a {
            constructor(t){
                super({
                    num: t
                });
            }
            fromNumber(t) {
                return this.num = t, this;
            }
            static fromNumber(t) {
                return (new this).fromNumber(t);
            }
            toNumber() {
                return this.num;
            }
            fromString(t) {
                const e = i[t];
                if (void 0 === e) throw new Error("Invalid opCodeStr");
                return this.num = e, this;
            }
            toString() {
                const t = s.str[this.num];
                if (void 0 === t) {
                    if (this.num > 0 && this.num < a.OP_PUSHDATA1) return this.num.toString();
                    throw new Error("OpCode does not have a string representation");
                }
                return t;
            }
        }
        s.str = {};
        for(const t1 in i)s[t1] = i[t1], Object.prototype.hasOwnProperty.call(i, t1) && (s.str[i[t1]] = t1);
        const a = s;
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return o;
            });
            var i = r(14);
            function n(t, e, ...r) {
                if (!(this instanceof n)) return new n(t, e, ...r);
                i.call(this, t, e, ...r);
            }
            for (const t1 of Object.keys(i))n[t1] = i[t1];
            function s(e) {
                const r = t.alloc(e.length);
                for(let t1 = 0; t1 < e.length; t1++)r[t1] = e[e.length - 1 - t1];
                return r;
            }
            function a(t) {
                n.prototype["_" + t] = n.prototype[t];
                n.prototype[t] = function(e) {
                    return "string" == typeof e ? e = new n(e) : "number" == typeof e && (e = new n(e.toString())), this["_" + t](e);
                };
            }
            n.prototype = Object.create(i.prototype), n.prototype.constructor = n, n.prototype.fromHex = function(e, r) {
                return this.fromBuffer(t.from(e, "hex"), r);
            }, n.prototype.toHex = function(t) {
                return this.toBuffer(t).toString("hex");
            }, n.prototype.toJSON = function() {
                return this.toString();
            }, n.prototype.fromJSON = function(t) {
                return n(t).copy(this), this;
            }, n.prototype.fromNumber = function(t) {
                return n(t).copy(this), this;
            }, n.prototype.toNumber = function() {
                return parseInt(this.toString(10), 10);
            }, n.prototype.fromString = function(t, e) {
                return n(t, e).copy(this), this;
            }, n.fromBuffer = function(t, e = {
                endian: "big"
            }) {
                "little" === e.endian && (t = s(t));
                return new n(t.toString("hex"), 16);
            }, n.prototype.fromBuffer = function(t, e) {
                return n.fromBuffer(t, e).copy(this), this;
            }, n.prototype.toBuffer = function(e = {
                size: void 0,
                endian: "big"
            }) {
                let r;
                if (e.size) {
                    const i = this.toString(16, 2), n = i.length / 2;
                    if (r = t.from(i, "hex"), n === e.size) ;
                    else if (n > e.size) r = r.slice(n - r.length, r.length);
                    else if (n < e.size) {
                        const i1 = t.alloc(e.size);
                        for(let t1 = 0; t1 < r.length; t1++)i1[i1.length - 1 - t1] = r[r.length - 1 - t1];
                        for(let t2 = 0; t2 < e.size - n; t2++)i1[t2] = 0;
                        r = i1;
                    }
                } else {
                    const e1 = this.toString(16, 2);
                    r = t.from(e1, "hex");
                }
                "little" === e.endian && (r = s(r));
                const i2 = t.from([
                    0
                ]);
                return 0 === t.compare(r, i2) ? t.from([]) : r;
            }, n.prototype.toFastBuffer = n.prototype.toBuffer, n.fromFastBuffer = n.fromBuffer, n.prototype.fromFastBuffer = n.prototype.fromBuffer, n.prototype.fromSm = function(e, r = {
                endian: "big"
            }) {
                0 === e.length && this.fromBuffer(t.from([
                    0
                ]));
                return "little" === r.endian && (e = s(e)), 128 & e[0] ? (e[0] = 127 & e[0], this.fromBuffer(e), this.neg().copy(this)) : this.fromBuffer(e), this;
            }, n.prototype.toSm = function(e = {
                endian: "big"
            }) {
                const r = e.endian;
                let i;
                return -1 === this.cmp(0) ? (i = this.neg().toBuffer(), 128 & i[0] ? i = t.concat([
                    t.from([
                        128
                    ]),
                    i
                ]) : i[0] = 128 | i[0]) : (i = this.toBuffer(), 128 & i[0] && (i = t.concat([
                    t.from([
                        0
                    ]),
                    i
                ]))), 1 === i.length && 0 === i[0] && (i = t.from([])), "little" === r && (i = s(i)), i;
            }, n.prototype.fromBits = function(e, r = {
                strict: !1
            }) {
                let i = t.alloc(4);
                if (i.writeUInt32BE(e, 0), e = i.readInt32BE(0), r.strict && 8388608 & e) throw new Error("negative bit set");
                const s = e >> 24, a = 8388607 & e;
                if (i = t.alloc(4), i.writeInt32BE(a), s <= 3) i = i.slice(1, s + 1);
                else {
                    const e1 = t.alloc(s - 3);
                    e1.fill(0), i = t.concat([
                        i,
                        e1
                    ]);
                }
                return this.fromBuffer(i), 8388608 & e && n(0).sub(this).copy(this), this;
            }, n.prototype.toBits = function() {
                let e;
                e = this.lt(0) ? this.neg().toBuffer() : this.toBuffer();
                let r, i = e.length;
                if (i > 3) r = t.concat([
                    t.from([
                        0
                    ]),
                    e.slice(0, 3)
                ]).readUInt32BE(0);
                else if (i <= 3) {
                    const n = t.alloc(3 - i + 1);
                    n.fill(0), r = t.concat([
                        n,
                        e.slice(0, i)
                    ]).readUInt32BE(0);
                }
                8388608 & r && (r >>= 8, i++), this.lt(0) && (r |= 8388608);
                const n1 = i << 24 | r;
                return e = t.alloc(4), e.writeInt32BE(n1, 0), e.readUInt32BE(0);
            }, n.prototype.fromScriptNumBuffer = function(t, e, r) {
                if (void 0 === r && (r = 4), t.length > r) throw new Error("script number overflow");
                if (e && t.length > 0 && 0 == (127 & t[t.length - 1]) && (t.length <= 1 || 0 == (128 & t[t.length - 2]))) throw new Error("non-minimally encoded script number");
                return this.fromSm(t, {
                    endian: "little"
                });
            }, n.prototype.toScriptNumBuffer = function() {
                return this.toSm({
                    endian: "little"
                });
            }, n.prototype.neg = function() {
                const t = i.prototype.neg.call(this), e = Object.create(n.prototype);
                return t.copy(e), e;
            }, n.prototype.add = function(t) {
                const e = i.prototype.add.call(this, t);
                return t = Object.create(n.prototype), e.copy(t), t;
            }, n.prototype.sub = function(t) {
                const e = i.prototype.sub.call(this, t);
                return t = Object.create(n.prototype), e.copy(t), t;
            }, n.prototype.mul = function(t) {
                const e = i.prototype.mul.call(this, t);
                return t = Object.create(n.prototype), e.copy(t), t;
            }, n.prototype.mod = function(t) {
                const e = i.prototype.mod.call(this, t);
                return t = Object.create(n.prototype), e.copy(t), t;
            }, n.prototype.umod = function(t) {
                const e = i.prototype.umod.call(this, t);
                return t = Object.create(n.prototype), e.copy(t), t;
            }, n.prototype.invm = function(t) {
                const e = i.prototype.invm.call(this, t);
                return t = Object.create(n.prototype), e.copy(t), t;
            }, n.prototype.div = function(t) {
                const e = i.prototype.div.call(this, t);
                return t = Object.create(n.prototype), e.copy(t), t;
            }, n.prototype.ushln = function(t) {
                const e = i.prototype.ushln.call(this, t), r = Object.create(n.prototype);
                return e.copy(r), r;
            }, n.prototype.ushrn = function(t) {
                const e = i.prototype.ushrn.call(this, t), r = Object.create(n.prototype);
                return e.copy(r), r;
            }, n.prototype.cmp = function(t) {
                return i.prototype.cmp.call(this, t);
            }, n.prototype.eq = function(t) {
                return 0 === this.cmp(t);
            }, n.prototype.neq = function(t) {
                return 0 !== this.cmp(t);
            }, n.prototype.gt = function(t) {
                return this.cmp(t) > 0;
            }, n.prototype.geq = function(t) {
                return this.cmp(t) >= 0;
            }, n.prototype.lt = function(t) {
                return this.cmp(t) < 0;
            }, n.prototype.leq = function(t) {
                return this.cmp(t) <= 0;
            }, a("add"), a("sub"), a("mul"), a("mod"), a("invm"), a("div"), a("cmp"), a("gt"), a("geq"), a("lt"), a("leq");
            const o = n;
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return s;
            });
            var i = r(45);
            let n;
            class s {
                constructor(t = [], e = 0, r = [], i = new Map){
                    this.nativeWorkers = t, this.lastid = e, this.incompconsteRes = r, this.promisemap = i;
                }
                asyncObjectMethod(t, e, r, n = this.lastid + 1) {
                    if (!r) throw new Error("must specify args");
                    const s = t[e](...r);
                    return (new i.a).fromResult(s, n);
                }
                static async asyncObjectMethod(t, e, r, i) {
                    return n || (n = new s), n.asyncObjectMethod(t, e, r, i);
                }
                asyncClassMethod(t, e, r, n = this.lastid + 1) {
                    if (!r) throw new Error("must specify args");
                    const s = t[e](...r);
                    return (new i.a).fromResult(s, n);
                }
                static async asyncClassMethod(t, e, r, i) {
                    return n || (n = new s), n.asyncClassMethod(t, e, r, i);
                }
                static endGlobalWorkers() {
                    n && !t.browser && (n = void 0);
                }
            }
        }).call(this, r(26));
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return s;
            });
            var i = r(32), n = r(2);
            class s {
                static sha1(e) {
                    if (!t.isBuffer(e)) throw new Error("sha1 hash must be of a buffer");
                    const r = Object(i.sha1)().update(e).digest();
                    return t.from(r);
                }
                static async asyncSha1(t) {
                    const e = [
                        t
                    ];
                    return (await n.a.asyncClassMethod(s, "sha1", e)).resbuf;
                }
                static sha256(e) {
                    if (!t.isBuffer(e)) throw new Error("sha256 hash must be of a buffer");
                    const r = Object(i.sha256)().update(e).digest();
                    return t.from(r);
                }
                static async asyncSha256(t) {
                    const e = [
                        t
                    ];
                    return (await n.a.asyncClassMethod(s, "sha256", e)).resbuf;
                }
                static sha256Sha256(t) {
                    try {
                        return s.sha256(s.sha256(t));
                    } catch (t1) {
                        throw new Error("sha256Sha256 hash must be of a buffer: " + t1);
                    }
                }
                static async asyncSha256Sha256(t) {
                    const e = [
                        t
                    ];
                    return (await n.a.asyncClassMethod(s, "sha256Sha256", e)).resbuf;
                }
                static ripemd160(e) {
                    if (!t.isBuffer(e)) throw new Error("ripemd160 hash must be of a buffer");
                    const r = Object(i.ripemd160)().update(e).digest();
                    return t.from(r);
                }
                static async asyncRipemd160(t) {
                    const e = [
                        t
                    ];
                    return (await n.a.asyncClassMethod(s, "ripemd160", e)).resbuf;
                }
                static sha256Ripemd160(t) {
                    try {
                        return s.ripemd160(s.sha256(t));
                    } catch (t1) {
                        throw new Error("sha256Ripemd160 hash must be of a buffer: " + t1);
                    }
                }
                static async asyncSha256Ripemd160(t) {
                    const e = [
                        t
                    ];
                    return (await n.a.asyncClassMethod(s, "sha256Ripemd160", e)).resbuf;
                }
                static sha512(e) {
                    if (!t.isBuffer(e)) throw new Error("sha512 hash must be of a buffer");
                    const r = Object(i.sha512)().update(e).digest();
                    return t.from(r);
                }
                static async asyncSha512(t) {
                    const e = [
                        t
                    ];
                    return (await n.a.asyncClassMethod(s, "sha512", e)).resbuf;
                }
                static hmac(e, r, i) {
                    if ("sha1" !== e && "sha256" !== e && "sha512" !== e) throw new Error("invalid choice of hash function");
                    const n = s[e];
                    if (!t.isBuffer(r) || !t.isBuffer(i)) throw new Error("data and key must be buffers");
                    const a = s.blockSize[e] / 8;
                    if (i.length > a && (i = n(i)), i.length < a) {
                        const e1 = t.alloc(a);
                        e1.fill(0, i.length), i.copy(e1), i = e1;
                    }
                    const o = t.alloc(a), h = t.alloc(a);
                    for(let t1 = 0; t1 < a; t1++)o[t1] = 92 ^ i[t1], h[t1] = 54 ^ i[t1];
                    return n(t.concat([
                        o,
                        n(t.concat([
                            h,
                            r
                        ]))
                    ]));
                }
                static sha1Hmac(t, e) {
                    return s.hmac("sha1", t, e);
                }
                static async asyncSha1Hmac(t, e) {
                    const r = [
                        t,
                        e
                    ];
                    return (await n.a.asyncClassMethod(s, "sha1Hmac", r)).resbuf;
                }
                static sha256Hmac(t, e) {
                    return s.hmac("sha256", t, e);
                }
                static async asyncSha256Hmac(t, e) {
                    const r = [
                        t,
                        e
                    ];
                    return (await n.a.asyncClassMethod(s, "sha256Hmac", r)).resbuf;
                }
                static sha512Hmac(t, e) {
                    return s.hmac("sha512", t, e);
                }
                static async asyncSha512Hmac(t, e) {
                    const r = [
                        t,
                        e
                    ];
                    return (await n.a.asyncClassMethod(s, "sha512Hmac", r)).resbuf;
                }
            }
            s.blockSize = {
                sha1: 512,
                sha256: 512,
                sha512: 1024
            }, s.bitsize = {
                sha1Hmac: 160,
                sha256Hmac: 256,
                sha512Hmac: 512
            };
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return a;
            });
            var i = r(49), n = r(12), s = r(6);
            class a {
                constructor(t){
                    this.fromObject(t);
                }
                fromObject(t) {
                    if (!t) return this;
                    for (const e of Object.keys(t))void 0 !== t[e] && (this[e] = t[e]);
                    return this;
                }
                static fromObject(t) {
                    return (new this).fromObject(t);
                }
                fromBr(t, ...e) {
                    if (!(t instanceof n.a)) throw new Error("br must be a buffer reader");
                    throw new Error("not implemented");
                }
                static fromBr(t) {
                    return (new this).fromBr(t);
                }
                asyncFromBr(t, ...e) {
                    if (!(t instanceof n.a)) throw new Error("br must be a buffer reader");
                    throw new Error("not implemented");
                }
                static asyncFromBr(t) {
                    return (new this).asyncFromBr(t);
                }
                toBw(t) {
                    throw new Error("not implemented");
                }
                asyncToBw(t) {
                    throw new Error("not implemented");
                }
                *genFromBuffers() {
                    throw new Error("not implemented");
                }
                *expect(t, e) {
                    let r = e;
                    const i = new s.a;
                    let n = 0;
                    for(e && (i.write(e), n += e.length); n < t;){
                        const e1 = t - n;
                        r = yield e1, r && (i.write(r), n += r.length);
                    }
                    r = i.toBuffer();
                    const a = n - t, o = r.slice(r.length - a, r.length);
                    return r = r.slice(0, r.length - a), {
                        buf: r,
                        remainderbuf: o
                    };
                }
                fromBuffer(e, ...r) {
                    if (!t.isBuffer(e)) throw new Error("buf must be a buffer");
                    const i = new n.a(e);
                    return this.fromBr(i, ...r);
                }
                static fromBuffer(t, ...e) {
                    return (new this).fromBuffer(t, ...e);
                }
                asyncFromBuffer(e, ...r) {
                    if (!t.isBuffer(e)) throw new Error("buf must be a buffer");
                    const i = new n.a(e);
                    return this.asyncFromBr(i, ...r);
                }
                static asyncFromBuffer(t, ...e) {
                    return (new this).asyncFromBuffer(t, ...e);
                }
                fromFastBuffer(t, ...e) {
                    return 0 === t.length ? this : this.fromBuffer(t, ...e);
                }
                static fromFastBuffer(t, ...e) {
                    return (new this).fromFastBuffer(t, ...e);
                }
                toBuffer() {
                    return this.toBw().toBuffer();
                }
                asyncToBuffer() {
                    return this.asyncToBw().then((t)=>t.toBuffer());
                }
                toFastBuffer() {
                    return 0 === Object.keys(this).length ? t.alloc(0) : this.toBuffer();
                }
                fromHex(e, ...r) {
                    if (!i(e)) throw new Error("invalid hex string");
                    const n = t.from(e, "hex");
                    return this.fromBuffer(n, ...r);
                }
                static fromHex(t, ...e) {
                    return (new this).fromHex(t, ...e);
                }
                asyncFromHex(e, ...r) {
                    if (!i(e)) throw new Error("invalid hex string");
                    const n = t.from(e, "hex");
                    return this.asyncFromBuffer(n, ...r);
                }
                static asyncFromHex(t, ...e) {
                    return (new this).asyncFromHex(t, ...e);
                }
                fromFastHex(e, ...r) {
                    if (!i(e)) throw new Error("invalid hex string");
                    const n = t.from(e, "hex");
                    return this.fromFastBuffer(n, ...r);
                }
                static fromFastHex(t, ...e) {
                    return (new this).fromFastHex(t, ...e);
                }
                toHex() {
                    return this.toBuffer().toString("hex");
                }
                asyncToHex() {
                    return this.asyncToBuffer().then((t)=>t.toString("hex"));
                }
                toFastHex() {
                    return this.toFastBuffer().toString("hex");
                }
                fromString(t, ...e) {
                    if ("string" != typeof t) throw new Error("str must be a string");
                    return this.fromHex(t, ...e);
                }
                static fromString(t, ...e) {
                    return (new this).fromString(t, ...e);
                }
                asyncFromString(t, ...e) {
                    if ("string" != typeof t) throw new Error("str must be a string");
                    return this.asyncFromHex(t, ...e);
                }
                static asyncFromString(t, ...e) {
                    return (new this).asyncFromString(t, ...e);
                }
                toString() {
                    return this.toHex();
                }
                asyncToString() {
                    return this.asyncToHex();
                }
                fromJSON(t) {
                    throw new Error("not implemented");
                }
                static fromJSON(t) {
                    return (new this).fromJSON(t);
                }
                asyncFromJSON(t, ...e) {
                    throw new Error("not implemented");
                }
                static asyncFromJSON(t, ...e) {
                    return (new this).asyncFromJSON(t, ...e);
                }
                toJSON() {
                    const e = {};
                    for(const r in this)if (Array.isArray(this[r])) {
                        const t1 = [];
                        for(const e1 in this[r])"function" == typeof this[r][e1].toJSON ? t1.push(this[r][e1].toJSON()) : t1.push(JSON.stringify(this[r][e1]));
                        e[r] = t1;
                    } else if (null === this[r]) e[r] = this[r];
                    else if ("object" == typeof this[r] && "function" == typeof this[r].toJSON) e[r] = this[r].toJSON();
                    else if ("boolean" == typeof this[r] || "number" == typeof this[r] || "string" == typeof this[r]) e[r] = this[r];
                    else if (t.isBuffer(this[r])) e[r] = this[r].toString("hex");
                    else if (this[r] instanceof Map) e[r] = JSON.stringify(this[r]);
                    else if ("object" == typeof this[r]) throw new Error("not implemented");
                    return e;
                }
                asyncToJSON() {
                    throw new Error("not implemented");
                }
                clone() {
                    return this.cloneByJSON();
                }
                cloneByBuffer() {
                    return (new this.constructor).fromBuffer(this.toBuffer());
                }
                cloneByFastBuffer() {
                    return (new this.constructor).fromFastBuffer(this.toFastBuffer());
                }
                cloneByHex() {
                    return (new this.constructor).fromHex(this.toHex());
                }
                cloneByString() {
                    return (new this.constructor).fromString(this.toString());
                }
                cloneByJSON() {
                    return (new this.constructor).fromJSON(this.toJSON());
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return s;
            });
            var i = r(1), n = r(4);
            class s extends n.a {
                constructor(t, e, r, i, n){
                    super({
                        r: t,
                        s: e,
                        nHashType: r,
                        recovery: i,
                        compressed: n
                    });
                }
                fromBuffer(t) {
                    try {
                        return this.fromDer(t, !0);
                    } catch (t1) {}
                    try {
                        return this.fromCompact(t);
                    } catch (t2) {}
                    return this.fromTxFormat(t);
                }
                toBuffer() {
                    return void 0 !== this.nHashType ? this.toTxFormat() : void 0 !== this.recovery ? this.toCompact() : this.toDer();
                }
                fromCompact(t) {
                    let e = !0, r = t.slice(0, 1)[0] - 27 - 4;
                    if (r < 0 && (e = !1, r += 4), 0 !== r && 1 !== r && 2 !== r && 3 !== r) throw new Error("i must be 0, 1, 2, or 3");
                    this.compressed = e, this.recovery = r;
                    const i = t.slice(1);
                    return this.fromRS(i), this;
                }
                static fromCompact(t) {
                    return (new this).fromCompact(t);
                }
                fromRS(t) {
                    const e = t.slice(0, 32), r = t.slice(32, 64);
                    if (32 !== e.length) throw new Error("r must be 32 bytes");
                    if (32 !== r.length || t.length > 64) throw new Error("s must be 32 bytes");
                    return this.r = (new i.a).fromBuffer(e), this.s = (new i.a).fromBuffer(r), this;
                }
                static fromRS(t) {
                    return (new this).fromRS(t);
                }
                fromDer(t, e) {
                    const r = s.parseDer(t, e);
                    return this.r = r.r, this.s = r.s, this;
                }
                static fromDer(t, e) {
                    return (new this).fromDer(t, e);
                }
                fromTxFormat(t) {
                    if (0 === t.length) return this.r = new i.a(1), this.s = new i.a(1), this.nHashType = 1, this;
                    const e = t.readUInt8(t.length - 1), r = t.slice(0, t.length - 1);
                    return this.fromDer(r, !1), this.nHashType = e, this;
                }
                static fromTxFormat(t) {
                    return (new this).fromTxFormat(t);
                }
                fromString(t) {
                    return this.fromHex(t);
                }
                static parseDer(e, r) {
                    if (void 0 === r && (r = !0), !t.isBuffer(e)) throw new Error("DER formatted signature should be a buffer");
                    const n = e[0];
                    if (48 !== n) throw new Error("Header byte should be 0x30");
                    let s = e[1];
                    const a = e.slice(2).length;
                    if (r && s !== a) throw new Error("LEngth byte should length of what follows");
                    s = s < a ? s : a;
                    const o = e[2];
                    if (2 !== o) throw new Error("Integer byte for r should be 0x02");
                    const h = e[3], c = e.slice(4, 4 + h), u = (new i.a).fromBuffer(c), f = 0 === e[4];
                    if (h !== c.length) throw new Error("LEngth of r incorrect");
                    const d = e[4 + h + 0];
                    if (2 !== d) throw new Error("Integer byte for s should be 0x02");
                    const l = e[4 + h + 1], p = e.slice(4 + h + 2, 4 + h + 2 + l), b = (new i.a).fromBuffer(p), m = 0 === e[4 + h + 2 + 2];
                    if (l !== p.length) throw new Error("LEngth of s incorrect");
                    if (s !== 4 + h + 2 + l - 2) throw new Error("LEngth of signature incorrect");
                    return {
                        header: n,
                        length: s,
                        rheader: o,
                        rlength: h,
                        rneg: f,
                        rbuf: c,
                        r: u,
                        sheader: d,
                        slength: l,
                        sneg: m,
                        sbuf: p,
                        s: b
                    };
                }
                static IsTxDer(t) {
                    if (t.length < 9) return !1;
                    if (t.length > 73) return !1;
                    if (48 !== t[0]) return !1;
                    if (t[1] !== t.length - 3) return !1;
                    const e = t[3];
                    if (5 + e >= t.length) return !1;
                    const r = t[5 + e];
                    if (e + r + 7 !== t.length) return !1;
                    const i = t.slice(4);
                    if (2 !== t[2]) return !1;
                    if (0 === e) return !1;
                    if (128 & i[0]) return !1;
                    if (e > 1 && 0 === i[0] && !(128 & i[1])) return !1;
                    const n = t.slice(6 + e);
                    return 2 === t[6 + e - 2] && 0 !== r && !(128 & n[0]) && !(r > 1 && 0 === n[0] && !(128 & n[1]));
                }
                hasLowS() {
                    return !this.s.lt(1) && !this.s.gt(i.a.fromBuffer(t.from("7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0", "hex")));
                }
                hasDefinedHashType() {
                    return !(this.nHashType < s.SIGHASH_ALL || this.nHashType > s.SIGHASH_SINGLE);
                }
                toCompact(e, r) {
                    if (e = "number" == typeof e ? e : this.recovery, r = "boolean" == typeof r ? r : this.compressed, 0 !== e && 1 !== e && 2 !== e && 3 !== e) throw new Error("recovery must be equal to 0, 1, 2, or 3");
                    let i = e + 27 + 4;
                    !1 === r && (i -= 4);
                    const n = t.from([
                        i
                    ]), s = this.r.toBuffer({
                        size: 32
                    }), a = this.s.toBuffer({
                        size: 32
                    });
                    return t.concat([
                        n,
                        s,
                        a
                    ]);
                }
                toRS() {
                    return t.concat([
                        this.r.toBuffer({
                            size: 32
                        }),
                        this.s.toBuffer({
                            size: 32
                        })
                    ]);
                }
                toDer() {
                    const e = this.r.toBuffer(), r = this.s.toBuffer(), i = 128 & e[0], n = 128 & r[0], s = i ? t.concat([
                        t.from([
                            0
                        ]),
                        e
                    ]) : e, a = n ? t.concat([
                        t.from([
                            0
                        ]),
                        r
                    ]) : r, o = 2 + s.length + 2 + a.length, h = s.length, c = a.length;
                    return t.concat([
                        t.from([
                            48,
                            o,
                            2,
                            h
                        ]),
                        s,
                        t.from([
                            2,
                            c
                        ]),
                        a
                    ]);
                }
                toTxFormat() {
                    const e = this.toDer(), r = t.alloc(1);
                    return r.writeUInt8(this.nHashType, 0), t.concat([
                        e,
                        r
                    ]);
                }
                toString() {
                    return this.toHex();
                }
            }
            s.SIGHASH_ALL = 1, s.SIGHASH_NONE = 2, s.SIGHASH_SINGLE = 3, s.SIGHASH_FORKID = 64, s.SIGHASH_ANYONECANPAY = 128;
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return i;
            });
            class i {
                constructor(t){
                    this.fromObject({
                        bufs: t
                    });
                }
                fromObject(t) {
                    return this.bufs = t.bufs || this.bufs || [], this;
                }
                getLength() {
                    let t = 0;
                    for(const e in this.bufs)t += this.bufs[e].length;
                    return t;
                }
                toBuffer() {
                    return t.concat(this.bufs);
                }
                write(t) {
                    return this.bufs.push(t), this;
                }
                writeReverse(e) {
                    const r = t.alloc(e.length);
                    for(let t1 = 0; t1 < r.length; t1++)r[t1] = e[e.length - 1 - t1];
                    return this.bufs.push(r), this;
                }
                writeUInt8(e) {
                    const r = t.alloc(1);
                    return r.writeUInt8(e, 0), this.write(r), this;
                }
                writeInt8(e) {
                    const r = t.alloc(1);
                    return r.writeInt8(e, 0), this.write(r), this;
                }
                writeUInt16BE(e) {
                    const r = t.alloc(2);
                    return r.writeUInt16BE(e, 0), this.write(r), this;
                }
                writeInt16BE(e) {
                    const r = t.alloc(2);
                    return r.writeInt16BE(e, 0), this.write(r), this;
                }
                writeUInt16LE(e) {
                    const r = t.alloc(2);
                    return r.writeUInt16LE(e, 0), this.write(r), this;
                }
                writeInt16LE(e) {
                    const r = t.alloc(2);
                    return r.writeInt16LE(e, 0), this.write(r), this;
                }
                writeUInt32BE(e) {
                    const r = t.alloc(4);
                    return r.writeUInt32BE(e, 0), this.write(r), this;
                }
                writeInt32BE(e) {
                    const r = t.alloc(4);
                    return r.writeInt32BE(e, 0), this.write(r), this;
                }
                writeUInt32LE(e) {
                    const r = t.alloc(4);
                    return r.writeUInt32LE(e, 0), this.write(r), this;
                }
                writeInt32LE(e) {
                    const r = t.alloc(4);
                    return r.writeInt32LE(e, 0), this.write(r), this;
                }
                writeUInt64BEBn(t) {
                    const e = t.toBuffer({
                        size: 8
                    });
                    return this.write(e), this;
                }
                writeUInt64LEBn(t) {
                    const e = t.toBuffer({
                        size: 8
                    });
                    return this.writeReverse(e), this;
                }
                writeVarIntNum(t) {
                    const e = i.varIntBufNum(t);
                    return this.write(e), this;
                }
                writeVarIntBn(t) {
                    const e = i.varIntBufBn(t);
                    return this.write(e), this;
                }
                static varIntBufNum(e) {
                    let r;
                    return e < 253 ? (r = t.alloc(1), r.writeUInt8(e, 0)) : e < 65536 ? (r = t.alloc(3), r.writeUInt8(253, 0), r.writeUInt16LE(e, 1)) : e < 4294967296 ? (r = t.alloc(5), r.writeUInt8(254, 0), r.writeUInt32LE(e, 1)) : (r = t.alloc(9), r.writeUInt8(255, 0), r.writeInt32LE(-1 & e, 1), r.writeUInt32LE(Math.floor(e / 4294967296), 5)), r;
                }
                static varIntBufBn(e) {
                    let r;
                    const n = e.toNumber();
                    if (n < 253) r = t.alloc(1), r.writeUInt8(n, 0);
                    else if (n < 65536) r = t.alloc(3), r.writeUInt8(253, 0), r.writeUInt16LE(n, 1);
                    else if (n < 4294967296) r = t.alloc(5), r.writeUInt8(254, 0), r.writeUInt32LE(n, 1);
                    else {
                        const t1 = new i;
                        t1.writeUInt8(255), t1.writeUInt64LEBn(e), r = t1.toBuffer();
                    }
                    return r;
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */ var i = r(88), n = r(89), s = r(90);
            function a() {
                return h.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
            }
            function o(t, e) {
                if (a() < e) throw new RangeError("Invalid typed array length");
                return h.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e)).__proto__ = h.prototype : (null === t && (t = new h(e)), t.length = e), t;
            }
            function h(t, e, r) {
                if (!(h.TYPED_ARRAY_SUPPORT || this instanceof h)) return new h(t, e, r);
                if ("number" == typeof t) {
                    if ("string" == typeof e) throw new Error("If encoding is specified then the first argument must be a string");
                    return f(this, t);
                }
                return c(this, t, e, r);
            }
            function c(t, e, r, i) {
                if ("number" == typeof e) throw new TypeError('"value" argument must not be a number');
                return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer ? function(t, e, r, i) {
                    if (e.byteLength, r < 0 || e.byteLength < r) throw new RangeError("'offset' is out of bounds");
                    if (e.byteLength < r + (i || 0)) throw new RangeError("'length' is out of bounds");
                    e = void 0 === r && void 0 === i ? new Uint8Array(e) : void 0 === i ? new Uint8Array(e, r) : new Uint8Array(e, r, i);
                    h.TYPED_ARRAY_SUPPORT ? (t = e).__proto__ = h.prototype : t = d(t, e);
                    return t;
                }(t, e, r, i) : "string" == typeof e ? function(t, e, r) {
                    "string" == typeof r && "" !== r || (r = "utf8");
                    if (!h.isEncoding(r)) throw new TypeError('"encoding" must be a valid string encoding');
                    var i = 0 | p(e, r), n = (t = o(t, i)).write(e, r);
                    n !== i && (t = t.slice(0, n));
                    return t;
                }(t, e, r) : function(t, e) {
                    if (h.isBuffer(e)) {
                        var r = 0 | l(e.length);
                        return 0 === (t = o(t, r)).length || e.copy(t, 0, 0, r), t;
                    }
                    if (e) {
                        if ("undefined" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || "length" in e) return "number" != typeof e.length || (i = e.length) != i ? o(t, 0) : d(t, e);
                        if ("Buffer" === e.type && s(e.data)) return d(t, e.data);
                    }
                    var i;
                    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
                }(t, e);
            }
            function u(t) {
                if ("number" != typeof t) throw new TypeError('"size" argument must be a number');
                if (t < 0) throw new RangeError('"size" argument must not be negative');
            }
            function f(t, e) {
                if (u(e), t = o(t, e < 0 ? 0 : 0 | l(e)), !h.TYPED_ARRAY_SUPPORT) for(var r = 0; r < e; ++r)t[r] = 0;
                return t;
            }
            function d(t, e) {
                var r = e.length < 0 ? 0 : 0 | l(e.length);
                t = o(t, r);
                for(var i = 0; i < r; i += 1)t[i] = 255 & e[i];
                return t;
            }
            function l(t) {
                if (t >= a()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a().toString(16) + " bytes");
                return 0 | t;
            }
            function p(t, e) {
                if (h.isBuffer(t)) return t.length;
                if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength;
                "string" != typeof t && (t = "" + t);
                var r = t.length;
                if (0 === r) return 0;
                for(var i = !1;;)switch(e){
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return r;
                    case "utf8":
                    case "utf-8":
                    case void 0:
                        return D(t).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return 2 * r;
                    case "hex":
                        return r >>> 1;
                    case "base64":
                        return K(t).length;
                    default:
                        if (i) return D(t).length;
                        e = ("" + e).toLowerCase(), i = !0;
                }
            }
            function b(t, e, r) {
                var i = !1;
                if ((void 0 === e || e < 0) && (e = 0), e > this.length) return "";
                if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return "";
                if ((r >>>= 0) <= (e >>>= 0)) return "";
                for(t || (t = "utf8");;)switch(t){
                    case "hex":
                        return k(this, e, r);
                    case "utf8":
                    case "utf-8":
                        return B(this, e, r);
                    case "ascii":
                        return P(this, e, r);
                    case "latin1":
                    case "binary":
                        return R(this, e, r);
                    case "base64":
                        return I(this, e, r);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return A(this, e, r);
                    default:
                        if (i) throw new TypeError("Unknown encoding: " + t);
                        t = (t + "").toLowerCase(), i = !0;
                }
            }
            function m(t, e, r) {
                var i = t[e];
                t[e] = t[r], t[r] = i;
            }
            function g(t, e, r, i, n) {
                if (0 === t.length) return -1;
                if ("string" == typeof r ? (i = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, isNaN(r) && (r = n ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
                    if (n) return -1;
                    r = t.length - 1;
                } else if (r < 0) {
                    if (!n) return -1;
                    r = 0;
                }
                if ("string" == typeof e && (e = h.from(e, i)), h.isBuffer(e)) return 0 === e.length ? -1 : y(t, e, r, i, n);
                if ("number" == typeof e) return e &= 255, h.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? n ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : y(t, [
                    e
                ], r, i, n);
                throw new TypeError("val must be string, number or Buffer");
            }
            function y(t, e, r, i, n) {
                var s, a = 1, o = t.length, h = e.length;
                if (void 0 !== i && ("ucs2" === (i = String(i).toLowerCase()) || "ucs-2" === i || "utf16le" === i || "utf-16le" === i)) {
                    if (t.length < 2 || e.length < 2) return -1;
                    a = 2, o /= 2, h /= 2, r /= 2;
                }
                function c(t, e) {
                    return 1 === a ? t[e] : t.readUInt16BE(e * a);
                }
                if (n) {
                    var u = -1;
                    for(s = r; s < o; s++)if (c(t, s) === c(e, -1 === u ? 0 : s - u)) {
                        if (-1 === u && (u = s), s - u + 1 === h) return u * a;
                    } else -1 !== u && (s -= s - u), u = -1;
                } else for(r + h > o && (r = o - h), s = r; s >= 0; s--){
                    for(var f = !0, d = 0; d < h; d++)if (c(t, s + d) !== c(e, d)) {
                        f = !1;
                        break;
                    }
                    if (f) return s;
                }
                return -1;
            }
            function w(t, e, r, i) {
                r = Number(r) || 0;
                var n = t.length - r;
                i ? (i = Number(i)) > n && (i = n) : i = n;
                var s = e.length;
                if (s % 2 != 0) throw new TypeError("Invalid hex string");
                i > s / 2 && (i = s / 2);
                for(var a = 0; a < i; ++a){
                    var o = parseInt(e.substr(2 * a, 2), 16);
                    if (isNaN(o)) return a;
                    t[r + a] = o;
                }
                return a;
            }
            function _(t, e, r, i) {
                return V(D(e, t.length - r), t, r, i);
            }
            function v(t, e, r, i) {
                return V(function(t) {
                    for(var e = [], r = 0; r < t.length; ++r)e.push(255 & t.charCodeAt(r));
                    return e;
                }(e), t, r, i);
            }
            function S(t, e, r, i) {
                return v(t, e, r, i);
            }
            function O(t, e, r, i) {
                return V(K(e), t, r, i);
            }
            function E(t, e, r, i) {
                return V(function(t, e) {
                    for(var r, i, n, s = [], a = 0; a < t.length && !((e -= 2) < 0); ++a)r = t.charCodeAt(a), i = r >> 8, n = r % 256, s.push(n), s.push(i);
                    return s;
                }(e, t.length - r), t, r, i);
            }
            function I(t, e, r) {
                return 0 === e && r === t.length ? i.fromByteArray(t) : i.fromByteArray(t.slice(e, r));
            }
            function B(t, e, r) {
                r = Math.min(t.length, r);
                for(var i = [], n = e; n < r;){
                    var s, a, o, h, c = t[n], u = null, f = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
                    if (n + f <= r) switch(f){
                        case 1:
                            c < 128 && (u = c);
                            break;
                        case 2:
                            128 == (192 & (s = t[n + 1])) && (h = (31 & c) << 6 | 63 & s) > 127 && (u = h);
                            break;
                        case 3:
                            s = t[n + 1], a = t[n + 2], 128 == (192 & s) && 128 == (192 & a) && (h = (15 & c) << 12 | (63 & s) << 6 | 63 & a) > 2047 && (h < 55296 || h > 57343) && (u = h);
                            break;
                        case 4:
                            s = t[n + 1], a = t[n + 2], o = t[n + 3], 128 == (192 & s) && 128 == (192 & a) && 128 == (192 & o) && (h = (15 & c) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) > 65535 && h < 1114112 && (u = h);
                    }
                    null === u ? (u = 65533, f = 1) : u > 65535 && (u -= 65536, i.push(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), i.push(u), n += f;
                }
                return function(t) {
                    var e = t.length;
                    if (e <= 4096) return String.fromCharCode.apply(String, t);
                    var r = "", i = 0;
                    for(; i < e;)r += String.fromCharCode.apply(String, t.slice(i, i += 4096));
                    return r;
                }(i);
            }
            e.Buffer = h, e.SlowBuffer = function(t) {
                +t != t && (t = 0);
                return h.alloc(+t);
            }, e.INSPECT_MAX_BYTES = 50, h.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : function() {
                try {
                    var t = new Uint8Array(1);
                    return t.__proto__ = {
                        __proto__: Uint8Array.prototype,
                        foo: function() {
                            return 42;
                        }
                    }, 42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength;
                } catch (t1) {
                    return !1;
                }
            }(), e.kMaxLength = a(), h.poolSize = 8192, h._augment = function(t) {
                return t.__proto__ = h.prototype, t;
            }, h.from = function(t, e, r) {
                return c(null, t, e, r);
            }, h.TYPED_ARRAY_SUPPORT && (h.prototype.__proto__ = Uint8Array.prototype, h.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && h[Symbol.species] === h && Object.defineProperty(h, Symbol.species, {
                value: null,
                configurable: !0
            })), h.alloc = function(t, e, r) {
                return function(t, e, r, i) {
                    return u(e), e <= 0 ? o(t, e) : void 0 !== r ? "string" == typeof i ? o(t, e).fill(r, i) : o(t, e).fill(r) : o(t, e);
                }(null, t, e, r);
            }, h.allocUnsafe = function(t) {
                return f(null, t);
            }, h.allocUnsafeSlow = function(t) {
                return f(null, t);
            }, h.isBuffer = function(t) {
                return !(null == t || !t._isBuffer);
            }, h.compare = function(t, e) {
                if (!h.isBuffer(t) || !h.isBuffer(e)) throw new TypeError("Arguments must be Buffers");
                if (t === e) return 0;
                for(var r = t.length, i = e.length, n = 0, s = Math.min(r, i); n < s; ++n)if (t[n] !== e[n]) {
                    r = t[n], i = e[n];
                    break;
                }
                return r < i ? -1 : i < r ? 1 : 0;
            }, h.isEncoding = function(t) {
                switch(String(t).toLowerCase()){
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return !0;
                    default:
                        return !1;
                }
            }, h.concat = function(t, e) {
                if (!s(t)) throw new TypeError('"list" argument must be an Array of Buffers');
                if (0 === t.length) return h.alloc(0);
                var r;
                if (void 0 === e) for(e = 0, r = 0; r < t.length; ++r)e += t[r].length;
                var i = h.allocUnsafe(e), n = 0;
                for(r = 0; r < t.length; ++r){
                    var a = t[r];
                    if (!h.isBuffer(a)) throw new TypeError('"list" argument must be an Array of Buffers');
                    a.copy(i, n), n += a.length;
                }
                return i;
            }, h.byteLength = p, h.prototype._isBuffer = !0, h.prototype.swap16 = function() {
                var t = this.length;
                if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                for(var e = 0; e < t; e += 2)m(this, e, e + 1);
                return this;
            }, h.prototype.swap32 = function() {
                var t = this.length;
                if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                for(var e = 0; e < t; e += 4)m(this, e, e + 3), m(this, e + 1, e + 2);
                return this;
            }, h.prototype.swap64 = function() {
                var t = this.length;
                if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                for(var e = 0; e < t; e += 8)m(this, e, e + 7), m(this, e + 1, e + 6), m(this, e + 2, e + 5), m(this, e + 3, e + 4);
                return this;
            }, h.prototype.toString = function() {
                var t = 0 | this.length;
                return 0 === t ? "" : 0 === arguments.length ? B(this, 0, t) : b.apply(this, arguments);
            }, h.prototype.equals = function(t) {
                if (!h.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
                return this === t || 0 === h.compare(this, t);
            }, h.prototype.inspect = function() {
                var t = "", r = e.INSPECT_MAX_BYTES;
                return this.length > 0 && (t = this.toString("hex", 0, r).match(/.{2}/g).join(" "), this.length > r && (t += " ... ")), "<Buffer " + t + ">";
            }, h.prototype.compare = function(t, e, r, i, n) {
                if (!h.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
                if (void 0 === e && (e = 0), void 0 === r && (r = t ? t.length : 0), void 0 === i && (i = 0), void 0 === n && (n = this.length), e < 0 || r > t.length || i < 0 || n > this.length) throw new RangeError("out of range index");
                if (i >= n && e >= r) return 0;
                if (i >= n) return -1;
                if (e >= r) return 1;
                if (this === t) return 0;
                for(var s = (n >>>= 0) - (i >>>= 0), a = (r >>>= 0) - (e >>>= 0), o = Math.min(s, a), c = this.slice(i, n), u = t.slice(e, r), f = 0; f < o; ++f)if (c[f] !== u[f]) {
                    s = c[f], a = u[f];
                    break;
                }
                return s < a ? -1 : a < s ? 1 : 0;
            }, h.prototype.includes = function(t, e, r) {
                return -1 !== this.indexOf(t, e, r);
            }, h.prototype.indexOf = function(t, e, r) {
                return g(this, t, e, r, !0);
            }, h.prototype.lastIndexOf = function(t, e, r) {
                return g(this, t, e, r, !1);
            }, h.prototype.write = function(t, e, r, i) {
                if (void 0 === e) i = "utf8", r = this.length, e = 0;
                else if (void 0 === r && "string" == typeof e) i = e, r = this.length, e = 0;
                else {
                    if (!isFinite(e)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    e |= 0, isFinite(r) ? (r |= 0, void 0 === i && (i = "utf8")) : (i = r, r = void 0);
                }
                var n = this.length - e;
                if ((void 0 === r || r > n) && (r = n), t.length > 0 && (r < 0 || e < 0) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                i || (i = "utf8");
                for(var s = !1;;)switch(i){
                    case "hex":
                        return w(this, t, e, r);
                    case "utf8":
                    case "utf-8":
                        return _(this, t, e, r);
                    case "ascii":
                        return v(this, t, e, r);
                    case "latin1":
                    case "binary":
                        return S(this, t, e, r);
                    case "base64":
                        return O(this, t, e, r);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return E(this, t, e, r);
                    default:
                        if (s) throw new TypeError("Unknown encoding: " + i);
                        i = ("" + i).toLowerCase(), s = !0;
                }
            }, h.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };
            function P(t, e, r) {
                var i = "";
                r = Math.min(t.length, r);
                for(var n = e; n < r; ++n)i += String.fromCharCode(127 & t[n]);
                return i;
            }
            function R(t, e, r) {
                var i = "";
                r = Math.min(t.length, r);
                for(var n = e; n < r; ++n)i += String.fromCharCode(t[n]);
                return i;
            }
            function k(t, e, r) {
                var i = t.length;
                (!e || e < 0) && (e = 0), (!r || r < 0 || r > i) && (r = i);
                for(var n = "", s = e; s < r; ++s)n += F(t[s]);
                return n;
            }
            function A(t, e, r) {
                for(var i = t.slice(e, r), n = "", s = 0; s < i.length; s += 2)n += String.fromCharCode(i[s] + 256 * i[s + 1]);
                return n;
            }
            function N(t, e, r) {
                if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
                if (t + e > r) throw new RangeError("Trying to access beyond buffer length");
            }
            function x(t, e, r, i, n, s) {
                if (!h.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (e > n || e < s) throw new RangeError('"value" argument is out of bounds');
                if (r + i > t.length) throw new RangeError("Index out of range");
            }
            function M(t, e, r, i) {
                e < 0 && (e = 65535 + e + 1);
                for(var n = 0, s = Math.min(t.length - r, 2); n < s; ++n)t[r + n] = (e & 255 << 8 * (i ? n : 1 - n)) >>> 8 * (i ? n : 1 - n);
            }
            function T(t, e, r, i) {
                e < 0 && (e = 4294967295 + e + 1);
                for(var n = 0, s = Math.min(t.length - r, 4); n < s; ++n)t[r + n] = e >>> 8 * (i ? n : 3 - n) & 255;
            }
            function C(t, e, r, i, n, s) {
                if (r + i > t.length) throw new RangeError("Index out of range");
                if (r < 0) throw new RangeError("Index out of range");
            }
            function L(t, e, r, i, s) {
                return s || C(t, 0, r, 4), n.write(t, e, r, i, 23, 4), r + 4;
            }
            function H(t, e, r, i, s) {
                return s || C(t, 0, r, 8), n.write(t, e, r, i, 52, 8), r + 8;
            }
            h.prototype.slice = function(t, e) {
                var r, i = this.length;
                if ((t = ~~t) < 0 ? (t += i) < 0 && (t = 0) : t > i && (t = i), (e = void 0 === e ? i : ~~e) < 0 ? (e += i) < 0 && (e = 0) : e > i && (e = i), e < t && (e = t), h.TYPED_ARRAY_SUPPORT) (r = this.subarray(t, e)).__proto__ = h.prototype;
                else {
                    var n = e - t;
                    r = new h(n, void 0);
                    for(var s = 0; s < n; ++s)r[s] = this[s + t];
                }
                return r;
            }, h.prototype.readUIntLE = function(t, e, r) {
                t |= 0, e |= 0, r || N(t, e, this.length);
                for(var i = this[t], n = 1, s = 0; ++s < e && (n *= 256);)i += this[t + s] * n;
                return i;
            }, h.prototype.readUIntBE = function(t, e, r) {
                t |= 0, e |= 0, r || N(t, e, this.length);
                for(var i = this[t + --e], n = 1; e > 0 && (n *= 256);)i += this[t + --e] * n;
                return i;
            }, h.prototype.readUInt8 = function(t, e) {
                return e || N(t, 1, this.length), this[t];
            }, h.prototype.readUInt16LE = function(t, e) {
                return e || N(t, 2, this.length), this[t] | this[t + 1] << 8;
            }, h.prototype.readUInt16BE = function(t, e) {
                return e || N(t, 2, this.length), this[t] << 8 | this[t + 1];
            }, h.prototype.readUInt32LE = function(t, e) {
                return e || N(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3];
            }, h.prototype.readUInt32BE = function(t, e) {
                return e || N(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
            }, h.prototype.readIntLE = function(t, e, r) {
                t |= 0, e |= 0, r || N(t, e, this.length);
                for(var i = this[t], n = 1, s = 0; ++s < e && (n *= 256);)i += this[t + s] * n;
                return i >= (n *= 128) && (i -= Math.pow(2, 8 * e)), i;
            }, h.prototype.readIntBE = function(t, e, r) {
                t |= 0, e |= 0, r || N(t, e, this.length);
                for(var i = e, n = 1, s = this[t + --i]; i > 0 && (n *= 256);)s += this[t + --i] * n;
                return s >= (n *= 128) && (s -= Math.pow(2, 8 * e)), s;
            }, h.prototype.readInt8 = function(t, e) {
                return e || N(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t];
            }, h.prototype.readInt16LE = function(t, e) {
                e || N(t, 2, this.length);
                var r = this[t] | this[t + 1] << 8;
                return 32768 & r ? 4294901760 | r : r;
            }, h.prototype.readInt16BE = function(t, e) {
                e || N(t, 2, this.length);
                var r = this[t + 1] | this[t] << 8;
                return 32768 & r ? 4294901760 | r : r;
            }, h.prototype.readInt32LE = function(t, e) {
                return e || N(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
            }, h.prototype.readInt32BE = function(t, e) {
                return e || N(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
            }, h.prototype.readFloatLE = function(t, e) {
                return e || N(t, 4, this.length), n.read(this, t, !0, 23, 4);
            }, h.prototype.readFloatBE = function(t, e) {
                return e || N(t, 4, this.length), n.read(this, t, !1, 23, 4);
            }, h.prototype.readDoubleLE = function(t, e) {
                return e || N(t, 8, this.length), n.read(this, t, !0, 52, 8);
            }, h.prototype.readDoubleBE = function(t, e) {
                return e || N(t, 8, this.length), n.read(this, t, !1, 52, 8);
            }, h.prototype.writeUIntLE = function(t, e, r, i) {
                (t = +t, e |= 0, r |= 0, i) || x(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
                var n = 1, s = 0;
                for(this[e] = 255 & t; ++s < r && (n *= 256);)this[e + s] = t / n & 255;
                return e + r;
            }, h.prototype.writeUIntBE = function(t, e, r, i) {
                (t = +t, e |= 0, r |= 0, i) || x(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
                var n = r - 1, s = 1;
                for(this[e + n] = 255 & t; --n >= 0 && (s *= 256);)this[e + n] = t / s & 255;
                return e + r;
            }, h.prototype.writeUInt8 = function(t, e, r) {
                return t = +t, e |= 0, r || x(this, t, e, 1, 255, 0), h.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e] = 255 & t, e + 1;
            }, h.prototype.writeUInt16LE = function(t, e, r) {
                return t = +t, e |= 0, r || x(this, t, e, 2, 65535, 0), h.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : M(this, t, e, !0), e + 2;
            }, h.prototype.writeUInt16BE = function(t, e, r) {
                return t = +t, e |= 0, r || x(this, t, e, 2, 65535, 0), h.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : M(this, t, e, !1), e + 2;
            }, h.prototype.writeUInt32LE = function(t, e, r) {
                return t = +t, e |= 0, r || x(this, t, e, 4, 4294967295, 0), h.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t) : T(this, t, e, !0), e + 4;
            }, h.prototype.writeUInt32BE = function(t, e, r) {
                return t = +t, e |= 0, r || x(this, t, e, 4, 4294967295, 0), h.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : T(this, t, e, !1), e + 4;
            }, h.prototype.writeIntLE = function(t, e, r, i) {
                if (t = +t, e |= 0, !i) {
                    var n = Math.pow(2, 8 * r - 1);
                    x(this, t, e, r, n - 1, -n);
                }
                var s = 0, a = 1, o = 0;
                for(this[e] = 255 & t; ++s < r && (a *= 256);)t < 0 && 0 === o && 0 !== this[e + s - 1] && (o = 1), this[e + s] = (t / a >> 0) - o & 255;
                return e + r;
            }, h.prototype.writeIntBE = function(t, e, r, i) {
                if (t = +t, e |= 0, !i) {
                    var n = Math.pow(2, 8 * r - 1);
                    x(this, t, e, r, n - 1, -n);
                }
                var s = r - 1, a = 1, o = 0;
                for(this[e + s] = 255 & t; --s >= 0 && (a *= 256);)t < 0 && 0 === o && 0 !== this[e + s + 1] && (o = 1), this[e + s] = (t / a >> 0) - o & 255;
                return e + r;
            }, h.prototype.writeInt8 = function(t, e, r) {
                return t = +t, e |= 0, r || x(this, t, e, 1, 127, -128), h.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1;
            }, h.prototype.writeInt16LE = function(t, e, r) {
                return t = +t, e |= 0, r || x(this, t, e, 2, 32767, -32768), h.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : M(this, t, e, !0), e + 2;
            }, h.prototype.writeInt16BE = function(t, e, r) {
                return t = +t, e |= 0, r || x(this, t, e, 2, 32767, -32768), h.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : M(this, t, e, !1), e + 2;
            }, h.prototype.writeInt32LE = function(t, e, r) {
                return t = +t, e |= 0, r || x(this, t, e, 4, 2147483647, -2147483648), h.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24) : T(this, t, e, !0), e + 4;
            }, h.prototype.writeInt32BE = function(t, e, r) {
                return t = +t, e |= 0, r || x(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), h.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : T(this, t, e, !1), e + 4;
            }, h.prototype.writeFloatLE = function(t, e, r) {
                return L(this, t, e, !0, r);
            }, h.prototype.writeFloatBE = function(t, e, r) {
                return L(this, t, e, !1, r);
            }, h.prototype.writeDoubleLE = function(t, e, r) {
                return H(this, t, e, !0, r);
            }, h.prototype.writeDoubleBE = function(t, e, r) {
                return H(this, t, e, !1, r);
            }, h.prototype.copy = function(t, e, r, i) {
                if (r || (r = 0), i || 0 === i || (i = this.length), e >= t.length && (e = t.length), e || (e = 0), i > 0 && i < r && (i = r), i === r) return 0;
                if (0 === t.length || 0 === this.length) return 0;
                if (e < 0) throw new RangeError("targetStart out of bounds");
                if (r < 0 || r >= this.length) throw new RangeError("sourceStart out of bounds");
                if (i < 0) throw new RangeError("sourceEnd out of bounds");
                i > this.length && (i = this.length), t.length - e < i - r && (i = t.length - e + r);
                var n, s = i - r;
                if (this === t && r < e && e < i) for(n = s - 1; n >= 0; --n)t[n + e] = this[n + r];
                else if (s < 1e3 || !h.TYPED_ARRAY_SUPPORT) for(n = 0; n < s; ++n)t[n + e] = this[n + r];
                else Uint8Array.prototype.set.call(t, this.subarray(r, r + s), e);
                return s;
            }, h.prototype.fill = function(t, e, r, i) {
                if ("string" == typeof t) {
                    if ("string" == typeof e ? (i = e, e = 0, r = this.length) : "string" == typeof r && (i = r, r = this.length), 1 === t.length) {
                        var n = t.charCodeAt(0);
                        n < 256 && (t = n);
                    }
                    if (void 0 !== i && "string" != typeof i) throw new TypeError("encoding must be a string");
                    if ("string" == typeof i && !h.isEncoding(i)) throw new TypeError("Unknown encoding: " + i);
                } else "number" == typeof t && (t &= 255);
                if (e < 0 || this.length < e || this.length < r) throw new RangeError("Out of range index");
                if (r <= e) return this;
                var s;
                if (e >>>= 0, r = void 0 === r ? this.length : r >>> 0, t || (t = 0), "number" == typeof t) for(s = e; s < r; ++s)this[s] = t;
                else {
                    var a = h.isBuffer(t) ? t : D(new h(t, i).toString()), o = a.length;
                    for(s = 0; s < r - e; ++s)this[s + e] = a[s % o];
                }
                return this;
            };
            var U = /[^+\/0-9A-Za-z-_]/g;
            function F(t) {
                return t < 16 ? "0" + t.toString(16) : t.toString(16);
            }
            function D(t, e) {
                var r;
                e = e || 1 / 0;
                for(var i = t.length, n = null, s = [], a = 0; a < i; ++a){
                    if ((r = t.charCodeAt(a)) > 55295 && r < 57344) {
                        if (!n) {
                            if (r > 56319) {
                                (e -= 3) > -1 && s.push(239, 191, 189);
                                continue;
                            }
                            if (a + 1 === i) {
                                (e -= 3) > -1 && s.push(239, 191, 189);
                                continue;
                            }
                            n = r;
                            continue;
                        }
                        if (r < 56320) {
                            (e -= 3) > -1 && s.push(239, 191, 189), n = r;
                            continue;
                        }
                        r = 65536 + (n - 55296 << 10 | r - 56320);
                    } else n && (e -= 3) > -1 && s.push(239, 191, 189);
                    if (n = null, r < 128) {
                        if ((e -= 1) < 0) break;
                        s.push(r);
                    } else if (r < 2048) {
                        if ((e -= 2) < 0) break;
                        s.push(r >> 6 | 192, 63 & r | 128);
                    } else if (r < 65536) {
                        if ((e -= 3) < 0) break;
                        s.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128);
                    } else {
                        if (!(r < 1114112)) throw new Error("Invalid code point");
                        if ((e -= 4) < 0) break;
                        s.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128);
                    }
                }
                return s;
            }
            function K(t) {
                return i.toByteArray(function(t) {
                    if ((t = (function(t) {
                        return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
                    })(t).replace(U, "")).length < 2) return "";
                    for(; t.length % 4 != 0;)t += "=";
                    return t;
                }(t));
            }
            function V(t, e, r, i) {
                for(var n = 0; n < i && !(n + r >= e.length || n >= t.length); ++n)e[n + r] = t[n];
                return n;
            }
        }).call(this, r(33));
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return h;
            });
            var i = r(1), n = r(6), s = r(11), a = r(4), o = r(2);
            class h extends a.a {
                constructor(t, e){
                    super({
                        point: t,
                        compressed: e
                    });
                }
                fromJSON(t) {
                    return this.fromFastHex(t), this;
                }
                toJSON() {
                    return this.toFastHex();
                }
                fromPrivKey(t) {
                    return this.fromObject({
                        point: s.a.getG().mul(t.bn),
                        compressed: t.compressed
                    }), this;
                }
                static fromPrivKey(t) {
                    return (new this).fromPrivKey(t);
                }
                async asyncFromPrivKey(t) {
                    const e = await o.a.asyncObjectMethod(this, "fromPrivKey", [
                        t
                    ]);
                    return this.fromFastBuffer(e.resbuf);
                }
                static asyncFromPrivKey(t) {
                    return (new this).asyncFromPrivKey(t);
                }
                fromBuffer(t, e) {
                    return this.fromDer(t, e);
                }
                async asyncFromBuffer(t, e) {
                    const r = [
                        t,
                        e
                    ], i = await o.a.asyncObjectMethod(this, "fromBuffer", r);
                    return this.fromFastBuffer(i.resbuf);
                }
                fromFastBuffer(t) {
                    if (0 === t.length) return this;
                    const e = Boolean(t[0]);
                    return t = t.slice(1), this.fromDer(t), this.compressed = e, this;
                }
                fromDer(t, e) {
                    if (e = void 0 === e, 4 !== t[0] && (e || 6 !== t[0] && 7 !== t[0])) {
                        if (3 === t[0]) {
                            const e1 = t.slice(1), r = new i.a(e1);
                            this.fromX(!0, r), this.compressed = !0;
                        } else {
                            if (2 !== t[0]) throw new Error("Invalid DER format pubKey");
                            {
                                const e2 = t.slice(1), r1 = new i.a(e2);
                                this.fromX(!1, r1), this.compressed = !0;
                            }
                        }
                    } else {
                        const e3 = t.slice(1, 33), r2 = t.slice(33, 65);
                        if (32 !== e3.length || 32 !== r2.length || 65 !== t.length) throw new Error("LEngth of x and y must be 32 bytes");
                        const n = new i.a(e3), a = new i.a(r2);
                        this.point = new s.a(n, a), this.compressed = !1;
                    }
                    return this;
                }
                static fromDer(t, e) {
                    return (new this).fromDer(t, e);
                }
                fromString(e) {
                    return this.fromDer(t.from(e, "hex")), this;
                }
                fromX(t, e) {
                    if ("boolean" != typeof t) throw new Error("Must specify whether x is odd or not (true or false)");
                    return this.point = s.a.fromX(t, e), this;
                }
                static fromX(t, e) {
                    return (new this).fromX(t, e);
                }
                toBuffer() {
                    const t = void 0 === this.compressed || this.compressed;
                    return this.toDer(t);
                }
                toFastBuffer() {
                    if (!this.point) return t.alloc(0);
                    const e = new n.a, r = void 0 === this.compressed || Boolean(this.compressed);
                    return e.writeUInt8(Number(r)), e.write(this.toDer(!1)), e.toBuffer();
                }
                toDer(e) {
                    if ("boolean" != typeof (e = void 0 === e ? this.compressed : e)) throw new Error("Must specify whether the public key is compressed or not (true or false)");
                    const r = this.point.getX(), i = this.point.getY(), n = r.toBuffer({
                        size: 32
                    }), s = i.toBuffer({
                        size: 32
                    });
                    let a;
                    if (e) return a = s[s.length - 1] % 2 ? t.from([
                        3
                    ]) : t.from([
                        2
                    ]), t.concat([
                        a,
                        n
                    ]);
                    return a = t.from([
                        4
                    ]), t.concat([
                        a,
                        n,
                        s
                    ]);
                }
                toString() {
                    const t = void 0 === this.compressed || this.compressed;
                    return this.toDer(t).toString("hex");
                }
                static isCompressedOrUncompressed(t) {
                    if (t.length < 33) return !1;
                    if (4 === t[0]) {
                        if (65 !== t.length) return !1;
                    } else {
                        if (2 !== t[0] && 3 !== t[0]) return !1;
                        if (33 !== t.length) return !1;
                    }
                    return !0;
                }
                validate() {
                    if (this.point.isInfinity()) throw new Error("point: Point cannot be equal to Infinity");
                    if (this.point.eq(new s.a(new i.a(0), new i.a(0)))) throw new Error("point: Point cannot be equal to 0, 0");
                    return this.point.validate(), this;
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return f;
            });
            var i = r(1), n = r(12), s = r(6), a = r(18), o = r(0), h = r(8), c = r(5), u = r(4);
            class f extends u.a {
                constructor(t = []){
                    super({
                        chunks: t
                    });
                }
                fromJSON(t) {
                    return this.fromString(t);
                }
                toJSON() {
                    return this.toString();
                }
                fromBuffer(e) {
                    this.chunks = [];
                    const r = new n.a(e);
                    for(; !r.eof();){
                        const e1 = r.readUInt8();
                        let i = 0, n1 = t.from([]);
                        if (e1 > 0 && e1 < o.a.OP_PUSHDATA1) i = e1, this.chunks.push({
                            buf: r.read(i),
                            len: i,
                            opCodeNum: e1
                        });
                        else if (e1 === o.a.OP_PUSHDATA1) {
                            try {
                                i = r.readUInt8(), n1 = r.read(i);
                            } catch (t1) {
                                r.read();
                            }
                            this.chunks.push({
                                buf: n1,
                                len: i,
                                opCodeNum: e1
                            });
                        } else if (e1 === o.a.OP_PUSHDATA2) {
                            try {
                                i = r.readUInt16LE(), n1 = r.read(i);
                            } catch (t2) {
                                r.read();
                            }
                            this.chunks.push({
                                buf: n1,
                                len: i,
                                opCodeNum: e1
                            });
                        } else if (e1 === o.a.OP_PUSHDATA4) {
                            try {
                                i = r.readUInt32LE(), n1 = r.read(i);
                            } catch (t3) {
                                r.read();
                            }
                            this.chunks.push({
                                buf: n1,
                                len: i,
                                opCodeNum: e1
                            });
                        } else this.chunks.push({
                            opCodeNum: e1
                        });
                    }
                    return this;
                }
                toBuffer() {
                    const t = new s.a;
                    for(let e = 0; e < this.chunks.length; e++){
                        const r = this.chunks[e], i = r.opCodeNum;
                        t.writeUInt8(i), r.buf && (i < o.a.OP_PUSHDATA1 ? t.write(r.buf) : i === o.a.OP_PUSHDATA1 ? (t.writeUInt8(r.len), t.write(r.buf)) : i === o.a.OP_PUSHDATA2 ? (t.writeUInt16LE(r.len), t.write(r.buf)) : i === o.a.OP_PUSHDATA4 && (t.writeUInt32LE(r.len), t.write(r.buf)));
                    }
                    return t.toBuffer();
                }
                fromString(e) {
                    if (this.chunks = [], "" === e || void 0 === e) return this;
                    const r = e.split(" ");
                    let i = 0;
                    for(; i < r.length;){
                        const e1 = r[i];
                        let n;
                        try {
                            n = (new o.a).fromString(e1).toNumber();
                        } catch (t1) {}
                        if (void 0 === n) {
                            if (n = parseInt(e1, 10), n > 0 && n < o.a.OP_PUSHDATA1) this.chunks.push({
                                buf: t.from(r[i + 1].slice(2), "hex"),
                                len: n,
                                opCodeNum: n
                            }), i += 2;
                            else {
                                if (0 !== n) throw new Error("Invalid script");
                                this.chunks.push({
                                    opCodeNum: 0
                                }), i += 1;
                            }
                        } else if (n === o.a.OP_PUSHDATA1 || n === o.a.OP_PUSHDATA2 || n === o.a.OP_PUSHDATA4) {
                            if ("0x" !== r[i + 2].slice(0, 2)) throw new Error("Pushdata data must start with 0x");
                            this.chunks.push({
                                buf: t.from(r[i + 2].slice(2), "hex"),
                                len: parseInt(r[i + 1], 10),
                                opCodeNum: n
                            }), i += 3;
                        } else this.chunks.push({
                            opCodeNum: n
                        }), i += 1;
                    }
                    return this;
                }
                toString() {
                    let t = "";
                    for(let e = 0; e < this.chunks.length; e++){
                        const r = this.chunks[e], i = r.opCodeNum;
                        r.buf ? (i !== o.a.OP_PUSHDATA1 && i !== o.a.OP_PUSHDATA2 && i !== o.a.OP_PUSHDATA4 || (t = t + " " + new o.a(i).toString()), t = t + " " + r.len, t = t + " 0x" + r.buf.toString("hex")) : t = void 0 !== o.a.str[i] ? t + " " + new o.a(i).toString() : t + " 0x" + i.toString(16);
                    }
                    return t.substr(1);
                }
                fromBitcoindString(e) {
                    const r = new s.a, n = e.split(" ");
                    let a;
                    for(a = 0; a < n.length; a++){
                        const e1 = n[a];
                        if ("" !== e1) {
                            if ("0" === e1[0] && "x" === e1[1]) {
                                const i1 = e1.slice(2);
                                r.write(t.from(i1, "hex"));
                            } else if ("'" === e1[0]) {
                                const i2 = e1.slice(1, e1.length - 1), n1 = t.from(i2), s1 = (new f).writeBuffer(n1).toBuffer();
                                r.write(s1);
                            } else if (void 0 !== o.a["OP_" + e1]) {
                                const t1 = "OP_" + e1, i3 = o.a[t1];
                                r.writeUInt8(i3);
                            } else if ("number" == typeof o.a[e1]) {
                                const t2 = e1, i4 = o.a[t2];
                                r.writeUInt8(i4);
                            } else {
                                if (isNaN(parseInt(e1, 10))) throw new Error("Could not determine type of script value");
                                {
                                    const t3 = new i.a(e1), n2 = (new f).writeBn(t3).toBuffer();
                                    r.write(n2);
                                }
                            }
                        }
                    }
                    const h = r.toBuffer();
                    return this.fromBuffer(h);
                }
                static fromBitcoindString(t) {
                    return (new this).fromBitcoindString(t);
                }
                toBitcoindString() {
                    let t = "";
                    for(let e = 0; e < this.chunks.length; e++){
                        const r = this.chunks[e];
                        if (r.buf) t = t + " 0x" + new f([
                            r
                        ]).toBuffer().toString("hex");
                        else if (void 0 !== o.a.str[r.opCodeNum]) t = t + " " + new o.a(r.opCodeNum).toString().slice(3);
                        else t = t + " 0x" + r.opCodeNum.toString(16);
                    }
                    return t.substr(1);
                }
                fromAsmString(e) {
                    this.chunks = [];
                    const r = e.split(" ");
                    let i = 0;
                    for(; i < r.length;){
                        const e1 = r[i];
                        let n, s;
                        try {
                            n = o.a.fromString(e1), s = n.toNumber();
                        } catch (t1) {
                            n = void 0, s = void 0;
                        }
                        if ("0" === e1) s = 0, this.chunks.push({
                            opCodeNum: s
                        }), i += 1;
                        else if ("-1" === e1) s = o.a.OP_1NEGATE, this.chunks.push({
                            opCodeNum: s
                        }), i += 1;
                        else if (void 0 === n) {
                            const e2 = r[i], n1 = t.from(e2, "hex");
                            if (n1.toString("hex") !== e2) throw new Error("invalid hex string in script");
                            const a = n1.length;
                            a >= 0 && a < o.a.OP_PUSHDATA1 ? s = a : a < Math.pow(2, 8) ? s = o.a.OP_PUSHDATA1 : a < Math.pow(2, 16) ? s = o.a.OP_PUSHDATA2 : a < Math.pow(2, 32) && (s = o.a.OP_PUSHDATA4), this.chunks.push({
                                buf: n1,
                                len: n1.length,
                                opCodeNum: s
                            }), i += 1;
                        } else this.chunks.push({
                            opCodeNum: s
                        }), i += 1;
                    }
                    return this;
                }
                static fromAsmString(t) {
                    return (new this).fromAsmString(t);
                }
                toAsmString() {
                    let t = "";
                    for(let e = 0; e < this.chunks.length; e++){
                        const r = this.chunks[e];
                        t += this._chunkToString(r);
                    }
                    return t.substr(1);
                }
                _chunkToString(t) {
                    const e = t.opCodeNum;
                    let r = "";
                    if (t.buf) t.len > 0 && (r = r + " " + t.buf.toString("hex"));
                    else if (void 0 !== o.a.str[e]) 0 === e ? r += " 0" : 79 === e ? r += " -1" : r = r + " " + new o.a(e).toString();
                    else {
                        let t1 = e.toString(16);
                        t1.length % 2 != 0 && (t1 = "0" + t1), r = r + " " + t1;
                    }
                    return r;
                }
                fromOpReturnData(t) {
                    return this.writeOpCode(o.a.OP_RETURN), this.writeBuffer(t), this;
                }
                static fromOpReturnData(t) {
                    return (new this).fromOpReturnData(t);
                }
                fromSafeData(t) {
                    return this.writeOpCode(o.a.OP_FALSE), this.writeOpCode(o.a.OP_RETURN), this.writeBuffer(t), this;
                }
                static fromSafeData(t) {
                    return (new this).fromSafeData(t);
                }
                fromSafeDataArray(t) {
                    this.writeOpCode(o.a.OP_FALSE), this.writeOpCode(o.a.OP_RETURN);
                    for(const e in t){
                        const r = t[e];
                        this.writeBuffer(r);
                    }
                    return this;
                }
                static fromSafeDataArray(t) {
                    return (new this).fromSafeDataArray(t);
                }
                getData() {
                    if (this.isSafeDataOut()) return this.chunks.slice(2).map((t)=>t.buf);
                    if (this.isOpReturn()) return this.chunks.slice(1).map((t)=>t.buf);
                    throw new Error("Unrecognized script type to get data from");
                }
                fromPubKeyHash(t) {
                    if (20 !== t.length) throw new Error("hashBuf must be a 20 byte buffer");
                    return this.writeOpCode(o.a.OP_DUP), this.writeOpCode(o.a.OP_HASH160), this.writeBuffer(t), this.writeOpCode(o.a.OP_EQUALVERIFY), this.writeOpCode(o.a.OP_CHECKSIG), this;
                }
                static fromPubKeyHash(t) {
                    return (new this).fromPubKeyHash(t);
                }
                static sortPubKeys(t) {
                    return t.slice().sort((t, e)=>{
                        const r = t.toBuffer(), i = e.toBuffer(), n = Math.max(r.length, i.length);
                        for(let t1 = 0; t1 <= n; t1++){
                            if (void 0 === r[t1]) return -1;
                            if (void 0 === i[t1]) return 1;
                            if (r[t1] < i[t1]) return -1;
                            if (r[t1] > i[t1]) return 1;
                        }
                    });
                }
                fromPubKeys(t, e, r = !0) {
                    if ("number" != typeof t) throw new Error("m must be a number");
                    r && (e = f.sortPubKeys(e)), this.writeOpCode(t + o.a.OP_1 - 1);
                    for(const t1 in e)this.writeBuffer(e[t1].toBuffer());
                    return this.writeOpCode(e.length + o.a.OP_1 - 1), this.writeOpCode(o.a.OP_CHECKMULTISIG), this;
                }
                static fromPubKeys(t, e, r = !0) {
                    return (new this).fromPubKeys(t, e, r);
                }
                removeCodeseparators() {
                    const t = [];
                    for(let e = 0; e < this.chunks.length; e++)this.chunks[e].opCodeNum !== o.a.OP_CODESEPARATOR && t.push(this.chunks[e]);
                    return this.chunks = t, this;
                }
                isPushOnly() {
                    for(let t = 0; t < this.chunks.length; t++){
                        if (this.chunks[t].opCodeNum > o.a.OP_16) return !1;
                    }
                    return !0;
                }
                isNonSpendable() {
                    const t = this.chunks[0].opCodeNum === o.a.OP_FALSE, e = this.chunks[1] && this.chunks[1].opCodeNum === o.a.OP_RETURN;
                    return !!t && !!e;
                }
                isOpReturn() {
                    return this.chunks[0].opCodeNum === o.a.OP_RETURN && this.chunks.filter((e)=>t.isBuffer(e.buf)).length === this.chunks.slice(1).length;
                }
                isSafeDataOut() {
                    if (this.chunks.length < 2) return !1;
                    if (this.chunks[0].opCodeNum !== o.a.OP_FALSE) return !1;
                    const t = this.chunks.slice(1);
                    return new f(t).isOpReturn();
                }
                isPubKeyHashOut() {
                    return !!(this.chunks[0] && this.chunks[0].opCodeNum === o.a.OP_DUP && this.chunks[1] && this.chunks[1].opCodeNum === o.a.OP_HASH160 && this.chunks[2].buf && this.chunks[3] && this.chunks[3].opCodeNum === o.a.OP_EQUALVERIFY && this.chunks[4] && this.chunks[4].opCodeNum === o.a.OP_CHECKSIG);
                }
                isPubKeyHashIn() {
                    return !(2 !== this.chunks.length || !this.chunks[0].buf && this.chunks[0].opCodeNum !== o.a.OP_0 || !this.chunks[1].buf && this.chunks[0].opCodeNum !== o.a.OP_0);
                }
                isScriptHashOut() {
                    const t = this.toBuffer();
                    return 23 === t.length && t[0] === o.a.OP_HASH160 && 20 === t[1] && t[22] === o.a.OP_EQUAL;
                }
                isScriptHashIn() {
                    if (!this.isPushOnly()) return !1;
                    try {
                        (new f).fromBuffer(this.chunks[this.chunks.length - 1].buf);
                    } catch (t) {
                        return !1;
                    }
                    return !0;
                }
                isMultiSigOut() {
                    const t = this.chunks[0].opCodeNum - o.a.OP_1 + 1;
                    if (!(t >= 1 && t <= 16)) return !1;
                    if (!this.chunks.slice(1, this.chunks.length - 2).every((t)=>{
                        try {
                            const e = t.buf;
                            return (new h.a).fromDer(e).validate(), !0;
                        } catch (t1) {
                            return !1;
                        }
                    })) return !1;
                    const e = this.chunks[this.chunks.length - 2].opCodeNum - o.a.OP_1 + 1;
                    return e >= t && e <= 16 && this.chunks[1 + e + 1].opCodeNum === o.a.OP_CHECKMULTISIG;
                }
                isMultiSigIn() {
                    if (this.chunks[0].opCodeNum !== o.a.OP_0) return !1;
                    const e = this.chunks.slice(1);
                    return !(e.length < 1) && e.every((e)=>t.isBuffer(e.buf) && c.a.IsTxDer(e.buf));
                }
                findAndDelete(t) {
                    const e = t.toBuffer();
                    for(let t1 = 0; t1 < this.chunks.length; t1++){
                        const r = new f([
                            this.chunks[t1]
                        ]).toBuffer();
                        Object(a.a)(e, r) && this.chunks.splice(t1, 1);
                    }
                    return this;
                }
                writeScript(t) {
                    return this.chunks = this.chunks.concat(t.chunks), this;
                }
                static writeScript(t) {
                    return (new this).writeScript(t);
                }
                writeString(t) {
                    const e = (new f).fromString(t);
                    return this.chunks = this.chunks.concat(e.chunks), this;
                }
                static writeString(t) {
                    return (new this).writeString(t);
                }
                writeOpCode(t) {
                    return this.chunks.push({
                        opCodeNum: t
                    }), this;
                }
                static writeOpCode(t) {
                    return (new this).writeOpCode(t);
                }
                setChunkOpCode(t, e) {
                    return this.chunks[t] = {
                        opCodeNum: e
                    }, this;
                }
                writeBn(t) {
                    if (t.cmp(0) === o.a.OP_0) this.chunks.push({
                        opCodeNum: o.a.OP_0
                    });
                    else if (0 === t.cmp(-1)) this.chunks.push({
                        opCodeNum: o.a.OP_1NEGATE
                    });
                    else if (t.cmp(1) >= 0 && t.cmp(16) <= 0) this.chunks.push({
                        opCodeNum: t.toNumber() + o.a.OP_1 - 1
                    });
                    else {
                        const e = t.toSm({
                            endian: "little"
                        });
                        this.writeBuffer(e);
                    }
                    return this;
                }
                static writeBn(t) {
                    return (new this).writeBn(t);
                }
                writeNumber(t) {
                    return this.writeBn((new i.a).fromNumber(t)), this;
                }
                static writeNumber(t) {
                    return (new this).writeNumber(t);
                }
                setChunkBn(t, e) {
                    return this.chunks[t] = (new f).writeBn(e).chunks[0], this;
                }
                writeBuffer(t) {
                    let e;
                    const r = t.length;
                    if (t.length > 0 && t.length < o.a.OP_PUSHDATA1) e = t.length;
                    else if (0 === t.length) e = o.a.OP_0;
                    else if (t.length < Math.pow(2, 8)) e = o.a.OP_PUSHDATA1;
                    else if (t.length < Math.pow(2, 16)) e = o.a.OP_PUSHDATA2;
                    else {
                        if (!(t.length < Math.pow(2, 32))) throw new Error("You can't push that much data");
                        e = o.a.OP_PUSHDATA4;
                    }
                    return this.chunks.push({
                        buf: t,
                        len: r,
                        opCodeNum: e
                    }), this;
                }
                static writeBuffer(t) {
                    return (new this).writeBuffer(t);
                }
                setChunkBuffer(t, e) {
                    return this.chunks[t] = (new f).writeBuffer(e).chunks[0], this;
                }
                checkMinimalPush(t) {
                    const e = this.chunks[t], r = e.buf, i = e.opCodeNum;
                    return !r || (0 === r.length ? i === o.a.OP_0 : 1 === r.length && r[0] >= 1 && r[0] <= 16 ? i === o.a.OP_1 + (r[0] - 1) : 1 === r.length && 129 === r[0] ? i === o.a.OP_1NEGATE : r.length <= 75 ? i === r.length : r.length <= 255 ? i === o.a.OP_PUSHDATA1 : !(r.length <= 65535) || i === o.a.OP_PUSHDATA2);
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return a;
            });
            var i = r(12), n = r(6), s = r(4);
            class a extends s.a {
                constructor(t){
                    super({
                        buf: t
                    });
                }
                fromJSON(e) {
                    return this.fromObject({
                        buf: t.from(e, "hex")
                    }), this;
                }
                toJSON() {
                    return this.buf.toString("hex");
                }
                fromBuffer(t) {
                    return this.buf = t, this;
                }
                fromBr(t) {
                    return this.buf = t.readVarIntBuf(), this;
                }
                fromBn(t) {
                    return this.buf = (new n.a).writeVarIntBn(t).toBuffer(), this;
                }
                static fromBn(t) {
                    return (new this).fromBn(t);
                }
                fromNumber(t) {
                    return this.buf = (new n.a).writeVarIntNum(t).toBuffer(), this;
                }
                static fromNumber(t) {
                    return (new this).fromNumber(t);
                }
                toBuffer() {
                    return this.buf;
                }
                toBn() {
                    return new i.a(this.buf).readVarIntBn();
                }
                toNumber() {
                    return new i.a(this.buf).readVarIntNum();
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        r.d(e, "a", function() {
            return o;
        });
        var i = r(82), n = r(1);
        const s = i.curves.secp256k1, a = s.curve.point().constructor;
        class o extends a {
            constructor(t, e, r){
                super(s.curve, t, e, r);
            }
            static fromX(t, e) {
                const r = s.curve.pointFromX(e, t);
                return Object.create(o.prototype).copyFrom(r);
            }
            copyFrom(t) {
                if (!(t instanceof a)) throw new Error("point should be an external point");
                for (const e of Object.keys(t))this[e] = t[e];
                return this;
            }
            add(t) {
                t = a.prototype.add.call(this, t);
                return Object.create(o.prototype).copyFrom(t);
            }
            mul(t) {
                if (!t.lt(o.getN())) throw new Error("point mul out of range");
                const e = a.prototype.mul.call(this, t);
                return Object.create(o.prototype).copyFrom(e);
            }
            mulAdd(t, e, r) {
                const i = a.prototype.mulAdd.call(this, t, e, r);
                return (e = Object.create(o.prototype)).copyFrom(i);
            }
            getX() {
                const t = a.prototype.getX.call(this), e = Object.create(n.a.prototype);
                return t.copy(e), e;
            }
            getY() {
                const t = a.prototype.getY.call(this), e = Object.create(n.a.prototype);
                return t.copy(e), e;
            }
            fromX(t, e) {
                const r = o.fromX(t, e);
                return this.copyFrom(r);
            }
            toJSON() {
                return {
                    x: this.getX().toString(),
                    y: this.getY().toString()
                };
            }
            fromJSON(t) {
                const e = (new n.a).fromString(t.x), r = (new n.a).fromString(t.y), i = new o(e, r);
                return this.copyFrom(i);
            }
            toString() {
                return JSON.stringify(this.toJSON());
            }
            fromString(t) {
                const e = JSON.parse(t), r = (new o).fromJSON(e);
                return this.copyFrom(r);
            }
            static getG() {
                const t = s.curve.g;
                return Object.create(o.prototype).copyFrom(t);
            }
            static getN() {
                return new n.a(s.curve.n.toArray());
            }
            validate() {
                if (0 !== o.fromX(this.getY().isOdd(), this.getX()).getY().cmp(this.getY())) throw new Error("Invalid y value of public key");
                if (!(this.getX().gt(-1) && this.getX().lt(o.getN()) && this.getY().gt(-1) && this.getY().lt(o.getN()))) throw new Error("Point does not lie on the curve");
                return this;
            }
        }
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return n;
            });
            var i = r(1);
            class n {
                constructor(t){
                    this.fromObject({
                        buf: t
                    });
                }
                fromObject(t) {
                    return this.buf = t.buf || this.buf || void 0, this.pos = t.pos || this.pos || 0, this;
                }
                eof() {
                    return this.pos >= this.buf.length;
                }
                read(t = this.buf.length) {
                    const e = this.buf.slice(this.pos, this.pos + t);
                    return this.pos = this.pos + t, e;
                }
                readReverse(e = this.buf.length) {
                    const r = this.buf.slice(this.pos, this.pos + e);
                    this.pos = this.pos + e;
                    const i = t.alloc(r.length);
                    for(let t1 = 0; t1 < i.length; t1++)i[t1] = r[r.length - 1 - t1];
                    return i;
                }
                readUInt8() {
                    const t = this.buf.readUInt8(this.pos);
                    return this.pos = this.pos + 1, t;
                }
                readInt8() {
                    const t = this.buf.readInt8(this.pos);
                    return this.pos = this.pos + 1, t;
                }
                readUInt16BE() {
                    const t = this.buf.readUInt16BE(this.pos);
                    return this.pos = this.pos + 2, t;
                }
                readInt16BE() {
                    const t = this.buf.readInt16BE(this.pos);
                    return this.pos = this.pos + 2, t;
                }
                readUInt16LE() {
                    const t = this.buf.readUInt16LE(this.pos);
                    return this.pos = this.pos + 2, t;
                }
                readInt16LE() {
                    const t = this.buf.readInt16LE(this.pos);
                    return this.pos = this.pos + 2, t;
                }
                readUInt32BE() {
                    const t = this.buf.readUInt32BE(this.pos);
                    return this.pos = this.pos + 4, t;
                }
                readInt32BE() {
                    const t = this.buf.readInt32BE(this.pos);
                    return this.pos = this.pos + 4, t;
                }
                readUInt32LE() {
                    const t = this.buf.readUInt32LE(this.pos);
                    return this.pos = this.pos + 4, t;
                }
                readInt32LE() {
                    const t = this.buf.readInt32LE(this.pos);
                    return this.pos = this.pos + 4, t;
                }
                readUInt64BEBn() {
                    const t = this.buf.slice(this.pos, this.pos + 8), e = (new i.a).fromBuffer(t);
                    return this.pos = this.pos + 8, e;
                }
                readUInt64LEBn() {
                    const t = this.readReverse(8);
                    return (new i.a).fromBuffer(t);
                }
                readVarIntNum() {
                    const t = this.readUInt8();
                    let e, r;
                    switch(t){
                        case 253:
                            return this.readUInt16LE();
                        case 254:
                            return this.readUInt32LE();
                        case 255:
                            if (e = this.readUInt64LEBn(), r = e.toNumber(), r <= Math.pow(2, 53)) return r;
                            throw new Error("number too large to retain precision - use readVarIntBn");
                        default:
                            return t;
                    }
                }
                readVarIntBuf() {
                    switch(this.buf.readUInt8(this.pos)){
                        case 253:
                            return this.read(3);
                        case 254:
                            return this.read(5);
                        case 255:
                            return this.read(9);
                        default:
                            return this.read(1);
                    }
                }
                readVarIntBn() {
                    const t = this.readUInt8();
                    switch(t){
                        case 253:
                            return new i.a(this.readUInt16LE());
                        case 254:
                            return new i.a(this.readUInt32LE());
                        case 255:
                            return this.readUInt64LEBn();
                        default:
                            return new i.a(t);
                    }
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return c;
            });
            var i = r(12), n = r(6), s = r(0), a = r(9), o = r(4), h = r(10);
            class c extends o.a {
                constructor(t, e, r, i, n = 4294967295){
                    super({
                        txHashBuf: t,
                        txOutNum: e,
                        scriptVi: r,
                        script: i,
                        nSequence: n
                    });
                }
                setScript(t) {
                    return this.scriptVi = h.a.fromNumber(t.toBuffer().length), this.script = t, this;
                }
                fromProperties(t, e, r, i) {
                    return this.fromObject({
                        txHashBuf: t,
                        txOutNum: e,
                        nSequence: i
                    }), this.setScript(r), this;
                }
                static fromProperties(t, e, r, i) {
                    return (new this).fromProperties(t, e, r, i);
                }
                fromJSON(e) {
                    return this.fromObject({
                        txHashBuf: void 0 !== e.txHashBuf ? t.from(e.txHashBuf, "hex") : void 0,
                        txOutNum: e.txOutNum,
                        scriptVi: void 0 !== e.scriptVi ? h.a.fromJSON(e.scriptVi) : void 0,
                        script: void 0 !== e.script ? a.a.fromJSON(e.script) : void 0,
                        nSequence: e.nSequence
                    }), this;
                }
                toJSON() {
                    return {
                        txHashBuf: void 0 !== this.txHashBuf ? this.txHashBuf.toString("hex") : void 0,
                        txOutNum: this.txOutNum,
                        scriptVi: void 0 !== this.scriptVi ? this.scriptVi.toJSON() : void 0,
                        script: void 0 !== this.script ? this.script.toJSON() : void 0,
                        nSequence: this.nSequence
                    };
                }
                fromBr(t) {
                    return this.txHashBuf = t.read(32), this.txOutNum = t.readUInt32LE(), this.scriptVi = h.a.fromBuffer(t.readVarIntBuf()), this.script = a.a.fromBuffer(t.read(this.scriptVi.toNumber())), this.nSequence = t.readUInt32LE(), this;
                }
                toBw(t) {
                    return t || (t = new n.a), t.write(this.txHashBuf), t.writeUInt32LE(this.txOutNum), t.write(this.scriptVi.buf), t.write(this.script.toBuffer()), t.writeUInt32LE(this.nSequence), t;
                }
                fromPubKeyHashTxOut(t, e, r, i) {
                    const n = new a.a;
                    if (!r.script.isPubKeyHashOut()) throw new Error("txOut must be of type pubKeyHash");
                    return n.writeOpCode(s.a.OP_0), i ? n.writeBuffer(i.toBuffer()) : n.writeOpCode(s.a.OP_0), this.txHashBuf = t, this.txOutNum = e, this.setScript(n), this;
                }
                hasNullInput() {
                    return "0000000000000000000000000000000000000000000000000000000000000000" === this.txHashBuf.toString("hex") && 4294967295 === this.txOutNum;
                }
                setNullInput() {
                    this.txHashBuf = t.alloc(32), this.txHashBuf.fill(0), this.txOutNum = 4294967295;
                }
                txid() {
                    return new i.a(this.txHashBuf).readReverse().toString("hex");
                }
            }
            c.LOCKTIME_VERIFY_SEQUENCE = 1, c.SEQUENCE_FINAL = 4294967295, c.SEQUENCE_LOCKTIME_DISABLE_FLAG = -2147483648, c.SEQUENCE_LOCKTIME_TYPE_FLAG = 4194304, c.SEQUENCE_LOCKTIME_MASK = 65535, c.SEQUENCE_LOCKTIME_GRANULARITY = 9;
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        (function(t) {
            !function(t, e) {
                "use strict";
                function i(t, e) {
                    if (!t) throw new Error(e || "Assertion failed");
                }
                function n(t, e) {
                    t.super_ = e;
                    var r = function() {};
                    r.prototype = e.prototype, t.prototype = new r, t.prototype.constructor = t;
                }
                function s(t, e, r) {
                    if (s.isBN(t)) return t;
                    this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== t && ("le" !== e && "be" !== e || (r = e, e = 10), this._init(t || 0, e || 10, r || "be"));
                }
                var a;
                "object" == typeof t ? t.exports = s : e.BN = s, s.BN = s, s.wordSize = 26;
                try {
                    a = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : r(93).Buffer;
                } catch (t1) {}
                function o(t, e) {
                    var r = t.charCodeAt(e);
                    return r >= 48 && r <= 57 ? r - 48 : r >= 65 && r <= 70 ? r - 55 : r >= 97 && r <= 102 ? r - 87 : void i(!1, "Invalid character in " + t);
                }
                function h(t, e, r) {
                    var i = o(t, r);
                    return r - 1 >= e && (i |= o(t, r - 1) << 4), i;
                }
                function c(t, e, r, n) {
                    for(var s = 0, a = 0, o = Math.min(t.length, r), h = e; h < o; h++){
                        var c = t.charCodeAt(h) - 48;
                        s *= n, a = c >= 49 ? c - 49 + 10 : c >= 17 ? c - 17 + 10 : c, i(c >= 0 && a < n, "Invalid character"), s += a;
                    }
                    return s;
                }
                function u(t, e) {
                    t.words = e.words, t.length = e.length, t.negative = e.negative, t.red = e.red;
                }
                if (s.isBN = function(t) {
                    return t instanceof s || null !== t && "object" == typeof t && t.constructor.wordSize === s.wordSize && Array.isArray(t.words);
                }, s.max = function(t, e) {
                    return t.cmp(e) > 0 ? t : e;
                }, s.min = function(t, e) {
                    return t.cmp(e) < 0 ? t : e;
                }, s.prototype._init = function(t, e, r) {
                    if ("number" == typeof t) return this._initNumber(t, e, r);
                    if ("object" == typeof t) return this._initArray(t, e, r);
                    "hex" === e && (e = 16), i(e === (0 | e) && e >= 2 && e <= 36);
                    var n = 0;
                    "-" === (t = t.toString().replace(/\s+/g, ""))[0] && (n++, this.negative = 1), n < t.length && (16 === e ? this._parseHex(t, n, r) : (this._parseBase(t, e, n), "le" === r && this._initArray(this.toArray(), e, r)));
                }, s.prototype._initNumber = function(t, e, r) {
                    t < 0 && (this.negative = 1, t = -t), t < 67108864 ? (this.words = [
                        67108863 & t
                    ], this.length = 1) : t < 4503599627370496 ? (this.words = [
                        67108863 & t,
                        t / 67108864 & 67108863
                    ], this.length = 2) : (i(t < 9007199254740992), this.words = [
                        67108863 & t,
                        t / 67108864 & 67108863,
                        1
                    ], this.length = 3), "le" === r && this._initArray(this.toArray(), e, r);
                }, s.prototype._initArray = function(t, e, r) {
                    if (i("number" == typeof t.length), t.length <= 0) return this.words = [
                        0
                    ], this.length = 1, this;
                    this.length = Math.ceil(t.length / 3), this.words = new Array(this.length);
                    for(var n = 0; n < this.length; n++)this.words[n] = 0;
                    var s, a, o = 0;
                    if ("be" === r) for(n = t.length - 1, s = 0; n >= 0; n -= 3)a = t[n] | t[n - 1] << 8 | t[n - 2] << 16, this.words[s] |= a << o & 67108863, this.words[s + 1] = a >>> 26 - o & 67108863, (o += 24) >= 26 && (o -= 26, s++);
                    else if ("le" === r) for(n = 0, s = 0; n < t.length; n += 3)a = t[n] | t[n + 1] << 8 | t[n + 2] << 16, this.words[s] |= a << o & 67108863, this.words[s + 1] = a >>> 26 - o & 67108863, (o += 24) >= 26 && (o -= 26, s++);
                    return this._strip();
                }, s.prototype._parseHex = function(t, e, r) {
                    this.length = Math.ceil((t.length - e) / 6), this.words = new Array(this.length);
                    for(var i = 0; i < this.length; i++)this.words[i] = 0;
                    var n, s = 0, a = 0;
                    if ("be" === r) for(i = t.length - 1; i >= e; i -= 2)n = h(t, e, i) << s, this.words[a] |= 67108863 & n, s >= 18 ? (s -= 18, a += 1, this.words[a] |= n >>> 26) : s += 8;
                    else for(i = (t.length - e) % 2 == 0 ? e + 1 : e; i < t.length; i += 2)n = h(t, e, i) << s, this.words[a] |= 67108863 & n, s >= 18 ? (s -= 18, a += 1, this.words[a] |= n >>> 26) : s += 8;
                    this._strip();
                }, s.prototype._parseBase = function(t, e, r) {
                    this.words = [
                        0
                    ], this.length = 1;
                    for(var i = 0, n = 1; n <= 67108863; n *= e)i++;
                    i--, n = n / e | 0;
                    for(var s = t.length - r, a = s % i, o = Math.min(s, s - a) + r, h = 0, u = r; u < o; u += i)h = c(t, u, u + i, e), this.imuln(n), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h);
                    if (0 !== a) {
                        var f = 1;
                        for(h = c(t, u, t.length, e), u = 0; u < a; u++)f *= e;
                        this.imuln(f), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h);
                    }
                    this._strip();
                }, s.prototype.copy = function(t) {
                    t.words = new Array(this.length);
                    for(var e = 0; e < this.length; e++)t.words[e] = this.words[e];
                    t.length = this.length, t.negative = this.negative, t.red = this.red;
                }, s.prototype._move = function(t) {
                    u(t, this);
                }, s.prototype.clone = function() {
                    var t = new s(null);
                    return this.copy(t), t;
                }, s.prototype._expand = function(t) {
                    for(; this.length < t;)this.words[this.length++] = 0;
                    return this;
                }, s.prototype._strip = function() {
                    for(; this.length > 1 && 0 === this.words[this.length - 1];)this.length--;
                    return this._normSign();
                }, s.prototype._normSign = function() {
                    return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this;
                }, "undefined" != typeof Symbol && "function" == typeof Symbol.for) try {
                    s.prototype[Symbol.for("nodejs.util.inspect.custom")] = f;
                } catch (t2) {
                    s.prototype.inspect = f;
                }
                else s.prototype.inspect = f;
                function f() {
                    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
                }
                var d = [
                    "",
                    "0",
                    "00",
                    "000",
                    "0000",
                    "00000",
                    "000000",
                    "0000000",
                    "00000000",
                    "000000000",
                    "0000000000",
                    "00000000000",
                    "000000000000",
                    "0000000000000",
                    "00000000000000",
                    "000000000000000",
                    "0000000000000000",
                    "00000000000000000",
                    "000000000000000000",
                    "0000000000000000000",
                    "00000000000000000000",
                    "000000000000000000000",
                    "0000000000000000000000",
                    "00000000000000000000000",
                    "000000000000000000000000",
                    "0000000000000000000000000"
                ], l = [
                    0,
                    0,
                    25,
                    16,
                    12,
                    11,
                    10,
                    9,
                    8,
                    8,
                    7,
                    7,
                    7,
                    7,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                ], p = [
                    0,
                    0,
                    33554432,
                    43046721,
                    16777216,
                    48828125,
                    60466176,
                    40353607,
                    16777216,
                    43046721,
                    1e7,
                    19487171,
                    35831808,
                    62748517,
                    7529536,
                    11390625,
                    16777216,
                    24137569,
                    34012224,
                    47045881,
                    64e6,
                    4084101,
                    5153632,
                    6436343,
                    7962624,
                    9765625,
                    11881376,
                    14348907,
                    17210368,
                    20511149,
                    243e5,
                    28629151,
                    33554432,
                    39135393,
                    45435424,
                    52521875,
                    60466176
                ];
                s.prototype.toString = function(t, e) {
                    var r;
                    if (e = 0 | e || 1, 16 === (t = t || 10) || "hex" === t) {
                        r = "";
                        for(var n = 0, s = 0, a = 0; a < this.length; a++){
                            var o = this.words[a], h = (16777215 & (o << n | s)).toString(16);
                            r = 0 !== (s = o >>> 24 - n & 16777215) || a !== this.length - 1 ? d[6 - h.length] + h + r : h + r, (n += 2) >= 26 && (n -= 26, a--);
                        }
                        for(0 !== s && (r = s.toString(16) + r); r.length % e != 0;)r = "0" + r;
                        return 0 !== this.negative && (r = "-" + r), r;
                    }
                    if (t === (0 | t) && t >= 2 && t <= 36) {
                        var c = l[t], u = p[t];
                        r = "";
                        var f = this.clone();
                        for(f.negative = 0; !f.isZero();){
                            var b = f.modrn(u).toString(t);
                            r = (f = f.idivn(u)).isZero() ? b + r : d[c - b.length] + b + r;
                        }
                        for(this.isZero() && (r = "0" + r); r.length % e != 0;)r = "0" + r;
                        return 0 !== this.negative && (r = "-" + r), r;
                    }
                    i(!1, "Base should be between 2 and 36");
                }, s.prototype.toNumber = function() {
                    var t = this.words[0];
                    return 2 === this.length ? t += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? t += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && i(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -t : t;
                }, s.prototype.toJSON = function() {
                    return this.toString(16, 2);
                }, a && (s.prototype.toBuffer = function(t, e) {
                    return this.toArrayLike(a, t, e);
                }), s.prototype.toArray = function(t, e) {
                    return this.toArrayLike(Array, t, e);
                };
                function b(t, e, r) {
                    r.negative = e.negative ^ t.negative;
                    var i = t.length + e.length | 0;
                    r.length = i, i = i - 1 | 0;
                    var n = 0 | t.words[0], s = 0 | e.words[0], a = n * s, o = 67108863 & a, h = a / 67108864 | 0;
                    r.words[0] = o;
                    for(var c = 1; c < i; c++){
                        for(var u = h >>> 26, f = 67108863 & h, d = Math.min(c, e.length - 1), l = Math.max(0, c - t.length + 1); l <= d; l++){
                            var p = c - l | 0;
                            u += (a = (n = 0 | t.words[p]) * (s = 0 | e.words[l]) + f) / 67108864 | 0, f = 67108863 & a;
                        }
                        r.words[c] = 0 | f, h = 0 | u;
                    }
                    return 0 !== h ? r.words[c] = 0 | h : r.length--, r._strip();
                }
                s.prototype.toArrayLike = function(t, e, r) {
                    this._strip();
                    var n = this.byteLength(), s = r || Math.max(1, n);
                    i(n <= s, "byte array longer than desired length"), i(s > 0, "Requested array length <= 0");
                    var a = function(t, e) {
                        return t.allocUnsafe ? t.allocUnsafe(e) : new t(e);
                    }(t, s);
                    return this["_toArrayLike" + ("le" === e ? "LE" : "BE")](a, n), a;
                }, s.prototype._toArrayLikeLE = function(t, e) {
                    for(var r = 0, i = 0, n = 0, s = 0; n < this.length; n++){
                        var a = this.words[n] << s | i;
                        t[r++] = 255 & a, r < t.length && (t[r++] = a >> 8 & 255), r < t.length && (t[r++] = a >> 16 & 255), 6 === s ? (r < t.length && (t[r++] = a >> 24 & 255), i = 0, s = 0) : (i = a >>> 24, s += 2);
                    }
                    if (r < t.length) for(t[r++] = i; r < t.length;)t[r++] = 0;
                }, s.prototype._toArrayLikeBE = function(t, e) {
                    for(var r = t.length - 1, i = 0, n = 0, s = 0; n < this.length; n++){
                        var a = this.words[n] << s | i;
                        t[r--] = 255 & a, r >= 0 && (t[r--] = a >> 8 & 255), r >= 0 && (t[r--] = a >> 16 & 255), 6 === s ? (r >= 0 && (t[r--] = a >> 24 & 255), i = 0, s = 0) : (i = a >>> 24, s += 2);
                    }
                    if (r >= 0) for(t[r--] = i; r >= 0;)t[r--] = 0;
                }, Math.clz32 ? s.prototype._countBits = function(t) {
                    return 32 - Math.clz32(t);
                } : s.prototype._countBits = function(t) {
                    var e = t, r = 0;
                    return e >= 4096 && (r += 13, e >>>= 13), e >= 64 && (r += 7, e >>>= 7), e >= 8 && (r += 4, e >>>= 4), e >= 2 && (r += 2, e >>>= 2), r + e;
                }, s.prototype._zeroBits = function(t) {
                    if (0 === t) return 26;
                    var e = t, r = 0;
                    return 0 == (8191 & e) && (r += 13, e >>>= 13), 0 == (127 & e) && (r += 7, e >>>= 7), 0 == (15 & e) && (r += 4, e >>>= 4), 0 == (3 & e) && (r += 2, e >>>= 2), 0 == (1 & e) && r++, r;
                }, s.prototype.bitLength = function() {
                    var t = this.words[this.length - 1], e = this._countBits(t);
                    return 26 * (this.length - 1) + e;
                }, s.prototype.zeroBits = function() {
                    if (this.isZero()) return 0;
                    for(var t = 0, e = 0; e < this.length; e++){
                        var r = this._zeroBits(this.words[e]);
                        if (t += r, 26 !== r) break;
                    }
                    return t;
                }, s.prototype.byteLength = function() {
                    return Math.ceil(this.bitLength() / 8);
                }, s.prototype.toTwos = function(t) {
                    return 0 !== this.negative ? this.abs().inotn(t).iaddn(1) : this.clone();
                }, s.prototype.fromTwos = function(t) {
                    return this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone();
                }, s.prototype.isNeg = function() {
                    return 0 !== this.negative;
                }, s.prototype.neg = function() {
                    return this.clone().ineg();
                }, s.prototype.ineg = function() {
                    return this.isZero() || (this.negative ^= 1), this;
                }, s.prototype.iuor = function(t) {
                    for(; this.length < t.length;)this.words[this.length++] = 0;
                    for(var e = 0; e < t.length; e++)this.words[e] = this.words[e] | t.words[e];
                    return this._strip();
                }, s.prototype.ior = function(t) {
                    return i(0 == (this.negative | t.negative)), this.iuor(t);
                }, s.prototype.or = function(t) {
                    return this.length > t.length ? this.clone().ior(t) : t.clone().ior(this);
                }, s.prototype.uor = function(t) {
                    return this.length > t.length ? this.clone().iuor(t) : t.clone().iuor(this);
                }, s.prototype.iuand = function(t) {
                    var e;
                    e = this.length > t.length ? t : this;
                    for(var r = 0; r < e.length; r++)this.words[r] = this.words[r] & t.words[r];
                    return this.length = e.length, this._strip();
                }, s.prototype.iand = function(t) {
                    return i(0 == (this.negative | t.negative)), this.iuand(t);
                }, s.prototype.and = function(t) {
                    return this.length > t.length ? this.clone().iand(t) : t.clone().iand(this);
                }, s.prototype.uand = function(t) {
                    return this.length > t.length ? this.clone().iuand(t) : t.clone().iuand(this);
                }, s.prototype.iuxor = function(t) {
                    var e, r;
                    this.length > t.length ? (e = this, r = t) : (e = t, r = this);
                    for(var i = 0; i < r.length; i++)this.words[i] = e.words[i] ^ r.words[i];
                    if (this !== e) for(; i < e.length; i++)this.words[i] = e.words[i];
                    return this.length = e.length, this._strip();
                }, s.prototype.ixor = function(t) {
                    return i(0 == (this.negative | t.negative)), this.iuxor(t);
                }, s.prototype.xor = function(t) {
                    return this.length > t.length ? this.clone().ixor(t) : t.clone().ixor(this);
                }, s.prototype.uxor = function(t) {
                    return this.length > t.length ? this.clone().iuxor(t) : t.clone().iuxor(this);
                }, s.prototype.inotn = function(t) {
                    i("number" == typeof t && t >= 0);
                    var e = 0 | Math.ceil(t / 26), r = t % 26;
                    this._expand(e), r > 0 && e--;
                    for(var n = 0; n < e; n++)this.words[n] = 67108863 & ~this.words[n];
                    return r > 0 && (this.words[n] = ~this.words[n] & 67108863 >> 26 - r), this._strip();
                }, s.prototype.notn = function(t) {
                    return this.clone().inotn(t);
                }, s.prototype.setn = function(t, e) {
                    i("number" == typeof t && t >= 0);
                    var r = t / 26 | 0, n = t % 26;
                    return this._expand(r + 1), this.words[r] = e ? this.words[r] | 1 << n : this.words[r] & ~(1 << n), this._strip();
                }, s.prototype.iadd = function(t) {
                    var e, r, i;
                    if (0 !== this.negative && 0 === t.negative) return this.negative = 0, e = this.isub(t), this.negative ^= 1, this._normSign();
                    if (0 === this.negative && 0 !== t.negative) return t.negative = 0, e = this.isub(t), t.negative = 1, e._normSign();
                    this.length > t.length ? (r = this, i = t) : (r = t, i = this);
                    for(var n = 0, s = 0; s < i.length; s++)e = (0 | r.words[s]) + (0 | i.words[s]) + n, this.words[s] = 67108863 & e, n = e >>> 26;
                    for(; 0 !== n && s < r.length; s++)e = (0 | r.words[s]) + n, this.words[s] = 67108863 & e, n = e >>> 26;
                    if (this.length = r.length, 0 !== n) this.words[this.length] = n, this.length++;
                    else if (r !== this) for(; s < r.length; s++)this.words[s] = r.words[s];
                    return this;
                }, s.prototype.add = function(t) {
                    var e;
                    return 0 !== t.negative && 0 === this.negative ? (t.negative = 0, e = this.sub(t), t.negative ^= 1, e) : 0 === t.negative && 0 !== this.negative ? (this.negative = 0, e = t.sub(this), this.negative = 1, e) : this.length > t.length ? this.clone().iadd(t) : t.clone().iadd(this);
                }, s.prototype.isub = function(t) {
                    if (0 !== t.negative) {
                        t.negative = 0;
                        var e = this.iadd(t);
                        return t.negative = 1, e._normSign();
                    }
                    if (0 !== this.negative) return this.negative = 0, this.iadd(t), this.negative = 1, this._normSign();
                    var r, i, n = this.cmp(t);
                    if (0 === n) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                    n > 0 ? (r = this, i = t) : (r = t, i = this);
                    for(var s = 0, a = 0; a < i.length; a++)s = (e = (0 | r.words[a]) - (0 | i.words[a]) + s) >> 26, this.words[a] = 67108863 & e;
                    for(; 0 !== s && a < r.length; a++)s = (e = (0 | r.words[a]) + s) >> 26, this.words[a] = 67108863 & e;
                    if (0 === s && a < r.length && r !== this) for(; a < r.length; a++)this.words[a] = r.words[a];
                    return this.length = Math.max(this.length, a), r !== this && (this.negative = 1), this._strip();
                }, s.prototype.sub = function(t) {
                    return this.clone().isub(t);
                };
                var m = function(t, e, r) {
                    var i, n, s, a = t.words, o = e.words, h = r.words, c = 0, u = 0 | a[0], f = 8191 & u, d = u >>> 13, l = 0 | a[1], p = 8191 & l, b = l >>> 13, m = 0 | a[2], g = 8191 & m, y = m >>> 13, w = 0 | a[3], _ = 8191 & w, v = w >>> 13, S = 0 | a[4], O = 8191 & S, E = S >>> 13, I = 0 | a[5], B = 8191 & I, P = I >>> 13, R = 0 | a[6], k = 8191 & R, A = R >>> 13, N = 0 | a[7], x = 8191 & N, M = N >>> 13, T = 0 | a[8], C = 8191 & T, L = T >>> 13, H = 0 | a[9], U = 8191 & H, F = H >>> 13, D = 0 | o[0], K = 8191 & D, V = D >>> 13, j = 0 | o[1], q = 8191 & j, Y = j >>> 13, z = 0 | o[2], G = 8191 & z, J = z >>> 13, W = 0 | o[3], $ = 8191 & W, Q = W >>> 13, X = 0 | o[4], Z = 8191 & X, tt = X >>> 13, et = 0 | o[5], rt = 8191 & et, it = et >>> 13, nt = 0 | o[6], st = 8191 & nt, at = nt >>> 13, ot = 0 | o[7], ht = 8191 & ot, ct = ot >>> 13, ut = 0 | o[8], ft = 8191 & ut, dt = ut >>> 13, lt = 0 | o[9], pt = 8191 & lt, bt = lt >>> 13;
                    r.negative = t.negative ^ e.negative, r.length = 19;
                    var mt = (c + (i = Math.imul(f, K)) | 0) + ((8191 & (n = (n = Math.imul(f, V)) + Math.imul(d, K) | 0)) << 13) | 0;
                    c = ((s = Math.imul(d, V)) + (n >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, i = Math.imul(p, K), n = (n = Math.imul(p, V)) + Math.imul(b, K) | 0, s = Math.imul(b, V);
                    var gt = (c + (i = i + Math.imul(f, q) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(f, Y) | 0) + Math.imul(d, q) | 0)) << 13) | 0;
                    c = ((s = s + Math.imul(d, Y) | 0) + (n >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, i = Math.imul(g, K), n = (n = Math.imul(g, V)) + Math.imul(y, K) | 0, s = Math.imul(y, V), i = i + Math.imul(p, q) | 0, n = (n = n + Math.imul(p, Y) | 0) + Math.imul(b, q) | 0, s = s + Math.imul(b, Y) | 0;
                    var yt = (c + (i = i + Math.imul(f, G) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(f, J) | 0) + Math.imul(d, G) | 0)) << 13) | 0;
                    c = ((s = s + Math.imul(d, J) | 0) + (n >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, i = Math.imul(_, K), n = (n = Math.imul(_, V)) + Math.imul(v, K) | 0, s = Math.imul(v, V), i = i + Math.imul(g, q) | 0, n = (n = n + Math.imul(g, Y) | 0) + Math.imul(y, q) | 0, s = s + Math.imul(y, Y) | 0, i = i + Math.imul(p, G) | 0, n = (n = n + Math.imul(p, J) | 0) + Math.imul(b, G) | 0, s = s + Math.imul(b, J) | 0;
                    var wt = (c + (i = i + Math.imul(f, $) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(f, Q) | 0) + Math.imul(d, $) | 0)) << 13) | 0;
                    c = ((s = s + Math.imul(d, Q) | 0) + (n >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, i = Math.imul(O, K), n = (n = Math.imul(O, V)) + Math.imul(E, K) | 0, s = Math.imul(E, V), i = i + Math.imul(_, q) | 0, n = (n = n + Math.imul(_, Y) | 0) + Math.imul(v, q) | 0, s = s + Math.imul(v, Y) | 0, i = i + Math.imul(g, G) | 0, n = (n = n + Math.imul(g, J) | 0) + Math.imul(y, G) | 0, s = s + Math.imul(y, J) | 0, i = i + Math.imul(p, $) | 0, n = (n = n + Math.imul(p, Q) | 0) + Math.imul(b, $) | 0, s = s + Math.imul(b, Q) | 0;
                    var _t = (c + (i = i + Math.imul(f, Z) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(f, tt) | 0) + Math.imul(d, Z) | 0)) << 13) | 0;
                    c = ((s = s + Math.imul(d, tt) | 0) + (n >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, i = Math.imul(B, K), n = (n = Math.imul(B, V)) + Math.imul(P, K) | 0, s = Math.imul(P, V), i = i + Math.imul(O, q) | 0, n = (n = n + Math.imul(O, Y) | 0) + Math.imul(E, q) | 0, s = s + Math.imul(E, Y) | 0, i = i + Math.imul(_, G) | 0, n = (n = n + Math.imul(_, J) | 0) + Math.imul(v, G) | 0, s = s + Math.imul(v, J) | 0, i = i + Math.imul(g, $) | 0, n = (n = n + Math.imul(g, Q) | 0) + Math.imul(y, $) | 0, s = s + Math.imul(y, Q) | 0, i = i + Math.imul(p, Z) | 0, n = (n = n + Math.imul(p, tt) | 0) + Math.imul(b, Z) | 0, s = s + Math.imul(b, tt) | 0;
                    var vt = (c + (i = i + Math.imul(f, rt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(f, it) | 0) + Math.imul(d, rt) | 0)) << 13) | 0;
                    c = ((s = s + Math.imul(d, it) | 0) + (n >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, i = Math.imul(k, K), n = (n = Math.imul(k, V)) + Math.imul(A, K) | 0, s = Math.imul(A, V), i = i + Math.imul(B, q) | 0, n = (n = n + Math.imul(B, Y) | 0) + Math.imul(P, q) | 0, s = s + Math.imul(P, Y) | 0, i = i + Math.imul(O, G) | 0, n = (n = n + Math.imul(O, J) | 0) + Math.imul(E, G) | 0, s = s + Math.imul(E, J) | 0, i = i + Math.imul(_, $) | 0, n = (n = n + Math.imul(_, Q) | 0) + Math.imul(v, $) | 0, s = s + Math.imul(v, Q) | 0, i = i + Math.imul(g, Z) | 0, n = (n = n + Math.imul(g, tt) | 0) + Math.imul(y, Z) | 0, s = s + Math.imul(y, tt) | 0, i = i + Math.imul(p, rt) | 0, n = (n = n + Math.imul(p, it) | 0) + Math.imul(b, rt) | 0, s = s + Math.imul(b, it) | 0;
                    var St = (c + (i = i + Math.imul(f, st) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(f, at) | 0) + Math.imul(d, st) | 0)) << 13) | 0;
                    c = ((s = s + Math.imul(d, at) | 0) + (n >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, i = Math.imul(x, K), n = (n = Math.imul(x, V)) + Math.imul(M, K) | 0, s = Math.imul(M, V), i = i + Math.imul(k, q) | 0, n = (n = n + Math.imul(k, Y) | 0) + Math.imul(A, q) | 0, s = s + Math.imul(A, Y) | 0, i = i + Math.imul(B, G) | 0, n = (n = n + Math.imul(B, J) | 0) + Math.imul(P, G) | 0, s = s + Math.imul(P, J) | 0, i = i + Math.imul(O, $) | 0, n = (n = n + Math.imul(O, Q) | 0) + Math.imul(E, $) | 0, s = s + Math.imul(E, Q) | 0, i = i + Math.imul(_, Z) | 0, n = (n = n + Math.imul(_, tt) | 0) + Math.imul(v, Z) | 0, s = s + Math.imul(v, tt) | 0, i = i + Math.imul(g, rt) | 0, n = (n = n + Math.imul(g, it) | 0) + Math.imul(y, rt) | 0, s = s + Math.imul(y, it) | 0, i = i + Math.imul(p, st) | 0, n = (n = n + Math.imul(p, at) | 0) + Math.imul(b, st) | 0, s = s + Math.imul(b, at) | 0;
                    var Ot = (c + (i = i + Math.imul(f, ht) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(f, ct) | 0) + Math.imul(d, ht) | 0)) << 13) | 0;
                    c = ((s = s + Math.imul(d, ct) | 0) + (n >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, i = Math.imul(C, K), n = (n = Math.imul(C, V)) + Math.imul(L, K) | 0, s = Math.imul(L, V), i = i + Math.imul(x, q) | 0, n = (n = n + Math.imul(x, Y) | 0) + Math.imul(M, q) | 0, s = s + Math.imul(M, Y) | 0, i = i + Math.imul(k, G) | 0, n = (n = n + Math.imul(k, J) | 0) + Math.imul(A, G) | 0, s = s + Math.imul(A, J) | 0, i = i + Math.imul(B, $) | 0, n = (n = n + Math.imul(B, Q) | 0) + Math.imul(P, $) | 0, s = s + Math.imul(P, Q) | 0, i = i + Math.imul(O, Z) | 0, n = (n = n + Math.imul(O, tt) | 0) + Math.imul(E, Z) | 0, s = s + Math.imul(E, tt) | 0, i = i + Math.imul(_, rt) | 0, n = (n = n + Math.imul(_, it) | 0) + Math.imul(v, rt) | 0, s = s + Math.imul(v, it) | 0, i = i + Math.imul(g, st) | 0, n = (n = n + Math.imul(g, at) | 0) + Math.imul(y, st) | 0, s = s + Math.imul(y, at) | 0, i = i + Math.imul(p, ht) | 0, n = (n = n + Math.imul(p, ct) | 0) + Math.imul(b, ht) | 0, s = s + Math.imul(b, ct) | 0;
                    var Et = (c + (i = i + Math.imul(f, ft) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(f, dt) | 0) + Math.imul(d, ft) | 0)) << 13) | 0;
                    c = ((s = s + Math.imul(d, dt) | 0) + (n >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, i = Math.imul(U, K), n = (n = Math.imul(U, V)) + Math.imul(F, K) | 0, s = Math.imul(F, V), i = i + Math.imul(C, q) | 0, n = (n = n + Math.imul(C, Y) | 0) + Math.imul(L, q) | 0, s = s + Math.imul(L, Y) | 0, i = i + Math.imul(x, G) | 0, n = (n = n + Math.imul(x, J) | 0) + Math.imul(M, G) | 0, s = s + Math.imul(M, J) | 0, i = i + Math.imul(k, $) | 0, n = (n = n + Math.imul(k, Q) | 0) + Math.imul(A, $) | 0, s = s + Math.imul(A, Q) | 0, i = i + Math.imul(B, Z) | 0, n = (n = n + Math.imul(B, tt) | 0) + Math.imul(P, Z) | 0, s = s + Math.imul(P, tt) | 0, i = i + Math.imul(O, rt) | 0, n = (n = n + Math.imul(O, it) | 0) + Math.imul(E, rt) | 0, s = s + Math.imul(E, it) | 0, i = i + Math.imul(_, st) | 0, n = (n = n + Math.imul(_, at) | 0) + Math.imul(v, st) | 0, s = s + Math.imul(v, at) | 0, i = i + Math.imul(g, ht) | 0, n = (n = n + Math.imul(g, ct) | 0) + Math.imul(y, ht) | 0, s = s + Math.imul(y, ct) | 0, i = i + Math.imul(p, ft) | 0, n = (n = n + Math.imul(p, dt) | 0) + Math.imul(b, ft) | 0, s = s + Math.imul(b, dt) | 0;
                    var It = (c + (i = i + Math.imul(f, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(f, bt) | 0) + Math.imul(d, pt) | 0)) << 13) | 0;
                    c = ((s = s + Math.imul(d, bt) | 0) + (n >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, i = Math.imul(U, q), n = (n = Math.imul(U, Y)) + Math.imul(F, q) | 0, s = Math.imul(F, Y), i = i + Math.imul(C, G) | 0, n = (n = n + Math.imul(C, J) | 0) + Math.imul(L, G) | 0, s = s + Math.imul(L, J) | 0, i = i + Math.imul(x, $) | 0, n = (n = n + Math.imul(x, Q) | 0) + Math.imul(M, $) | 0, s = s + Math.imul(M, Q) | 0, i = i + Math.imul(k, Z) | 0, n = (n = n + Math.imul(k, tt) | 0) + Math.imul(A, Z) | 0, s = s + Math.imul(A, tt) | 0, i = i + Math.imul(B, rt) | 0, n = (n = n + Math.imul(B, it) | 0) + Math.imul(P, rt) | 0, s = s + Math.imul(P, it) | 0, i = i + Math.imul(O, st) | 0, n = (n = n + Math.imul(O, at) | 0) + Math.imul(E, st) | 0, s = s + Math.imul(E, at) | 0, i = i + Math.imul(_, ht) | 0, n = (n = n + Math.imul(_, ct) | 0) + Math.imul(v, ht) | 0, s = s + Math.imul(v, ct) | 0, i = i + Math.imul(g, ft) | 0, n = (n = n + Math.imul(g, dt) | 0) + Math.imul(y, ft) | 0, s = s + Math.imul(y, dt) | 0;
                    var Bt = (c + (i = i + Math.imul(p, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(p, bt) | 0) + Math.imul(b, pt) | 0)) << 13) | 0;
                    c = ((s = s + Math.imul(b, bt) | 0) + (n >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, i = Math.imul(U, G), n = (n = Math.imul(U, J)) + Math.imul(F, G) | 0, s = Math.imul(F, J), i = i + Math.imul(C, $) | 0, n = (n = n + Math.imul(C, Q) | 0) + Math.imul(L, $) | 0, s = s + Math.imul(L, Q) | 0, i = i + Math.imul(x, Z) | 0, n = (n = n + Math.imul(x, tt) | 0) + Math.imul(M, Z) | 0, s = s + Math.imul(M, tt) | 0, i = i + Math.imul(k, rt) | 0, n = (n = n + Math.imul(k, it) | 0) + Math.imul(A, rt) | 0, s = s + Math.imul(A, it) | 0, i = i + Math.imul(B, st) | 0, n = (n = n + Math.imul(B, at) | 0) + Math.imul(P, st) | 0, s = s + Math.imul(P, at) | 0, i = i + Math.imul(O, ht) | 0, n = (n = n + Math.imul(O, ct) | 0) + Math.imul(E, ht) | 0, s = s + Math.imul(E, ct) | 0, i = i + Math.imul(_, ft) | 0, n = (n = n + Math.imul(_, dt) | 0) + Math.imul(v, ft) | 0, s = s + Math.imul(v, dt) | 0;
                    var Pt = (c + (i = i + Math.imul(g, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(g, bt) | 0) + Math.imul(y, pt) | 0)) << 13) | 0;
                    c = ((s = s + Math.imul(y, bt) | 0) + (n >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, i = Math.imul(U, $), n = (n = Math.imul(U, Q)) + Math.imul(F, $) | 0, s = Math.imul(F, Q), i = i + Math.imul(C, Z) | 0, n = (n = n + Math.imul(C, tt) | 0) + Math.imul(L, Z) | 0, s = s + Math.imul(L, tt) | 0, i = i + Math.imul(x, rt) | 0, n = (n = n + Math.imul(x, it) | 0) + Math.imul(M, rt) | 0, s = s + Math.imul(M, it) | 0, i = i + Math.imul(k, st) | 0, n = (n = n + Math.imul(k, at) | 0) + Math.imul(A, st) | 0, s = s + Math.imul(A, at) | 0, i = i + Math.imul(B, ht) | 0, n = (n = n + Math.imul(B, ct) | 0) + Math.imul(P, ht) | 0, s = s + Math.imul(P, ct) | 0, i = i + Math.imul(O, ft) | 0, n = (n = n + Math.imul(O, dt) | 0) + Math.imul(E, ft) | 0, s = s + Math.imul(E, dt) | 0;
                    var Rt = (c + (i = i + Math.imul(_, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(_, bt) | 0) + Math.imul(v, pt) | 0)) << 13) | 0;
                    c = ((s = s + Math.imul(v, bt) | 0) + (n >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, i = Math.imul(U, Z), n = (n = Math.imul(U, tt)) + Math.imul(F, Z) | 0, s = Math.imul(F, tt), i = i + Math.imul(C, rt) | 0, n = (n = n + Math.imul(C, it) | 0) + Math.imul(L, rt) | 0, s = s + Math.imul(L, it) | 0, i = i + Math.imul(x, st) | 0, n = (n = n + Math.imul(x, at) | 0) + Math.imul(M, st) | 0, s = s + Math.imul(M, at) | 0, i = i + Math.imul(k, ht) | 0, n = (n = n + Math.imul(k, ct) | 0) + Math.imul(A, ht) | 0, s = s + Math.imul(A, ct) | 0, i = i + Math.imul(B, ft) | 0, n = (n = n + Math.imul(B, dt) | 0) + Math.imul(P, ft) | 0, s = s + Math.imul(P, dt) | 0;
                    var kt = (c + (i = i + Math.imul(O, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(O, bt) | 0) + Math.imul(E, pt) | 0)) << 13) | 0;
                    c = ((s = s + Math.imul(E, bt) | 0) + (n >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, i = Math.imul(U, rt), n = (n = Math.imul(U, it)) + Math.imul(F, rt) | 0, s = Math.imul(F, it), i = i + Math.imul(C, st) | 0, n = (n = n + Math.imul(C, at) | 0) + Math.imul(L, st) | 0, s = s + Math.imul(L, at) | 0, i = i + Math.imul(x, ht) | 0, n = (n = n + Math.imul(x, ct) | 0) + Math.imul(M, ht) | 0, s = s + Math.imul(M, ct) | 0, i = i + Math.imul(k, ft) | 0, n = (n = n + Math.imul(k, dt) | 0) + Math.imul(A, ft) | 0, s = s + Math.imul(A, dt) | 0;
                    var At = (c + (i = i + Math.imul(B, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(B, bt) | 0) + Math.imul(P, pt) | 0)) << 13) | 0;
                    c = ((s = s + Math.imul(P, bt) | 0) + (n >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, i = Math.imul(U, st), n = (n = Math.imul(U, at)) + Math.imul(F, st) | 0, s = Math.imul(F, at), i = i + Math.imul(C, ht) | 0, n = (n = n + Math.imul(C, ct) | 0) + Math.imul(L, ht) | 0, s = s + Math.imul(L, ct) | 0, i = i + Math.imul(x, ft) | 0, n = (n = n + Math.imul(x, dt) | 0) + Math.imul(M, ft) | 0, s = s + Math.imul(M, dt) | 0;
                    var Nt = (c + (i = i + Math.imul(k, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(k, bt) | 0) + Math.imul(A, pt) | 0)) << 13) | 0;
                    c = ((s = s + Math.imul(A, bt) | 0) + (n >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, i = Math.imul(U, ht), n = (n = Math.imul(U, ct)) + Math.imul(F, ht) | 0, s = Math.imul(F, ct), i = i + Math.imul(C, ft) | 0, n = (n = n + Math.imul(C, dt) | 0) + Math.imul(L, ft) | 0, s = s + Math.imul(L, dt) | 0;
                    var xt = (c + (i = i + Math.imul(x, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(x, bt) | 0) + Math.imul(M, pt) | 0)) << 13) | 0;
                    c = ((s = s + Math.imul(M, bt) | 0) + (n >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, i = Math.imul(U, ft), n = (n = Math.imul(U, dt)) + Math.imul(F, ft) | 0, s = Math.imul(F, dt);
                    var Mt = (c + (i = i + Math.imul(C, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(C, bt) | 0) + Math.imul(L, pt) | 0)) << 13) | 0;
                    c = ((s = s + Math.imul(L, bt) | 0) + (n >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863;
                    var Tt = (c + (i = Math.imul(U, pt)) | 0) + ((8191 & (n = (n = Math.imul(U, bt)) + Math.imul(F, pt) | 0)) << 13) | 0;
                    return c = ((s = Math.imul(F, bt)) + (n >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, h[0] = mt, h[1] = gt, h[2] = yt, h[3] = wt, h[4] = _t, h[5] = vt, h[6] = St, h[7] = Ot, h[8] = Et, h[9] = It, h[10] = Bt, h[11] = Pt, h[12] = Rt, h[13] = kt, h[14] = At, h[15] = Nt, h[16] = xt, h[17] = Mt, h[18] = Tt, 0 !== c && (h[19] = c, r.length++), r;
                };
                function g(t, e, r) {
                    r.negative = e.negative ^ t.negative, r.length = t.length + e.length;
                    for(var i = 0, n = 0, s = 0; s < r.length - 1; s++){
                        var a = n;
                        n = 0;
                        for(var o = 67108863 & i, h = Math.min(s, e.length - 1), c = Math.max(0, s - t.length + 1); c <= h; c++){
                            var u = s - c, f = (0 | t.words[u]) * (0 | e.words[c]), d = 67108863 & f;
                            o = 67108863 & (d = d + o | 0), n += (a = (a = a + (f / 67108864 | 0) | 0) + (d >>> 26) | 0) >>> 26, a &= 67108863;
                        }
                        r.words[s] = o, i = a, a = n;
                    }
                    return 0 !== i ? r.words[s] = i : r.length--, r._strip();
                }
                function y(t, e, r) {
                    return g(t, e, r);
                }
                function w(t, e) {
                    this.x = t, this.y = e;
                }
                Math.imul || (m = b), s.prototype.mulTo = function(t, e) {
                    var r = this.length + t.length;
                    return 10 === this.length && 10 === t.length ? m(this, t, e) : r < 63 ? b(this, t, e) : r < 1024 ? g(this, t, e) : y(this, t, e);
                }, w.prototype.makeRBT = function(t) {
                    for(var e = new Array(t), r = s.prototype._countBits(t) - 1, i = 0; i < t; i++)e[i] = this.revBin(i, r, t);
                    return e;
                }, w.prototype.revBin = function(t, e, r) {
                    if (0 === t || t === r - 1) return t;
                    for(var i = 0, n = 0; n < e; n++)i |= (1 & t) << e - n - 1, t >>= 1;
                    return i;
                }, w.prototype.permute = function(t, e, r, i, n, s) {
                    for(var a = 0; a < s; a++)i[a] = e[t[a]], n[a] = r[t[a]];
                }, w.prototype.transform = function(t, e, r, i, n, s) {
                    this.permute(s, t, e, r, i, n);
                    for(var a = 1; a < n; a <<= 1)for(var o = a << 1, h = Math.cos(2 * Math.PI / o), c = Math.sin(2 * Math.PI / o), u = 0; u < n; u += o)for(var f = h, d = c, l = 0; l < a; l++){
                        var p = r[u + l], b = i[u + l], m = r[u + l + a], g = i[u + l + a], y = f * m - d * g;
                        g = f * g + d * m, m = y, r[u + l] = p + m, i[u + l] = b + g, r[u + l + a] = p - m, i[u + l + a] = b - g, l !== o && (y = h * f - c * d, d = h * d + c * f, f = y);
                    }
                }, w.prototype.guessLen13b = function(t, e) {
                    var r = 1 | Math.max(e, t), i = 1 & r, n = 0;
                    for(r = r / 2 | 0; r; r >>>= 1)n++;
                    return 1 << n + 1 + i;
                }, w.prototype.conjugate = function(t, e, r) {
                    if (!(r <= 1)) for(var i = 0; i < r / 2; i++){
                        var n = t[i];
                        t[i] = t[r - i - 1], t[r - i - 1] = n, n = e[i], e[i] = -e[r - i - 1], e[r - i - 1] = -n;
                    }
                }, w.prototype.normalize13b = function(t, e) {
                    for(var r = 0, i = 0; i < e / 2; i++){
                        var n = 8192 * Math.round(t[2 * i + 1] / e) + Math.round(t[2 * i] / e) + r;
                        t[i] = 67108863 & n, r = n < 67108864 ? 0 : n / 67108864 | 0;
                    }
                    return t;
                }, w.prototype.convert13b = function(t, e, r, n) {
                    for(var s = 0, a = 0; a < e; a++)s += 0 | t[a], r[2 * a] = 8191 & s, s >>>= 13, r[2 * a + 1] = 8191 & s, s >>>= 13;
                    for(a = 2 * e; a < n; ++a)r[a] = 0;
                    i(0 === s), i(0 == (-8192 & s));
                }, w.prototype.stub = function(t) {
                    for(var e = new Array(t), r = 0; r < t; r++)e[r] = 0;
                    return e;
                }, w.prototype.mulp = function(t, e, r) {
                    var i = 2 * this.guessLen13b(t.length, e.length), n = this.makeRBT(i), s = this.stub(i), a = new Array(i), o = new Array(i), h = new Array(i), c = new Array(i), u = new Array(i), f = new Array(i), d = r.words;
                    d.length = i, this.convert13b(t.words, t.length, a, i), this.convert13b(e.words, e.length, c, i), this.transform(a, s, o, h, i, n), this.transform(c, s, u, f, i, n);
                    for(var l = 0; l < i; l++){
                        var p = o[l] * u[l] - h[l] * f[l];
                        h[l] = o[l] * f[l] + h[l] * u[l], o[l] = p;
                    }
                    return this.conjugate(o, h, i), this.transform(o, h, d, s, i, n), this.conjugate(d, s, i), this.normalize13b(d, i), r.negative = t.negative ^ e.negative, r.length = t.length + e.length, r._strip();
                }, s.prototype.mul = function(t) {
                    var e = new s(null);
                    return e.words = new Array(this.length + t.length), this.mulTo(t, e);
                }, s.prototype.mulf = function(t) {
                    var e = new s(null);
                    return e.words = new Array(this.length + t.length), y(this, t, e);
                }, s.prototype.imul = function(t) {
                    return this.clone().mulTo(t, this);
                }, s.prototype.imuln = function(t) {
                    var e = t < 0;
                    e && (t = -t), i("number" == typeof t), i(t < 67108864);
                    for(var r = 0, n = 0; n < this.length; n++){
                        var s = (0 | this.words[n]) * t, a = (67108863 & s) + (67108863 & r);
                        r >>= 26, r += s / 67108864 | 0, r += a >>> 26, this.words[n] = 67108863 & a;
                    }
                    return 0 !== r && (this.words[n] = r, this.length++), e ? this.ineg() : this;
                }, s.prototype.muln = function(t) {
                    return this.clone().imuln(t);
                }, s.prototype.sqr = function() {
                    return this.mul(this);
                }, s.prototype.isqr = function() {
                    return this.imul(this.clone());
                }, s.prototype.pow = function(t) {
                    var e = function(t) {
                        for(var e = new Array(t.bitLength()), r = 0; r < e.length; r++){
                            var i = r / 26 | 0, n = r % 26;
                            e[r] = t.words[i] >>> n & 1;
                        }
                        return e;
                    }(t);
                    if (0 === e.length) return new s(1);
                    for(var r = this, i = 0; i < e.length && 0 === e[i]; i++, r = r.sqr());
                    if (++i < e.length) for(var n = r.sqr(); i < e.length; i++, n = n.sqr())0 !== e[i] && (r = r.mul(n));
                    return r;
                }, s.prototype.iushln = function(t) {
                    i("number" == typeof t && t >= 0);
                    var e, r = t % 26, n = (t - r) / 26, s = 67108863 >>> 26 - r << 26 - r;
                    if (0 !== r) {
                        var a = 0;
                        for(e = 0; e < this.length; e++){
                            var o = this.words[e] & s, h = (0 | this.words[e]) - o << r;
                            this.words[e] = h | a, a = o >>> 26 - r;
                        }
                        a && (this.words[e] = a, this.length++);
                    }
                    if (0 !== n) {
                        for(e = this.length - 1; e >= 0; e--)this.words[e + n] = this.words[e];
                        for(e = 0; e < n; e++)this.words[e] = 0;
                        this.length += n;
                    }
                    return this._strip();
                }, s.prototype.ishln = function(t) {
                    return i(0 === this.negative), this.iushln(t);
                }, s.prototype.iushrn = function(t, e, r) {
                    var n;
                    i("number" == typeof t && t >= 0), n = e ? (e - e % 26) / 26 : 0;
                    var s = t % 26, a = Math.min((t - s) / 26, this.length), o = 67108863 ^ 67108863 >>> s << s, h = r;
                    if (n -= a, n = Math.max(0, n), h) {
                        for(var c = 0; c < a; c++)h.words[c] = this.words[c];
                        h.length = a;
                    }
                    if (0 === a) ;
                    else if (this.length > a) for(this.length -= a, c = 0; c < this.length; c++)this.words[c] = this.words[c + a];
                    else this.words[0] = 0, this.length = 1;
                    var u = 0;
                    for(c = this.length - 1; c >= 0 && (0 !== u || c >= n); c--){
                        var f = 0 | this.words[c];
                        this.words[c] = u << 26 - s | f >>> s, u = f & o;
                    }
                    return h && 0 !== u && (h.words[h.length++] = u), 0 === this.length && (this.words[0] = 0, this.length = 1), this._strip();
                }, s.prototype.ishrn = function(t, e, r) {
                    return i(0 === this.negative), this.iushrn(t, e, r);
                }, s.prototype.shln = function(t) {
                    return this.clone().ishln(t);
                }, s.prototype.ushln = function(t) {
                    return this.clone().iushln(t);
                }, s.prototype.shrn = function(t) {
                    return this.clone().ishrn(t);
                }, s.prototype.ushrn = function(t) {
                    return this.clone().iushrn(t);
                }, s.prototype.testn = function(t) {
                    i("number" == typeof t && t >= 0);
                    var e = t % 26, r = (t - e) / 26, n = 1 << e;
                    return !(this.length <= r) && !!(this.words[r] & n);
                }, s.prototype.imaskn = function(t) {
                    i("number" == typeof t && t >= 0);
                    var e = t % 26, r = (t - e) / 26;
                    if (i(0 === this.negative, "imaskn works only with positive numbers"), this.length <= r) return this;
                    if (0 !== e && r++, this.length = Math.min(r, this.length), 0 !== e) {
                        var n = 67108863 ^ 67108863 >>> e << e;
                        this.words[this.length - 1] &= n;
                    }
                    return this._strip();
                }, s.prototype.maskn = function(t) {
                    return this.clone().imaskn(t);
                }, s.prototype.iaddn = function(t) {
                    return i("number" == typeof t), i(t < 67108864), t < 0 ? this.isubn(-t) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) <= t ? (this.words[0] = t - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(t), this.negative = 1, this) : this._iaddn(t);
                }, s.prototype._iaddn = function(t) {
                    this.words[0] += t;
                    for(var e = 0; e < this.length && this.words[e] >= 67108864; e++)this.words[e] -= 67108864, e === this.length - 1 ? this.words[e + 1] = 1 : this.words[e + 1]++;
                    return this.length = Math.max(this.length, e + 1), this;
                }, s.prototype.isubn = function(t) {
                    if (i("number" == typeof t), i(t < 67108864), t < 0) return this.iaddn(-t);
                    if (0 !== this.negative) return this.negative = 0, this.iaddn(t), this.negative = 1, this;
                    if (this.words[0] -= t, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                    else for(var e = 0; e < this.length && this.words[e] < 0; e++)this.words[e] += 67108864, this.words[e + 1] -= 1;
                    return this._strip();
                }, s.prototype.addn = function(t) {
                    return this.clone().iaddn(t);
                }, s.prototype.subn = function(t) {
                    return this.clone().isubn(t);
                }, s.prototype.iabs = function() {
                    return this.negative = 0, this;
                }, s.prototype.abs = function() {
                    return this.clone().iabs();
                }, s.prototype._ishlnsubmul = function(t, e, r) {
                    var n, s, a = t.length + r;
                    this._expand(a);
                    var o = 0;
                    for(n = 0; n < t.length; n++){
                        s = (0 | this.words[n + r]) + o;
                        var h = (0 | t.words[n]) * e;
                        o = ((s -= 67108863 & h) >> 26) - (h / 67108864 | 0), this.words[n + r] = 67108863 & s;
                    }
                    for(; n < this.length - r; n++)o = (s = (0 | this.words[n + r]) + o) >> 26, this.words[n + r] = 67108863 & s;
                    if (0 === o) return this._strip();
                    for(i(-1 === o), o = 0, n = 0; n < this.length; n++)o = (s = -(0 | this.words[n]) + o) >> 26, this.words[n] = 67108863 & s;
                    return this.negative = 1, this._strip();
                }, s.prototype._wordDiv = function(t, e) {
                    var r = (this.length, t.length), i = this.clone(), n = t, a = 0 | n.words[n.length - 1];
                    0 !== (r = 26 - this._countBits(a)) && (n = n.ushln(r), i.iushln(r), a = 0 | n.words[n.length - 1]);
                    var o, h = i.length - n.length;
                    if ("mod" !== e) {
                        (o = new s(null)).length = h + 1, o.words = new Array(o.length);
                        for(var c = 0; c < o.length; c++)o.words[c] = 0;
                    }
                    var u = i.clone()._ishlnsubmul(n, 1, h);
                    0 === u.negative && (i = u, o && (o.words[h] = 1));
                    for(var f = h - 1; f >= 0; f--){
                        var d = 67108864 * (0 | i.words[n.length + f]) + (0 | i.words[n.length + f - 1]);
                        for(d = Math.min(d / a | 0, 67108863), i._ishlnsubmul(n, d, f); 0 !== i.negative;)d--, i.negative = 0, i._ishlnsubmul(n, 1, f), i.isZero() || (i.negative ^= 1);
                        o && (o.words[f] = d);
                    }
                    return o && o._strip(), i._strip(), "div" !== e && 0 !== r && i.iushrn(r), {
                        div: o || null,
                        mod: i
                    };
                }, s.prototype.divmod = function(t, e, r) {
                    var n, a, o;
                    return i(!t.isZero()), this.isZero() ? {
                        div: new s(0),
                        mod: new s(0)
                    } : 0 !== this.negative && 0 === t.negative ? (o = this.neg().divmod(t, e), "mod" !== e && (n = o.div.neg()), "div" !== e && (a = o.mod.neg(), r && 0 !== a.negative && a.iadd(t)), {
                        div: n,
                        mod: a
                    }) : 0 === this.negative && 0 !== t.negative ? (o = this.divmod(t.neg(), e), "mod" !== e && (n = o.div.neg()), {
                        div: n,
                        mod: o.mod
                    }) : 0 != (this.negative & t.negative) ? (o = this.neg().divmod(t.neg(), e), "div" !== e && (a = o.mod.neg(), r && 0 !== a.negative && a.isub(t)), {
                        div: o.div,
                        mod: a
                    }) : t.length > this.length || this.cmp(t) < 0 ? {
                        div: new s(0),
                        mod: this
                    } : 1 === t.length ? "div" === e ? {
                        div: this.divn(t.words[0]),
                        mod: null
                    } : "mod" === e ? {
                        div: null,
                        mod: new s(this.modrn(t.words[0]))
                    } : {
                        div: this.divn(t.words[0]),
                        mod: new s(this.modrn(t.words[0]))
                    } : this._wordDiv(t, e);
                }, s.prototype.div = function(t) {
                    return this.divmod(t, "div", !1).div;
                }, s.prototype.mod = function(t) {
                    return this.divmod(t, "mod", !1).mod;
                }, s.prototype.umod = function(t) {
                    return this.divmod(t, "mod", !0).mod;
                }, s.prototype.divRound = function(t) {
                    var e = this.divmod(t);
                    if (e.mod.isZero()) return e.div;
                    var r = 0 !== e.div.negative ? e.mod.isub(t) : e.mod, i = t.ushrn(1), n = t.andln(1), s = r.cmp(i);
                    return s < 0 || 1 === n && 0 === s ? e.div : 0 !== e.div.negative ? e.div.isubn(1) : e.div.iaddn(1);
                }, s.prototype.modrn = function(t) {
                    var e = t < 0;
                    e && (t = -t), i(t <= 67108863);
                    for(var r = 67108864 % t, n = 0, s = this.length - 1; s >= 0; s--)n = (r * n + (0 | this.words[s])) % t;
                    return e ? -n : n;
                }, s.prototype.modn = function(t) {
                    return this.modrn(t);
                }, s.prototype.idivn = function(t) {
                    var e = t < 0;
                    e && (t = -t), i(t <= 67108863);
                    for(var r = 0, n = this.length - 1; n >= 0; n--){
                        var s = (0 | this.words[n]) + 67108864 * r;
                        this.words[n] = s / t | 0, r = s % t;
                    }
                    return this._strip(), e ? this.ineg() : this;
                }, s.prototype.divn = function(t) {
                    return this.clone().idivn(t);
                }, s.prototype.egcd = function(t) {
                    i(0 === t.negative), i(!t.isZero());
                    var e = this, r = t.clone();
                    e = 0 !== e.negative ? e.umod(t) : e.clone();
                    for(var n = new s(1), a = new s(0), o = new s(0), h = new s(1), c = 0; e.isEven() && r.isEven();)e.iushrn(1), r.iushrn(1), ++c;
                    for(var u = r.clone(), f = e.clone(); !e.isZero();){
                        for(var d = 0, l = 1; 0 == (e.words[0] & l) && d < 26; ++d, l <<= 1);
                        if (d > 0) for(e.iushrn(d); d-- > 0;)(n.isOdd() || a.isOdd()) && (n.iadd(u), a.isub(f)), n.iushrn(1), a.iushrn(1);
                        for(var p = 0, b = 1; 0 == (r.words[0] & b) && p < 26; ++p, b <<= 1);
                        if (p > 0) for(r.iushrn(p); p-- > 0;)(o.isOdd() || h.isOdd()) && (o.iadd(u), h.isub(f)), o.iushrn(1), h.iushrn(1);
                        e.cmp(r) >= 0 ? (e.isub(r), n.isub(o), a.isub(h)) : (r.isub(e), o.isub(n), h.isub(a));
                    }
                    return {
                        a: o,
                        b: h,
                        gcd: r.iushln(c)
                    };
                }, s.prototype._invmp = function(t) {
                    i(0 === t.negative), i(!t.isZero());
                    var e = this, r = t.clone();
                    e = 0 !== e.negative ? e.umod(t) : e.clone();
                    for(var n, a = new s(1), o = new s(0), h = r.clone(); e.cmpn(1) > 0 && r.cmpn(1) > 0;){
                        for(var c = 0, u = 1; 0 == (e.words[0] & u) && c < 26; ++c, u <<= 1);
                        if (c > 0) for(e.iushrn(c); c-- > 0;)a.isOdd() && a.iadd(h), a.iushrn(1);
                        for(var f = 0, d = 1; 0 == (r.words[0] & d) && f < 26; ++f, d <<= 1);
                        if (f > 0) for(r.iushrn(f); f-- > 0;)o.isOdd() && o.iadd(h), o.iushrn(1);
                        e.cmp(r) >= 0 ? (e.isub(r), a.isub(o)) : (r.isub(e), o.isub(a));
                    }
                    return (n = 0 === e.cmpn(1) ? a : o).cmpn(0) < 0 && n.iadd(t), n;
                }, s.prototype.gcd = function(t) {
                    if (this.isZero()) return t.abs();
                    if (t.isZero()) return this.abs();
                    var e = this.clone(), r = t.clone();
                    e.negative = 0, r.negative = 0;
                    for(var i = 0; e.isEven() && r.isEven(); i++)e.iushrn(1), r.iushrn(1);
                    for(;;){
                        for(; e.isEven();)e.iushrn(1);
                        for(; r.isEven();)r.iushrn(1);
                        var n = e.cmp(r);
                        if (n < 0) {
                            var s = e;
                            e = r, r = s;
                        } else if (0 === n || 0 === r.cmpn(1)) break;
                        e.isub(r);
                    }
                    return r.iushln(i);
                }, s.prototype.invm = function(t) {
                    return this.egcd(t).a.umod(t);
                }, s.prototype.isEven = function() {
                    return 0 == (1 & this.words[0]);
                }, s.prototype.isOdd = function() {
                    return 1 == (1 & this.words[0]);
                }, s.prototype.andln = function(t) {
                    return this.words[0] & t;
                }, s.prototype.bincn = function(t) {
                    i("number" == typeof t);
                    var e = t % 26, r = (t - e) / 26, n = 1 << e;
                    if (this.length <= r) return this._expand(r + 1), this.words[r] |= n, this;
                    for(var s = n, a = r; 0 !== s && a < this.length; a++){
                        var o = 0 | this.words[a];
                        s = (o += s) >>> 26, o &= 67108863, this.words[a] = o;
                    }
                    return 0 !== s && (this.words[a] = s, this.length++), this;
                }, s.prototype.isZero = function() {
                    return 1 === this.length && 0 === this.words[0];
                }, s.prototype.cmpn = function(t) {
                    var e, r = t < 0;
                    if (0 !== this.negative && !r) return -1;
                    if (0 === this.negative && r) return 1;
                    if (this._strip(), this.length > 1) e = 1;
                    else {
                        r && (t = -t), i(t <= 67108863, "Number is too big");
                        var n = 0 | this.words[0];
                        e = n === t ? 0 : n < t ? -1 : 1;
                    }
                    return 0 !== this.negative ? 0 | -e : e;
                }, s.prototype.cmp = function(t) {
                    if (0 !== this.negative && 0 === t.negative) return -1;
                    if (0 === this.negative && 0 !== t.negative) return 1;
                    var e = this.ucmp(t);
                    return 0 !== this.negative ? 0 | -e : e;
                }, s.prototype.ucmp = function(t) {
                    if (this.length > t.length) return 1;
                    if (this.length < t.length) return -1;
                    for(var e = 0, r = this.length - 1; r >= 0; r--){
                        var i = 0 | this.words[r], n = 0 | t.words[r];
                        if (i !== n) {
                            i < n ? e = -1 : i > n && (e = 1);
                            break;
                        }
                    }
                    return e;
                }, s.prototype.gtn = function(t) {
                    return 1 === this.cmpn(t);
                }, s.prototype.gt = function(t) {
                    return 1 === this.cmp(t);
                }, s.prototype.gten = function(t) {
                    return this.cmpn(t) >= 0;
                }, s.prototype.gte = function(t) {
                    return this.cmp(t) >= 0;
                }, s.prototype.ltn = function(t) {
                    return -1 === this.cmpn(t);
                }, s.prototype.lt = function(t) {
                    return -1 === this.cmp(t);
                }, s.prototype.lten = function(t) {
                    return this.cmpn(t) <= 0;
                }, s.prototype.lte = function(t) {
                    return this.cmp(t) <= 0;
                }, s.prototype.eqn = function(t) {
                    return 0 === this.cmpn(t);
                }, s.prototype.eq = function(t) {
                    return 0 === this.cmp(t);
                }, s.red = function(t) {
                    return new B(t);
                }, s.prototype.toRed = function(t) {
                    return i(!this.red, "Already a number in reduction context"), i(0 === this.negative, "red works only with positives"), t.convertTo(this)._forceRed(t);
                }, s.prototype.fromRed = function() {
                    return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
                }, s.prototype._forceRed = function(t) {
                    return this.red = t, this;
                }, s.prototype.forceRed = function(t) {
                    return i(!this.red, "Already a number in reduction context"), this._forceRed(t);
                }, s.prototype.redAdd = function(t) {
                    return i(this.red, "redAdd works only with red numbers"), this.red.add(this, t);
                }, s.prototype.redIAdd = function(t) {
                    return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t);
                }, s.prototype.redSub = function(t) {
                    return i(this.red, "redSub works only with red numbers"), this.red.sub(this, t);
                }, s.prototype.redISub = function(t) {
                    return i(this.red, "redISub works only with red numbers"), this.red.isub(this, t);
                }, s.prototype.redShl = function(t) {
                    return i(this.red, "redShl works only with red numbers"), this.red.shl(this, t);
                }, s.prototype.redMul = function(t) {
                    return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.mul(this, t);
                }, s.prototype.redIMul = function(t) {
                    return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.imul(this, t);
                }, s.prototype.redSqr = function() {
                    return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
                }, s.prototype.redISqr = function() {
                    return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
                }, s.prototype.redSqrt = function() {
                    return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
                }, s.prototype.redInvm = function() {
                    return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
                }, s.prototype.redNeg = function() {
                    return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
                }, s.prototype.redPow = function(t) {
                    return i(this.red && !t.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t);
                };
                var _ = {
                    k256: null,
                    p224: null,
                    p192: null,
                    p25519: null
                };
                function v(t, e) {
                    this.name = t, this.p = new s(e, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
                }
                function S() {
                    v.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
                }
                function O() {
                    v.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
                }
                function E() {
                    v.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
                }
                function I() {
                    v.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
                }
                function B(t) {
                    if ("string" == typeof t) {
                        var e = s._prime(t);
                        this.m = e.p, this.prime = e;
                    } else i(t.gtn(1), "modulus must be greater than 1"), this.m = t, this.prime = null;
                }
                function P(t) {
                    B.call(this, t), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
                }
                v.prototype._tmp = function() {
                    var t = new s(null);
                    return t.words = new Array(Math.ceil(this.n / 13)), t;
                }, v.prototype.ireduce = function(t) {
                    var e, r = t;
                    do this.split(r, this.tmp), e = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength();
                    while (e > this.n);
                    var i = e < this.n ? -1 : r.ucmp(this.p);
                    return 0 === i ? (r.words[0] = 0, r.length = 1) : i > 0 ? r.isub(this.p) : void 0 !== r.strip ? r.strip() : r._strip(), r;
                }, v.prototype.split = function(t, e) {
                    t.iushrn(this.n, 0, e);
                }, v.prototype.imulK = function(t) {
                    return t.imul(this.k);
                }, n(S, v), S.prototype.split = function(t, e) {
                    for(var r = Math.min(t.length, 9), i = 0; i < r; i++)e.words[i] = t.words[i];
                    if (e.length = r, t.length <= 9) return t.words[0] = 0, void (t.length = 1);
                    var n = t.words[9];
                    for(e.words[e.length++] = 4194303 & n, i = 10; i < t.length; i++){
                        var s = 0 | t.words[i];
                        t.words[i - 10] = (4194303 & s) << 4 | n >>> 22, n = s;
                    }
                    n >>>= 22, t.words[i - 10] = n, 0 === n && t.length > 10 ? t.length -= 10 : t.length -= 9;
                }, S.prototype.imulK = function(t) {
                    t.words[t.length] = 0, t.words[t.length + 1] = 0, t.length += 2;
                    for(var e = 0, r = 0; r < t.length; r++){
                        var i = 0 | t.words[r];
                        e += 977 * i, t.words[r] = 67108863 & e, e = 64 * i + (e / 67108864 | 0);
                    }
                    return 0 === t.words[t.length - 1] && (t.length--, 0 === t.words[t.length - 1] && t.length--), t;
                }, n(O, v), n(E, v), n(I, v), I.prototype.imulK = function(t) {
                    for(var e = 0, r = 0; r < t.length; r++){
                        var i = 19 * (0 | t.words[r]) + e, n = 67108863 & i;
                        i >>>= 26, t.words[r] = n, e = i;
                    }
                    return 0 !== e && (t.words[t.length++] = e), t;
                }, s._prime = function(t) {
                    if (_[t]) return _[t];
                    var e;
                    if ("k256" === t) e = new S;
                    else if ("p224" === t) e = new O;
                    else if ("p192" === t) e = new E;
                    else {
                        if ("p25519" !== t) throw new Error("Unknown prime " + t);
                        e = new I;
                    }
                    return _[t] = e, e;
                }, B.prototype._verify1 = function(t) {
                    i(0 === t.negative, "red works only with positives"), i(t.red, "red works only with red numbers");
                }, B.prototype._verify2 = function(t, e) {
                    i(0 == (t.negative | e.negative), "red works only with positives"), i(t.red && t.red === e.red, "red works only with red numbers");
                }, B.prototype.imod = function(t) {
                    return this.prime ? this.prime.ireduce(t)._forceRed(this) : (u(t, t.umod(this.m)._forceRed(this)), t);
                }, B.prototype.neg = function(t) {
                    return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this);
                }, B.prototype.add = function(t, e) {
                    this._verify2(t, e);
                    var r = t.add(e);
                    return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this);
                }, B.prototype.iadd = function(t, e) {
                    this._verify2(t, e);
                    var r = t.iadd(e);
                    return r.cmp(this.m) >= 0 && r.isub(this.m), r;
                }, B.prototype.sub = function(t, e) {
                    this._verify2(t, e);
                    var r = t.sub(e);
                    return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this);
                }, B.prototype.isub = function(t, e) {
                    this._verify2(t, e);
                    var r = t.isub(e);
                    return r.cmpn(0) < 0 && r.iadd(this.m), r;
                }, B.prototype.shl = function(t, e) {
                    return this._verify1(t), this.imod(t.ushln(e));
                }, B.prototype.imul = function(t, e) {
                    return this._verify2(t, e), this.imod(t.imul(e));
                }, B.prototype.mul = function(t, e) {
                    return this._verify2(t, e), this.imod(t.mul(e));
                }, B.prototype.isqr = function(t) {
                    return this.imul(t, t.clone());
                }, B.prototype.sqr = function(t) {
                    return this.mul(t, t);
                }, B.prototype.sqrt = function(t) {
                    if (t.isZero()) return t.clone();
                    var e = this.m.andln(3);
                    if (i(e % 2 == 1), 3 === e) {
                        var r = this.m.add(new s(1)).iushrn(2);
                        return this.pow(t, r);
                    }
                    for(var n = this.m.subn(1), a = 0; !n.isZero() && 0 === n.andln(1);)a++, n.iushrn(1);
                    i(!n.isZero());
                    var o = new s(1).toRed(this), h = o.redNeg(), c = this.m.subn(1).iushrn(1), u = this.m.bitLength();
                    for(u = new s(2 * u * u).toRed(this); 0 !== this.pow(u, c).cmp(h);)u.redIAdd(h);
                    for(var f = this.pow(u, n), d = this.pow(t, n.addn(1).iushrn(1)), l = this.pow(t, n), p = a; 0 !== l.cmp(o);){
                        for(var b = l, m = 0; 0 !== b.cmp(o); m++)b = b.redSqr();
                        i(m < p);
                        var g = this.pow(f, new s(1).iushln(p - m - 1));
                        d = d.redMul(g), f = g.redSqr(), l = l.redMul(f), p = m;
                    }
                    return d;
                }, B.prototype.invm = function(t) {
                    var e = t._invmp(this.m);
                    return 0 !== e.negative ? (e.negative = 0, this.imod(e).redNeg()) : this.imod(e);
                }, B.prototype.pow = function(t, e) {
                    if (e.isZero()) return new s(1).toRed(this);
                    if (0 === e.cmpn(1)) return t.clone();
                    var r = new Array(16);
                    r[0] = new s(1).toRed(this), r[1] = t;
                    for(var i = 2; i < r.length; i++)r[i] = this.mul(r[i - 1], t);
                    var n = r[0], a = 0, o = 0, h = e.bitLength() % 26;
                    for(0 === h && (h = 26), i = e.length - 1; i >= 0; i--){
                        for(var c = e.words[i], u = h - 1; u >= 0; u--){
                            var f = c >> u & 1;
                            n !== r[0] && (n = this.sqr(n)), 0 !== f || 0 !== a ? (a <<= 1, a |= f, (4 === ++o || 0 === i && 0 === u) && (n = this.mul(n, r[a]), o = 0, a = 0)) : o = 0;
                        }
                        h = 26;
                    }
                    return n;
                }, B.prototype.convertTo = function(t) {
                    var e = t.umod(this.m);
                    return e === t ? e.clone() : e;
                }, B.prototype.convertFrom = function(t) {
                    var e = t.clone();
                    return e.red = null, e;
                }, s.mont = function(t) {
                    return new P(t);
                }, n(P, B), P.prototype.convertTo = function(t) {
                    return this.imod(t.ushln(this.shift));
                }, P.prototype.convertFrom = function(t) {
                    var e = this.imod(t.mul(this.rinv));
                    return e.red = null, e;
                }, P.prototype.imul = function(t, e) {
                    if (t.isZero() || e.isZero()) return t.words[0] = 0, t.length = 1, t;
                    var r = t.imul(e), i = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), n = r.isub(i).iushrn(this.shift), s = n;
                    return n.cmp(this.m) >= 0 ? s = n.isub(this.m) : n.cmpn(0) < 0 && (s = n.iadd(this.m)), s._forceRed(this);
                }, P.prototype.mul = function(t, e) {
                    if (t.isZero() || e.isZero()) return new s(0)._forceRed(this);
                    var r = t.mul(e), i = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), n = r.isub(i).iushrn(this.shift), a = n;
                    return n.cmp(this.m) >= 0 ? a = n.isub(this.m) : n.cmpn(0) < 0 && (a = n.iadd(this.m)), a._forceRed(this);
                }, P.prototype.invm = function(t) {
                    return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this);
                };
            }(t, this);
        }).call(this, r(92)(t));
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return m;
            });
            var i = r(1), n = r(12), s = r(6), a = r(29), o = r(3), h = r(41), c = r(9), u = r(5), f = r(4), d = r(13), l = r(20), p = r(10), b = r(2);
            class m extends f.a {
                constructor(t = 1, e = p.a.fromNumber(0), r = [], i = p.a.fromNumber(0), n = [], s = 0){
                    super({
                        versionBytesNum: t,
                        txInsVi: e,
                        txIns: r,
                        txOutsVi: i,
                        txOuts: n,
                        nLockTime: s
                    });
                }
                fromJSON(t) {
                    const e = [];
                    for (const r of t.txIns)e.push((new d.a).fromJSON(r));
                    const r1 = [];
                    for (const e1 of t.txOuts)r1.push((new l.a).fromJSON(e1));
                    return this.fromObject({
                        versionBytesNum: t.versionBytesNum,
                        txInsVi: (new p.a).fromJSON(t.txInsVi),
                        txIns: e,
                        txOutsVi: (new p.a).fromJSON(t.txOutsVi),
                        txOuts: r1,
                        nLockTime: t.nLockTime
                    }), this;
                }
                toJSON() {
                    const t = [];
                    for (const e of this.txIns)t.push(e.toJSON());
                    const e1 = [];
                    for (const t1 of this.txOuts)e1.push(t1.toJSON());
                    return {
                        versionBytesNum: this.versionBytesNum,
                        txInsVi: this.txInsVi.toJSON(),
                        txIns: t,
                        txOutsVi: this.txOutsVi.toJSON(),
                        txOuts: e1,
                        nLockTime: this.nLockTime
                    };
                }
                fromBr(t) {
                    this.versionBytesNum = t.readUInt32LE(), this.txInsVi = new p.a(t.readVarIntBuf());
                    const e = this.txInsVi.toNumber();
                    this.txIns = [];
                    for(let r = 0; r < e; r++)this.txIns.push((new d.a).fromBr(t));
                    this.txOutsVi = new p.a(t.readVarIntBuf());
                    const r1 = this.txOutsVi.toNumber();
                    this.txOuts = [];
                    for(let e1 = 0; e1 < r1; e1++)this.txOuts.push((new l.a).fromBr(t));
                    return this.nLockTime = t.readUInt32LE(), this;
                }
                toBw(t) {
                    t || (t = new s.a), t.writeUInt32LE(this.versionBytesNum), t.write(this.txInsVi.buf);
                    for(let e = 0; e < this.txIns.length; e++)this.txIns[e].toBw(t);
                    t.write(this.txOutsVi.buf);
                    for(let e1 = 0; e1 < this.txOuts.length; e1++)this.txOuts[e1].toBw(t);
                    return t.writeUInt32LE(this.nLockTime), t;
                }
                hashPrevouts() {
                    const t = new s.a;
                    for(const e in this.txIns){
                        const r = this.txIns[e];
                        t.write(r.txHashBuf), t.writeUInt32LE(r.txOutNum);
                    }
                    return o.a.sha256Sha256(t.toBuffer());
                }
                hashSequence() {
                    const t = new s.a;
                    for(const e in this.txIns){
                        const r = this.txIns[e];
                        t.writeUInt32LE(r.nSequence);
                    }
                    return o.a.sha256Sha256(t.toBuffer());
                }
                hashOutputs() {
                    const t = new s.a;
                    for(const e in this.txOuts){
                        const r = this.txOuts[e];
                        t.write(r.toBuffer());
                    }
                    return o.a.sha256Sha256(t.toBuffer());
                }
                sighash(e, r, i, s, a = 0, c = new h.a) {
                    const u = this.sighashPreimage(e, r, i, s, a, c);
                    return 0 === u.compare(t.from("0000000000000000000000000000000000000000000000000000000000000001", "hex")) ? u : new n.a(o.a.sha256Sha256(u)).readReverse();
                }
                async asyncSighash(t, e, r, i, n = 0, s) {
                    return (await b.a.asyncObjectMethod(this, "sighash", [
                        t,
                        e,
                        r,
                        i,
                        n,
                        s
                    ])).resbuf;
                }
                sighashPreimage(e, r, n, a, f = 0, b = new h.a) {
                    if (e & u.a.SIGHASH_FORKID && f & m.SCRIPT_ENABLE_SIGHASH_FORKID) {
                        let i1 = t.alloc(32, 0), h1 = t.alloc(32, 0), c1 = t.alloc(32, 0);
                        e & u.a.SIGHASH_ANYONECANPAY || (i1 = b.prevoutsHashBuf ? b.prevoutsHashBuf : b.prevoutsHashBuf = this.hashPrevouts()), e & u.a.SIGHASH_ANYONECANPAY || (31 & e) === u.a.SIGHASH_SINGLE || (31 & e) === u.a.SIGHASH_NONE || (h1 = b.sequenceHashBuf ? b.sequenceHashBuf : b.sequenceHashBuf = this.hashSequence()), (31 & e) !== u.a.SIGHASH_SINGLE && (31 & e) !== u.a.SIGHASH_NONE ? c1 = b.outputsHashBuf ? b.outputsHashBuf : b.outputsHashBuf = this.hashOutputs() : (31 & e) === u.a.SIGHASH_SINGLE && r < this.txOuts.length && (c1 = o.a.sha256Sha256(this.txOuts[r].toBuffer()));
                        const f1 = new s.a;
                        return f1.writeUInt32LE(this.versionBytesNum), f1.write(i1), f1.write(h1), f1.write(this.txIns[r].txHashBuf), f1.writeUInt32LE(this.txIns[r].txOutNum), f1.writeVarIntNum(n.toBuffer().length), f1.write(n.toBuffer()), f1.writeUInt64LEBn(a), f1.writeUInt32LE(this.txIns[r].nSequence), f1.write(c1), f1.writeUInt32LE(this.nLockTime), f1.writeUInt32LE(e >>> 0), f1.toBuffer();
                    }
                    const g = this.cloneByBuffer();
                    (n = (new c.a).fromBuffer(n.toBuffer())).removeCodeseparators();
                    for(let t1 = 0; t1 < g.txIns.length; t1++)g.txIns[t1] = d.a.fromBuffer(g.txIns[t1].toBuffer()).setScript(new c.a);
                    if (g.txIns[r] = d.a.fromBuffer(g.txIns[r].toBuffer()).setScript(n), (31 & e) === u.a.SIGHASH_NONE) {
                        g.txOuts.length = 0, g.txOutsVi = p.a.fromNumber(0);
                        for(let t2 = 0; t2 < g.txIns.length; t2++)t2 !== r && (g.txIns[t2].nSequence = 0);
                    } else if ((31 & e) === u.a.SIGHASH_SINGLE) {
                        if (r > g.txOuts.length - 1) return t.from("0000000000000000000000000000000000000000000000000000000000000001", "hex");
                        g.txOuts.length = r + 1, g.txOutsVi = p.a.fromNumber(r + 1);
                        for(let e1 = 0; e1 < g.txOuts.length; e1++)e1 < r && (g.txOuts[e1] = l.a.fromProperties((new i.a).fromBuffer(t.from("ffffffffffffffff", "hex")), new c.a));
                        for(let t3 = 0; t3 < g.txIns.length; t3++)t3 !== r && (g.txIns[t3].nSequence = 0);
                    }
                    return e & u.a.SIGHASH_ANYONECANPAY && (g.txIns[0] = g.txIns[r], g.txIns.length = 1, g.txInsVi = p.a.fromNumber(1)), (new s.a).write(g.toBuffer()).writeInt32LE(e).toBuffer();
                }
                async asyncSighashPreimage(t, e, r, i, n = 0, s) {
                    return (await b.a.asyncObjectMethod(this, "sighashPreimage", [
                        t,
                        e,
                        r,
                        i,
                        n,
                        s
                    ])).resbuf;
                }
                sign(t, e = u.a.SIGHASH_ALL | u.a.SIGHASH_FORKID, r, i, n, s = m.SCRIPT_ENABLE_SIGHASH_FORKID, o) {
                    const h = this.sighash(e, r, i, n, s, o);
                    return a.a.sign(h, t, "little").fromObject({
                        nHashType: e
                    });
                }
                async asyncSign(t, e = u.a.SIGHASH_ALL | u.a.SIGHASH_FORKID, r, i, n, s = m.SCRIPT_ENABLE_SIGHASH_FORKID, a) {
                    const o = await b.a.asyncObjectMethod(this, "sign", [
                        t,
                        e,
                        r,
                        i,
                        n,
                        s,
                        a
                    ]);
                    return (new u.a).fromFastBuffer(o.resbuf);
                }
                verify(t, e, r, i, n = !1, s, o = m.SCRIPT_ENABLE_SIGHASH_FORKID, h) {
                    const c = this.sighash(t.nHashType, r, i, s, o, h);
                    return a.a.verify(c, t, e, "little", n);
                }
                async asyncVerify(t, e, r, i, n = !1, s, a = m.SCRIPT_ENABLE_SIGHASH_FORKID, o) {
                    const h = await b.a.asyncObjectMethod(this, "verify", [
                        t,
                        e,
                        r,
                        i,
                        n,
                        s,
                        a,
                        o
                    ]);
                    return JSON.parse(h.resbuf.toString());
                }
                hash() {
                    return o.a.sha256Sha256(this.toBuffer());
                }
                async asyncHash() {
                    return (await b.a.asyncObjectMethod(this, "hash", [])).resbuf;
                }
                id() {
                    return new n.a(this.hash()).readReverse().toString("hex");
                }
                async asyncId() {
                    const t = await b.a.asyncObjectMethod(this, "id", []);
                    return JSON.parse(t.resbuf.toString());
                }
                addTxIn(t, e, r, i) {
                    let n;
                    return n = t instanceof d.a ? t : (new d.a).fromObject({
                        txHashBuf: t,
                        txOutNum: e,
                        nSequence: i
                    }).setScript(r), this.txIns.push(n), this.txInsVi = p.a.fromNumber(this.txInsVi.toNumber() + 1), this;
                }
                addTxOut(t, e) {
                    let r;
                    return r = t instanceof l.a ? t : (new l.a).fromObject({
                        valueBn: t
                    }).setScript(e), this.txOuts.push(r), this.txOutsVi = p.a.fromNumber(this.txOutsVi.toNumber() + 1), this;
                }
                isCoinbase() {
                    return 1 === this.txIns.length && this.txIns[0].hasNullInput();
                }
                sort() {
                    return this.txIns.sort((t, e)=>new n.a(t.txHashBuf).readReverse().compare(new n.a(e.txHashBuf).readReverse()) || t.txOutNum - e.txOutNum), this.txOuts.sort((t, e)=>t.valueBn.sub(e.valueBn).toNumber() || t.script.toBuffer().compare(e.script.toBuffer())), this;
                }
            }
            m.MAX_MONEY = 21e14, m.SCRIPT_ENABLE_SIGHASH_FORKID = 65536;
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        r.d(e, "a", function() {
            return n;
        });
        var i = r(83);
        class n {
            static getRandomBuffer(t) {
                return i(t);
            }
        }
    },
    function(t, e) {
        "function" == typeof Object.create ? t.exports = function(t, e) {
            e && (t.super_ = e, t.prototype = Object.create(e.prototype, {
                constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }));
        } : t.exports = function(t, e) {
            if (e) {
                t.super_ = e;
                var r = function() {};
                r.prototype = e.prototype, t.prototype = new r, t.prototype.constructor = t;
            }
        };
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            function i(e, r) {
                if (!t.isBuffer(e) || !t.isBuffer(r)) throw new Error("buf1 and buf2 must be buffers");
                if (e.length !== r.length) return !1;
                let i = 0;
                for(let t1 = 0; t1 < e.length; t1++)i |= e[t1] ^ r[t1];
                return 0 === i;
            }
            r.d(e, "a", function() {
                return i;
            });
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        r.d(e, "a", function() {
            return n;
        }), r.d(e, "b", function() {
            return s;
        });
        var i = r(42);
        const n = {
            Mainnet: {
                MaxSize: 33554432,
                Port: 8333,
                Address: {
                    pubKeyHash: 0,
                    payToScriptHash: 5
                },
                Bip32: {
                    pubKey: 76067358,
                    privKey: 76066276
                },
                Block: {
                    maxNBits: 486604799,
                    magicNum: 3823236072
                },
                Msg: {
                    magicNum: 3823236072,
                    versionBytesNum: 70015
                },
                PrivKey: {
                    versionByteNum: 128
                },
                TxBuilder: {
                    dust: 546,
                    feePerKbNum: 500
                },
                Workers: {
                    timeout: 6e4
                }
            }
        };
        if (n.Testnet = Object.assign({}, n.Mainnet, {
            Port: 18333,
            Address: {
                pubKeyHash: 111,
                payToScriptHash: 196
            },
            Bip32: {
                pubKey: 70617039,
                privKey: 70615956
            },
            Block: {
                maxNBits: 486604799,
                magicNum: 4108710900
            },
            Msg: {
                magicNum: 4108710900,
                versionBytesNum: 70015
            },
            PrivKey: {
                versionByteNum: 239
            }
        }), n.Regtest = Object.assign({}, n.Mainnet, {
            Port: 18444,
            Address: {
                pubKeyHash: 111,
                payToScriptHash: 196
            },
            Bip32: {
                pubKey: 70617039,
                privKey: 70615956
            },
            Block: {
                maxNBits: 545259519,
                magicNum: 3669344250
            },
            Msg: {
                magicNum: 3669344250,
                versionBytesNum: 70015
            },
            PrivKey: {
                versionByteNum: 239
            }
        }), n.STN = Object.assign({}, n.Mainnet, {
            Port: 9333,
            Address: {
                pubKeyHash: 111,
                payToScriptHash: 196
            },
            Bip32: {
                pubKey: 70617039,
                privKey: 70615956
            },
            Block: {
                maxNBits: 486604799,
                magicNum: 4224632057
            },
            Msg: {
                magicNum: 4224632057,
                versionBytesNum: 70015
            },
            PrivKey: {
                versionByteNum: 239
            }
        }), "testnet" === i.a.get("NETWORK")) n.Default = Object.assign({}, n.Testnet);
        else if ("mainnet" === i.a.get("NETWORK")) n.Default = Object.assign({}, n.Mainnet);
        else if ("regtest" === i.a.get("NETWORK")) n.Default = Object.assign({}, n.Regtest);
        else {
            if ("stn" !== i.a.get("NETWORK")) throw new Error("must set network in environment variable - mainnet, testnet, regtest or stn?, received " + i.a.get("NETWORK"));
            n.Default = Object.assign({}, n.STN);
        }
        const s = (t)=>n.Mainnet.Msg.magicNum === t ? n.Mainnet : n.Testnet.Msg.magicNum === t ? n.Testnet : n.Regtest.Msg.magicNum === t ? n.Regtest : n.STN.Msg.magicNum === t ? n.STN : n.Default;
    },
    function(t, e, r) {
        "use strict";
        r.d(e, "a", function() {
            return h;
        });
        var i = r(1), n = r(6), s = r(9), a = r(4), o = r(10);
        class h extends a.a {
            constructor(t, e, r){
                super({
                    valueBn: t,
                    scriptVi: e,
                    script: r
                });
            }
            setScript(t) {
                return this.scriptVi = o.a.fromNumber(t.toBuffer().length), this.script = t, this;
            }
            fromProperties(t, e) {
                return this.fromObject({
                    valueBn: t
                }), this.setScript(e), this;
            }
            static fromProperties(t, e) {
                return (new this).fromProperties(t, e);
            }
            fromJSON(t) {
                return this.fromObject({
                    valueBn: (new i.a).fromJSON(t.valueBn),
                    scriptVi: (new o.a).fromJSON(t.scriptVi),
                    script: (new s.a).fromJSON(t.script)
                }), this;
            }
            toJSON() {
                return {
                    valueBn: this.valueBn.toJSON(),
                    scriptVi: this.scriptVi.toJSON(),
                    script: this.script.toJSON()
                };
            }
            fromBr(t) {
                return this.valueBn = t.readUInt64LEBn(), this.scriptVi = o.a.fromNumber(t.readVarIntNum()), this.script = (new s.a).fromBuffer(t.read(this.scriptVi.toNumber())), this;
            }
            toBw(t) {
                return t || (t = new n.a), t.writeUInt64LEBn(this.valueBn), t.write(this.scriptVi.buf), t.write(this.script.toBuffer()), t;
            }
        }
    },
    function(t, e, r) {
        /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ var i = r(7), n = i.Buffer;
        function s(t, e) {
            for(var r in t)e[r] = t[r];
        }
        function a(t, e, r) {
            return n(t, e, r);
        }
        n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? t.exports = i : (s(i, e), e.Buffer = a), a.prototype = Object.create(n.prototype), s(n, a), a.from = function(t, e, r) {
            if ("number" == typeof t) throw new TypeError("Argument must not be a number");
            return n(t, e, r);
        }, a.alloc = function(t, e, r) {
            if ("number" != typeof t) throw new TypeError("Argument must be a number");
            var i = n(t);
            return void 0 !== e ? "string" == typeof r ? i.fill(e, r) : i.fill(e) : i.fill(0), i;
        }, a.allocUnsafe = function(t) {
            if ("number" != typeof t) throw new TypeError("Argument must be a number");
            return n(t);
        }, a.allocUnsafeSlow = function(t) {
            if ("number" != typeof t) throw new TypeError("Argument must be a number");
            return i.SlowBuffer(t);
        };
    },
    function(t, e, r) {
        "use strict";
        r.d(e, "a", function() {
            return o;
        });
        var i = r(6), n = r(23), s = r(8), a = r(4);
        class o extends a.a {
            constructor(t, e, r = n.a){
                super({
                    privKey: t,
                    pubKey: e
                }), this.PrivKey = r;
            }
            fromJSON(t) {
                return t.privKey && (this.privKey = this.PrivKey.fromJSON(t.privKey)), t.pubKey && (this.pubKey = s.a.fromJSON(t.pubKey)), this;
            }
            fromBr(t) {
                const e = t.readUInt8();
                e > 0 && (this.privKey = (new this.PrivKey).fromFastBuffer(t.read(e)));
                const r = t.readUInt8();
                return r > 0 && (this.pubKey = (new s.a).fromFastBuffer(t.read(r))), this;
            }
            toBw(t) {
                if (t || (t = new i.a), this.privKey) {
                    const e = this.privKey.toFastBuffer();
                    t.writeUInt8(e.length), t.write(e);
                } else t.writeUInt8(0);
                if (this.pubKey) {
                    const e1 = this.pubKey.toFastBuffer();
                    t.writeUInt8(e1.length), t.write(e1);
                } else t.writeUInt8(0);
                return t;
            }
            fromString(t) {
                return this.fromJSON(JSON.parse(t));
            }
            toString() {
                return JSON.stringify(this.toJSON());
            }
            toPublic() {
                const t = (new o).fromObject(this);
                return t.privKey = void 0, t;
            }
            fromPrivKey(t) {
                return this.privKey = t, this.pubKey = (new s.a).fromPrivKey(t), this;
            }
            static fromPrivKey(t) {
                return (new this).fromPrivKey(t);
            }
            async asyncFromPrivKey(t) {
                return this.privKey = t, this.pubKey = await (new s.a).asyncFromPrivKey(t), this;
            }
            static asyncFromPrivKey(t) {
                return (new this).asyncFromPrivKey(t);
            }
            fromRandom() {
                return this.privKey = (new this.PrivKey).fromRandom(), this.pubKey = (new s.a).fromPrivKey(this.privKey), this;
            }
            static fromRandom() {
                return (new this).fromRandom();
            }
            async asyncFromRandom() {
                return this.privKey = (new this.PrivKey).fromRandom(), this.asyncFromPrivKey(this.privKey);
            }
            static asyncFromRandom() {
                return (new this).asyncFromRandom();
            }
        }
        o.Mainnet = class extends o {
            constructor(t, e){
                super(t, e, n.a.Mainnet);
            }
        }, o.Testnet = class extends o {
            constructor(t, e){
                super(t, e, n.a.Testnet);
            }
        };
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return c;
            });
            var i = r(24), n = r(1), s = r(19), a = r(11), o = r(16), h = r(4);
            class c extends h.a {
                constructor(t, e, r){
                    super({
                        bn: t,
                        compressed: e
                    }), r = r || s.a.Default.PrivKey, this.Constants = r;
                }
                fromJSON(t) {
                    return this.fromHex(t), this;
                }
                toJSON() {
                    return this.toHex();
                }
                fromRandom() {
                    let t, e, r;
                    do t = o.a.getRandomBuffer(32), e = (new n.a).fromBuffer(t), r = e.lt(a.a.getN());
                    while (!r);
                    return this.fromObject({
                        bn: e,
                        compressed: !0
                    }), this;
                }
                static fromRandom() {
                    return (new this).fromRandom();
                }
                toBuffer() {
                    let e = this.compressed;
                    void 0 === e && (e = !0);
                    const r = this.bn.toBuffer({
                        size: 32
                    });
                    let i;
                    return i = e ? t.concat([
                        t.from([
                            this.Constants.versionByteNum
                        ]),
                        r,
                        t.from([
                            1
                        ])
                    ]) : t.concat([
                        t.from([
                            this.Constants.versionByteNum
                        ]),
                        r
                    ]), i;
                }
                fromBuffer(t) {
                    if (34 === t.length && 1 === t[33]) this.compressed = !0;
                    else {
                        if (33 !== t.length) throw new Error("Length of privKey buffer must be 33 (uncompressed pubKey) or 34 (compressed pubKey)");
                        this.compressed = !1;
                    }
                    if (t[0] !== this.Constants.versionByteNum) throw new Error("Invalid versionByteNum byte");
                    return this.fromBn((new n.a).fromBuffer(t.slice(1, 33)));
                }
                toBn() {
                    return this.bn;
                }
                fromBn(t) {
                    return this.bn = t, this;
                }
                static fromBn(t) {
                    return (new this).fromBn(t);
                }
                validate() {
                    if (!this.bn.lt(a.a.getN())) throw new Error("Number must be less than N");
                    if ("boolean" != typeof this.compressed) throw new Error("Must specify whether the corresponding public key is compressed or not (true or false)");
                    return this;
                }
                toWif() {
                    return i.a.encode(this.toBuffer());
                }
                fromWif(t) {
                    return this.fromBuffer(i.a.decode(t));
                }
                static fromWif(t) {
                    return (new this).fromWif(t);
                }
                toString() {
                    return this.toWif();
                }
                fromString(t) {
                    return this.fromWif(t);
                }
            }
            c.Mainnet = class extends c {
                constructor(t, e){
                    super(t, e, s.a.Mainnet.PrivKey);
                }
            }, c.Testnet = class extends c {
                constructor(t, e){
                    super(t, e, s.a.Testnet.PrivKey);
                }
            };
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return o;
            });
            var i = r(44), n = r(18), s = r(3), a = r(4);
            class o extends a.a {
                constructor(t){
                    super({
                        buf: t
                    });
                }
                fromHex(e) {
                    return this.fromBuffer(t.from(e, "hex"));
                }
                toHex() {
                    return this.toBuffer().toString("hex");
                }
                static decode(t) {
                    if ("string" != typeof t) throw new Error("Input must be a string");
                    const e = i.a.decode(t);
                    if (e.length < 4) throw new Error("Input string too short");
                    const r = e.slice(0, -4), a = e.slice(-4), o = s.a.sha256Sha256(r).slice(0, 4);
                    if (!Object(n.a)(a, o)) throw new Error("Checksum mismatch");
                    return r;
                }
                static encode(e) {
                    if (!t.isBuffer(e)) throw new Error("Input must be a buffer");
                    const r = t.alloc(e.length + 4), n = s.a.sha256Sha256(e);
                    return e.copy(r), n.copy(r, e.length), i.a.encode(r);
                }
                fromBuffer(t) {
                    return this.buf = t, this;
                }
                fromString(t) {
                    const e = o.decode(t);
                    return this.buf = e, this;
                }
                toBuffer() {
                    return this.buf;
                }
                toString() {
                    return o.encode(this.buf);
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        var i = r(30), n = r(17);
        function s(t, e) {
            return 55296 == (64512 & t.charCodeAt(e)) && !(e < 0 || e + 1 >= t.length) && 56320 == (64512 & t.charCodeAt(e + 1));
        }
        function a(t) {
            return (t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (255 & t) << 24) >>> 0;
        }
        function o(t) {
            return 1 === t.length ? "0" + t : t;
        }
        function h(t) {
            return 7 === t.length ? "0" + t : 6 === t.length ? "00" + t : 5 === t.length ? "000" + t : 4 === t.length ? "0000" + t : 3 === t.length ? "00000" + t : 2 === t.length ? "000000" + t : 1 === t.length ? "0000000" + t : t;
        }
        e.inherits = n, e.toArray = function(t, e) {
            if (Array.isArray(t)) return t.slice();
            if (!t) return [];
            var r = [];
            if ("string" == typeof t) {
                if (e) {
                    if ("hex" === e) for((t = t.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (t = "0" + t), n = 0; n < t.length; n += 2)r.push(parseInt(t[n] + t[n + 1], 16));
                } else for(var i = 0, n = 0; n < t.length; n++){
                    var a = t.charCodeAt(n);
                    a < 128 ? r[i++] = a : a < 2048 ? (r[i++] = a >> 6 | 192, r[i++] = 63 & a | 128) : s(t, n) ? (a = 65536 + ((1023 & a) << 10) + (1023 & t.charCodeAt(++n)), r[i++] = a >> 18 | 240, r[i++] = a >> 12 & 63 | 128, r[i++] = a >> 6 & 63 | 128, r[i++] = 63 & a | 128) : (r[i++] = a >> 12 | 224, r[i++] = a >> 6 & 63 | 128, r[i++] = 63 & a | 128);
                }
            } else for(n = 0; n < t.length; n++)r[n] = 0 | t[n];
            return r;
        }, e.toHex = function(t) {
            for(var e = "", r = 0; r < t.length; r++)e += o(t[r].toString(16));
            return e;
        }, e.htonl = a, e.toHex32 = function(t, e) {
            for(var r = "", i = 0; i < t.length; i++){
                var n = t[i];
                "little" === e && (n = a(n)), r += h(n.toString(16));
            }
            return r;
        }, e.zero2 = o, e.zero8 = h, e.join32 = function(t, e, r, n) {
            var s = r - e;
            i(s % 4 == 0);
            for(var a = new Array(s / 4), o = 0, h = e; o < a.length; o++, h += 4){
                var c;
                c = "big" === n ? t[h] << 24 | t[h + 1] << 16 | t[h + 2] << 8 | t[h + 3] : t[h + 3] << 24 | t[h + 2] << 16 | t[h + 1] << 8 | t[h], a[o] = c >>> 0;
            }
            return a;
        }, e.split32 = function(t, e) {
            for(var r = new Array(4 * t.length), i = 0, n = 0; i < t.length; i++, n += 4){
                var s = t[i];
                "big" === e ? (r[n] = s >>> 24, r[n + 1] = s >>> 16 & 255, r[n + 2] = s >>> 8 & 255, r[n + 3] = 255 & s) : (r[n + 3] = s >>> 24, r[n + 2] = s >>> 16 & 255, r[n + 1] = s >>> 8 & 255, r[n] = 255 & s);
            }
            return r;
        }, e.rotr32 = function(t, e) {
            return t >>> e | t << 32 - e;
        }, e.rotl32 = function(t, e) {
            return t << e | t >>> 32 - e;
        }, e.sum32 = function(t, e) {
            return t + e >>> 0;
        }, e.sum32_3 = function(t, e, r) {
            return t + e + r >>> 0;
        }, e.sum32_4 = function(t, e, r, i) {
            return t + e + r + i >>> 0;
        }, e.sum32_5 = function(t, e, r, i, n) {
            return t + e + r + i + n >>> 0;
        }, e.sum64 = function(t, e, r, i) {
            var n = t[e], s = i + t[e + 1] >>> 0, a = (s < i ? 1 : 0) + r + n;
            t[e] = a >>> 0, t[e + 1] = s;
        }, e.sum64_hi = function(t, e, r, i) {
            return (e + i >>> 0 < e ? 1 : 0) + t + r >>> 0;
        }, e.sum64_lo = function(t, e, r, i) {
            return e + i >>> 0;
        }, e.sum64_4_hi = function(t, e, r, i, n, s, a, o) {
            var h = 0, c = e;
            return h += (c = c + i >>> 0) < e ? 1 : 0, h += (c = c + s >>> 0) < s ? 1 : 0, t + r + n + a + (h += (c = c + o >>> 0) < o ? 1 : 0) >>> 0;
        }, e.sum64_4_lo = function(t, e, r, i, n, s, a, o) {
            return e + i + s + o >>> 0;
        }, e.sum64_5_hi = function(t, e, r, i, n, s, a, o, h, c) {
            var u = 0, f = e;
            return u += (f = f + i >>> 0) < e ? 1 : 0, u += (f = f + s >>> 0) < s ? 1 : 0, u += (f = f + o >>> 0) < o ? 1 : 0, t + r + n + a + h + (u += (f = f + c >>> 0) < c ? 1 : 0) >>> 0;
        }, e.sum64_5_lo = function(t, e, r, i, n, s, a, o, h, c) {
            return e + i + s + o + c >>> 0;
        }, e.rotr64_hi = function(t, e, r) {
            return (e << 32 - r | t >>> r) >>> 0;
        }, e.rotr64_lo = function(t, e, r) {
            return (t << 32 - r | e >>> r) >>> 0;
        }, e.shr64_hi = function(t, e, r) {
            return t >>> r;
        }, e.shr64_lo = function(t, e, r) {
            return (t << 32 - r | e >>> r) >>> 0;
        };
    },
    function(t, e) {
        var r, i, n = t.exports = {};
        function s() {
            throw new Error("setTimeout has not been defined");
        }
        function a() {
            throw new Error("clearTimeout has not been defined");
        }
        function o(t) {
            if (r === setTimeout) return setTimeout(t, 0);
            if ((r === s || !r) && setTimeout) return r = setTimeout, setTimeout(t, 0);
            try {
                return r(t, 0);
            } catch (e1) {
                try {
                    return r.call(null, t, 0);
                } catch (e) {
                    return r.call(this, t, 0);
                }
            }
        }
        !function() {
            try {
                r = "function" == typeof setTimeout ? setTimeout : s;
            } catch (t) {
                r = s;
            }
            try {
                i = "function" == typeof clearTimeout ? clearTimeout : a;
            } catch (t1) {
                i = a;
            }
        }();
        var h, c = [], u = !1, f = -1;
        function d() {
            u && h && (u = !1, h.length ? c = h.concat(c) : f = -1, c.length && l());
        }
        function l() {
            if (!u) {
                var t = o(d);
                u = !0;
                for(var e = c.length; e;){
                    for(h = c, c = []; ++f < e;)h && h[f].run();
                    f = -1, e = c.length;
                }
                h = null, u = !1, function(t) {
                    if (i === clearTimeout) return clearTimeout(t);
                    if ((i === a || !i) && clearTimeout) return i = clearTimeout, clearTimeout(t);
                    try {
                        i(t);
                    } catch (e1) {
                        try {
                            return i.call(null, t);
                        } catch (e) {
                            return i.call(this, t);
                        }
                    }
                }(t);
            }
        }
        function p(t, e) {
            this.fun = t, this.array = e;
        }
        function b() {}
        n.nextTick = function(t) {
            var e = new Array(arguments.length - 1);
            if (arguments.length > 1) for(var r = 1; r < arguments.length; r++)e[r - 1] = arguments[r];
            c.push(new p(t, e)), 1 !== c.length || u || o(l);
        }, p.prototype.run = function() {
            this.fun.apply(null, this.array);
        }, n.title = "browser", n.browser = !0, n.env = {}, n.argv = [], n.version = "", n.versions = {}, n.on = b, n.addListener = b, n.once = b, n.off = b, n.removeListener = b, n.removeAllListeners = b, n.emit = b, n.prependListener = b, n.prependOnceListener = b, n.listeners = function(t) {
            return [];
        }, n.binding = function(t) {
            throw new Error("process.binding is not supported");
        }, n.cwd = function() {
            return "/";
        }, n.chdir = function(t) {
            throw new Error("process.chdir is not supported");
        }, n.umask = function() {
            return 0;
        };
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return a;
            });
            var i = r(39), n = r(40), s = r(16);
            class a {
                static encrypt(e, r, a, o = !0) {
                    a = a || s.a.getRandomBuffer(16);
                    const h = n.a.encrypt(e, a, i.a, r);
                    return o ? t.concat([
                        a,
                        h
                    ]) : h;
                }
                static decrypt(t, e, r) {
                    if (r) {
                        const s = t;
                        return n.a.decrypt(s, r, i.a, e);
                    }
                    {
                        r = t.slice(0, 16);
                        const s1 = t.slice(16);
                        return n.a.decrypt(s1, r, i.a, e);
                    }
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return d;
            });
            var i = r(24), n = r(19), s = r(3), a = r(0), o = r(23), h = r(8), c = r(9), u = r(4), f = r(2);
            class d extends u.a {
                constructor(t, e, r){
                    super({
                        versionByteNum: t,
                        hashBuf: e
                    }), this.Constants = r || n.a.Default.Address;
                }
                fromBuffer(t) {
                    if (21 !== t.length) throw new Error("address buffers must be exactly 21 bytes");
                    if (t[0] !== this.Constants.pubKeyHash) throw new Error("address: invalid versionByteNum byte");
                    return this.versionByteNum = t[0], this.hashBuf = t.slice(1), this;
                }
                fromPubKeyHashBuf(t) {
                    return this.hashBuf = t, this.versionByteNum = this.Constants.pubKeyHash, this;
                }
                static fromPubKeyHashBuf(t) {
                    return (new this).fromPubKeyHashBuf(t);
                }
                fromPubKey(t) {
                    const e = s.a.sha256Ripemd160(t.toBuffer());
                    return this.fromPubKeyHashBuf(e);
                }
                static fromPubKey(t) {
                    return (new this).fromPubKey(t);
                }
                async asyncFromPubKey(t) {
                    const e = [
                        t
                    ], r = await f.a.asyncObjectMethod(this, "fromPubKey", e);
                    return this.fromFastBuffer(r.resbuf);
                }
                static asyncFromPubKey(t) {
                    return (new this).asyncFromPubKey(t);
                }
                fromPrivKey(t) {
                    const e = (new h.a).fromPrivKey(t), r = s.a.sha256Ripemd160(e.toBuffer());
                    return this.fromPubKeyHashBuf(r);
                }
                static fromPrivKey(t) {
                    return (new this).fromPrivKey(t);
                }
                async asyncFromPrivKey(t) {
                    const e = [
                        t
                    ], r = await f.a.asyncObjectMethod(this, "fromPrivKey", e);
                    return this.fromFastBuffer(r.resbuf);
                }
                static asyncFromPrivKey(t) {
                    return (new this).asyncFromPrivKey(t);
                }
                fromRandom() {
                    const t = (new o.a).fromRandom();
                    return this.fromPrivKey(t);
                }
                static fromRandom() {
                    return (new this).fromRandom();
                }
                async asyncFromRandom() {
                    const t = await f.a.asyncObjectMethod(this, "fromRandom", []);
                    return this.fromFastBuffer(t.resbuf);
                }
                static asyncFromRandom() {
                    return (new this).asyncFromRandom();
                }
                fromString(t) {
                    const e = i.a.decode(t);
                    return this.fromBuffer(e);
                }
                async asyncFromString(t) {
                    const e = [
                        t
                    ], r = await f.a.asyncObjectMethod(this, "fromString", e);
                    return this.fromFastBuffer(r.resbuf);
                }
                static isValid(t) {
                    let e;
                    try {
                        e = (new d).fromString(t);
                    } catch (t1) {
                        return !1;
                    }
                    return e.isValid();
                }
                isValid() {
                    try {
                        return this.validate(), !0;
                    } catch (t) {
                        return !1;
                    }
                }
                toTxOutScript() {
                    const t = new c.a;
                    return t.writeOpCode(a.a.OP_DUP), t.writeOpCode(a.a.OP_HASH160), t.writeBuffer(this.hashBuf), t.writeOpCode(a.a.OP_EQUALVERIFY), t.writeOpCode(a.a.OP_CHECKSIG), t;
                }
                fromTxInScript(e) {
                    const r = s.a.sha256Ripemd160(e.chunks[1].buf || t.from("00".repeat(32), "hex"));
                    return this.fromPubKeyHashBuf(r);
                }
                static fromTxInScript(t) {
                    return (new this).fromTxInScript(t);
                }
                fromTxOutScript(t) {
                    return this.fromPubKeyHashBuf(t.chunks[2].buf);
                }
                static fromTxOutScript(t) {
                    return (new this).fromTxOutScript(t);
                }
                toBuffer() {
                    const e = t.from([
                        this.versionByteNum
                    ]);
                    return t.concat([
                        e,
                        this.hashBuf
                    ]);
                }
                toJSON() {
                    const t = {};
                    return this.hashBuf && (t.hashBuf = this.hashBuf.toString("hex")), void 0 !== this.versionByteNum && (t.versionByteNum = this.versionByteNum), t;
                }
                fromJSON(e) {
                    return e.hashBuf && (this.hashBuf = t.from(e.hashBuf, "hex")), void 0 !== e.versionByteNum && (this.versionByteNum = e.versionByteNum), this;
                }
                toString() {
                    return i.a.encode(this.toBuffer());
                }
                async asyncToString() {
                    const t = await f.a.asyncObjectMethod(this, "toString", []);
                    return JSON.parse(t.resbuf.toString());
                }
                validate() {
                    if (!t.isBuffer(this.hashBuf) || 20 !== this.hashBuf.length) throw new Error("hashBuf must be a buffer of 20 bytes");
                    if (this.versionByteNum !== this.Constants.pubKeyHash) throw new Error("invalid versionByteNum");
                    return this;
                }
            }
            d.Mainnet = class extends d {
                constructor(t, e){
                    super(t, e, n.a.Mainnet.Address);
                }
            }, d.Testnet = class extends d {
                constructor(t, e){
                    super(t, e, n.a.Testnet.Address);
                }
            };
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return l;
            });
            var i = r(1), n = r(12), s = r(3), a = r(22), o = r(11), h = r(8), c = r(16), u = r(5), f = r(4), d = r(2);
            class l extends f.a {
                constructor(t, e, r, i, n, s){
                    super({
                        sig: t,
                        keyPair: e,
                        hashBuf: r,
                        k: i,
                        endian: n,
                        verified: s
                    });
                }
                toJSON() {
                    return {
                        sig: this.sig ? this.sig.toString() : void 0,
                        keyPair: this.keyPair ? this.keyPair.toBuffer().toString("hex") : void 0,
                        hashBuf: this.hashBuf ? this.hashBuf.toString("hex") : void 0,
                        k: this.k ? this.k.toString() : void 0,
                        endian: this.endian,
                        verified: this.verified
                    };
                }
                fromJSON(e) {
                    return this.sig = e.sig ? (new u.a).fromString(e.sig) : void 0, this.keyPair = e.keyPair ? (new a.a).fromBuffer(t.from(e.keyPair, "hex")) : void 0, this.hashBuf = e.hashBuf ? t.from(e.hashBuf, "hex") : void 0, this.k = e.k ? (new i.a).fromString(e.k) : void 0, this.endian = e.endian, this.verified = e.verified, this;
                }
                toBuffer() {
                    const e = JSON.stringify(this.toJSON());
                    return t.from(e);
                }
                fromBuffer(t) {
                    const e = JSON.parse(t.toString());
                    return this.fromJSON(e);
                }
                calcrecovery() {
                    for(let t = 0; t < 4; t++){
                        let e;
                        this.sig.recovery = t;
                        try {
                            e = this.sig2PubKey();
                        } catch (t1) {
                            continue;
                        }
                        if (e.point.eq(this.keyPair.pubKey.point)) {
                            const t2 = this.keyPair.pubKey.compressed;
                            return this.sig.compressed = void 0 === this.keyPair.pubKey.compressed || t2, this;
                        }
                    }
                    throw this.sig.recovery = void 0, new Error("Unable to find valid recovery factor");
                }
                async asyncCalcrecovery() {
                    const t = await d.a.asyncObjectMethod(this, "calcrecovery", []);
                    return this.fromFastBuffer(t.resbuf);
                }
                static calcrecovery(t, e, r) {
                    return (new l).fromObject({
                        sig: t,
                        keyPair: (new a.a).fromObject({
                            pubKey: e
                        }),
                        hashBuf: r
                    }).calcrecovery().sig;
                }
                static async asyncCalcrecovery(t, e, r) {
                    const i = await d.a.asyncClassMethod(l, "calcrecovery", [
                        t,
                        e,
                        r
                    ]);
                    return (new u.a).fromFastBuffer(i.resbuf);
                }
                fromString(e) {
                    const r = JSON.parse(e);
                    return r.hashBuf && (this.hashBuf = t.from(r.hashBuf, "hex")), r.keyPair && (this.keyPair = (new a.a).fromString(r.keyPair)), r.sig && (this.sig = (new u.a).fromString(r.sig)), r.k && (this.k = new i.a(r.k, 10)), this;
                }
                randomK() {
                    const t = o.a.getN();
                    let e;
                    do e = (new i.a).fromBuffer(c.a.getRandomBuffer(32));
                    while (!e.lt(t) || !e.gt(0));
                    return this.k = e, this;
                }
                deterministicK(e) {
                    let r = t.alloc(32);
                    r.fill(1);
                    let n = t.alloc(32);
                    n.fill(0);
                    const a = this.keyPair.privKey.bn.toBuffer({
                        size: 32
                    });
                    n = s.a.sha256Hmac(t.concat([
                        r,
                        t.from([
                            0
                        ]),
                        a,
                        this.hashBuf
                    ]), n), r = s.a.sha256Hmac(r, n), n = s.a.sha256Hmac(t.concat([
                        r,
                        t.from([
                            1
                        ]),
                        a,
                        this.hashBuf
                    ]), n), r = s.a.sha256Hmac(r, n), r = s.a.sha256Hmac(r, n);
                    let h = (new i.a).fromBuffer(r);
                    const c = o.a.getN();
                    void 0 === e && (e = 0);
                    for(let a1 = 0; a1 < e || !h.lt(c) || !h.gt(0); a1++)n = s.a.sha256Hmac(t.concat([
                        r,
                        t.from([
                            0
                        ])
                    ]), n), r = s.a.sha256Hmac(r, n), r = s.a.sha256Hmac(r, n), h = (new i.a).fromBuffer(r);
                    return this.k = h, this;
                }
                sig2PubKey() {
                    const t = this.sig.recovery;
                    if (0 !== t && 1 !== t && 2 !== t && 3 !== t) throw new Error("i must be equal to 0, 1, 2, or 3");
                    const e = (new i.a).fromBuffer(this.hashBuf), r = this.sig.r, n = this.sig.s, s = !!(1 & t), a = t >> 1, c = o.a.getN(), u = o.a.getG(), f = a ? r.add(c) : r, d = o.a.fromX(s, f);
                    let l = "";
                    try {
                        d.mul(c);
                    } catch (t1) {
                        l = t1.message;
                    }
                    if ("point mul out of range" !== l) throw new Error("nR is not a valid curve point");
                    const p = e.neg().umod(c), b = r.invm(c), m = d.mul(n).add(u.mul(p)).mul(b), g = new h.a(m);
                    return g.compressed = this.sig.compressed, g.validate(), g;
                }
                async asyncSig2PubKey() {
                    const t = await d.a.asyncObjectMethod(this, "sig2PubKey", []);
                    return h.a.fromFastBuffer(t.resbuf);
                }
                static sig2PubKey(t, e) {
                    return (new l).fromObject({
                        sig: t,
                        hashBuf: e
                    }).sig2PubKey();
                }
                static async asyncSig2PubKey(t, e) {
                    const r = (new l).fromObject({
                        sig: t,
                        hashBuf: e
                    });
                    return await r.asyncSig2PubKey();
                }
                verifyStr(e = !0) {
                    if (!t.isBuffer(this.hashBuf) || 32 !== this.hashBuf.length) return "hashBuf must be a 32 byte buffer";
                    try {
                        this.keyPair.pubKey.validate();
                    } catch (t1) {
                        return "Invalid pubKey: " + t1;
                    }
                    const r = this.sig.r, n = this.sig.s;
                    if (!(r.gt(0) && r.lt(o.a.getN()) && n.gt(0) && n.lt(o.a.getN()))) return "r and s not in range";
                    if (e && !this.sig.hasLowS()) return "s is too high and does not satisfy low s contraint - see bip 62";
                    const s = (new i.a).fromBuffer(this.hashBuf, this.endian ? {
                        endian: this.endian
                    } : void 0), a = o.a.getN(), h = n.invm(a), c = h.mul(s).mod(a), u = h.mul(r).mod(a), f = o.a.getG().mulAdd(c, this.keyPair.pubKey.point, u);
                    return f.isInfinity() ? "p is infinity" : 0 !== f.getX().mod(a).cmp(r) && "Invalid signature";
                }
                sign() {
                    const e = "little" === this.endian ? new n.a(this.hashBuf).readReverse() : this.hashBuf, r = this.keyPair.privKey, s = r.bn;
                    if (!e || !r || !s) throw new Error("invalid parameters");
                    if (!t.isBuffer(e) || 32 !== e.length) throw new Error("hashBuf must be a 32 byte buffer");
                    const a = o.a.getN(), h = o.a.getG(), c = (new i.a).fromBuffer(e);
                    let f, d, l, p, b = 0;
                    do (!this.k || b > 0) && this.deterministicK(b), b++, f = this.k, d = h.mul(f), l = d.getX().mod(a), p = f.invm(a).mul(c.add(s.mul(l))).mod(a);
                    while (l.cmp(0) <= 0 || p.cmp(0) <= 0);
                    return p.gt((new i.a).fromBuffer(t.from("7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0", "hex"))) && (p = o.a.getN().sub(p)), this.sig = u.a.fromObject({
                        r: l,
                        s: p,
                        compressed: this.keyPair.pubKey.compressed
                    }), this;
                }
                async asyncSign() {
                    const t = await d.a.asyncObjectMethod(this, "sign", []);
                    return this.fromFastBuffer(t.resbuf);
                }
                signRandomK() {
                    return this.randomK(), this.sign();
                }
                toString() {
                    const t = {};
                    return this.hashBuf && (t.hashBuf = this.hashBuf.toString("hex")), this.keyPair && (t.keyPair = this.keyPair.toString()), this.sig && (t.sig = this.sig.toString()), this.k && (t.k = this.k.toString()), JSON.stringify(t);
                }
                verify(t = !0) {
                    return this.verifyStr(t) ? this.verified = !1 : this.verified = !0, this;
                }
                async asyncVerify(t = !0) {
                    const e = await d.a.asyncObjectMethod(this, "verify", [
                        t
                    ]);
                    return this.fromFastBuffer(e.resbuf);
                }
                static sign(t, e, r) {
                    return (new l).fromObject({
                        hashBuf: t,
                        endian: r,
                        keyPair: e
                    }).sign().sig;
                }
                static async asyncSign(t, e, r) {
                    const i = (new l).fromObject({
                        hashBuf: t,
                        endian: r,
                        keyPair: e
                    });
                    return await i.asyncSign(), i.sig;
                }
                static verify(t, e, r, i, n = !0) {
                    return (new l).fromObject({
                        hashBuf: t,
                        endian: i,
                        sig: e,
                        keyPair: (new a.a).fromObject({
                            pubKey: r
                        })
                    }).verify(n).verified;
                }
                static async asyncVerify(t, e, r, i, n = !0) {
                    const s = (new l).fromObject({
                        hashBuf: t,
                        endian: i,
                        sig: e,
                        keyPair: (new a.a).fromObject({
                            pubKey: r
                        })
                    });
                    return await s.asyncVerify(n), s.verified;
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e) {
        function r(t, e) {
            if (!t) throw new Error(e || "Assertion failed");
        }
        t.exports = r, r.equal = function(t, e, r) {
            if (t != e) throw new Error(r || "Assertion failed: " + t + " != " + e);
        };
    },
    function(t, e, r) {
        "use strict";
        var i = e, n = r(14), s = r(30), a = r(55);
        i.assert = s, i.toArray = a.toArray, i.zero2 = a.zero2, i.toHex = a.toHex, i.encode = a.encode, i.getNAF = function(t, e, r) {
            var i = new Array(Math.max(t.bitLength(), r) + 1);
            i.fill(0);
            for(var n = 1 << e + 1, s = t.clone(), a = 0; a < i.length; a++){
                var o, h = s.andln(n - 1);
                s.isOdd() ? (o = h > (n >> 1) - 1 ? (n >> 1) - h : h, s.isubn(o)) : o = 0, i[a] = o, s.iushrn(1);
            }
            return i;
        }, i.getJSF = function(t, e) {
            var r = [
                [],
                []
            ];
            t = t.clone(), e = e.clone();
            for(var i = 0, n = 0; t.cmpn(-i) > 0 || e.cmpn(-n) > 0;){
                var s, a, o, h = t.andln(3) + i & 3, c = e.andln(3) + n & 3;
                if (3 === h && (h = -1), 3 === c && (c = -1), 0 == (1 & h)) s = 0;
                else s = 3 !== (o = t.andln(7) + i & 7) && 5 !== o || 2 !== c ? h : -h;
                if (r[0].push(s), 0 == (1 & c)) a = 0;
                else a = 3 !== (o = e.andln(7) + n & 7) && 5 !== o || 2 !== h ? c : -c;
                r[1].push(a), 2 * i === s + 1 && (i = 1 - i), 2 * n === a + 1 && (n = 1 - n), t.iushrn(1), e.iushrn(1);
            }
            return r;
        }, i.cachedProperty = function(t, e, r) {
            var i = "_" + e;
            t.prototype[e] = function() {
                return void 0 !== this[i] ? this[i] : this[i] = r.call(this);
            };
        }, i.parseBytes = function(t) {
            return "string" == typeof t ? i.toArray(t, "hex") : t;
        }, i.intFromLE = function(t) {
            return new n(t, "hex", "le");
        };
    },
    function(t, e, r) {
        var i = e;
        i.utils = r(25), i.common = r(43), i.sha = r(94), i.ripemd = r(98), i.hmac = r(99), i.sha1 = i.sha.sha1, i.sha256 = i.sha.sha256, i.sha224 = i.sha.sha224, i.sha384 = i.sha.sha384, i.sha512 = i.sha.sha512, i.ripemd160 = i.ripemd.ripemd160;
    },
    function(t, e) {
        var r;
        r = function() {
            return this;
        }();
        try {
            r = r || new Function("return this")();
        } catch (t1) {
            "object" == typeof window && (r = window);
        }
        t.exports = r;
    },
    function(t, e, r) {
        "use strict";
        var i = {};
        function n(t, e, r) {
            r || (r = Error);
            var n = function(t) {
                var r, i;
                function n(r, i, n) {
                    return t.call(this, function(t, r, i) {
                        return "string" == typeof e ? e : e(t, r, i);
                    }(r, i, n)) || this;
                }
                return i = t, (r = n).prototype = Object.create(i.prototype), r.prototype.constructor = r, r.__proto__ = i, n;
            }(r);
            n.prototype.name = r.name, n.prototype.code = t, i[t] = n;
        }
        function s(t, e) {
            if (Array.isArray(t)) {
                var r = t.length;
                return t = t.map(function(t) {
                    return String(t);
                }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : 2 === r ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
            }
            return "of ".concat(e, " ").concat(String(t));
        }
        n("ERR_INVALID_OPT_VALUE", function(t, e) {
            return 'The value "' + e + '" is invalid for option "' + t + '"';
        }, TypeError), n("ERR_INVALID_ARG_TYPE", function(t, e, r) {
            var i, n, a, o;
            if ("string" == typeof e && (n = "not ", e.substr(!a || a < 0 ? 0 : +a, n.length) === n) ? (i = "must not be", e = e.replace(/^not /, "")) : i = "must be", function(t, e, r) {
                return (void 0 === r || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
            }(t, " argument")) o = "The ".concat(t, " ").concat(i, " ").concat(s(e, "type"));
            else {
                var h = function(t, e, r) {
                    return "number" != typeof r && (r = 0), !(r + e.length > t.length) && -1 !== t.indexOf(e, r);
                }(t, ".") ? "property" : "argument";
                o = 'The "'.concat(t, '" ').concat(h, " ").concat(i, " ").concat(s(e, "type"));
            }
            return o += ". Received type ".concat(typeof r);
        }, TypeError), n("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), n("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
            return "The " + t + " method is not implemented";
        }), n("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), n("ERR_STREAM_DESTROYED", function(t) {
            return "Cannot call " + t + " after a stream was destroyed";
        }), n("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), n("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), n("ERR_STREAM_WRITE_AFTER_END", "write after end"), n("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), n("ERR_UNKNOWN_ENCODING", function(t) {
            return "Unknown encoding: " + t;
        }, TypeError), n("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t.exports.codes = i;
    },
    function(t, e, r) {
        "use strict";
        (function(e) {
            var i = Object.keys || function(t) {
                var e = [];
                for(var r in t)e.push(r);
                return e;
            };
            t.exports = c;
            var n = r(66), s = r(71);
            r(17)(c, n);
            for(var a = i(s.prototype), o = 0; o < a.length; o++){
                var h = a[o];
                c.prototype[h] || (c.prototype[h] = s.prototype[h]);
            }
            function c(t) {
                if (!(this instanceof c)) return new c(t);
                n.call(this, t), s.call(this, t), this.allowHalfOpen = !0, t && (!1 === t.readable && (this.readable = !1), !1 === t.writable && (this.writable = !1), !1 === t.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", u)));
            }
            function u() {
                this._writableState.ended || e.nextTick(f, this);
            }
            function f(t) {
                t.end();
            }
            Object.defineProperty(c.prototype, "writableHighWaterMark", {
                enumerable: !1,
                get: function() {
                    return this._writableState.highWaterMark;
                }
            }), Object.defineProperty(c.prototype, "writableBuffer", {
                enumerable: !1,
                get: function() {
                    return this._writableState && this._writableState.getBuffer();
                }
            }), Object.defineProperty(c.prototype, "writableLength", {
                enumerable: !1,
                get: function() {
                    return this._writableState.length;
                }
            }), Object.defineProperty(c.prototype, "destroyed", {
                enumerable: !1,
                get: function() {
                    return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
                },
                set: function(t) {
                    void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = t, this._writableState.destroyed = t);
                }
            });
        }).call(this, r(26));
    },
    function(t, e, r) {
        var i = r(21).Buffer;
        function n(t, e) {
            this._block = i.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
        }
        n.prototype.update = function(t, e) {
            "string" == typeof t && (e = e || "utf8", t = i.from(t, e));
            for(var r = this._block, n = this._blockSize, s = t.length, a = this._len, o = 0; o < s;){
                for(var h = a % n, c = Math.min(s - o, n - h), u = 0; u < c; u++)r[h + u] = t[o + u];
                o += c, (a += c) % n == 0 && this._update(r);
            }
            return this._len += s, this;
        }, n.prototype.digest = function(t) {
            var e = this._len % this._blockSize;
            this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
            var r = 8 * this._len;
            if (r <= 4294967295) this._block.writeUInt32BE(r, this._blockSize - 4);
            else {
                var i = (4294967295 & r) >>> 0, n = (r - i) / 4294967296;
                this._block.writeUInt32BE(n, this._blockSize - 8), this._block.writeUInt32BE(i, this._blockSize - 4);
            }
            this._update(this._block);
            var s = this._hash();
            return t ? s.toString(t) : s;
        }, n.prototype._update = function() {
            throw new Error("_update must be implemented by subclass");
        }, t.exports = n;
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return s;
            });
            var i = r(6), n = r(4);
            class s extends n.a {
                constructor(t, e, r, i, n, s){
                    super({
                        versionBytesNum: t,
                        prevBlockHashBuf: e,
                        merkleRootBuf: r,
                        time: i,
                        bits: n,
                        nonce: s
                    });
                }
                fromJSON(e) {
                    return this.fromObject({
                        versionBytesNum: e.versionBytesNum,
                        prevBlockHashBuf: t.from(e.prevBlockHashBuf, "hex"),
                        merkleRootBuf: t.from(e.merkleRootBuf, "hex"),
                        time: e.time,
                        bits: e.bits,
                        nonce: e.nonce
                    }), this;
                }
                toJSON() {
                    return {
                        versionBytesNum: this.versionBytesNum,
                        prevBlockHashBuf: this.prevBlockHashBuf.toString("hex"),
                        merkleRootBuf: this.merkleRootBuf.toString("hex"),
                        time: this.time,
                        bits: this.bits,
                        nonce: this.nonce
                    };
                }
                fromBr(t) {
                    return this.versionBytesNum = t.readUInt32LE(), this.prevBlockHashBuf = t.read(32), this.merkleRootBuf = t.read(32), this.time = t.readUInt32LE(), this.bits = t.readUInt32LE(), this.nonce = t.readUInt32LE(), this;
                }
                toBw(t) {
                    return t || (t = new i.a), t.writeUInt32LE(this.versionBytesNum), t.write(this.prevBlockHashBuf), t.write(this.merkleRootBuf), t.writeUInt32LE(this.time), t.writeUInt32LE(this.bits), t.writeUInt32LE(this.nonce), t;
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return p;
            });
            var i = r(1), n = r(6), s = r(18), a = r(3), o = r(0), h = r(8), c = r(9), u = r(5), f = r(4), d = r(15), l = r(13);
            class p extends f.a {
                constructor(t, e, r, n = [], s = [], a = 0, o = 0, h = 0, c = [], u = "", f = p.defaultFlags, d = new i.a(0)){
                    super({
                        script: t,
                        tx: e,
                        nIn: r,
                        stack: n,
                        altStack: s,
                        pc: a,
                        pBeginCodeHash: o,
                        nOpCount: h,
                        ifStack: c,
                        errStr: u,
                        flags: f,
                        valueBn: d
                    });
                }
                initialize() {
                    return this.script = new c.a, this.stack = [], this.altStack = [], this.pc = 0, this.pBeginCodeHash = 0, this.nOpCount = 0, this.ifStack = [], this.errStr = "", this.flags = p.defaultFlags, this;
                }
                fromJSON(t) {
                    return this.fromJSONNoTx(t), this.tx = t.tx ? (new d.a).fromJSON(t.tx) : void 0, this;
                }
                fromJSONNoTx(e) {
                    this.fromObject({
                        script: void 0 !== e.script ? (new c.a).fromJSON(e.script) : void 0,
                        nIn: e.nIn
                    }), this.stack = [];
                    for (const r of e.stack)this.stack.push(t.from(r, "hex"));
                    this.altStack = [];
                    for (const r1 of e.altStack)this.altStack.push(t.from(r1, "hex"));
                    return this.fromObject({
                        pc: e.pc,
                        pBeginCodeHash: e.pBeginCodeHash,
                        nOpCount: e.nOpCount,
                        ifStack: e.ifStack,
                        errStr: e.errStr,
                        flags: e.flags
                    }), this;
                }
                fromBr(t) {
                    const e = t.readVarIntNum(), r = t.read(e);
                    this.fromJSONNoTx(JSON.parse(r.toString()));
                    const i = t.readVarIntNum();
                    if (i > 0) {
                        const e1 = t.read(i);
                        this.tx = (new d.a).fromFastBuffer(e1);
                    }
                    return this;
                }
                toJSON() {
                    const t = this.toJSONNoTx();
                    return t.tx = this.tx ? this.tx.toJSON() : void 0, t;
                }
                toJSONNoTx() {
                    const t = [];
                    for (const e of this.stack)t.push(e.toString("hex"));
                    const e1 = [];
                    for (const t1 of this.altStack)e1.push(t1.toString("hex"));
                    return {
                        script: this.script ? this.script.toJSON() : void 0,
                        nIn: this.nIn,
                        stack: t,
                        altStack: e1,
                        pc: this.pc,
                        pBeginCodeHash: this.pBeginCodeHash,
                        nOpCount: this.nOpCount,
                        ifStack: this.ifStack,
                        errStr: this.errStr,
                        flags: this.flags
                    };
                }
                toBw(e) {
                    e || (e = new n.a);
                    const r = t.from(JSON.stringify(this.toJSONNoTx()));
                    if (e.writeVarIntNum(r.length), e.write(r), this.tx) {
                        const t1 = this.tx.toFastBuffer();
                        e.writeVarIntNum(t1.length), e.write(t1);
                    } else e.writeVarIntNum(0);
                    return e;
                }
                static getFlags(t) {
                    let e = 0;
                    return -1 !== t.indexOf("NONE") && (e |= p.SCRIPT_VERIFY_NONE), -1 !== t.indexOf("P2SH") && (e |= p.SCRIPT_VERIFY_P2SH), -1 !== t.indexOf("STRICTENC") && (e |= p.SCRIPT_VERIFY_STRICTENC), -1 !== t.indexOf("DERSIG") && (e |= p.SCRIPT_VERIFY_DERSIG), -1 !== t.indexOf("LOW_S") && (e |= p.SCRIPT_VERIFY_LOW_S), -1 !== t.indexOf("NULLDUMMY") && (e |= p.SCRIPT_VERIFY_NULLDUMMY), -1 !== t.indexOf("SIGPUSHONLY") && (e |= p.SCRIPT_VERIFY_SIGPUSHONLY), -1 !== t.indexOf("MINIMALDATA") && (e |= p.SCRIPT_VERIFY_MINIMALDATA), -1 !== t.indexOf("DISCOURAGE_UPGRADABLE_NOPS") && (e |= p.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS), -1 !== t.indexOf("CLEANSTACK") && (e |= p.SCRIPT_VERIFY_CLEANSTACK), -1 !== t.indexOf("CHECKLOCKTIMEVERIFY") && (e |= p.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY), -1 !== t.indexOf("CHECKSEQUENCEVERIFY") && (e |= p.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY), -1 !== t.indexOf("SIGHASH_FORKID") && (e |= p.SCRIPT_ENABLE_SIGHASH_FORKID), e;
                }
                static castToBool(t) {
                    for(let e = 0; e < t.length; e++)if (0 !== t[e]) return e !== t.length - 1 || 128 !== t[e];
                    return !1;
                }
                checkSigEncoding(t) {
                    if (0 === t.length) return !0;
                    if (0 != (this.flags & (p.SCRIPT_VERIFY_DERSIG | p.SCRIPT_VERIFY_LOW_S | p.SCRIPT_VERIFY_STRICTENC)) && !u.a.IsTxDer(t)) return this.errStr = "SCRIPT_ERR_SIG_DER", !1;
                    if (0 != (this.flags & p.SCRIPT_VERIFY_LOW_S)) {
                        if (!(new u.a).fromTxFormat(t).hasLowS()) return this.errStr = "SCRIPT_ERR_SIG_DER", !1;
                    } else if (0 != (this.flags & p.SCRIPT_VERIFY_STRICTENC)) {
                        if (!(new u.a).fromTxFormat(t).hasDefinedHashType()) return this.errStr = "SCRIPT_ERR_SIG_HASHTYPE", !1;
                    }
                    return !0;
                }
                checkPubKeyEncoding(t) {
                    return !(0 != (this.flags & p.SCRIPT_VERIFY_STRICTENC) && !h.a.isCompressedOrUncompressed(t)) || (this.errStr = "SCRIPT_ERR_PUBKEYTYPE", !1);
                }
                checkLockTime(t) {
                    return (this.tx.nLockTime < p.LOCKTIME_THRESHOLD && t < p.LOCKTIME_THRESHOLD || this.tx.nLockTime >= p.LOCKTIME_THRESHOLD && t >= p.LOCKTIME_THRESHOLD) && !(t > this.tx.nLockTime) && l.a.SEQUENCE_FINAL !== this.tx.txIns[this.nIn].nSequence;
                }
                checkSequence(t) {
                    const e = this.tx.txIns[this.nIn].nSequence;
                    if (this.tx.versionBytesNum < 2) return !1;
                    if (e & l.a.SEQUENCE_LOCKTIME_DISABLE_FLAG) return !1;
                    const r = l.a.SEQUENCE_LOCKTIME_TYPE_FLAG | l.a.SEQUENCE_LOCKTIME_MASK, i = e & r, n = t & r;
                    return (i < l.a.SEQUENCE_LOCKTIME_TYPE_FLAG && n < l.a.SEQUENCE_LOCKTIME_TYPE_FLAG || i >= l.a.SEQUENCE_LOCKTIME_TYPE_FLAG && n >= l.a.SEQUENCE_LOCKTIME_TYPE_FLAG) && !(n > i);
                }
                *eval() {
                    this.script.toBuffer().length > 1e4 && (this.errStr = "SCRIPT_ERR_SCRIPT_SIZE", yield !1);
                    try {
                        for(; this.pc < this.script.chunks.length;){
                            const t = this.step();
                            t ? yield t : yield !1;
                        }
                        this.stack.length + this.altStack.length > 1e3 && (this.errStr = "SCRIPT_ERR_STACK_SIZE", yield !1);
                    } catch (t1) {
                        this.errStr = "SCRIPT_ERR_UNKNOWN_ERROR: " + t1, yield !1;
                    }
                    this.ifStack.length > 0 && (this.errStr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL", yield !1), yield !0;
                }
                step() {
                    const e = 0 != (this.flags & p.SCRIPT_VERIFY_MINIMALDATA), r = !(this.ifStack.indexOf(!1) + 1), n = this.script.chunks[this.pc];
                    this.pc++;
                    const f = n.opCodeNum;
                    if (void 0 === f) return this.errStr = "SCRIPT_ERR_BAD_OPCODE", !1;
                    if (n.buf && n.buf.length > p.MAX_SCRIPT_ELEMENT_SIZE) return this.errStr = "SCRIPT_ERR_PUSH_SIZE", !1;
                    if (f > o.a.OP_16 && ++this.nOpCount > 201) return this.errStr = "SCRIPT_ERR_OP_COUNT", !1;
                    if (f === o.a.OP_LEFT || f === o.a.OP_RIGHT || f === o.a.OP_2MUL || f === o.a.OP_2DIV) return this.errStr = "SCRIPT_ERR_DISABLED_OPCODE", !1;
                    if (r && f >= 0 && f <= o.a.OP_PUSHDATA4) {
                        if (e && !this.script.checkMinimalPush(this.pc - 1)) return this.errStr = "SCRIPT_ERR_MINIMALDATA", !1;
                        if (n.buf) {
                            if (n.len !== n.buf.length) throw new Error("LEngth of push value not equal to length of data");
                            this.stack.push(n.buf);
                        } else this.stack.push(p.false);
                    } else if (r || o.a.OP_IF <= f && f <= o.a.OP_ENDIF) switch(f){
                        case o.a.OP_1NEGATE:
                        case o.a.OP_1:
                        case o.a.OP_2:
                        case o.a.OP_3:
                        case o.a.OP_4:
                        case o.a.OP_5:
                        case o.a.OP_6:
                        case o.a.OP_7:
                        case o.a.OP_8:
                        case o.a.OP_9:
                        case o.a.OP_10:
                        case o.a.OP_11:
                        case o.a.OP_12:
                        case o.a.OP_13:
                        case o.a.OP_14:
                        case o.a.OP_15:
                        case o.a.OP_16:
                            {
                                const t1 = f - (o.a.OP_1 - 1), e1 = new i.a(t1).toScriptNumBuffer();
                                this.stack.push(e1);
                            }
                            break;
                        case o.a.OP_NOP:
                            break;
                        case o.a.OP_CHECKLOCKTIMEVERIFY:
                            {
                                if (!(this.flags & p.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {
                                    if (this.flags & p.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) return this.errStr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS", !1;
                                    break;
                                }
                                if (this.stack.length < 1) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t2 = this.stack[this.stack.length - 1], r1 = (new i.a).fromScriptNumBuffer(t2, e, 5).toNumber();
                                if (r1 < 0) return this.errStr = "SCRIPT_ERR_NEGATIVE_LOCKTIME", !1;
                                if (!this.checkLockTime(r1)) return this.errStr = "SCRIPT_ERR_UNSATISFIED_LOCKTIME", !1;
                            }
                            break;
                        case o.a.OP_CHECKSEQUENCEVERIFY:
                            {
                                if (!(this.flags & p.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {
                                    if (this.flags & p.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) return this.errStr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS", !1;
                                    break;
                                }
                                if (this.stack.length < 1) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t3 = this.stack[this.stack.length - 1], r2 = (new i.a).fromScriptNumBuffer(t3, e, 5).toNumber();
                                if (r2 < 0) return this.errStr = "SCRIPT_ERR_NEGATIVE_LOCKTIME", !1;
                                if (0 != (r2 & l.a.SEQUENCE_LOCKTIME_DISABLE_FLAG)) break;
                                if (!this.checkSequence(r2)) return this.errStr = "SCRIPT_ERR_UNSATISFIED_LOCKTIME", !1;
                            }
                            break;
                        case o.a.OP_NOP1:
                        case o.a.OP_NOP3:
                        case o.a.OP_NOP4:
                        case o.a.OP_NOP5:
                        case o.a.OP_NOP6:
                        case o.a.OP_NOP7:
                        case o.a.OP_NOP8:
                        case o.a.OP_NOP9:
                        case o.a.OP_NOP10:
                            if (this.flags & p.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) return this.errStr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS", !1;
                            break;
                        case o.a.OP_IF:
                        case o.a.OP_NOTIF:
                            {
                                let t4 = !1;
                                if (r) {
                                    if (this.stack.length < 1) return this.errStr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL", !1;
                                    const e2 = this.stack.pop();
                                    t4 = p.castToBool(e2), f === o.a.OP_NOTIF && (t4 = !t4);
                                }
                                this.ifStack.push(t4);
                            }
                            break;
                        case o.a.OP_ELSE:
                            if (0 === this.ifStack.length) return this.errStr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL", !1;
                            this.ifStack[this.ifStack.length - 1] = !this.ifStack[this.ifStack.length - 1];
                            break;
                        case o.a.OP_ENDIF:
                            if (0 === this.ifStack.length) return this.errStr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL", !1;
                            this.ifStack.pop();
                            break;
                        case o.a.OP_VERIFY:
                            {
                                if (this.stack.length < 1) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t5 = this.stack[this.stack.length - 1];
                                if (!p.castToBool(t5)) return this.errStr = "SCRIPT_ERR_VERIFY", !1;
                                this.stack.pop();
                            }
                            break;
                        case o.a.OP_RETURN:
                            return this.errStr = "SCRIPT_ERR_OP_RETURN", !1;
                        case o.a.OP_TOALTSTACK:
                            if (this.stack.length < 1) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                            this.altStack.push(this.stack.pop());
                            break;
                        case o.a.OP_FROMALTSTACK:
                            if (this.altStack.length < 1) return this.errStr = "SCRIPT_ERR_INVALID_ALTSTACK_OPERATION", !1;
                            this.stack.push(this.altStack.pop());
                            break;
                        case o.a.OP_2DROP:
                            if (this.stack.length < 2) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                            this.stack.pop(), this.stack.pop();
                            break;
                        case o.a.OP_2DUP:
                            {
                                if (this.stack.length < 2) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t6 = this.stack[this.stack.length - 2], e3 = this.stack[this.stack.length - 1];
                                this.stack.push(t6), this.stack.push(e3);
                            }
                            break;
                        case o.a.OP_3DUP:
                            {
                                if (this.stack.length < 3) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t7 = this.stack[this.stack.length - 3], e4 = this.stack[this.stack.length - 2], r3 = this.stack[this.stack.length - 1];
                                this.stack.push(t7), this.stack.push(e4), this.stack.push(r3);
                            }
                            break;
                        case o.a.OP_2OVER:
                            {
                                if (this.stack.length < 4) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t8 = this.stack[this.stack.length - 4], e5 = this.stack[this.stack.length - 3];
                                this.stack.push(t8), this.stack.push(e5);
                            }
                            break;
                        case o.a.OP_2ROT:
                            {
                                if (this.stack.length < 6) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t9 = this.stack.splice(this.stack.length - 6, 2);
                                this.stack.push(t9[0]), this.stack.push(t9[1]);
                            }
                            break;
                        case o.a.OP_2SWAP:
                            {
                                if (this.stack.length < 4) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t10 = this.stack.splice(this.stack.length - 4, 2);
                                this.stack.push(t10[0]), this.stack.push(t10[1]);
                            }
                            break;
                        case o.a.OP_IFDUP:
                            {
                                if (this.stack.length < 1) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t11 = this.stack[this.stack.length - 1];
                                p.castToBool(t11) && this.stack.push(t11);
                            }
                            break;
                        case o.a.OP_DEPTH:
                            {
                                const t12 = new i.a(this.stack.length).toScriptNumBuffer();
                                this.stack.push(t12);
                            }
                            break;
                        case o.a.OP_DROP:
                            if (this.stack.length < 1) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                            this.stack.pop();
                            break;
                        case o.a.OP_DUP:
                            if (this.stack.length < 1) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                            this.stack.push(this.stack[this.stack.length - 1]);
                            break;
                        case o.a.OP_NIP:
                            if (this.stack.length < 2) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                            this.stack.splice(this.stack.length - 2, 1);
                            break;
                        case o.a.OP_OVER:
                            if (this.stack.length < 2) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                            this.stack.push(this.stack[this.stack.length - 2]);
                            break;
                        case o.a.OP_PICK:
                        case o.a.OP_ROLL:
                            {
                                if (this.stack.length < 2) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                let t13 = this.stack[this.stack.length - 1];
                                const r4 = (new i.a).fromScriptNumBuffer(t13, e).toNumber();
                                if (this.stack.pop(), r4 < 0 || r4 >= this.stack.length) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                t13 = this.stack[this.stack.length - r4 - 1], f === o.a.OP_ROLL && this.stack.splice(this.stack.length - r4 - 1, 1), this.stack.push(t13);
                            }
                            break;
                        case o.a.OP_ROT:
                            {
                                if (this.stack.length < 3) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t14 = this.stack[this.stack.length - 3], e6 = this.stack[this.stack.length - 2], r5 = this.stack[this.stack.length - 1];
                                this.stack[this.stack.length - 3] = e6, this.stack[this.stack.length - 2] = r5, this.stack[this.stack.length - 1] = t14;
                            }
                            break;
                        case o.a.OP_SWAP:
                            {
                                if (this.stack.length < 2) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t15 = this.stack[this.stack.length - 2], e7 = this.stack[this.stack.length - 1];
                                this.stack[this.stack.length - 2] = e7, this.stack[this.stack.length - 1] = t15;
                            }
                            break;
                        case o.a.OP_TUCK:
                            if (this.stack.length < 2) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                            this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);
                            break;
                        case o.a.OP_SIZE:
                            {
                                if (this.stack.length < 1) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t16 = new i.a(this.stack[this.stack.length - 1].length);
                                this.stack.push(t16.toScriptNumBuffer());
                            }
                            break;
                        case o.a.OP_OR:
                        case o.a.OP_AND:
                        case o.a.OP_XOR:
                            if (this.stack.length < 2) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                            const n1 = this.stack[this.stack.length - 2], d = this.stack[this.stack.length - 1];
                            if (n1.length !== d.length) return this.errStr = "SCRIPT_ERR_INVALID_OPERAND_SIZE", !1;
                            switch(f){
                                case o.a.OP_AND:
                                    for(let t17 = 0; t17 < n1.length; t17++)n1[t17] &= d[t17];
                                    break;
                                case o.a.OP_OR:
                                    for(let t18 = 0; t18 < n1.length; t18++)n1[t18] |= d[t18];
                                    break;
                                case o.a.OP_XOR:
                                    for(let t19 = 0; t19 < n1.length; t19++)n1[t19] ^= d[t19];
                            }
                            this.stack.pop();
                            break;
                        case o.a.OP_INVERT:
                            if (this.stack.length < 1) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                            const b = this.stack[this.stack.length - 1];
                            for(let t20 = 0; t20 < b.length; t20++)b[t20] = ~b[t20];
                            break;
                        case o.a.OP_LSHIFT:
                        case o.a.OP_RSHIFT:
                            {
                                if (this.stack.length < 2) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const r6 = this.stack[this.stack.length - 2];
                                let n2 = new i.a(r6);
                                const s1 = (new i.a).fromScriptNumBuffer(this.stack[this.stack.length - 1], e).toNumber();
                                if (s1 < 0) return this.errStr = "SCRIPT_ERR_INVALID_NUMBER_RANGE", !1;
                                switch(this.stack.pop(), this.stack.pop(), f){
                                    case o.a.OP_LSHIFT:
                                        n2 = n2.ushln(s1);
                                        break;
                                    case o.a.OP_RSHIFT:
                                        n2 = n2.ushrn(s1);
                                }
                                let a1 = n2.toBuffer().slice(-r6.length);
                                a1.length < r6.length && (a1 = t.concat([
                                    t.alloc(r6.length - a1.length),
                                    a1
                                ])), this.stack.push(a1);
                                break;
                            }
                        case o.a.OP_EQUAL:
                        case o.a.OP_EQUALVERIFY:
                            {
                                if (this.stack.length < 2) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t21 = this.stack[this.stack.length - 2], e8 = this.stack[this.stack.length - 1], r7 = Object(s.a)(t21, e8);
                                if (this.stack.pop(), this.stack.pop(), this.stack.push(r7 ? p.true : p.false), f === o.a.OP_EQUALVERIFY) {
                                    if (!r7) return this.errStr = "SCRIPT_ERR_EQUALVERIFY", !1;
                                    this.stack.pop();
                                }
                            }
                            break;
                        case o.a.OP_1ADD:
                        case o.a.OP_1SUB:
                        case o.a.OP_NEGATE:
                        case o.a.OP_ABS:
                        case o.a.OP_NOT:
                        case o.a.OP_0NOTEQUAL:
                            {
                                if (this.stack.length < 1) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t22 = this.stack[this.stack.length - 1];
                                let r8 = (new i.a).fromScriptNumBuffer(t22, e);
                                switch(f){
                                    case o.a.OP_1ADD:
                                        r8 = r8.add(1);
                                        break;
                                    case o.a.OP_1SUB:
                                        r8 = r8.sub(1);
                                        break;
                                    case o.a.OP_NEGATE:
                                        r8 = r8.neg();
                                        break;
                                    case o.a.OP_ABS:
                                        r8.lt(0) && (r8 = r8.neg());
                                        break;
                                    case o.a.OP_NOT:
                                        r8 = new i.a(~~r8.eq(0));
                                        break;
                                    case o.a.OP_0NOTEQUAL:
                                        r8 = new i.a(~~r8.neq(0));
                                }
                                this.stack.pop(), this.stack.push(r8.toScriptNumBuffer());
                            }
                            break;
                        case o.a.OP_ADD:
                        case o.a.OP_SUB:
                        case o.a.OP_MUL:
                        case o.a.OP_DIV:
                        case o.a.OP_MOD:
                        case o.a.OP_BOOLAND:
                        case o.a.OP_BOOLOR:
                        case o.a.OP_NUMEQUAL:
                        case o.a.OP_NUMEQUALVERIFY:
                        case o.a.OP_NUMNOTEQUAL:
                        case o.a.OP_LESSTHAN:
                        case o.a.OP_GREATERTHAN:
                        case o.a.OP_LESSTHANOREQUAL:
                        case o.a.OP_GREATERTHANOREQUAL:
                        case o.a.OP_MIN:
                        case o.a.OP_MAX:
                            {
                                if (this.stack.length < 2) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t23 = (new i.a).fromScriptNumBuffer(this.stack[this.stack.length - 2], e), r9 = (new i.a).fromScriptNumBuffer(this.stack[this.stack.length - 1], e);
                                let n3 = new i.a(0);
                                switch(f){
                                    case o.a.OP_ADD:
                                        n3 = t23.add(r9);
                                        break;
                                    case o.a.OP_SUB:
                                        n3 = t23.sub(r9);
                                        break;
                                    case o.a.OP_MUL:
                                        n3 = t23.mul(r9);
                                        break;
                                    case o.a.OP_DIV:
                                        if (r9.eq(0)) return this.errStr = "SCRIPT_ERR_DIV_BY_ZERO", !1;
                                        n3 = t23.div(r9);
                                        break;
                                    case o.a.OP_MOD:
                                        if (r9.eq(0)) return this.errStr = "SCRIPT_ERR_DIV_BY_ZERO", !1;
                                        n3 = t23.mod(r9);
                                        break;
                                    case o.a.OP_BOOLAND:
                                        n3 = new i.a(~~(t23.neq(0) && r9.neq(0)));
                                        break;
                                    case o.a.OP_BOOLOR:
                                        n3 = new i.a(~~(t23.neq(0) || r9.neq(0)));
                                        break;
                                    case o.a.OP_NUMEQUAL:
                                    case o.a.OP_NUMEQUALVERIFY:
                                        n3 = new i.a(~~t23.eq(r9));
                                        break;
                                    case o.a.OP_NUMNOTEQUAL:
                                        n3 = new i.a(~~t23.neq(r9));
                                        break;
                                    case o.a.OP_LESSTHAN:
                                        n3 = new i.a(~~t23.lt(r9));
                                        break;
                                    case o.a.OP_GREATERTHAN:
                                        n3 = new i.a(~~t23.gt(r9));
                                        break;
                                    case o.a.OP_LESSTHANOREQUAL:
                                        n3 = new i.a(~~t23.leq(r9));
                                        break;
                                    case o.a.OP_GREATERTHANOREQUAL:
                                        n3 = new i.a(~~t23.geq(r9));
                                        break;
                                    case o.a.OP_MIN:
                                        n3 = t23.lt(r9) ? t23 : r9;
                                        break;
                                    case o.a.OP_MAX:
                                        n3 = t23.gt(r9) ? t23 : r9;
                                }
                                if (this.stack.pop(), this.stack.pop(), this.stack.push(n3.toScriptNumBuffer()), f === o.a.OP_NUMEQUALVERIFY) {
                                    if (!p.castToBool(this.stack[this.stack.length - 1])) return this.errStr = "SCRIPT_ERR_NUMEQUALVERIFY", !1;
                                    this.stack.pop();
                                }
                            }
                            break;
                        case o.a.OP_WITHIN:
                            {
                                if (this.stack.length < 3) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t24 = (new i.a).fromScriptNumBuffer(this.stack[this.stack.length - 3], e), r10 = (new i.a).fromScriptNumBuffer(this.stack[this.stack.length - 2], e), n4 = (new i.a).fromScriptNumBuffer(this.stack[this.stack.length - 1], e), s2 = r10.leq(t24) && t24.lt(n4);
                                this.stack.pop(), this.stack.pop(), this.stack.pop(), this.stack.push(s2 ? p.true : p.false);
                            }
                            break;
                        case o.a.OP_RIPEMD160:
                        case o.a.OP_SHA1:
                        case o.a.OP_SHA256:
                        case o.a.OP_HASH160:
                        case o.a.OP_HASH256:
                            {
                                if (this.stack.length < 1) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t25 = this.stack[this.stack.length - 1];
                                let e9;
                                f === o.a.OP_RIPEMD160 ? e9 = a.a.ripemd160(t25) : f === o.a.OP_SHA1 ? e9 = a.a.sha1(t25) : f === o.a.OP_SHA256 ? e9 = a.a.sha256(t25) : f === o.a.OP_HASH160 ? e9 = a.a.sha256Ripemd160(t25) : f === o.a.OP_HASH256 && (e9 = a.a.sha256Sha256(t25)), this.stack.pop(), this.stack.push(e9);
                            }
                            break;
                        case o.a.OP_CODESEPARATOR:
                            this.pBeginCodeHash = this.pc;
                            break;
                        case o.a.OP_CHECKSIG:
                        case o.a.OP_CHECKSIGVERIFY:
                            {
                                if (this.stack.length < 2) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const t26 = this.stack[this.stack.length - 2], e10 = this.stack[this.stack.length - 1], r11 = (new c.a).fromObject({
                                    chunks: this.script.chunks.slice(this.pBeginCodeHash)
                                });
                                if ((t26.length > 0 ? t26.readUInt8(t26.length - 1) : 0) & u.a.SIGHASH_FORKID) {
                                    if (!(this.flags & p.SCRIPT_ENABLE_SIGHASH_FORKID)) return this.errStr = "SCRIPT_ERR_ILLEGAL_FORKID", !1;
                                } else r11.findAndDelete((new c.a).writeBuffer(t26));
                                if (!this.checkSigEncoding(t26) || !this.checkPubKeyEncoding(e10)) return !1;
                                let i1;
                                try {
                                    const n5 = (new u.a).fromTxFormat(t26), s3 = (new h.a).fromBuffer(e10, !1);
                                    i1 = this.tx.verify(n5, s3, this.nIn, r11, Boolean(this.flags & p.SCRIPT_VERIFY_LOW_S), this.valueBn, this.flags);
                                } catch (t27) {
                                    i1 = !1;
                                }
                                if (this.stack.pop(), this.stack.pop(), this.stack.push(i1 ? p.true : p.false), f === o.a.OP_CHECKSIGVERIFY) {
                                    if (!i1) return this.errStr = "SCRIPT_ERR_CHECKSIGVERIFY", !1;
                                    this.stack.pop();
                                }
                            }
                            break;
                        case o.a.OP_CHECKMULTISIG:
                        case o.a.OP_CHECKMULTISIGVERIFY:
                            {
                                let t28 = 1;
                                if (this.stack.length < t28) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                let r12 = (new i.a).fromScriptNumBuffer(this.stack[this.stack.length - t28], e).toNumber();
                                if (r12 < 0 || r12 > 20) return this.errStr = "SCRIPT_ERR_PUBKEY_COUNT", !1;
                                if (this.nOpCount += r12, this.nOpCount > 201) return this.errStr = "SCRIPT_ERR_OP_COUNT", !1;
                                let n6 = ++t28;
                                if (t28 += r12, this.stack.length < t28) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                let s4 = (new i.a).fromScriptNumBuffer(this.stack[this.stack.length - t28], e).toNumber();
                                if (s4 < 0 || s4 > r12) return this.errStr = "SCRIPT_ERR_SIG_COUNT", !1;
                                let a2 = ++t28;
                                if (t28 += s4, this.stack.length < t28) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                const d1 = (new c.a).fromObject({
                                    chunks: this.script.chunks.slice(this.pBeginCodeHash)
                                });
                                for(let t29 = 0; t29 < s4; t29++){
                                    const e11 = this.stack[this.stack.length - a2 - t29];
                                    if ((e11.length > 0 ? e11.readUInt8(e11.length - 1) : 0) & u.a.SIGHASH_FORKID) {
                                        if (!(this.flags & p.SCRIPT_ENABLE_SIGHASH_FORKID)) return this.errStr = "SCRIPT_ERR_ILLEGAL_FORKID", !1;
                                    } else d1.findAndDelete((new c.a).writeBuffer(e11));
                                }
                                let l1 = !0;
                                for(; l1 && s4 > 0;){
                                    const t30 = this.stack[this.stack.length - a2], e12 = this.stack[this.stack.length - n6];
                                    if (!this.checkSigEncoding(t30) || !this.checkPubKeyEncoding(e12)) return !1;
                                    let i2;
                                    try {
                                        const r13 = (new u.a).fromTxFormat(t30), n7 = (new h.a).fromBuffer(e12, !1);
                                        i2 = this.tx.verify(r13, n7, this.nIn, d1, Boolean(this.flags & p.SCRIPT_VERIFY_LOW_S), this.valueBn, this.flags);
                                    } catch (t31) {
                                        i2 = !1;
                                    }
                                    i2 && (a2++, s4--), n6++, r12--, s4 > r12 && (l1 = !1);
                                }
                                for(; t28-- > 1;)this.stack.pop();
                                if (this.stack.length < 1) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                                if (this.flags & p.SCRIPT_VERIFY_NULLDUMMY && this.stack[this.stack.length - 1].length) return this.errStr = "SCRIPT_ERR_SIG_NULLDUMMY", !1;
                                if (this.stack.pop(), this.stack.push(l1 ? p.true : p.false), f === o.a.OP_CHECKMULTISIGVERIFY) {
                                    if (!l1) return this.errStr = "SCRIPT_ERR_CHECKMULTISIGVERIFY", !1;
                                    this.stack.pop();
                                }
                            }
                            break;
                        case o.a.OP_CAT:
                            if (this.stack.length < 2) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                            const m = this.stack[this.stack.length - 2], g = this.stack[this.stack.length - 1];
                            this.stack[this.stack.length - 2] = t.concat([
                                m,
                                g
                            ]), this.stack.pop();
                            break;
                        case o.a.OP_SPLIT:
                            if (this.stack.length < 2) return this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION", !1;
                            const y = this.stack[this.stack.length - 2], w = (new i.a).fromScriptNumBuffer(this.stack[this.stack.length - 1], e);
                            if (w.lt(0) || w.gt(y.length)) return this.errStr = "SCRIPT_ERR_INVALID_SPLIT_RANGE", !1;
                            const _ = y.slice(0, w.toNumber()), v = y.slice(w.toNumber());
                            this.stack.pop(), this.stack.pop(), this.stack.push(_), this.stack.push(v);
                            break;
                        default:
                            return this.errStr = "SCRIPT_ERR_BAD_OPCODE", !1;
                    }
                    return !0;
                }
                verify(t, e, r, i, n, s) {
                    const a = this.results(t, e, r, i, n, s);
                    for (const t1 of a)if (!t1) return !1;
                    return !0;
                }
                *results(t, e, r, i, n, s) {
                    let a;
                    this.fromObject({
                        script: t,
                        tx: r,
                        nIn: i,
                        flags: n,
                        valueBn: s
                    }), 0 == (n & p.SCRIPT_VERIFY_SIGPUSHONLY) || t.isPushOnly() || (this.errStr = this.errStr || "SCRIPT_ERR_SIG_PUSHONLY", yield !1), yield* this.eval(), n & p.SCRIPT_VERIFY_P2SH && (a = this.stack.slice());
                    let o = this.stack;
                    this.initialize(), this.fromObject({
                        script: e,
                        stack: o,
                        tx: r,
                        nIn: i,
                        flags: n,
                        valueBn: s
                    }), yield* this.eval(), 0 === this.stack.length && (this.errStr = this.errStr || "SCRIPT_ERR_EVAL_FALSE", yield !1);
                    const h = this.stack[this.stack.length - 1];
                    if (p.castToBool(h) || (this.errStr = this.errStr || "SCRIPT_ERR_EVAL_FALSE", yield !1), n & p.SCRIPT_VERIFY_P2SH && e.isScriptHashOut()) {
                        t.isPushOnly() || (this.errStr = this.errStr || "SCRIPT_ERR_SIG_PUSHONLY", yield !1);
                        const e1 = o;
                        if (o = a, a = e1, 0 === o.length) throw new Error("internal error - stack copy empty");
                        const h1 = o[o.length - 1], u = (new c.a).fromBuffer(h1);
                        o.pop(), this.initialize(), this.fromObject({
                            script: u,
                            stack: o,
                            tx: r,
                            nIn: i,
                            flags: n,
                            valueBn: s
                        }), yield* this.eval(), 0 === o.length && (this.errStr = this.errStr || "SCRIPT_ERR_EVAL_FALSE", yield !1), p.castToBool(o[o.length - 1]) ? yield !0 : (this.errStr = this.errStr || "SCRIPT_ERR_EVAL_FALSE", yield !1);
                    }
                    if (0 != (n & p.SCRIPT_VERIFY_CLEANSTACK)) {
                        if (!(n & p.SCRIPT_VERIFY_P2SH)) throw new Error("cannot use CLEANSTACK without P2SH");
                        1 !== o.length && (this.errStr = this.errStr || "SCRIPT_ERR_CLEANSTACK", yield !1);
                    }
                    yield !0;
                }
                getDebugObject() {
                    const t = this.pc - 1;
                    return {
                        errStr: this.errStr,
                        scriptStr: this.script ? this.script.toString() : "no script found",
                        pc: t,
                        stack: this.stack.map((t)=>t.toString("hex")),
                        altStack: this.altStack.map((t)=>t.toString("hex")),
                        opCodeStr: this.script ? o.a.fromNumber(this.script.chunks[t].opCodeNum).toString() : "no script found"
                    };
                }
                getDebugString() {
                    return JSON.stringify(this.getDebugObject(), null, 2);
                }
            }
            p.true = t.from([
                1
            ]), p.false = t.from([]), p.MAX_SCRIPT_ELEMENT_SIZE = 520, p.LOCKTIME_THRESHOLD = 5e8, p.SCRIPT_VERIFY_NONE = 0, p.SCRIPT_VERIFY_P2SH = 1, p.SCRIPT_VERIFY_STRICTENC = 2, p.SCRIPT_VERIFY_DERSIG = 4, p.SCRIPT_VERIFY_LOW_S = 8, p.SCRIPT_VERIFY_NULLDUMMY = 16, p.SCRIPT_VERIFY_SIGPUSHONLY = 32, p.SCRIPT_VERIFY_MINIMALDATA = 64, p.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 128, p.SCRIPT_VERIFY_CLEANSTACK = 256, p.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = 512, p.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = 1024, p.SCRIPT_ENABLE_SIGHASH_FORKID = 65536, p.defaultFlags = p.SCRIPT_VERIFY_P2SH | p.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return n;
            });
            const i = r(126);
            class n {
                static encrypt(t, e) {
                    const r = n.buf2Words(e), s = n.buf2Words(t), a = new i(r).encrypt(s);
                    return n.words2Buf(a);
                }
                static decrypt(t, e) {
                    const r = n.buf2Words(t), s = n.buf2Words(e), a = new i(s).decrypt(r);
                    return n.words2Buf(a);
                }
                static buf2Words(t) {
                    if (t.length % 4) throw new Error("buf length must be a multiple of 4");
                    const e = [];
                    for(let r = 0; r < t.length / 4; r++)e.push(t.readUInt32BE(4 * r));
                    return e;
                }
                static words2Buf(e) {
                    const r = t.alloc(4 * e.length);
                    for(let t1 = 0; t1 < e.length; t1++)r.writeUInt32BE(e[t1], 4 * t1);
                    return r;
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return n;
            });
            var i = r(18);
            class n {
                static buf2BlocksBuf(t, e) {
                    const r = e / 8, i = [];
                    for(let s = 0; s <= t.length / r; s++){
                        let a = t.slice(s * r, s * r + r);
                        a.length < e && (a = n.pkcs7Pad(a, e)), i.push(a);
                    }
                    return i;
                }
                static blockBufs2Buf(e) {
                    let r = e[e.length - 1];
                    r = n.pkcs7Unpad(r), e[e.length - 1] = r;
                    return t.concat(e);
                }
                static encrypt(e, r, i, s) {
                    const a = 8 * r.length, o = n.buf2BlocksBuf(e, a), h = n.encryptBlocks(o, r, i, s);
                    return t.concat(h);
                }
                static decrypt(t, e, r, i) {
                    const s = e.length, a = [];
                    for(let e1 = 0; e1 < t.length / s; e1++)a.push(t.slice(e1 * s, e1 * s + s));
                    const o = n.decryptBlocks(a, e, r, i);
                    return n.blockBufs2Buf(o);
                }
                static encryptBlock(t, e, r, i) {
                    const s = n.xorBufs(t, e);
                    return r.encrypt(s, i);
                }
                static decryptBlock(t, e, r, i) {
                    const s = r.decrypt(t, i);
                    return n.xorBufs(s, e);
                }
                static encryptBlocks(t, e, r, i) {
                    const s = [];
                    for(let a = 0; a < t.length; a++){
                        const o = t[a], h = n.encryptBlock(o, e, r, i);
                        s.push(h), e = h;
                    }
                    return s;
                }
                static decryptBlocks(t, e, r, i) {
                    const s = [];
                    for(let a = 0; a < t.length; a++){
                        const o = t[a], h = n.decryptBlock(o, e, r, i);
                        s.push(h), e = o;
                    }
                    return s;
                }
                static pkcs7Pad(e, r) {
                    const i = r / 8 - e.length, n = t.alloc(i);
                    n.fill(i);
                    return t.concat([
                        e,
                        n
                    ]);
                }
                static pkcs7Unpad(e) {
                    const r = e[e.length - 1], n = e.slice(e.length - r, e.length), s = t.alloc(r);
                    if (s.fill(r), !Object(i.a)(n, s)) throw new Error("invalid padding");
                    return e.slice(0, e.length - r);
                }
                static xorBufs(e, r) {
                    if (e.length !== r.length) throw new Error("bufs must have the same length");
                    const i = t.alloc(e.length);
                    for(let t1 = 0; t1 < e.length; t1++)i[t1] = e[t1] ^ r[t1];
                    return i;
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return n;
            });
            var i = r(4);
            class n extends i.a {
                constructor(t, e, r){
                    super(), this.fromObject({
                        prevoutsHashBuf: t,
                        sequenceHashBuf: e,
                        outputsHashBuf: r
                    });
                }
                fromBuffer(t) {
                    return this.fromJSON(JSON.parse(t.toString()));
                }
                toBuffer() {
                    return t.from(JSON.stringify(this.toJSON()));
                }
                fromJSON(e) {
                    return this.prevoutsHashBuf = e.prevoutsHashBuf ? t.from(e.prevoutsHashBuf, "hex") : void 0, this.sequenceHashBuf = e.sequenceHashBuf ? t.from(e.sequenceHashBuf, "hex") : void 0, this.outputsHashBuf = e.outputsHashBuf ? t.from(e.outputsHashBuf, "hex") : void 0, this;
                }
                toJSON() {
                    return {
                        prevoutsHashBuf: this.prevoutsHashBuf ? this.prevoutsHashBuf.toString("hex") : void 0,
                        sequenceHashBuf: this.sequenceHashBuf ? this.sequenceHashBuf.toString("hex") : void 0,
                        outputsHashBuf: this.outputsHashBuf ? this.outputsHashBuf.toString("hex") : void 0
                    };
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return n;
            });
            class i {
                constructor(t){
                    this.values = t;
                }
                keyDefined(t) {
                    return t in this.values;
                }
                getValue(t) {
                    return this.values[t];
                }
                get(t) {
                    if (this.keyDefined(t)) return this.getValue(t);
                    throw new Error("Unknown configuration: " + t);
                }
            }
            const n = (new class {
                constructor(){
                    this.variables = {};
                }
                build() {
                    return new i(this.variables);
                }
                addValue(t, e) {
                    if (void 0 === e) throw new Error(`Failed to add "${t}" property. The value cannot be undefined`);
                    if (t in this.variables) throw new Error(`"${t}" already has a value defined.`);
                    return this.variables[t] = e, this;
                }
                addValueWithDefault(t, e, r) {
                    if (void 0 === r) throw new Error(`Failed to add "${t}" property. Default value cannot be undefined`);
                    return this.addValue(t, void 0 === e ? r : e);
                }
            }).addValue("NETWORK", t.env.NETWORK || "mainnet").build();
        }).call(this, r(26));
    },
    function(t, e, r) {
        "use strict";
        var i = r(25), n = r(30);
        function s() {
            this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
        }
        e.BlockHash = s, s.prototype.update = function(t, e) {
            if (t = i.toArray(t, e), this.pending ? this.pending = this.pending.concat(t) : this.pending = t, this.pendingTotal += t.length, this.pending.length >= this._delta8) {
                var r = (t = this.pending).length % this._delta8;
                this.pending = t.slice(t.length - r, t.length), 0 === this.pending.length && (this.pending = null), t = i.join32(t, 0, t.length - r, this.endian);
                for(var n = 0; n < t.length; n += this._delta32)this._update(t, n, n + this._delta32);
            }
            return this;
        }, s.prototype.digest = function(t) {
            return this.update(this._pad()), n(null === this.pending), this._digest(t);
        }, s.prototype._pad = function() {
            var t = this.pendingTotal, e = this._delta8, r = e - (t + this.padLength) % e, i = new Array(r + this.padLength);
            i[0] = 128;
            for(var n = 1; n < r; n++)i[n] = 0;
            if (t <<= 3, "big" === this.endian) {
                for(var s = 8; s < this.padLength; s++)i[n++] = 0;
                i[n++] = 0, i[n++] = 0, i[n++] = 0, i[n++] = 0, i[n++] = t >>> 24 & 255, i[n++] = t >>> 16 & 255, i[n++] = t >>> 8 & 255, i[n++] = 255 & t;
            } else for(i[n++] = 255 & t, i[n++] = t >>> 8 & 255, i[n++] = t >>> 16 & 255, i[n++] = t >>> 24 & 255, i[n++] = 0, i[n++] = 0, i[n++] = 0, i[n++] = 0, s = 8; s < this.padLength; s++)i[n++] = 0;
            return i;
        };
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return s;
            });
            var i = r(51), n = r(4);
            class s extends n.a {
                constructor(t){
                    super({
                        buf: t
                    });
                }
                fromHex(e) {
                    return this.fromBuffer(t.from(e, "hex"));
                }
                toHex() {
                    return this.toBuffer().toString("hex");
                }
                static encode(e) {
                    if (!t.isBuffer(e)) throw new Error("Input should be a buffer");
                    return i.encode(e);
                }
                static decode(e) {
                    if ("string" != typeof e) throw new Error("Input should be a string");
                    return t.from(i.decode(e));
                }
                fromBuffer(t) {
                    return this.buf = t, this;
                }
                fromString(t) {
                    const e = s.decode(t);
                    return this.buf = e, this;
                }
                toBuffer() {
                    return this.buf;
                }
                toString() {
                    return s.encode(this.buf);
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return s;
            });
            var i = r(6), n = r(4);
            class s extends n.a {
                constructor(t, e, r){
                    super({
                        resbuf: t,
                        isError: e,
                        id: r
                    });
                }
                fromResult(e, r) {
                    return t.isBuffer(e) ? this.resbuf = e : e.toFastBuffer ? this.resbuf = e.toFastBuffer() : this.resbuf = t.from(JSON.stringify(e)), this.isError = !1, this.id = r, this;
                }
                static fromResult(t, e) {
                    return (new this).fromResult(t, e);
                }
                fromError(e, r) {
                    return this.resbuf = t.from(JSON.stringify(e.message)), this.isError = !0, this.id = r, this;
                }
                toBw(t) {
                    return t || (t = new i.a), t.writeVarIntNum(this.resbuf.length), t.write(this.resbuf), t.writeUInt8(Number(this.isError)), t.writeVarIntNum(this.id), t;
                }
                fromBr(t) {
                    const e = t.readVarIntNum();
                    return this.resbuf = t.read(e), this.isError = Boolean(t.readUInt8()), this.id = t.readVarIntNum(), this;
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        r.d(e, "a", function() {
            return s;
        });
        var i = r(5), n = r(4);
        class s extends n.a {
            constructor(t = new Map){
                super({
                    map: t
                });
            }
            toJSON() {
                const t = {};
                for (const [e, r] of this.map.entries())t[e] = r.map((t)=>({
                        nScriptChunk: t.nScriptChunk,
                        type: t.type,
                        addressStr: t.addressStr,
                        nHashType: t.nHashType,
                        log: t.log
                    }));
                return t;
            }
            fromJSON(t) {
                for (const e of Object.keys(t))this.map.set(e, t[e].map((t)=>({
                        nScriptChunk: t.nScriptChunk,
                        type: t.type,
                        addressStr: t.addressStr,
                        nHashType: t.nHashType,
                        log: t.log
                    })));
                return this;
            }
            setOne(t, e, r, n = "sig", s, a = i.a.SIGHASH_ALL | i.a.SIGHASH_FORKID) {
                const o = t.toString("hex") + ":" + e, h = {
                    nScriptChunk: r,
                    type: n,
                    addressStr: s,
                    nHashType: a
                };
                return this.map.set(o, [
                    h
                ]), this;
            }
            setMany(t, e, r) {
                const n = t.toString("hex") + ":" + e;
                return r = r.map((t)=>({
                        type: t.type || "sig",
                        nHashType: t.nHashType || i.a.SIGHASH_ALL | i.a.SIGHASH_FORKID,
                        ...t
                    })), this.map.set(n, r), this;
            }
            addOne(t, e, r, n = "sig", s, a = i.a.SIGHASH_ALL | i.a.SIGHASH_FORKID) {
                const o = this.get(t, e) || [];
                return o.push({
                    nScriptChunk: r,
                    type: n,
                    addressStr: s,
                    nHashType: a
                }), this.setMany(t, e, o), this;
            }
            get(t, e) {
                const r = t.toString("hex") + ":" + e;
                return this.map.get(r) || [];
            }
        }
    },
    function(t, e, r) {
        "use strict";
        r.d(e, "a", function() {
            return s;
        });
        var i = r(4), n = r(20);
        class s extends i.a {
            constructor(t = new Map){
                super({
                    map: t
                });
            }
            toJSON() {
                const t = {};
                for (const [e, r] of this.map.entries())t[e] = r.toHex();
                return t;
            }
            fromJSON(t) {
                for (const e of Object.keys(t))this.map.set(e, n.a.fromHex(t[e]));
                return this;
            }
            set(t, e, r) {
                const i = t.toString("hex") + ":" + e;
                return this.map.set(i, r), this;
            }
            get(t, e) {
                const r = t.toString("hex") + ":" + e;
                return this.map.get(r);
            }
            setTx(t) {
                const e = t.hash().toString("hex");
                for (const [r, i] of t.txOuts.entries()){
                    const t1 = e + ":" + r;
                    this.map.set(t1, i);
                }
                return this;
            }
        }
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return d;
            });
            var i = r(37), n = r(12), s = r(6), a = r(3), o = r(86), h = r(4), c = r(15), u = r(10), f = r(2);
            class d extends h.a {
                constructor(t, e, r){
                    super({
                        blockHeader: t,
                        txsVi: e,
                        txs: r
                    });
                }
                fromJSON(t) {
                    const e = [];
                    for (const r of t.txs)e.push((new c.a).fromJSON(r));
                    return this.fromObject({
                        blockHeader: (new i.a).fromJSON(t.blockHeader),
                        txsVi: (new u.a).fromJSON(t.txsVi),
                        txs: e
                    }), this;
                }
                toJSON() {
                    const t = [];
                    for (const e of t)t.push(e.toJSON());
                    return {
                        blockHeader: this.blockHeader.toJSON(),
                        txsVi: this.txsVi.toJSON(),
                        txs: t
                    };
                }
                fromBr(t) {
                    this.blockHeader = (new i.a).fromBr(t), this.txsVi = new u.a(t.readVarIntBuf());
                    const e = this.txsVi.toNumber();
                    this.txs = [];
                    for(let r = 0; r < e; r++)this.txs.push((new c.a).fromBr(t));
                    return this;
                }
                toBw(t) {
                    t || (t = new s.a), t.write(this.blockHeader.toBuffer()), t.write(this.txsVi.buf);
                    const e = this.txsVi.toNumber();
                    for(let r = 0; r < e; r++)this.txs[r].toBw(t);
                    return t;
                }
                hash() {
                    return a.a.sha256Sha256(this.blockHeader.toBuffer());
                }
                async asyncHash() {
                    return (await f.a.asyncObjectMethod(this, "hash", [])).resbuf;
                }
                id() {
                    return new n.a(this.hash()).readReverse().toString("hex");
                }
                async asyncId() {
                    const t = await f.a.asyncObjectMethod(this, "id", []);
                    return JSON.parse(t.resbuf.toString());
                }
                verifyMerkleRoot() {
                    const e = this.txs.map((t)=>t.toBuffer()), r = o.a.fromBuffers(e).hash();
                    return t.compare(r, this.blockHeader.merkleRootBuf);
                }
                static iterateTxs(t) {
                    const e = new n.a(t), r = (new i.a).fromBr(e), s = new u.a(e.readVarIntBuf()), a = s.toNumber();
                    return {
                        blockHeader: r,
                        txsVi: s,
                        txsNum: a,
                        *[Symbol.iterator] () {
                            for(let t = 0; t < a; t++)yield (new c.a).fromBr(e);
                        }
                    };
                }
            }
            d.MAX_BLOCK_SIZE = 1e6;
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        var i = /([0-9]|[a-f])/gim;
        t.exports = function(t) {
            return "string" == typeof t && (t.match(i) || []).length === t.length;
        };
    },
    function(t, e, r) {
        "use strict";
        var i = r(34).codes.ERR_STREAM_PREMATURE_CLOSE;
        function n() {}
        t.exports = function t(e, r, s) {
            if ("function" == typeof r) return t(e, null, r);
            r || (r = {}), s = function(t) {
                var e = !1;
                return function() {
                    if (!e) {
                        e = !0;
                        for(var r = arguments.length, i = new Array(r), n = 0; n < r; n++)i[n] = arguments[n];
                        t.apply(this, i);
                    }
                };
            }(s || n);
            var a = r.readable || !1 !== r.readable && e.readable, o = r.writable || !1 !== r.writable && e.writable, h = function() {
                e.writable || u();
            }, c = e._writableState && e._writableState.finished, u = function() {
                o = !1, c = !0, a || s.call(e);
            }, f = e._readableState && e._readableState.endEmitted, d = function() {
                a = !1, f = !0, o || s.call(e);
            }, l = function(t) {
                s.call(e, t);
            }, p = function() {
                var t;
                return a && !f ? (e._readableState && e._readableState.ended || (t = new i), s.call(e, t)) : o && !c ? (e._writableState && e._writableState.ended || (t = new i), s.call(e, t)) : void 0;
            }, b = function() {
                e.req.on("finish", u);
            };
            return !function(t) {
                return t.setHeader && "function" == typeof t.abort;
            }(e) ? o && !e._writableState && (e.on("end", h), e.on("close", h)) : (e.on("complete", u), e.on("abort", p), e.req ? b() : e.on("request", b)), e.on("end", d), e.on("finish", u), !1 !== r.error && e.on("error", l), e.on("close", p), function() {
                e.removeListener("complete", u), e.removeListener("abort", p), e.removeListener("request", b), e.req && e.req.removeListener("finish", u), e.removeListener("end", h), e.removeListener("close", h), e.removeListener("finish", u), e.removeListener("end", d), e.removeListener("error", l), e.removeListener("close", p);
            };
        };
    },
    function(t, e, r) {
        var i = r(91);
        t.exports = i("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    },
    function(t, e, r) {
        "use strict";
        var i = r(25).rotr32;
        function n(t, e, r) {
            return t & e ^ ~t & r;
        }
        function s(t, e, r) {
            return t & e ^ t & r ^ e & r;
        }
        function a(t, e, r) {
            return t ^ e ^ r;
        }
        e.ft_1 = function(t, e, r, i) {
            return 0 === t ? n(e, r, i) : 1 === t || 3 === t ? a(e, r, i) : 2 === t ? s(e, r, i) : void 0;
        }, e.ch32 = n, e.maj32 = s, e.p32 = a, e.s0_256 = function(t) {
            return i(t, 2) ^ i(t, 13) ^ i(t, 22);
        }, e.s1_256 = function(t) {
            return i(t, 6) ^ i(t, 11) ^ i(t, 25);
        }, e.g0_256 = function(t) {
            return i(t, 7) ^ i(t, 18) ^ t >>> 3;
        }, e.g1_256 = function(t) {
            return i(t, 17) ^ i(t, 19) ^ t >>> 10;
        };
    },
    function(t, e, r) {
        "use strict";
        var i = r(25), n = r(43), s = r(52), a = r(30), o = i.sum32, h = i.sum32_4, c = i.sum32_5, u = s.ch32, f = s.maj32, d = s.s0_256, l = s.s1_256, p = s.g0_256, b = s.g1_256, m = n.BlockHash, g = [
            1116352408,
            1899447441,
            3049323471,
            3921009573,
            961987163,
            1508970993,
            2453635748,
            2870763221,
            3624381080,
            310598401,
            607225278,
            1426881987,
            1925078388,
            2162078206,
            2614888103,
            3248222580,
            3835390401,
            4022224774,
            264347078,
            604807628,
            770255983,
            1249150122,
            1555081692,
            1996064986,
            2554220882,
            2821834349,
            2952996808,
            3210313671,
            3336571891,
            3584528711,
            113926993,
            338241895,
            666307205,
            773529912,
            1294757372,
            1396182291,
            1695183700,
            1986661051,
            2177026350,
            2456956037,
            2730485921,
            2820302411,
            3259730800,
            3345764771,
            3516065817,
            3600352804,
            4094571909,
            275423344,
            430227734,
            506948616,
            659060556,
            883997877,
            958139571,
            1322822218,
            1537002063,
            1747873779,
            1955562222,
            2024104815,
            2227730452,
            2361852424,
            2428436474,
            2756734187,
            3204031479,
            3329325298
        ];
        function y() {
            if (!(this instanceof y)) return new y;
            m.call(this), this.h = [
                1779033703,
                3144134277,
                1013904242,
                2773480762,
                1359893119,
                2600822924,
                528734635,
                1541459225
            ], this.k = g, this.W = new Array(64);
        }
        i.inherits(y, m), t.exports = y, y.blockSize = 512, y.outSize = 256, y.hmacStrength = 192, y.padLength = 64, y.prototype._update = function(t, e) {
            for(var r = this.W, i = 0; i < 16; i++)r[i] = t[e + i];
            for(; i < r.length; i++)r[i] = h(b(r[i - 2]), r[i - 7], p(r[i - 15]), r[i - 16]);
            var n = this.h[0], s = this.h[1], m = this.h[2], g = this.h[3], y = this.h[4], w = this.h[5], _ = this.h[6], v = this.h[7];
            for(a(this.k.length === r.length), i = 0; i < r.length; i++){
                var S = c(v, l(y), u(y, w, _), this.k[i], r[i]), O = o(d(n), f(n, s, m));
                v = _, _ = w, w = y, y = o(g, S), g = m, m = s, s = n, n = o(S, O);
            }
            this.h[0] = o(this.h[0], n), this.h[1] = o(this.h[1], s), this.h[2] = o(this.h[2], m), this.h[3] = o(this.h[3], g), this.h[4] = o(this.h[4], y), this.h[5] = o(this.h[5], w), this.h[6] = o(this.h[6], _), this.h[7] = o(this.h[7], v);
        }, y.prototype._digest = function(t) {
            return "hex" === t ? i.toHex32(this.h, "big") : i.split32(this.h, "big");
        };
    },
    function(t, e, r) {
        "use strict";
        var i = r(25), n = r(43), s = r(30), a = i.rotr64_hi, o = i.rotr64_lo, h = i.shr64_hi, c = i.shr64_lo, u = i.sum64, f = i.sum64_hi, d = i.sum64_lo, l = i.sum64_4_hi, p = i.sum64_4_lo, b = i.sum64_5_hi, m = i.sum64_5_lo, g = n.BlockHash, y = [
            1116352408,
            3609767458,
            1899447441,
            602891725,
            3049323471,
            3964484399,
            3921009573,
            2173295548,
            961987163,
            4081628472,
            1508970993,
            3053834265,
            2453635748,
            2937671579,
            2870763221,
            3664609560,
            3624381080,
            2734883394,
            310598401,
            1164996542,
            607225278,
            1323610764,
            1426881987,
            3590304994,
            1925078388,
            4068182383,
            2162078206,
            991336113,
            2614888103,
            633803317,
            3248222580,
            3479774868,
            3835390401,
            2666613458,
            4022224774,
            944711139,
            264347078,
            2341262773,
            604807628,
            2007800933,
            770255983,
            1495990901,
            1249150122,
            1856431235,
            1555081692,
            3175218132,
            1996064986,
            2198950837,
            2554220882,
            3999719339,
            2821834349,
            766784016,
            2952996808,
            2566594879,
            3210313671,
            3203337956,
            3336571891,
            1034457026,
            3584528711,
            2466948901,
            113926993,
            3758326383,
            338241895,
            168717936,
            666307205,
            1188179964,
            773529912,
            1546045734,
            1294757372,
            1522805485,
            1396182291,
            2643833823,
            1695183700,
            2343527390,
            1986661051,
            1014477480,
            2177026350,
            1206759142,
            2456956037,
            344077627,
            2730485921,
            1290863460,
            2820302411,
            3158454273,
            3259730800,
            3505952657,
            3345764771,
            106217008,
            3516065817,
            3606008344,
            3600352804,
            1432725776,
            4094571909,
            1467031594,
            275423344,
            851169720,
            430227734,
            3100823752,
            506948616,
            1363258195,
            659060556,
            3750685593,
            883997877,
            3785050280,
            958139571,
            3318307427,
            1322822218,
            3812723403,
            1537002063,
            2003034995,
            1747873779,
            3602036899,
            1955562222,
            1575990012,
            2024104815,
            1125592928,
            2227730452,
            2716904306,
            2361852424,
            442776044,
            2428436474,
            593698344,
            2756734187,
            3733110249,
            3204031479,
            2999351573,
            3329325298,
            3815920427,
            3391569614,
            3928383900,
            3515267271,
            566280711,
            3940187606,
            3454069534,
            4118630271,
            4000239992,
            116418474,
            1914138554,
            174292421,
            2731055270,
            289380356,
            3203993006,
            460393269,
            320620315,
            685471733,
            587496836,
            852142971,
            1086792851,
            1017036298,
            365543100,
            1126000580,
            2618297676,
            1288033470,
            3409855158,
            1501505948,
            4234509866,
            1607167915,
            987167468,
            1816402316,
            1246189591
        ];
        function w() {
            if (!(this instanceof w)) return new w;
            g.call(this), this.h = [
                1779033703,
                4089235720,
                3144134277,
                2227873595,
                1013904242,
                4271175723,
                2773480762,
                1595750129,
                1359893119,
                2917565137,
                2600822924,
                725511199,
                528734635,
                4215389547,
                1541459225,
                327033209
            ], this.k = y, this.W = new Array(160);
        }
        function _(t, e, r, i, n) {
            var s = t & r ^ ~t & n;
            return s < 0 && (s += 4294967296), s;
        }
        function v(t, e, r, i, n, s) {
            var a = e & i ^ ~e & s;
            return a < 0 && (a += 4294967296), a;
        }
        function S(t, e, r, i, n) {
            var s = t & r ^ t & n ^ r & n;
            return s < 0 && (s += 4294967296), s;
        }
        function O(t, e, r, i, n, s) {
            var a = e & i ^ e & s ^ i & s;
            return a < 0 && (a += 4294967296), a;
        }
        function E(t, e) {
            var r = a(t, e, 28) ^ a(e, t, 2) ^ a(e, t, 7);
            return r < 0 && (r += 4294967296), r;
        }
        function I(t, e) {
            var r = o(t, e, 28) ^ o(e, t, 2) ^ o(e, t, 7);
            return r < 0 && (r += 4294967296), r;
        }
        function B(t, e) {
            var r = a(t, e, 14) ^ a(t, e, 18) ^ a(e, t, 9);
            return r < 0 && (r += 4294967296), r;
        }
        function P(t, e) {
            var r = o(t, e, 14) ^ o(t, e, 18) ^ o(e, t, 9);
            return r < 0 && (r += 4294967296), r;
        }
        function R(t, e) {
            var r = a(t, e, 1) ^ a(t, e, 8) ^ h(t, e, 7);
            return r < 0 && (r += 4294967296), r;
        }
        function k(t, e) {
            var r = o(t, e, 1) ^ o(t, e, 8) ^ c(t, e, 7);
            return r < 0 && (r += 4294967296), r;
        }
        function A(t, e) {
            var r = a(t, e, 19) ^ a(e, t, 29) ^ h(t, e, 6);
            return r < 0 && (r += 4294967296), r;
        }
        function N(t, e) {
            var r = o(t, e, 19) ^ o(e, t, 29) ^ c(t, e, 6);
            return r < 0 && (r += 4294967296), r;
        }
        i.inherits(w, g), t.exports = w, w.blockSize = 1024, w.outSize = 512, w.hmacStrength = 192, w.padLength = 128, w.prototype._prepareBlock = function(t, e) {
            for(var r = this.W, i = 0; i < 32; i++)r[i] = t[e + i];
            for(; i < r.length; i += 2){
                var n = A(r[i - 4], r[i - 3]), s = N(r[i - 4], r[i - 3]), a = r[i - 14], o = r[i - 13], h = R(r[i - 30], r[i - 29]), c = k(r[i - 30], r[i - 29]), u = r[i - 32], f = r[i - 31];
                r[i] = l(n, s, a, o, h, c, u, f), r[i + 1] = p(n, s, a, o, h, c, u, f);
            }
        }, w.prototype._update = function(t, e) {
            this._prepareBlock(t, e);
            var r = this.W, i = this.h[0], n = this.h[1], a = this.h[2], o = this.h[3], h = this.h[4], c = this.h[5], l = this.h[6], p = this.h[7], g = this.h[8], y = this.h[9], w = this.h[10], R = this.h[11], k = this.h[12], A = this.h[13], N = this.h[14], x = this.h[15];
            s(this.k.length === r.length);
            for(var M = 0; M < r.length; M += 2){
                var T = N, C = x, L = B(g, y), H = P(g, y), U = _(g, y, w, R, k), F = v(g, y, w, R, k, A), D = this.k[M], K = this.k[M + 1], V = r[M], j = r[M + 1], q = b(T, C, L, H, U, F, D, K, V, j), Y = m(T, C, L, H, U, F, D, K, V, j);
                T = E(i, n), C = I(i, n), L = S(i, n, a, o, h), H = O(i, n, a, o, h, c);
                var z = f(T, C, L, H), G = d(T, C, L, H);
                N = k, x = A, k = w, A = R, w = g, R = y, g = f(l, p, q, Y), y = d(p, p, q, Y), l = h, p = c, h = a, c = o, a = i, o = n, i = f(q, Y, z, G), n = d(q, Y, z, G);
            }
            u(this.h, 0, i, n), u(this.h, 2, a, o), u(this.h, 4, h, c), u(this.h, 6, l, p), u(this.h, 8, g, y), u(this.h, 10, w, R), u(this.h, 12, k, A), u(this.h, 14, N, x);
        }, w.prototype._digest = function(t) {
            return "hex" === t ? i.toHex32(this.h, "big") : i.split32(this.h, "big");
        };
    },
    function(t, e, r) {
        "use strict";
        var i = e;
        function n(t) {
            return 1 === t.length ? "0" + t : t;
        }
        function s(t) {
            for(var e = "", r = 0; r < t.length; r++)e += n(t[r].toString(16));
            return e;
        }
        i.toArray = function(t, e) {
            if (Array.isArray(t)) return t.slice();
            if (!t) return [];
            var r = [];
            if ("string" != typeof t) {
                for(var i = 0; i < t.length; i++)r[i] = 0 | t[i];
                return r;
            }
            if ("hex" === e) {
                (t = t.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (t = "0" + t);
                for(i = 0; i < t.length; i += 2)r.push(parseInt(t[i] + t[i + 1], 16));
            } else for(i = 0; i < t.length; i++){
                var n = t.charCodeAt(i), s = n >> 8, a = 255 & n;
                s ? r.push(s, a) : r.push(a);
            }
            return r;
        }, i.zero2 = n, i.toHex = s, i.encode = function(t, e) {
            return "hex" === e ? s(t) : t;
        };
    },
    function(t, e, r) {
        var i;
        function n(t) {
            this.rand = t;
        }
        if (t.exports = function(t) {
            return i || (i = new n(null)), i.generate(t);
        }, t.exports.Rand = n, n.prototype.generate = function(t) {
            return this._rand(t);
        }, n.prototype._rand = function(t) {
            if (this.rand.getBytes) return this.rand.getBytes(t);
            for(var e = new Uint8Array(t), r = 0; r < e.length; r++)e[r] = this.rand.getByte();
            return e;
        }, "object" == typeof self) self.crypto && self.crypto.getRandomValues ? n.prototype._rand = function(t) {
            var e = new Uint8Array(t);
            return self.crypto.getRandomValues(e), e;
        } : self.msCrypto && self.msCrypto.getRandomValues ? n.prototype._rand = function(t) {
            var e = new Uint8Array(t);
            return self.msCrypto.getRandomValues(e), e;
        } : "object" == typeof window && (n.prototype._rand = function() {
            throw new Error("Not implemented yet");
        });
        else try {
            var s = r(101);
            if ("function" != typeof s.randomBytes) throw new Error("Not supported");
            n.prototype._rand = function(t) {
                return s.randomBytes(t);
            };
        } catch (t1) {}
    },
    function(t, e, r) {
        "use strict";
        var i = e;
        i.base = r(58), i.short = r(102);
    },
    function(t, e, r) {
        "use strict";
        var i = r(14), n = r(31), s = n.getNAF, a = n.getJSF, o = n.assert;
        function h(t, e) {
            this.type = t, this.p = new i(e.p, 16), this.red = e.prime ? i.red(e.prime) : i.mont(this.p), this.zero = new i(0).toRed(this.red), this.one = new i(1).toRed(this.red), this.two = new i(2).toRed(this.red), this.n = e.n && new i(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
            var r = this.n && this.p.div(this.n);
            !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
        }
        function c(t, e) {
            this.curve = t, this.type = e, this.precomputed = null;
        }
        t.exports = h, h.prototype.point = function() {
            throw new Error("Not implemented");
        }, h.prototype.validate = function() {
            throw new Error("Not implemented");
        }, h.prototype._fixedNafMul = function(t, e) {
            o(t.precomputed);
            var r = t._getDoubles(), i = s(e, 1, this._bitLength), n = (1 << r.step + 1) - (r.step % 2 == 0 ? 2 : 1);
            n /= 3;
            for(var a = [], h = 0; h < i.length; h += r.step){
                var c = 0;
                for(e = h + r.step - 1; e >= h; e--)c = (c << 1) + i[e];
                a.push(c);
            }
            for(var u = this.jpoint(null, null, null), f = this.jpoint(null, null, null), d = n; d > 0; d--){
                for(h = 0; h < a.length; h++)(c = a[h]) === d ? f = f.mixedAdd(r.points[h]) : c === -d && (f = f.mixedAdd(r.points[h].neg()));
                u = u.add(f);
            }
            return u.toP();
        }, h.prototype._wnafMul = function(t, e) {
            var r = 4, i = t._getNAFPoints(r);
            r = i.wnd;
            for(var n = i.points, a = s(e, r, this._bitLength), h = this.jpoint(null, null, null), c = a.length - 1; c >= 0; c--){
                for(e = 0; c >= 0 && 0 === a[c]; c--)e++;
                if (c >= 0 && e++, h = h.dblp(e), c < 0) break;
                var u = a[c];
                o(0 !== u), h = "affine" === t.type ? u > 0 ? h.mixedAdd(n[u - 1 >> 1]) : h.mixedAdd(n[-u - 1 >> 1].neg()) : u > 0 ? h.add(n[u - 1 >> 1]) : h.add(n[-u - 1 >> 1].neg());
            }
            return "affine" === t.type ? h.toP() : h;
        }, h.prototype._wnafMulAdd = function(t, e, r, i, n) {
            for(var o = this._wnafT1, h = this._wnafT2, c = this._wnafT3, u = 0, f = 0; f < i; f++){
                var d = (I = e[f])._getNAFPoints(t);
                o[f] = d.wnd, h[f] = d.points;
            }
            for(f = i - 1; f >= 1; f -= 2){
                var l = f - 1, p = f;
                if (1 === o[l] && 1 === o[p]) {
                    var b = [
                        e[l],
                        null,
                        null,
                        e[p]
                    ];
                    0 === e[l].y.cmp(e[p].y) ? (b[1] = e[l].add(e[p]), b[2] = e[l].toJ().mixedAdd(e[p].neg())) : 0 === e[l].y.cmp(e[p].y.redNeg()) ? (b[1] = e[l].toJ().mixedAdd(e[p]), b[2] = e[l].add(e[p].neg())) : (b[1] = e[l].toJ().mixedAdd(e[p]), b[2] = e[l].toJ().mixedAdd(e[p].neg()));
                    var m = [
                        -3,
                        -1,
                        -5,
                        -7,
                        0,
                        7,
                        5,
                        1,
                        3
                    ], g = a(r[l], r[p]);
                    u = Math.max(g[0].length, u), c[l] = new Array(u), c[p] = new Array(u);
                    for(var y = 0; y < u; y++){
                        var w = 0 | g[0][y], _ = 0 | g[1][y];
                        c[l][y] = m[3 * (w + 1) + (_ + 1)], c[p][y] = 0, h[l] = b;
                    }
                } else c[l] = s(r[l], o[l], this._bitLength), c[p] = s(r[p], o[p], this._bitLength), u = Math.max(c[l].length, u), u = Math.max(c[p].length, u);
            }
            var v = this.jpoint(null, null, null), S = this._wnafT4;
            for(f = u; f >= 0; f--){
                for(var O = 0; f >= 0;){
                    var E = !0;
                    for(y = 0; y < i; y++)S[y] = 0 | c[y][f], 0 !== S[y] && (E = !1);
                    if (!E) break;
                    O++, f--;
                }
                if (f >= 0 && O++, v = v.dblp(O), f < 0) break;
                for(y = 0; y < i; y++){
                    var I, B = S[y];
                    0 !== B && (B > 0 ? I = h[y][B - 1 >> 1] : B < 0 && (I = h[y][-B - 1 >> 1].neg()), v = "affine" === I.type ? v.mixedAdd(I) : v.add(I));
                }
            }
            for(f = 0; f < i; f++)h[f] = null;
            return n ? v : v.toP();
        }, h.BasePoint = c, c.prototype.eq = function() {
            throw new Error("Not implemented");
        }, c.prototype.validate = function() {
            return this.curve.validate(this);
        }, h.prototype.decodePoint = function(t, e) {
            t = n.toArray(t, e);
            var r = this.p.byteLength();
            if ((4 === t[0] || 6 === t[0] || 7 === t[0]) && t.length - 1 == 2 * r) return 6 === t[0] ? o(t[t.length - 1] % 2 == 0) : 7 === t[0] && o(t[t.length - 1] % 2 == 1), this.point(t.slice(1, 1 + r), t.slice(1 + r, 1 + 2 * r));
            if ((2 === t[0] || 3 === t[0]) && t.length - 1 === r) return this.pointFromX(t.slice(1, 1 + r), 3 === t[0]);
            throw new Error("Unknown point format");
        }, c.prototype.encodeCompressed = function(t) {
            return this.encode(t, !0);
        }, c.prototype._encode = function(t) {
            var e = this.curve.p.byteLength(), r = this.getX().toArray("be", e);
            return t ? [
                this.getY().isEven() ? 2 : 3
            ].concat(r) : [
                4
            ].concat(r, this.getY().toArray("be", e));
        }, c.prototype.encode = function(t, e) {
            return n.encode(this._encode(e), t);
        }, c.prototype.precompute = function(t) {
            if (this.precomputed) return this;
            var e = {
                doubles: null,
                naf: null,
                beta: null
            };
            return e.naf = this._getNAFPoints(8), e.doubles = this._getDoubles(4, t), e.beta = this._getBeta(), this.precomputed = e, this;
        }, c.prototype._hasDoubles = function(t) {
            if (!this.precomputed) return !1;
            var e = this.precomputed.doubles;
            return !!e && e.points.length >= Math.ceil((t.bitLength() + 1) / e.step);
        }, c.prototype._getDoubles = function(t, e) {
            if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
            for(var r = [
                this
            ], i = this, n = 0; n < e; n += t){
                for(var s = 0; s < t; s++)i = i.dbl();
                r.push(i);
            }
            return {
                step: t,
                points: r
            };
        }, c.prototype._getNAFPoints = function(t) {
            if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
            for(var e = [
                this
            ], r = (1 << t) - 1, i = 1 === r ? null : this.dbl(), n = 1; n < r; n++)e[n] = e[n - 1].add(i);
            return {
                wnd: t,
                points: e
            };
        }, c.prototype._getBeta = function() {
            return null;
        }, c.prototype.dblp = function(t) {
            for(var e = this, r = 0; r < t; r++)e = e.dbl();
            return e;
        };
    },
    function(t, e, r) {
        "use strict";
        var i, n, s, a = e, o = r(32), h = r(57), c = r(31).assert;
        function u(t) {
            if ("short" !== t.type) throw new Error("invalid curve type");
            this.curve = new h.short(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, c(this.g.validate(), "Invalid curve"), c(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
        }
        a.PresetCurve = u;
        try {
            i = r(103);
        } catch (t1) {
            i = void 0;
        }
        n = "secp256k1", s = {
            type: "short",
            prime: "k256",
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            a: "0",
            b: "7",
            n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
            h: "1",
            hash: o.sha256,
            beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
            basis: [
                {
                    a: "3086d221a7d46bcde86c90e49284eb15",
                    b: "-e4437ed6010e88286f547fa90abfe4c3"
                },
                {
                    a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                    b: "3086d221a7d46bcde86c90e49284eb15"
                }
            ],
            gRed: !1,
            g: [
                "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
                i
            ]
        }, Object.defineProperty(a, n, {
            configurable: !0,
            enumerable: !0,
            get: function() {
                var t = new u(s);
                return Object.defineProperty(a, n, {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                }), t;
            }
        });
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return p;
            });
            var i = r(24), n = r(1), s = r(6), a = r(19), o = r(3), h = r(11), c = r(23), u = r(8), f = r(16), d = r(4), l = r(2);
            class p extends d.a {
                constructor(t, e, r, i, n, s, o, h, u = c.a){
                    super({
                        versionBytesNum: t,
                        depth: e,
                        parentFingerPrint: r,
                        childIndex: i,
                        chainCode: n,
                        privKey: s,
                        pubKey: o
                    }), this.Constants = h || a.a.Default.Bip32, this.PrivKey = u;
                }
                fromRandom() {
                    return this.versionBytesNum = this.Constants.privKey, this.depth = 0, this.parentFingerPrint = t.from([
                        0,
                        0,
                        0,
                        0
                    ]), this.childIndex = 0, this.chainCode = f.a.getRandomBuffer(32), this.privKey = (new this.PrivKey).fromRandom(), this.pubKey = (new u.a).fromPrivKey(this.privKey), this;
                }
                static fromRandom() {
                    return (new this).fromRandom();
                }
                fromString(t) {
                    return this.fromBuffer(i.a.decode(t));
                }
                async asyncFromString(t) {
                    const e = [
                        t
                    ], r = await l.a.asyncObjectMethod(this, "fromString", e);
                    return this.fromFastBuffer(r.resbuf);
                }
                fromSeed(e) {
                    if (!t.isBuffer(e)) throw new Error("bytes must be a buffer");
                    if (e.length < 16) throw new Error("Need more than 128 bits of entropy");
                    if (e.length > 64) throw new Error("More than 512 bits of entropy is nonstandard");
                    const r = o.a.sha512Hmac(e, t.from("Bitcoin seed"));
                    return this.depth = 0, this.parentFingerPrint = t.from([
                        0,
                        0,
                        0,
                        0
                    ]), this.childIndex = 0, this.chainCode = r.slice(32, 64), this.versionBytesNum = this.Constants.privKey, this.privKey = (new this.PrivKey).fromBn((new n.a).fromBuffer(r.slice(0, 32))), this.pubKey = (new u.a).fromPrivKey(this.privKey), this;
                }
                static fromSeed(t) {
                    return (new this).fromSeed(t);
                }
                async asyncFromSeed(t) {
                    const e = await l.a.asyncObjectMethod(this, "fromSeed", [
                        t
                    ]);
                    return this.fromFastBuffer(e.resbuf);
                }
                static asyncFromSeed(t) {
                    return (new this).asyncFromSeed(t);
                }
                fromBuffer(t) {
                    if (78 !== t.length) throw new Error("incorrect bip32 data length");
                    this.versionBytesNum = t.slice(0, 4).readUInt32BE(0), this.depth = t.slice(4, 5).readUInt8(0), this.parentFingerPrint = t.slice(5, 9), this.childIndex = t.slice(9, 13).readUInt32BE(0), this.chainCode = t.slice(13, 45);
                    const e = t.slice(45, 78), r = this.versionBytesNum === this.Constants.privKey, i = this.versionBytesNum === this.Constants.pubKey;
                    if (r && 0 === e[0]) this.privKey = (new this.PrivKey).fromBn((new n.a).fromBuffer(e.slice(1, 33))), this.pubKey = (new u.a).fromPrivKey(this.privKey);
                    else {
                        if (!i || 2 !== e[0] && 3 !== e[0]) throw new Error("Invalid key");
                        this.pubKey = (new u.a).fromDer(e);
                    }
                    return this;
                }
                fromFastBuffer(t) {
                    if (0 === t.length) return this;
                    if (78 !== t.length && 111 !== t.length) throw new Error("incorrect bip32 fastBuffer data length: " + t.length);
                    this.versionBytesNum = t.slice(0, 4).readUInt32BE(0), this.depth = t.slice(4, 5).readUInt8(0), this.parentFingerPrint = t.slice(5, 9), this.childIndex = t.slice(9, 13).readUInt32BE(0), this.chainCode = t.slice(13, 45);
                    const e = t.slice(45, t.length), r = this.versionBytesNum === this.Constants.privKey, i = this.versionBytesNum === this.Constants.pubKey;
                    if (r && 0 === e[0] && 78 === t.length) this.privKey = (new this.PrivKey).fromBn((new n.a).fromBuffer(e.slice(1, 33))), this.pubKey = (new u.a).fromPrivKey(this.privKey);
                    else {
                        if (!i || 111 !== t.length) throw new Error("Invalid key");
                        this.pubKey = (new u.a).fromFastBuffer(e), this.pubKey.compressed = !0;
                    }
                    return this;
                }
                derive(t) {
                    const e = t.split("/");
                    if ("m" === t) return this;
                    let r = this;
                    for(const t1 in e){
                        const i = e[t1];
                        if ("0" === t1) {
                            if ("m" !== i) throw new Error("invalid path");
                            continue;
                        }
                        if (parseInt(i.replace("'", ""), 10).toString() !== i.replace("'", "")) throw new Error("invalid path");
                        const n = i.length > 1 && "'" === i[i.length - 1];
                        let s = 2147483647 & parseInt(n ? i.slice(0, i.length - 1) : i, 10);
                        n && (s += 2147483648), r = r.deriveChild(s);
                    }
                    return r;
                }
                async asyncDerive(t) {
                    const e = await l.a.asyncObjectMethod(this, "derive", [
                        t
                    ]);
                    return (new this.constructor).fromFastBuffer(e.resbuf);
                }
                deriveChild(e) {
                    if ("number" != typeof e) throw new Error("i must be a number");
                    const r = [];
                    r.push(e >> 24 & 255), r.push(e >> 16 & 255), r.push(e >> 8 & 255), r.push(255 & e);
                    const i = t.from(r), s = 0 != (2147483648 & e), a = this.versionBytesNum === this.Constants.privKey;
                    if (s && (!this.privKey || !a)) throw new Error("Cannot do private key derivation without private key");
                    let c = null;
                    if (this.privKey) {
                        let e1 = null;
                        e1 = s ? t.concat([
                            t.from([
                                0
                            ]),
                            this.privKey.bn.toBuffer({
                                size: 32
                            }),
                            i
                        ]) : t.concat([
                            this.pubKey.toBuffer(),
                            i
                        ]);
                        const r1 = o.a.sha512Hmac(e1, this.chainCode), a1 = (new n.a).fromBuffer(r1.slice(0, 32)), f = r1.slice(32, 64), d = a1.add(this.privKey.bn).mod(h.a.getN());
                        c = new p, c.chainCode = f, c.privKey = (new this.PrivKey).fromBn(d), c.pubKey = (new u.a).fromPrivKey(c.privKey);
                    } else {
                        const e2 = t.concat([
                            this.pubKey.toBuffer(),
                            i
                        ]), r2 = o.a.sha512Hmac(e2, this.chainCode), s1 = (new n.a).fromBuffer(r2.slice(0, 32)), a2 = r2.slice(32, 64), f1 = h.a.getG().mul(s1), d1 = this.pubKey.point, l = f1.add(d1), b = new u.a;
                        b.point = l, c = new p, c.chainCode = a2, c.pubKey = b;
                    }
                    c.childIndex = e;
                    const f2 = o.a.sha256Ripemd160(this.pubKey.toBuffer());
                    return c.parentFingerPrint = f2.slice(0, 4), c.versionBytesNum = this.versionBytesNum, c.depth = this.depth + 1, c;
                }
                toPublic() {
                    const t = (new p).fromObject(this);
                    return t.versionBytesNum = this.Constants.pubKey, t.privKey = void 0, t;
                }
                toBuffer() {
                    const t = this.versionBytesNum === this.Constants.privKey, e = this.versionBytesNum === this.Constants.pubKey;
                    if (t) return (new s.a).writeUInt32BE(this.versionBytesNum).writeUInt8(this.depth).write(this.parentFingerPrint).writeUInt32BE(this.childIndex).write(this.chainCode).writeUInt8(0).write(this.privKey.bn.toBuffer({
                        size: 32
                    })).toBuffer();
                    if (e) {
                        if (!1 === this.pubKey.compressed) throw new Error("cannot convert bip32 to buffer if pubKey is not compressed");
                        return (new s.a).writeUInt32BE(this.versionBytesNum).writeUInt8(this.depth).write(this.parentFingerPrint).writeUInt32BE(this.childIndex).write(this.chainCode).write(this.pubKey.toBuffer()).toBuffer();
                    }
                    throw new Error("bip32: invalid versionBytesNum byte");
                }
                toFastBuffer() {
                    if (!this.versionBytesNum) return t.alloc(0);
                    const e = this.versionBytesNum === this.Constants.privKey, r = this.versionBytesNum === this.Constants.pubKey;
                    if (e) return (new s.a).writeUInt32BE(this.versionBytesNum).writeUInt8(this.depth).write(this.parentFingerPrint).writeUInt32BE(this.childIndex).write(this.chainCode).writeUInt8(0).write(this.privKey.bn.toBuffer({
                        size: 32
                    })).toBuffer();
                    if (r) return (new s.a).writeUInt32BE(this.versionBytesNum).writeUInt8(this.depth).write(this.parentFingerPrint).writeUInt32BE(this.childIndex).write(this.chainCode).write(this.pubKey.toFastBuffer()).toBuffer();
                    throw new Error("bip32: invalid versionBytesNum byte");
                }
                toString() {
                    return i.a.encode(this.toBuffer());
                }
                async asyncToString() {
                    const t = await l.a.asyncObjectMethod(this, "toString", []);
                    return JSON.parse(t.resbuf.toString());
                }
                toJSON() {
                    return this.toFastHex();
                }
                fromJSON(t) {
                    return this.fromFastHex(t);
                }
                isPrivate() {
                    return this.versionBytesNum === this.Constants.privKey;
                }
            }
            p.Mainnet = class extends p {
                constructor(t, e, r, i, n, s, o){
                    super(t, e, r, i, n, s, o, a.a.Mainnet.Bip32, c.a.Mainnet);
                }
            }, p.Testnet = class extends p {
                constructor(t, e, r, i, n, s, o){
                    super(t, e, r, i, n, s, o, a.a.Testnet.Bip32, c.a.Testnet);
                }
            };
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return u;
            });
            var i = r(84), n = r(85), s = r(6), a = r(3), o = r(16), h = r(4), c = r(2);
            class u extends h.a {
                constructor(t, e, r = n.a){
                    super({
                        mnemonic: t,
                        seed: e
                    }), this.Wordlist = r;
                }
                toBw(e) {
                    if (e || (e = new s.a), this.mnemonic) {
                        const r = t.from(this.mnemonic);
                        e.writeVarIntNum(r.length), e.write(r);
                    } else e.writeVarIntNum(0);
                    return this.seed ? (e.writeVarIntNum(this.seed.length), e.write(this.seed)) : e.writeVarIntNum(0), e;
                }
                fromBr(t) {
                    const e = t.readVarIntNum();
                    e > 0 && (this.mnemonic = t.read(e).toString());
                    const r = t.readVarIntNum();
                    return r > 0 && (this.seed = t.read(r)), this;
                }
                fromRandom(t) {
                    if (t || (t = 128), t % 32 != 0) throw new Error("bits must be multiple of 32");
                    if (t < 128) throw new Error("bits must be at least 128");
                    const e = o.a.getRandomBuffer(t / 8);
                    return this.entropy2Mnemonic(e), this.mnemonic2Seed(), this;
                }
                static fromRandom(t) {
                    return (new this).fromRandom(t);
                }
                async asyncFromRandom(t) {
                    t || (t = 128);
                    const e = o.a.getRandomBuffer(t / 8);
                    let r = await c.a.asyncObjectMethod(this, "entropy2Mnemonic", [
                        e
                    ]);
                    const i = (new u).fromFastBuffer(r.resbuf);
                    return r = await c.a.asyncObjectMethod(i, "mnemonic2Seed", []), this.fromFastBuffer(r.resbuf);
                }
                static asyncFromRandom(t) {
                    return (new this).asyncFromRandom(t);
                }
                fromEntropy(t) {
                    return this.entropy2Mnemonic(t), this;
                }
                static fromEntropy(t) {
                    return (new this).fromEntropy(t);
                }
                async asyncFromEntropy(t) {
                    const e = await c.a.asyncObjectMethod(this, "fromEntropy", [
                        t
                    ]);
                    return this.fromFastBuffer(e.resbuf);
                }
                static asyncFromEntropy(t) {
                    return (new this).asyncFromEntropy(t);
                }
                fromString(t) {
                    return this.mnemonic = t, this;
                }
                toString() {
                    return this.mnemonic;
                }
                toSeed(t) {
                    return this.mnemonic2Seed(t), this.seed;
                }
                async asyncToSeed(t) {
                    void 0 === t && (t = "");
                    const e = [
                        t
                    ];
                    return (await c.a.asyncObjectMethod(this, "toSeed", e)).resbuf;
                }
                entropy2Mnemonic(e) {
                    if (!t.isBuffer(e) || e.length < 16) throw new Error("Entropy is less than 128 bits. It must be 128 bits or more.");
                    const r = a.a.sha256(e);
                    let i = "";
                    const n = 8 * e.length;
                    for(let t1 = 0; t1 < e.length; t1++)i += ("00000000" + e[t1].toString(2)).slice(-8);
                    let s = r[0].toString(2);
                    if (s = ("00000000" + s).slice(-8).slice(0, n / 32), i += s, i.length % 11 != 0) throw new Error("internal error - entropy not an even multiple of 11 bits - " + i.length);
                    let o = "";
                    for(let t2 = 0; t2 < i.length / 11; t2++){
                        "" !== o && (o += this.Wordlist.space);
                        const e1 = parseInt(i.slice(11 * t2, 11 * (t2 + 1)), 2);
                        o += this.Wordlist.value[e1];
                    }
                    return this.mnemonic = o, this;
                }
                check() {
                    const e = this.mnemonic.split(this.Wordlist.space);
                    let r = "";
                    for(let t1 = 0; t1 < e.length; t1++){
                        const i = this.Wordlist.value.indexOf(e[t1]);
                        if (i < 0) return !1;
                        r += ("00000000000" + i.toString(2)).slice(-11);
                    }
                    if (r.length % 11 != 0) throw new Error("internal error - entropy not an even multiple of 11 bits - " + r.length);
                    const i1 = r.length / 33, n = r.slice(-i1), s = r.slice(0, r.length - i1), o = t.alloc(s.length / 8);
                    for(let t2 = 0; t2 < s.length / 8; t2++)o.writeUInt8(parseInt(r.slice(8 * t2, 8 * (t2 + 1)), 2), t2);
                    let h = a.a.sha256(o)[0].toString(2);
                    return h = ("00000000" + h).slice(-8).slice(0, i1), h === n;
                }
                mnemonic2Seed(e = "") {
                    let r = this.mnemonic;
                    if (!this.check()) throw new Error("Mnemonic does not pass the check - was the mnemonic typed incorrectly? Are there extra spaces?");
                    if ("string" != typeof e) throw new Error("passphrase must be a string or undefined");
                    r = r.normalize("NFKD"), e = e.normalize("NFKD");
                    const n = t.from(r), s = t.concat([
                        t.from("mnemonic"),
                        t.from(e)
                    ]);
                    return this.seed = i.pbkdf2Sync(n, s, 2048, 64, "sha512"), this;
                }
                isValid(t = "") {
                    let e;
                    try {
                        e = !!this.mnemonic2Seed(t);
                    } catch (t1) {
                        e = !1;
                    }
                    return e;
                }
                static isValid(t, e = "") {
                    return new u(t).isValid(e);
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e) {
        var r = Math.pow(2, 30) - 1;
        t.exports = function(t, e) {
            if ("number" != typeof t) throw new TypeError("Iterations not a number");
            if (t < 0) throw new TypeError("Bad iterations");
            if ("number" != typeof e) throw new TypeError("Key length not a number");
            if (e < 0 || e > r || e != e) throw new TypeError("Bad key length");
        };
    },
    function(t, e, r) {
        (function(e) {
            var r;
            if (e.browser) r = "utf-8";
            else if (e.version) r = parseInt(e.version.split(".")[0].slice(1), 10) >= 6 ? "utf-8" : "binary";
            else r = "utf-8";
            t.exports = r;
        }).call(this, r(26));
    },
    function(t, e, r) {
        var i = r(109), n = r(120), s = r(121), a = r(21).Buffer, o = r(62), h = r(63), c = r(76), u = a.alloc(128), f = {
            md5: 16,
            sha1: 20,
            sha224: 28,
            sha256: 32,
            sha384: 48,
            sha512: 64,
            rmd160: 20,
            ripemd160: 20
        };
        function d(t, e, r) {
            var o = function(t) {
                function e(e) {
                    return s(t).update(e).digest();
                }
                return "rmd160" === t || "ripemd160" === t ? function(t) {
                    return (new n).update(t).digest();
                } : "md5" === t ? i : e;
            }(t), h = "sha512" === t || "sha384" === t ? 128 : 64;
            e.length > h ? e = o(e) : e.length < h && (e = a.concat([
                e,
                u
            ], h));
            for(var c = a.allocUnsafe(h + f[t]), d = a.allocUnsafe(h + f[t]), l = 0; l < h; l++)c[l] = 54 ^ e[l], d[l] = 92 ^ e[l];
            var p = a.allocUnsafe(h + r + 4);
            c.copy(p, 0, 0, h), this.ipad1 = p, this.ipad2 = c, this.opad = d, this.alg = t, this.blocksize = h, this.hash = o, this.size = f[t];
        }
        d.prototype.run = function(t, e) {
            return t.copy(e, this.blocksize), this.hash(e).copy(this.opad, this.blocksize), this.hash(this.opad);
        }, t.exports = function(t, e, r, i, n) {
            o(r, i);
            var s = new d(n = n || "sha1", t = c(t, h, "Password"), (e = c(e, h, "Salt")).length), u = a.allocUnsafe(i), l = a.allocUnsafe(e.length + 4);
            e.copy(l, 0, 0, e.length);
            for(var p = 0, b = f[n], m = Math.ceil(i / b), g = 1; g <= m; g++){
                l.writeUInt32BE(g, e.length);
                for(var y = s.run(l, s.ipad1), w = y, _ = 1; _ < r; _++){
                    w = s.run(w, s.ipad2);
                    for(var v = 0; v < b; v++)y[v] ^= w[v];
                }
                y.copy(u, p), p += b;
            }
            return u;
        };
    },
    function(t, e, r) {
        "use strict";
        var i = r(21).Buffer, n = r(111).Transform;
        function s(t) {
            n.call(this), this._block = i.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [
                0,
                0,
                0,
                0
            ], this._finalized = !1;
        }
        r(17)(s, n), s.prototype._transform = function(t, e, r) {
            var i = null;
            try {
                this.update(t, e);
            } catch (t1) {
                i = t1;
            }
            r(i);
        }, s.prototype._flush = function(t) {
            var e = null;
            try {
                this.push(this.digest());
            } catch (t1) {
                e = t1;
            }
            t(e);
        }, s.prototype.update = function(t, e) {
            if (function(t, e) {
                if (!i.isBuffer(t) && "string" != typeof t) throw new TypeError(e + " must be a string or a buffer");
            }(t, "Data"), this._finalized) throw new Error("Digest already called");
            i.isBuffer(t) || (t = i.from(t, e));
            for(var r = this._block, n = 0; this._blockOffset + t.length - n >= this._blockSize;){
                for(var s = this._blockOffset; s < this._blockSize;)r[s++] = t[n++];
                this._update(), this._blockOffset = 0;
            }
            for(; n < t.length;)r[this._blockOffset++] = t[n++];
            for(var a = 0, o = 8 * t.length; o > 0; ++a)this._length[a] += o, (o = this._length[a] / 4294967296 | 0) > 0 && (this._length[a] -= 4294967296 * o);
            return this;
        }, s.prototype._update = function() {
            throw new Error("_update is not implemented");
        }, s.prototype.digest = function(t) {
            if (this._finalized) throw new Error("Digest already called");
            this._finalized = !0;
            var e = this._digest();
            void 0 !== t && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
            for(var r = 0; r < 4; ++r)this._length[r] = 0;
            return e;
        }, s.prototype._digest = function() {
            throw new Error("_digest is not implemented");
        }, t.exports = s;
    },
    function(t, e, r) {
        "use strict";
        (function(e, i) {
            var n;
            t.exports = I, I.ReadableState = E;
            r(67).EventEmitter;
            var s = function(t, e) {
                return t.listeners(e).length;
            }, a = r(68), o = r(7).Buffer, h = e.Uint8Array || function() {};
            var c, u = r(112);
            c = u && u.debuglog ? u.debuglog("stream") : function() {};
            var f, d, l, p = r(113), b = r(69), m = r(70).getHighWaterMark, g = r(34).codes, y = g.ERR_INVALID_ARG_TYPE, w = g.ERR_STREAM_PUSH_AFTER_EOF, _ = g.ERR_METHOD_NOT_IMPLEMENTED, v = g.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
            r(17)(I, a);
            var S = b.errorOrDestroy, O = [
                "error",
                "close",
                "destroy",
                "pause",
                "resume"
            ];
            function E(t, e, i) {
                n = n || r(35), t = t || {}, "boolean" != typeof i && (i = e instanceof n), this.objectMode = !!t.objectMode, i && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = m(this, t, "readableHighWaterMark", i), this.buffer = new p, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.destroyed = !1, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, t.encoding && (f || (f = r(72).StringDecoder), this.decoder = new f(t.encoding), this.encoding = t.encoding);
            }
            function I(t) {
                if (n = n || r(35), !(this instanceof I)) return new I(t);
                var e = this instanceof n;
                this._readableState = new E(t, this, e), this.readable = !0, t && ("function" == typeof t.read && (this._read = t.read), "function" == typeof t.destroy && (this._destroy = t.destroy)), a.call(this);
            }
            function B(t, e, r, i, n) {
                c("readableAddChunk", e);
                var s, a = t._readableState;
                if (null === e) a.reading = !1, function(t, e) {
                    if (c("onEofChunk"), e.ended) return;
                    if (e.decoder) {
                        var r = e.decoder.end();
                        r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
                    }
                    e.ended = !0, e.sync ? k(t) : (e.needReadable = !1, e.emittedReadable || (e.emittedReadable = !0, A(t)));
                }(t, a);
                else if (n || (s = function(t, e) {
                    var r;
                    i = e, o.isBuffer(i) || i instanceof h || "string" == typeof e || void 0 === e || t.objectMode || (r = new y("chunk", [
                        "string",
                        "Buffer",
                        "Uint8Array"
                    ], e));
                    var i;
                    return r;
                }(a, e)), s) S(t, s);
                else if (a.objectMode || e && e.length > 0) {
                    if ("string" == typeof e || a.objectMode || Object.getPrototypeOf(e) === o.prototype || (e = function(t) {
                        return o.from(t);
                    }(e)), i) a.endEmitted ? S(t, new v) : P(t, a, e, !0);
                    else if (a.ended) S(t, new w);
                    else {
                        if (a.destroyed) return !1;
                        a.reading = !1, a.decoder && !r ? (e = a.decoder.write(e), a.objectMode || 0 !== e.length ? P(t, a, e, !1) : N(t, a)) : P(t, a, e, !1);
                    }
                } else i || (a.reading = !1, N(t, a));
                return !a.ended && (a.length < a.highWaterMark || 0 === a.length);
            }
            function P(t, e, r, i) {
                e.flowing && 0 === e.length && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, i ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && k(t)), N(t, e);
            }
            Object.defineProperty(I.prototype, "destroyed", {
                enumerable: !1,
                get: function() {
                    return void 0 !== this._readableState && this._readableState.destroyed;
                },
                set: function(t) {
                    this._readableState && (this._readableState.destroyed = t);
                }
            }), I.prototype.destroy = b.destroy, I.prototype._undestroy = b.undestroy, I.prototype._destroy = function(t, e) {
                e(t);
            }, I.prototype.push = function(t, e) {
                var r, i = this._readableState;
                return i.objectMode ? r = !0 : "string" == typeof t && ((e = e || i.defaultEncoding) !== i.encoding && (t = o.from(t, e), e = ""), r = !0), B(this, t, e, !1, r);
            }, I.prototype.unshift = function(t) {
                return B(this, t, null, !0, !1);
            }, I.prototype.isPaused = function() {
                return !1 === this._readableState.flowing;
            }, I.prototype.setEncoding = function(t) {
                f || (f = r(72).StringDecoder);
                var e = new f(t);
                this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
                for(var i = this._readableState.buffer.head, n = ""; null !== i;)n += e.write(i.data), i = i.next;
                return this._readableState.buffer.clear(), "" !== n && this._readableState.buffer.push(n), this._readableState.length = n.length, this;
            };
            function R(t, e) {
                return t <= 0 || 0 === e.length && e.ended ? 0 : e.objectMode ? 1 : t != t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = function(t) {
                    return t >= 1073741824 ? t = 1073741824 : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
                }(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = !0, 0));
            }
            function k(t) {
                var e = t._readableState;
                c("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = !1, e.emittedReadable || (c("emitReadable", e.flowing), e.emittedReadable = !0, i.nextTick(A, t));
            }
            function A(t) {
                var e = t._readableState;
                c("emitReadable_", e.destroyed, e.length, e.ended), e.destroyed || !e.length && !e.ended || (t.emit("readable"), e.emittedReadable = !1), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, L(t);
            }
            function N(t, e) {
                e.readingMore || (e.readingMore = !0, i.nextTick(x, t, e));
            }
            function x(t, e) {
                for(; !e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && 0 === e.length);){
                    var r = e.length;
                    if (c("maybeReadMore read 0"), t.read(0), r === e.length) break;
                }
                e.readingMore = !1;
            }
            function M(t) {
                var e = t._readableState;
                e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = !0 : t.listenerCount("data") > 0 && t.resume();
            }
            function T(t) {
                c("readable nexttick read 0"), t.read(0);
            }
            function C(t, e) {
                c("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = !1, t.emit("resume"), L(t), e.flowing && !e.reading && t.read(0);
            }
            function L(t) {
                var e = t._readableState;
                for(c("flow", e.flowing); e.flowing && null !== t.read(););
            }
            function H(t, e) {
                var r;
                return 0 === e.length ? null : (e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (r = e.decoder ? e.buffer.join("") : 1 === e.buffer.length ? e.buffer.first() : e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r);
            }
            function U(t) {
                var e = t._readableState;
                c("endReadable", e.endEmitted), e.endEmitted || (e.ended = !0, i.nextTick(F, e, t));
            }
            function F(t, e) {
                if (c("endReadableNT", t.endEmitted, t.length), !t.endEmitted && 0 === t.length && (t.endEmitted = !0, e.readable = !1, e.emit("end"), t.autoDestroy)) {
                    var r = e._writableState;
                    (!r || r.autoDestroy && r.finished) && e.destroy();
                }
            }
            function D(t, e) {
                for(var r = 0, i = t.length; r < i; r++)if (t[r] === e) return r;
                return -1;
            }
            I.prototype.read = function(t) {
                c("read", t), t = parseInt(t, 10);
                var e = this._readableState, r = t;
                if (0 !== t && (e.emittedReadable = !1), 0 === t && e.needReadable && ((0 !== e.highWaterMark ? e.length >= e.highWaterMark : e.length > 0) || e.ended)) return c("read: emitReadable", e.length, e.ended), 0 === e.length && e.ended ? U(this) : k(this), null;
                if (0 === (t = R(t, e)) && e.ended) return 0 === e.length && U(this), null;
                var i, n = e.needReadable;
                return c("need readable", n), (0 === e.length || e.length - t < e.highWaterMark) && c("length less than watermark", n = !0), e.ended || e.reading ? c("reading or ended", n = !1) : n && (c("do read"), e.reading = !0, e.sync = !0, 0 === e.length && (e.needReadable = !0), this._read(e.highWaterMark), e.sync = !1, e.reading || (t = R(r, e))), null === (i = t > 0 ? H(t, e) : null) ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), 0 === e.length && (e.ended || (e.needReadable = !0), r !== t && e.ended && U(this)), null !== i && this.emit("data", i), i;
            }, I.prototype._read = function(t) {
                S(this, new _("_read()"));
            }, I.prototype.pipe = function(t, e) {
                var r = this, n = this._readableState;
                switch(n.pipesCount){
                    case 0:
                        n.pipes = t;
                        break;
                    case 1:
                        n.pipes = [
                            n.pipes,
                            t
                        ];
                        break;
                    default:
                        n.pipes.push(t);
                }
                n.pipesCount += 1, c("pipe count=%d opts=%j", n.pipesCount, e);
                var a = (!e || !1 !== e.end) && t !== i.stdout && t !== i.stderr ? h : m;
                function o(e, i) {
                    c("onunpipe"), e === r && i && !1 === i.hasUnpiped && (i.hasUnpiped = !0, c("cleanup"), t.removeListener("close", p), t.removeListener("finish", b), t.removeListener("drain", u), t.removeListener("error", l), t.removeListener("unpipe", o), r.removeListener("end", h), r.removeListener("end", m), r.removeListener("data", d), f = !0, !n.awaitDrain || t._writableState && !t._writableState.needDrain || u());
                }
                function h() {
                    c("onend"), t.end();
                }
                n.endEmitted ? i.nextTick(a) : r.once("end", a), t.on("unpipe", o);
                var u = function(t) {
                    return function() {
                        var e = t._readableState;
                        c("pipeOnDrain", e.awaitDrain), e.awaitDrain && e.awaitDrain--, 0 === e.awaitDrain && s(t, "data") && (e.flowing = !0, L(t));
                    };
                }(r);
                t.on("drain", u);
                var f = !1;
                function d(e) {
                    c("ondata");
                    var i = t.write(e);
                    c("dest.write", i), !1 === i && ((1 === n.pipesCount && n.pipes === t || n.pipesCount > 1 && -1 !== D(n.pipes, t)) && !f && (c("false write response, pause", n.awaitDrain), n.awaitDrain++), r.pause());
                }
                function l(e) {
                    c("onerror", e), m(), t.removeListener("error", l), 0 === s(t, "error") && S(t, e);
                }
                function p() {
                    t.removeListener("finish", b), m();
                }
                function b() {
                    c("onfinish"), t.removeListener("close", p), m();
                }
                function m() {
                    c("unpipe"), r.unpipe(t);
                }
                return r.on("data", d), function(t, e, r) {
                    if ("function" == typeof t.prependListener) return t.prependListener(e, r);
                    t._events && t._events[e] ? Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [
                        r,
                        t._events[e]
                    ] : t.on(e, r);
                }(t, "error", l), t.once("close", p), t.once("finish", b), t.emit("pipe", r), n.flowing || (c("pipe resume"), r.resume()), t;
            }, I.prototype.unpipe = function(t) {
                var e = this._readableState, r = {
                    hasUnpiped: !1
                };
                if (0 === e.pipesCount) return this;
                if (1 === e.pipesCount) return t && t !== e.pipes || (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = !1, t && t.emit("unpipe", this, r)), this;
                if (!t) {
                    var i = e.pipes, n = e.pipesCount;
                    e.pipes = null, e.pipesCount = 0, e.flowing = !1;
                    for(var s = 0; s < n; s++)i[s].emit("unpipe", this, {
                        hasUnpiped: !1
                    });
                    return this;
                }
                var a = D(e.pipes, t);
                return -1 === a || (e.pipes.splice(a, 1), e.pipesCount -= 1, 1 === e.pipesCount && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r)), this;
            }, I.prototype.on = function(t, e) {
                var r = a.prototype.on.call(this, t, e), n = this._readableState;
                return "data" === t ? (n.readableListening = this.listenerCount("readable") > 0, !1 !== n.flowing && this.resume()) : "readable" === t && (n.endEmitted || n.readableListening || (n.readableListening = n.needReadable = !0, n.flowing = !1, n.emittedReadable = !1, c("on readable", n.length, n.reading), n.length ? k(this) : n.reading || i.nextTick(T, this))), r;
            }, I.prototype.addListener = I.prototype.on, I.prototype.removeListener = function(t, e) {
                var r = a.prototype.removeListener.call(this, t, e);
                return "readable" === t && i.nextTick(M, this), r;
            }, I.prototype.removeAllListeners = function(t) {
                var e = a.prototype.removeAllListeners.apply(this, arguments);
                return "readable" !== t && void 0 !== t || i.nextTick(M, this), e;
            }, I.prototype.resume = function() {
                var t = this._readableState;
                return t.flowing || (c("resume"), t.flowing = !t.readableListening, function(t, e) {
                    e.resumeScheduled || (e.resumeScheduled = !0, i.nextTick(C, t, e));
                }(this, t)), t.paused = !1, this;
            }, I.prototype.pause = function() {
                return c("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (c("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
            }, I.prototype.wrap = function(t) {
                var e = this, r = this._readableState, i = !1;
                for(var n in t.on("end", function() {
                    if (c("wrapped end"), r.decoder && !r.ended) {
                        var t = r.decoder.end();
                        t && t.length && e.push(t);
                    }
                    e.push(null);
                }), t.on("data", function(n) {
                    (c("wrapped data"), r.decoder && (n = r.decoder.write(n)), r.objectMode && null == n) || (r.objectMode || n && n.length) && (e.push(n) || (i = !0, t.pause()));
                }), t)void 0 === this[n] && "function" == typeof t[n] && (this[n] = function(e) {
                    return function() {
                        return t[e].apply(t, arguments);
                    };
                }(n));
                for(var s = 0; s < O.length; s++)t.on(O[s], this.emit.bind(this, O[s]));
                return this._read = function(e) {
                    c("wrapped _read", e), i && (i = !1, t.resume());
                }, this;
            }, "function" == typeof Symbol && (I.prototype[Symbol.asyncIterator] = function() {
                return void 0 === d && (d = r(116)), d(this);
            }), Object.defineProperty(I.prototype, "readableHighWaterMark", {
                enumerable: !1,
                get: function() {
                    return this._readableState.highWaterMark;
                }
            }), Object.defineProperty(I.prototype, "readableBuffer", {
                enumerable: !1,
                get: function() {
                    return this._readableState && this._readableState.buffer;
                }
            }), Object.defineProperty(I.prototype, "readableFlowing", {
                enumerable: !1,
                get: function() {
                    return this._readableState.flowing;
                },
                set: function(t) {
                    this._readableState && (this._readableState.flowing = t);
                }
            }), I._fromList = H, Object.defineProperty(I.prototype, "readableLength", {
                enumerable: !1,
                get: function() {
                    return this._readableState.length;
                }
            }), "function" == typeof Symbol && (I.from = function(t, e) {
                return void 0 === l && (l = r(117)), l(I, t, e);
            });
        }).call(this, r(33), r(26));
    },
    function(t, e, r) {
        "use strict";
        var i, n = "object" == typeof Reflect ? Reflect : null, s = n && "function" == typeof n.apply ? n.apply : function(t, e, r) {
            return Function.prototype.apply.call(t, e, r);
        };
        i = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(t) {
            return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
        } : function(t) {
            return Object.getOwnPropertyNames(t);
        };
        var a = Number.isNaN || function(t) {
            return t != t;
        };
        function o() {
            o.init.call(this);
        }
        t.exports = o, t.exports.once = function(t, e) {
            return new Promise(function(r, i) {
                function n(r) {
                    t.removeListener(e, s), i(r);
                }
                function s() {
                    "function" == typeof t.removeListener && t.removeListener("error", n), r([].slice.call(arguments));
                }
                g(t, e, s, {
                    once: !0
                }), "error" !== e && function(t, e, r) {
                    "function" == typeof t.on && g(t, "error", e, r);
                }(t, n, {
                    once: !0
                });
            });
        }, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
        var h = 10;
        function c(t) {
            if ("function" != typeof t) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
        }
        function u(t) {
            return void 0 === t._maxListeners ? o.defaultMaxListeners : t._maxListeners;
        }
        function f(t, e, r, i) {
            var n, s, a, o;
            if (c(r), void 0 === (s = t._events) ? (s = t._events = Object.create(null), t._eventsCount = 0) : (void 0 !== s.newListener && (t.emit("newListener", e, r.listener ? r.listener : r), s = t._events), a = s[e]), void 0 === a) a = s[e] = r, ++t._eventsCount;
            else if ("function" == typeof a ? a = s[e] = i ? [
                r,
                a
            ] : [
                a,
                r
            ] : i ? a.unshift(r) : a.push(r), (n = u(t)) > 0 && a.length > n && !a.warned) {
                a.warned = !0;
                var h = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                h.name = "MaxListenersExceededWarning", h.emitter = t, h.type = e, h.count = a.length, o = h, console && console.warn && console.warn(o);
            }
            return t;
        }
        function d() {
            if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }
        function l(t, e, r) {
            var i = {
                fired: !1,
                wrapFn: void 0,
                target: t,
                type: e,
                listener: r
            }, n = d.bind(i);
            return n.listener = r, i.wrapFn = n, n;
        }
        function p(t, e, r) {
            var i = t._events;
            if (void 0 === i) return [];
            var n = i[e];
            return void 0 === n ? [] : "function" == typeof n ? r ? [
                n.listener || n
            ] : [
                n
            ] : r ? function(t) {
                for(var e = new Array(t.length), r = 0; r < e.length; ++r)e[r] = t[r].listener || t[r];
                return e;
            }(n) : m(n, n.length);
        }
        function b(t) {
            var e = this._events;
            if (void 0 !== e) {
                var r = e[t];
                if ("function" == typeof r) return 1;
                if (void 0 !== r) return r.length;
            }
            return 0;
        }
        function m(t, e) {
            for(var r = new Array(e), i = 0; i < e; ++i)r[i] = t[i];
            return r;
        }
        function g(t, e, r, i) {
            if ("function" == typeof t.on) i.once ? t.once(e, r) : t.on(e, r);
            else {
                if ("function" != typeof t.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
                t.addEventListener(e, function n(s) {
                    i.once && t.removeEventListener(e, n), r(s);
                });
            }
        }
        Object.defineProperty(o, "defaultMaxListeners", {
            enumerable: !0,
            get: function() {
                return h;
            },
            set: function(t) {
                if ("number" != typeof t || t < 0 || a(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
                h = t;
            }
        }), o.init = function() {
            void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, o.prototype.setMaxListeners = function(t) {
            if ("number" != typeof t || t < 0 || a(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
            return this._maxListeners = t, this;
        }, o.prototype.getMaxListeners = function() {
            return u(this);
        }, o.prototype.emit = function(t) {
            for(var e = [], r = 1; r < arguments.length; r++)e.push(arguments[r]);
            var i = "error" === t, n = this._events;
            if (void 0 !== n) i = i && void 0 === n.error;
            else if (!i) return !1;
            if (i) {
                var a;
                if (e.length > 0 && (a = e[0]), a instanceof Error) throw a;
                var o = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
                throw o.context = a, o;
            }
            var h = n[t];
            if (void 0 === h) return !1;
            if ("function" == typeof h) s(h, this, e);
            else {
                var c = h.length, u = m(h, c);
                for(r = 0; r < c; ++r)s(u[r], this, e);
            }
            return !0;
        }, o.prototype.addListener = function(t, e) {
            return f(this, t, e, !1);
        }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(t, e) {
            return f(this, t, e, !0);
        }, o.prototype.once = function(t, e) {
            return c(e), this.on(t, l(this, t, e)), this;
        }, o.prototype.prependOnceListener = function(t, e) {
            return c(e), this.prependListener(t, l(this, t, e)), this;
        }, o.prototype.removeListener = function(t, e) {
            var r, i, n, s, a;
            if (c(e), void 0 === (i = this._events)) return this;
            if (void 0 === (r = i[t])) return this;
            if (r === e || r.listener === e) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, r.listener || e));
            else if ("function" != typeof r) {
                for(n = -1, s = r.length - 1; s >= 0; s--)if (r[s] === e || r[s].listener === e) {
                    a = r[s].listener, n = s;
                    break;
                }
                if (n < 0) return this;
                0 === n ? r.shift() : function(t, e) {
                    for(; e + 1 < t.length; e++)t[e] = t[e + 1];
                    t.pop();
                }(r, n), 1 === r.length && (i[t] = r[0]), void 0 !== i.removeListener && this.emit("removeListener", t, a || e);
            }
            return this;
        }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(t) {
            var e, r, i;
            if (void 0 === (r = this._events)) return this;
            if (void 0 === r.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== r[t] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete r[t]), this;
            if (0 === arguments.length) {
                var n, s = Object.keys(r);
                for(i = 0; i < s.length; ++i)"removeListener" !== (n = s[i]) && this.removeAllListeners(n);
                return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
            }
            if ("function" == typeof (e = r[t])) this.removeListener(t, e);
            else if (void 0 !== e) for(i = e.length - 1; i >= 0; i--)this.removeListener(t, e[i]);
            return this;
        }, o.prototype.listeners = function(t) {
            return p(this, t, !0);
        }, o.prototype.rawListeners = function(t) {
            return p(this, t, !1);
        }, o.listenerCount = function(t, e) {
            return "function" == typeof t.listenerCount ? t.listenerCount(e) : b.call(t, e);
        }, o.prototype.listenerCount = b, o.prototype.eventNames = function() {
            return this._eventsCount > 0 ? i(this._events) : [];
        };
    },
    function(t, e, r) {
        t.exports = r(67).EventEmitter;
    },
    function(t, e, r) {
        "use strict";
        (function(e) {
            function r(t, e) {
                n(t, e), i(t);
            }
            function i(t) {
                t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
            }
            function n(t, e) {
                t.emit("error", e);
            }
            t.exports = {
                destroy: function(t, s) {
                    var a = this, o = this._readableState && this._readableState.destroyed, h = this._writableState && this._writableState.destroyed;
                    return o || h ? (s ? s(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(n, this, t)) : e.nextTick(n, this, t)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, function(t) {
                        !s && t ? a._writableState ? a._writableState.errorEmitted ? e.nextTick(i, a) : (a._writableState.errorEmitted = !0, e.nextTick(r, a, t)) : e.nextTick(r, a, t) : s ? (e.nextTick(i, a), s(t)) : e.nextTick(i, a);
                    }), this);
                },
                undestroy: function() {
                    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
                },
                errorOrDestroy: function(t, e) {
                    var r = t._readableState, i = t._writableState;
                    r && r.autoDestroy || i && i.autoDestroy ? t.destroy(e) : t.emit("error", e);
                }
            };
        }).call(this, r(26));
    },
    function(t, e, r) {
        "use strict";
        var i = r(34).codes.ERR_INVALID_OPT_VALUE;
        t.exports = {
            getHighWaterMark: function(t, e, r, n) {
                var s = function(t, e, r) {
                    return null != t.highWaterMark ? t.highWaterMark : e ? t[r] : null;
                }(e, n, r);
                if (null != s) {
                    if (!isFinite(s) || Math.floor(s) !== s || s < 0) throw new i(n ? r : "highWaterMark", s);
                    return Math.floor(s);
                }
                return t.objectMode ? 16 : 16384;
            }
        };
    },
    function(t, e, r) {
        "use strict";
        (function(e, i) {
            function n(t) {
                var e = this;
                this.next = null, this.entry = null, this.finish = function() {
                    !function(t, e, r) {
                        var i = t.entry;
                        t.entry = null;
                        for(; i;){
                            var n = i.callback;
                            e.pendingcb--, n(r), i = i.next;
                        }
                        e.corkedRequestsFree.next = t;
                    }(e, t);
                };
            }
            var s;
            t.exports = I, I.WritableState = E;
            var a = {
                deprecate: r(115)
            }, o = r(68), h = r(7).Buffer, c = e.Uint8Array || function() {};
            var u, f = r(69), d = r(70).getHighWaterMark, l = r(34).codes, p = l.ERR_INVALID_ARG_TYPE, b = l.ERR_METHOD_NOT_IMPLEMENTED, m = l.ERR_MULTIPLE_CALLBACK, g = l.ERR_STREAM_CANNOT_PIPE, y = l.ERR_STREAM_DESTROYED, w = l.ERR_STREAM_NULL_VALUES, _ = l.ERR_STREAM_WRITE_AFTER_END, v = l.ERR_UNKNOWN_ENCODING, S = f.errorOrDestroy;
            function O() {}
            function E(t, e, a) {
                s = s || r(35), t = t || {}, "boolean" != typeof a && (a = e instanceof s), this.objectMode = !!t.objectMode, a && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = d(this, t, "writableHighWaterMark", a), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
                var o = !1 === t.decodeStrings;
                this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(t) {
                    !function(t, e) {
                        var r = t._writableState, n = r.sync, s = r.writecb;
                        if ("function" != typeof s) throw new m;
                        if (function(t) {
                            t.writing = !1, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
                        }(r), e) !function(t, e, r, n, s) {
                            --e.pendingcb, r ? (i.nextTick(s, n), i.nextTick(N, t, e), t._writableState.errorEmitted = !0, S(t, n)) : (s(n), t._writableState.errorEmitted = !0, S(t, n), N(t, e));
                        }(t, r, n, e, s);
                        else {
                            var a = k(r) || t.destroyed;
                            a || r.corked || r.bufferProcessing || !r.bufferedRequest || R(t, r), n ? i.nextTick(P, t, r, a, s) : P(t, r, a, s);
                        }
                    }(e, t);
                }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new n(this);
            }
            function I(t) {
                var e = this instanceof (s = s || r(35));
                if (!e && !u.call(I, this)) return new I(t);
                this._writableState = new E(t, this, e), this.writable = !0, t && ("function" == typeof t.write && (this._write = t.write), "function" == typeof t.writev && (this._writev = t.writev), "function" == typeof t.destroy && (this._destroy = t.destroy), "function" == typeof t.final && (this._final = t.final)), o.call(this);
            }
            function B(t, e, r, i, n, s, a) {
                e.writelen = i, e.writecb = a, e.writing = !0, e.sync = !0, e.destroyed ? e.onwrite(new y("write")) : r ? t._writev(n, e.onwrite) : t._write(n, s, e.onwrite), e.sync = !1;
            }
            function P(t, e, r, i) {
                r || function(t, e) {
                    0 === e.length && e.needDrain && (e.needDrain = !1, t.emit("drain"));
                }(t, e), e.pendingcb--, i(), N(t, e);
            }
            function R(t, e) {
                e.bufferProcessing = !0;
                var r = e.bufferedRequest;
                if (t._writev && r && r.next) {
                    var i = e.bufferedRequestCount, s = new Array(i), a = e.corkedRequestsFree;
                    a.entry = r;
                    for(var o = 0, h = !0; r;)s[o] = r, r.isBuf || (h = !1), r = r.next, o += 1;
                    s.allBuffers = h, B(t, e, !0, e.length, s, "", a.finish), e.pendingcb++, e.lastBufferedRequest = null, a.next ? (e.corkedRequestsFree = a.next, a.next = null) : e.corkedRequestsFree = new n(e), e.bufferedRequestCount = 0;
                } else {
                    for(; r;){
                        var c = r.chunk, u = r.encoding, f = r.callback;
                        if (B(t, e, !1, e.objectMode ? 1 : c.length, c, u, f), r = r.next, e.bufferedRequestCount--, e.writing) break;
                    }
                    null === r && (e.lastBufferedRequest = null);
                }
                e.bufferedRequest = r, e.bufferProcessing = !1;
            }
            function k(t) {
                return t.ending && 0 === t.length && null === t.bufferedRequest && !t.finished && !t.writing;
            }
            function A(t, e) {
                t._final(function(r) {
                    e.pendingcb--, r && S(t, r), e.prefinished = !0, t.emit("prefinish"), N(t, e);
                });
            }
            function N(t, e) {
                var r = k(e);
                if (r && (function(t, e) {
                    e.prefinished || e.finalCalled || ("function" != typeof t._final || e.destroyed ? (e.prefinished = !0, t.emit("prefinish")) : (e.pendingcb++, e.finalCalled = !0, i.nextTick(A, t, e)));
                }(t, e), 0 === e.pendingcb && (e.finished = !0, t.emit("finish"), e.autoDestroy))) {
                    var n = t._readableState;
                    (!n || n.autoDestroy && n.endEmitted) && t.destroy();
                }
                return r;
            }
            r(17)(I, o), E.prototype.getBuffer = function() {
                for(var t = this.bufferedRequest, e = []; t;)e.push(t), t = t.next;
                return e;
            }, function() {
                try {
                    Object.defineProperty(E.prototype, "buffer", {
                        get: a.deprecate(function() {
                            return this.getBuffer();
                        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                    });
                } catch (t) {}
            }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (u = Function.prototype[Symbol.hasInstance], Object.defineProperty(I, Symbol.hasInstance, {
                value: function(t) {
                    return !!u.call(this, t) || this === I && t && t._writableState instanceof E;
                }
            })) : u = function(t) {
                return t instanceof this;
            }, I.prototype.pipe = function() {
                S(this, new g);
            }, I.prototype.write = function(t, e, r) {
                var n, s = this._writableState, a = !1, o = !s.objectMode && (n = t, h.isBuffer(n) || n instanceof c);
                return o && !h.isBuffer(t) && (t = function(t) {
                    return h.from(t);
                }(t)), "function" == typeof e && (r = e, e = null), o ? e = "buffer" : e || (e = s.defaultEncoding), "function" != typeof r && (r = O), s.ending ? function(t, e) {
                    var r = new _;
                    S(t, r), i.nextTick(e, r);
                }(this, r) : (o || function(t, e, r, n) {
                    var s;
                    return null === r ? s = new w : "string" == typeof r || e.objectMode || (s = new p("chunk", [
                        "string",
                        "Buffer"
                    ], r)), !s || (S(t, s), i.nextTick(n, s), !1);
                }(this, s, t, r)) && (s.pendingcb++, a = function(t, e, r, i, n, s) {
                    if (!r) {
                        var a = function(t, e, r) {
                            t.objectMode || !1 === t.decodeStrings || "string" != typeof e || (e = h.from(e, r));
                            return e;
                        }(e, i, n);
                        i !== a && (r = !0, n = "buffer", i = a);
                    }
                    var o = e.objectMode ? 1 : i.length;
                    e.length += o;
                    var c = e.length < e.highWaterMark;
                    c || (e.needDrain = !0);
                    if (e.writing || e.corked) {
                        var u = e.lastBufferedRequest;
                        e.lastBufferedRequest = {
                            chunk: i,
                            encoding: n,
                            isBuf: r,
                            callback: s,
                            next: null
                        }, u ? u.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
                    } else B(t, e, !1, o, i, n, s);
                    return c;
                }(this, s, o, t, e, r)), a;
            }, I.prototype.cork = function() {
                this._writableState.corked++;
            }, I.prototype.uncork = function() {
                var t = this._writableState;
                t.corked && (t.corked--, t.writing || t.corked || t.bufferProcessing || !t.bufferedRequest || R(this, t));
            }, I.prototype.setDefaultEncoding = function(t) {
                if ("string" == typeof t && (t = t.toLowerCase()), !([
                    "hex",
                    "utf8",
                    "utf-8",
                    "ascii",
                    "binary",
                    "base64",
                    "ucs2",
                    "ucs-2",
                    "utf16le",
                    "utf-16le",
                    "raw"
                ].indexOf((t + "").toLowerCase()) > -1)) throw new v(t);
                return this._writableState.defaultEncoding = t, this;
            }, Object.defineProperty(I.prototype, "writableBuffer", {
                enumerable: !1,
                get: function() {
                    return this._writableState && this._writableState.getBuffer();
                }
            }), Object.defineProperty(I.prototype, "writableHighWaterMark", {
                enumerable: !1,
                get: function() {
                    return this._writableState.highWaterMark;
                }
            }), I.prototype._write = function(t, e, r) {
                r(new b("_write()"));
            }, I.prototype._writev = null, I.prototype.end = function(t, e, r) {
                var n = this._writableState;
                return "function" == typeof t ? (r = t, t = null, e = null) : "function" == typeof e && (r = e, e = null), null != t && this.write(t, e), n.corked && (n.corked = 1, this.uncork()), n.ending || function(t, e, r) {
                    e.ending = !0, N(t, e), r && (e.finished ? i.nextTick(r) : t.once("finish", r));
                    e.ended = !0, t.writable = !1;
                }(this, n, r), this;
            }, Object.defineProperty(I.prototype, "writableLength", {
                enumerable: !1,
                get: function() {
                    return this._writableState.length;
                }
            }), Object.defineProperty(I.prototype, "destroyed", {
                enumerable: !1,
                get: function() {
                    return void 0 !== this._writableState && this._writableState.destroyed;
                },
                set: function(t) {
                    this._writableState && (this._writableState.destroyed = t);
                }
            }), I.prototype.destroy = f.destroy, I.prototype._undestroy = f.undestroy, I.prototype._destroy = function(t, e) {
                e(t);
            };
        }).call(this, r(33), r(26));
    },
    function(t, e, r) {
        "use strict";
        var i = r(21).Buffer, n = i.isEncoding || function(t) {
            switch((t = "" + t) && t.toLowerCase()){
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                case "raw":
                    return !0;
                default:
                    return !1;
            }
        };
        function s(t) {
            var e;
            switch(this.encoding = function(t) {
                var e = function(t) {
                    if (!t) return "utf8";
                    for(var e;;)switch(t){
                        case "utf8":
                        case "utf-8":
                            return "utf8";
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return "utf16le";
                        case "latin1":
                        case "binary":
                            return "latin1";
                        case "base64":
                        case "ascii":
                        case "hex":
                            return t;
                        default:
                            if (e) return;
                            t = ("" + t).toLowerCase(), e = !0;
                    }
                }(t);
                if ("string" != typeof e && (i.isEncoding === n || !n(t))) throw new Error("Unknown encoding: " + t);
                return e || t;
            }(t), this.encoding){
                case "utf16le":
                    this.text = h, this.end = c, e = 4;
                    break;
                case "utf8":
                    this.fillLast = o, e = 4;
                    break;
                case "base64":
                    this.text = u, this.end = f, e = 3;
                    break;
                default:
                    return this.write = d, void (this.end = l);
            }
            this.lastNeed = 0, this.lastTotal = 0, this.lastChar = i.allocUnsafe(e);
        }
        function a(t) {
            return t <= 127 ? 0 : t >> 5 == 6 ? 2 : t >> 4 == 14 ? 3 : t >> 3 == 30 ? 4 : t >> 6 == 2 ? -1 : -2;
        }
        function o(t) {
            var e = this.lastTotal - this.lastNeed, r = function(t, e, r) {
                if (128 != (192 & e[0])) return t.lastNeed = 0, "�";
                if (t.lastNeed > 1 && e.length > 1) {
                    if (128 != (192 & e[1])) return t.lastNeed = 1, "�";
                    if (t.lastNeed > 2 && e.length > 2 && 128 != (192 & e[2])) return t.lastNeed = 2, "�";
                }
            }(this, t);
            return void 0 !== r ? r : this.lastNeed <= t.length ? (t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t.copy(this.lastChar, e, 0, t.length), void (this.lastNeed -= t.length));
        }
        function h(t, e) {
            if ((t.length - e) % 2 == 0) {
                var r = t.toString("utf16le", e);
                if (r) {
                    var i = r.charCodeAt(r.length - 1);
                    if (i >= 55296 && i <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1);
                }
                return r;
            }
            return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
        }
        function c(t) {
            var e = t && t.length ? this.write(t) : "";
            if (this.lastNeed) {
                var r = this.lastTotal - this.lastNeed;
                return e + this.lastChar.toString("utf16le", 0, r);
            }
            return e;
        }
        function u(t, e) {
            var r = (t.length - e) % 3;
            return 0 === r ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, 1 === r ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r));
        }
        function f(t) {
            var e = t && t.length ? this.write(t) : "";
            return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
        }
        function d(t) {
            return t.toString(this.encoding);
        }
        function l(t) {
            return t && t.length ? this.write(t) : "";
        }
        e.StringDecoder = s, s.prototype.write = function(t) {
            if (0 === t.length) return "";
            var e, r;
            if (this.lastNeed) {
                if (void 0 === (e = this.fillLast(t))) return "";
                r = this.lastNeed, this.lastNeed = 0;
            } else r = 0;
            return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "";
        }, s.prototype.end = function(t) {
            var e = t && t.length ? this.write(t) : "";
            return this.lastNeed ? e + "�" : e;
        }, s.prototype.text = function(t, e) {
            var r = function(t, e, r) {
                var i = e.length - 1;
                if (i < r) return 0;
                var n = a(e[i]);
                if (n >= 0) return n > 0 && (t.lastNeed = n - 1), n;
                if (--i < r || -2 === n) return 0;
                if ((n = a(e[i])) >= 0) return n > 0 && (t.lastNeed = n - 2), n;
                if (--i < r || -2 === n) return 0;
                if ((n = a(e[i])) >= 0) return n > 0 && (2 === n ? n = 0 : t.lastNeed = n - 3), n;
                return 0;
            }(this, t, e);
            if (!this.lastNeed) return t.toString("utf8", e);
            this.lastTotal = r;
            var i = t.length - (r - this.lastNeed);
            return t.copy(this.lastChar, 0, i), t.toString("utf8", e, i);
        }, s.prototype.fillLast = function(t) {
            if (this.lastNeed <= t.length) return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
            t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
        };
    },
    function(t, e, r) {
        "use strict";
        t.exports = u;
        var i = r(34).codes, n = i.ERR_METHOD_NOT_IMPLEMENTED, s = i.ERR_MULTIPLE_CALLBACK, a = i.ERR_TRANSFORM_ALREADY_TRANSFORMING, o = i.ERR_TRANSFORM_WITH_LENGTH_0, h = r(35);
        function c(t, e) {
            var r = this._transformState;
            r.transforming = !1;
            var i = r.writecb;
            if (null === i) return this.emit("error", new s);
            r.writechunk = null, r.writecb = null, null != e && this.push(e), i(t);
            var n = this._readableState;
            n.reading = !1, (n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
        }
        function u(t) {
            if (!(this instanceof u)) return new u(t);
            h.call(this, t), this._transformState = {
                afterTransform: c.bind(this),
                needTransform: !1,
                transforming: !1,
                writecb: null,
                writechunk: null,
                writeencoding: null
            }, this._readableState.needReadable = !0, this._readableState.sync = !1, t && ("function" == typeof t.transform && (this._transform = t.transform), "function" == typeof t.flush && (this._flush = t.flush)), this.on("prefinish", f);
        }
        function f() {
            var t = this;
            "function" != typeof this._flush || this._readableState.destroyed ? d(this, null, null) : this._flush(function(e, r) {
                d(t, e, r);
            });
        }
        function d(t, e, r) {
            if (e) return t.emit("error", e);
            if (null != r && t.push(r), t._writableState.length) throw new o;
            if (t._transformState.transforming) throw new a;
            return t.push(null);
        }
        r(17)(u, h), u.prototype.push = function(t, e) {
            return this._transformState.needTransform = !1, h.prototype.push.call(this, t, e);
        }, u.prototype._transform = function(t, e, r) {
            r(new n("_transform()"));
        }, u.prototype._write = function(t, e, r) {
            var i = this._transformState;
            if (i.writecb = r, i.writechunk = t, i.writeencoding = e, !i.transforming) {
                var n = this._readableState;
                (i.needTransform || n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
            }
        }, u.prototype._read = function(t) {
            var e = this._transformState;
            null === e.writechunk || e.transforming ? e.needTransform = !0 : (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform));
        }, u.prototype._destroy = function(t, e) {
            h.prototype._destroy.call(this, t, function(t) {
                e(t);
            });
        };
    },
    function(t, e, r) {
        var i = r(17), n = r(36), s = r(21).Buffer, a = [
            1116352408,
            1899447441,
            3049323471,
            3921009573,
            961987163,
            1508970993,
            2453635748,
            2870763221,
            3624381080,
            310598401,
            607225278,
            1426881987,
            1925078388,
            2162078206,
            2614888103,
            3248222580,
            3835390401,
            4022224774,
            264347078,
            604807628,
            770255983,
            1249150122,
            1555081692,
            1996064986,
            2554220882,
            2821834349,
            2952996808,
            3210313671,
            3336571891,
            3584528711,
            113926993,
            338241895,
            666307205,
            773529912,
            1294757372,
            1396182291,
            1695183700,
            1986661051,
            2177026350,
            2456956037,
            2730485921,
            2820302411,
            3259730800,
            3345764771,
            3516065817,
            3600352804,
            4094571909,
            275423344,
            430227734,
            506948616,
            659060556,
            883997877,
            958139571,
            1322822218,
            1537002063,
            1747873779,
            1955562222,
            2024104815,
            2227730452,
            2361852424,
            2428436474,
            2756734187,
            3204031479,
            3329325298
        ], o = new Array(64);
        function h() {
            this.init(), this._w = o, n.call(this, 64, 56);
        }
        function c(t, e, r) {
            return r ^ t & (e ^ r);
        }
        function u(t, e, r) {
            return t & e | r & (t | e);
        }
        function f(t) {
            return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
        }
        function d(t) {
            return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
        }
        function l(t) {
            return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
        }
        i(h, n), h.prototype.init = function() {
            return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
        }, h.prototype._update = function(t) {
            for(var e, r = this._w, i = 0 | this._a, n = 0 | this._b, s = 0 | this._c, o = 0 | this._d, h = 0 | this._e, p = 0 | this._f, b = 0 | this._g, m = 0 | this._h, g = 0; g < 16; ++g)r[g] = t.readInt32BE(4 * g);
            for(; g < 64; ++g)r[g] = 0 | (((e = r[g - 2]) >>> 17 | e << 15) ^ (e >>> 19 | e << 13) ^ e >>> 10) + r[g - 7] + l(r[g - 15]) + r[g - 16];
            for(var y = 0; y < 64; ++y){
                var w = m + d(h) + c(h, p, b) + a[y] + r[y] | 0, _ = f(i) + u(i, n, s) | 0;
                m = b, b = p, p = h, h = o + w | 0, o = s, s = n, n = i, i = w + _ | 0;
            }
            this._a = i + this._a | 0, this._b = n + this._b | 0, this._c = s + this._c | 0, this._d = o + this._d | 0, this._e = h + this._e | 0, this._f = p + this._f | 0, this._g = b + this._g | 0, this._h = m + this._h | 0;
        }, h.prototype._hash = function() {
            var t = s.allocUnsafe(32);
            return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
        }, t.exports = h;
    },
    function(t, e, r) {
        var i = r(17), n = r(36), s = r(21).Buffer, a = [
            1116352408,
            3609767458,
            1899447441,
            602891725,
            3049323471,
            3964484399,
            3921009573,
            2173295548,
            961987163,
            4081628472,
            1508970993,
            3053834265,
            2453635748,
            2937671579,
            2870763221,
            3664609560,
            3624381080,
            2734883394,
            310598401,
            1164996542,
            607225278,
            1323610764,
            1426881987,
            3590304994,
            1925078388,
            4068182383,
            2162078206,
            991336113,
            2614888103,
            633803317,
            3248222580,
            3479774868,
            3835390401,
            2666613458,
            4022224774,
            944711139,
            264347078,
            2341262773,
            604807628,
            2007800933,
            770255983,
            1495990901,
            1249150122,
            1856431235,
            1555081692,
            3175218132,
            1996064986,
            2198950837,
            2554220882,
            3999719339,
            2821834349,
            766784016,
            2952996808,
            2566594879,
            3210313671,
            3203337956,
            3336571891,
            1034457026,
            3584528711,
            2466948901,
            113926993,
            3758326383,
            338241895,
            168717936,
            666307205,
            1188179964,
            773529912,
            1546045734,
            1294757372,
            1522805485,
            1396182291,
            2643833823,
            1695183700,
            2343527390,
            1986661051,
            1014477480,
            2177026350,
            1206759142,
            2456956037,
            344077627,
            2730485921,
            1290863460,
            2820302411,
            3158454273,
            3259730800,
            3505952657,
            3345764771,
            106217008,
            3516065817,
            3606008344,
            3600352804,
            1432725776,
            4094571909,
            1467031594,
            275423344,
            851169720,
            430227734,
            3100823752,
            506948616,
            1363258195,
            659060556,
            3750685593,
            883997877,
            3785050280,
            958139571,
            3318307427,
            1322822218,
            3812723403,
            1537002063,
            2003034995,
            1747873779,
            3602036899,
            1955562222,
            1575990012,
            2024104815,
            1125592928,
            2227730452,
            2716904306,
            2361852424,
            442776044,
            2428436474,
            593698344,
            2756734187,
            3733110249,
            3204031479,
            2999351573,
            3329325298,
            3815920427,
            3391569614,
            3928383900,
            3515267271,
            566280711,
            3940187606,
            3454069534,
            4118630271,
            4000239992,
            116418474,
            1914138554,
            174292421,
            2731055270,
            289380356,
            3203993006,
            460393269,
            320620315,
            685471733,
            587496836,
            852142971,
            1086792851,
            1017036298,
            365543100,
            1126000580,
            2618297676,
            1288033470,
            3409855158,
            1501505948,
            4234509866,
            1607167915,
            987167468,
            1816402316,
            1246189591
        ], o = new Array(160);
        function h() {
            this.init(), this._w = o, n.call(this, 128, 112);
        }
        function c(t, e, r) {
            return r ^ t & (e ^ r);
        }
        function u(t, e, r) {
            return t & e | r & (t | e);
        }
        function f(t, e) {
            return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25);
        }
        function d(t, e) {
            return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23);
        }
        function l(t, e) {
            return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7;
        }
        function p(t, e) {
            return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25);
        }
        function b(t, e) {
            return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6;
        }
        function m(t, e) {
            return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26);
        }
        function g(t, e) {
            return t >>> 0 < e >>> 0 ? 1 : 0;
        }
        i(h, n), h.prototype.init = function() {
            return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
        }, h.prototype._update = function(t) {
            for(var e = this._w, r = 0 | this._ah, i = 0 | this._bh, n = 0 | this._ch, s = 0 | this._dh, o = 0 | this._eh, h = 0 | this._fh, y = 0 | this._gh, w = 0 | this._hh, _ = 0 | this._al, v = 0 | this._bl, S = 0 | this._cl, O = 0 | this._dl, E = 0 | this._el, I = 0 | this._fl, B = 0 | this._gl, P = 0 | this._hl, R = 0; R < 32; R += 2)e[R] = t.readInt32BE(4 * R), e[R + 1] = t.readInt32BE(4 * R + 4);
            for(; R < 160; R += 2){
                var k = e[R - 30], A = e[R - 30 + 1], N = l(k, A), x = p(A, k), M = b(k = e[R - 4], A = e[R - 4 + 1]), T = m(A, k), C = e[R - 14], L = e[R - 14 + 1], H = e[R - 32], U = e[R - 32 + 1], F = x + L | 0, D = N + C + g(F, x) | 0;
                D = (D = D + M + g(F = F + T | 0, T) | 0) + H + g(F = F + U | 0, U) | 0, e[R] = D, e[R + 1] = F;
            }
            for(var K = 0; K < 160; K += 2){
                D = e[K], F = e[K + 1];
                var V = u(r, i, n), j = u(_, v, S), q = f(r, _), Y = f(_, r), z = d(o, E), G = d(E, o), J = a[K], W = a[K + 1], $ = c(o, h, y), Q = c(E, I, B), X = P + G | 0, Z = w + z + g(X, P) | 0;
                Z = (Z = (Z = Z + $ + g(X = X + Q | 0, Q) | 0) + J + g(X = X + W | 0, W) | 0) + D + g(X = X + F | 0, F) | 0;
                var tt = Y + j | 0, et = q + V + g(tt, Y) | 0;
                w = y, P = B, y = h, B = I, h = o, I = E, o = s + Z + g(E = O + X | 0, O) | 0, s = n, O = S, n = i, S = v, i = r, v = _, r = Z + et + g(_ = X + tt | 0, X) | 0;
            }
            this._al = this._al + _ | 0, this._bl = this._bl + v | 0, this._cl = this._cl + S | 0, this._dl = this._dl + O | 0, this._el = this._el + E | 0, this._fl = this._fl + I | 0, this._gl = this._gl + B | 0, this._hl = this._hl + P | 0, this._ah = this._ah + r + g(this._al, _) | 0, this._bh = this._bh + i + g(this._bl, v) | 0, this._ch = this._ch + n + g(this._cl, S) | 0, this._dh = this._dh + s + g(this._dl, O) | 0, this._eh = this._eh + o + g(this._el, E) | 0, this._fh = this._fh + h + g(this._fl, I) | 0, this._gh = this._gh + y + g(this._gl, B) | 0, this._hh = this._hh + w + g(this._hl, P) | 0;
        }, h.prototype._hash = function() {
            var t = s.allocUnsafe(64);
            function e(e, r, i) {
                t.writeInt32BE(e, i), t.writeInt32BE(r, i + 4);
            }
            return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t;
        }, t.exports = h;
    },
    function(t, e, r) {
        var i = r(21).Buffer;
        t.exports = function(t, e, r) {
            if (i.isBuffer(t)) return t;
            if ("string" == typeof t) return i.from(t, e);
            if (ArrayBuffer.isView(t)) return i.from(t.buffer);
            throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView");
        };
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return d;
            });
            var i = r(28), n = r(6), s = r(18), a = r(29), o = r(3), h = r(22), c = r(5), u = r(4), f = r(2);
            class d extends u.a {
                constructor(t, e, r, i, n){
                    super({
                        messageBuf: t,
                        keyPair: e,
                        sig: r,
                        address: i,
                        verified: n
                    });
                }
                static magicHash(e) {
                    if (!t.isBuffer(e)) throw new Error("messageBuf must be a buffer");
                    const r = new n.a;
                    r.writeVarIntNum(d.magicBytes.length), r.write(d.magicBytes), r.writeVarIntNum(e.length), r.write(e);
                    const i = r.toBuffer();
                    return o.a.sha256Sha256(i);
                }
                static async asyncMagicHash(t) {
                    const e = [
                        t
                    ];
                    return (await f.a.asyncClassMethod(d, "magicHash", e)).resbuf;
                }
                static sign(t, e) {
                    const r = new d(t, e);
                    r.sign();
                    return r.sig.toCompact().toString("base64");
                }
                static async asyncSign(t, e) {
                    const r = [
                        t,
                        e
                    ], i = await f.a.asyncClassMethod(d, "sign", r);
                    return JSON.parse(i.resbuf.toString());
                }
                static verify(e, r, i) {
                    const n = t.from(r, "base64"), s = new d;
                    return s.messageBuf = e, s.sig = (new c.a).fromCompact(n), s.address = i, s.verify().verified;
                }
                static async asyncVerify(t, e, r) {
                    const i = [
                        t,
                        e,
                        r
                    ], n = await f.a.asyncClassMethod(d, "verify", i);
                    return JSON.parse(n.resbuf.toString());
                }
                sign() {
                    const t = d.magicHash(this.messageBuf), e = (new a.a).fromObject({
                        hashBuf: t,
                        keyPair: this.keyPair
                    });
                    return e.sign(), e.calcrecovery(), this.sig = e.sig, this;
                }
                verify() {
                    const t = d.magicHash(this.messageBuf), e = new a.a;
                    if (e.hashBuf = t, e.sig = this.sig, e.keyPair = new h.a, e.keyPair.pubKey = e.sig2PubKey(), !e.verify()) return this.verified = !1, this;
                    const r = (new i.a).fromPubKey(e.keyPair.pubKey);
                    return Object(s.a)(r.hashBuf, this.address.hashBuf) ? this.verified = !0 : this.verified = !1, this;
                }
            }
            d.magicBytes = t.from("Bitcoin Signed Message:\n");
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return g;
            });
            var i = r(28), n = r(1), s = r(19), a = r(41), o = r(9), h = r(5), c = r(46), u = r(4), f = r(15), d = r(13), l = r(20), p = r(47), b = r(10);
            const m = s.a.Default.TxBuilder;
            class g extends u.a {
                constructor(t = new f.a, e = [], r = [], i = new p.a, n = new c.a, s, o, h, u = m.feePerKbNum, d = 0, l = 1, b = 1, g = m.dust, y = !1, w = new a.a){
                    super({
                        tx: t,
                        txIns: e,
                        txOuts: r,
                        uTxOutMap: i,
                        sigOperations: n,
                        changeScript: s,
                        changeAmountBn: o,
                        feeAmountBn: h,
                        feePerKbNum: u,
                        nLockTime: d,
                        versionBytesNum: l,
                        sigsPerInput: b,
                        dust: g,
                        dustChangeToFees: y,
                        hashCache: w
                    });
                }
                toJSON() {
                    const t = {};
                    return t.tx = this.tx.toHex(), t.txIns = this.txIns.map((t)=>t.toHex()), t.txOuts = this.txOuts.map((t)=>t.toHex()), t.uTxOutMap = this.uTxOutMap.toJSON(), t.sigOperations = this.sigOperations.toJSON(), t.changeScript = this.changeScript ? this.changeScript.toHex() : void 0, t.changeAmountBn = this.changeAmountBn ? this.changeAmountBn.toNumber() : void 0, t.feeAmountBn = this.feeAmountBn ? this.feeAmountBn.toNumber() : void 0, t.feePerKbNum = this.feePerKbNum, t.sigsPerInput = this.sigsPerInput, t.dust = this.dust, t.dustChangeToFees = this.dustChangeToFees, t.hashCache = this.hashCache.toJSON(), t;
                }
                fromJSON(t) {
                    return this.tx = (new f.a).fromHex(t.tx), this.txIns = t.txIns.map((t)=>d.a.fromHex(t)), this.txOuts = t.txOuts.map((t)=>l.a.fromHex(t)), this.uTxOutMap = (new p.a).fromJSON(t.uTxOutMap), this.sigOperations = (new c.a).fromJSON(t.sigOperations), this.changeScript = t.changeScript ? (new o.a).fromHex(t.changeScript) : void 0, this.changeAmountBn = t.changeAmountBn ? new n.a(t.changeAmountBn) : void 0, this.feeAmountBn = t.feeAmountBn ? new n.a(t.feeAmountBn) : void 0, this.feePerKbNum = t.feePerKbNum || this.feePerKbNum, this.sigsPerInput = t.sigsPerInput || this.sigsPerInput, this.dust = t.dust || this.dust, this.dustChangeToFees = t.dustChangeToFees || this.dustChangeToFees, this.hashCache = a.a.fromJSON(t.hashCache), this;
                }
                setFeePerKbNum(t) {
                    if ("number" != typeof t || t < 0) throw new Error("cannot set a fee of zero or less");
                    return this.feePerKbNum = t, this;
                }
                setChangeAddress(t) {
                    return this.changeScript = t.toTxOutScript(), this;
                }
                setChangeScript(t) {
                    return this.changeScript = t, this;
                }
                setNLocktime(t) {
                    return this.nLockTime = t, this;
                }
                setVersion(t) {
                    return this.versionBytesNum = t, this;
                }
                setDust(t = m.dust) {
                    return this.dust = t, this;
                }
                sendDustChangeToFees(t = !1) {
                    return this.dustChangeToFees = t, this;
                }
                importPartiallySignedTx(t, e = this.uTxOutMap, r = this.sigOperations) {
                    return this.tx = t, this.uTxOutMap = e, this.sigOperations = r, this;
                }
                inputFromScript(e, r, i, n, s) {
                    if (!(t.isBuffer(e) && "number" == typeof r && i instanceof l.a && n instanceof o.a)) throw new Error("invalid one of: txHashBuf, txOutNum, txOut, script");
                    return this.txIns.push(d.a.fromProperties(e, r, n, s)), this.uTxOutMap.set(e, r, i), this;
                }
                addSigOperation(t, e, r, i, n, s) {
                    return this.sigOperations.addOne(t, e, r, i, n, s), this;
                }
                inputFromPubKeyHash(e, r, n, s, a, o) {
                    if (!(t.isBuffer(e) && "number" == typeof r && n instanceof l.a)) throw new Error("invalid one of: txHashBuf, txOutNum, txOut");
                    this.txIns.push((new d.a).fromObject({
                        nSequence: a
                    }).fromPubKeyHashTxOut(e, r, n, s)), this.uTxOutMap.set(e, r, n);
                    const h = i.a.fromTxOutScript(n.script).toString();
                    return this.addSigOperation(e, r, 0, "sig", h, o), this.addSigOperation(e, r, 1, "pubKey", h), this;
                }
                outputToAddress(t, e) {
                    if (!(e instanceof i.a && t instanceof n.a)) throw new Error("addr must be an Address, and valueBn must be a Bn");
                    const r = (new o.a).fromPubKeyHash(e.hashBuf);
                    return this.outputToScript(t, r), this;
                }
                outputToScript(t, e) {
                    if (!(e instanceof o.a && t instanceof n.a)) throw new Error("script must be a Script, and valueBn must be a Bn");
                    const r = l.a.fromProperties(t, e);
                    return this.txOuts.push(r), this;
                }
                buildOutputs() {
                    let t = new n.a(0);
                    for (const e of this.txOuts){
                        if (e.valueBn.lt(this.dust) && !e.script.isNonSpendable()) throw new Error("cannot create output lesser than dust");
                        t = t.add(e.valueBn), this.tx.addTxOut(e);
                    }
                    return t;
                }
                buildInputs(t, e = 0) {
                    let r = new n.a(0);
                    for (const i of this.txIns){
                        const n1 = this.uTxOutMap.get(i.txHashBuf, i.txOutNum);
                        if (r = r.add(n1.valueBn), this.tx.addTxIn(i), r.geq(t)) {
                            if (e <= 0) break;
                            e--;
                        }
                    }
                    if (r.lt(t)) throw new Error("not enough funds for outputs: inAmountBn " + r.toNumber() + " outAmountBn " + t.toNumber());
                    return r;
                }
                estimateSize() {
                    let t = this.tx.toBuffer().length;
                    for (const e of this.tx.txIns){
                        const { txHashBuf: r , txOutNum: i  } = e, n = this.sigOperations.get(r, i);
                        for (const r1 of n){
                            const { nScriptChunk: i1 , type: n1  } = r1;
                            if (t -= new o.a([
                                e.script.chunks[i1]
                            ]).toBuffer().length, "sig" === n1) t += 72;
                            else {
                                if ("pubKey" !== r1.type) throw new Error("unsupported sig operations type");
                                t += 35;
                            }
                        }
                    }
                    return t += 1, Math.round(t);
                }
                estimateFee(t = new n.a(0)) {
                    const e = Math.ceil(this.estimateSize() / 1e3 * this.feePerKbNum);
                    return new n.a(e).add(t);
                }
                build(t = {
                    useAllInputs: !1
                }) {
                    let e;
                    if (this.txIns.length <= 0) throw Error("tx-builder number of inputs must be greater than 0");
                    if (!this.changeScript) throw new Error("must specify change script to use build method");
                    for(let r = t.useAllInputs ? this.txIns.length - 1 : 0; r < this.txIns.length; r++){
                        this.tx = new f.a;
                        const t1 = this.buildOutputs(), i = l.a.fromProperties(new n.a(0), this.changeScript);
                        let s;
                        this.tx.addTxOut(i);
                        try {
                            s = this.buildInputs(t1, r);
                        } catch (t2) {
                            throw t2.message.includes("not enough funds for outputs") ? new Error("unable to gather enough inputs for outputs and fee") : t2;
                        }
                        if (this.changeAmountBn = s.sub(t1), i.valueBn = this.changeAmountBn, e = this.estimateFee(), this.changeAmountBn.geq(e) && this.changeAmountBn.sub(e).gt(this.dust)) break;
                    }
                    if (this.changeAmountBn.geq(e)) {
                        if (this.feeAmountBn = e, this.changeAmountBn = this.changeAmountBn.sub(this.feeAmountBn), this.tx.txOuts[this.tx.txOuts.length - 1].valueBn = this.changeAmountBn, this.changeAmountBn.lt(this.dust)) {
                            if (!this.dustChangeToFees) throw new Error("unable to create change amount greater than dust");
                            this.tx.txOuts.pop(), this.tx.txOutsVi = b.a.fromNumber(this.tx.txOutsVi.toNumber() - 1), this.feeAmountBn = this.feeAmountBn.add(this.changeAmountBn), this.changeAmountBn = new n.a(0);
                        }
                        if (this.tx.nLockTime = this.nLockTime, this.tx.versionBytesNum = this.versionBytesNum, 0 === this.tx.txOuts.length) throw new Error("outputs length is zero - unable to create any outputs greater than dust");
                        return this.tx;
                    }
                    throw new Error("unable to gather enough inputs for outputs and fee");
                }
                sort() {
                    return this.tx.sort(), this;
                }
                static allSigsPresent(t, e) {
                    let r = 0;
                    for(let t1 = 1; t1 < e.chunks.length - 1; t1++)e.chunks[t1].buf && r++;
                    return r === t;
                }
                static removeBlankSigs(t) {
                    t = new o.a(t.chunks.slice());
                    for(let e = 1; e < t.chunks.length - 1; e++)t.chunks[e].buf || t.chunks.splice(e, 1);
                    return t;
                }
                fillSig(t, e, r) {
                    const i = this.tx.txIns[t];
                    return i.script.chunks[e] = (new o.a).writeBuffer(r.toTxFormat()).chunks[0], i.scriptVi = b.a.fromNumber(i.script.toBuffer().length), this;
                }
                getSig(t, e = h.a.SIGHASH_ALL | h.a.SIGHASH_FORKID, r, i, n = f.a.SCRIPT_ENABLE_SIGHASH_FORKID) {
                    let s;
                    if (e & h.a.SIGHASH_FORKID && n & f.a.SCRIPT_ENABLE_SIGHASH_FORKID) {
                        const t1 = this.tx.txIns[r].txHashBuf, e1 = this.tx.txIns[r].txOutNum, i1 = this.uTxOutMap.get(t1, e1);
                        if (!i1) throw new Error("for SIGHASH_FORKID must provide UTXOs");
                        s = i1.valueBn;
                    }
                    return this.tx.sign(t, e, r, i, s, n, this.hashCache);
                }
                asyncGetSig(t, e = h.a.SIGHASH_ALL | h.a.SIGHASH_FORKID, r, i, n = f.a.SCRIPT_ENABLE_SIGHASH_FORKID) {
                    let s;
                    if (e & h.a.SIGHASH_FORKID && n & f.a.SCRIPT_ENABLE_SIGHASH_FORKID) {
                        const t1 = this.tx.txIns[r].txHashBuf, e1 = this.tx.txIns[r].txOutNum, i1 = this.uTxOutMap.get(t1, e1);
                        if (!i1) throw new Error("for SIGHASH_FORKID must provide UTXOs");
                        s = i1.valueBn;
                    }
                    return this.tx.asyncSign(t, e, r, i, s, n, this.hashCache);
                }
                signTxIn(t, e, r, i, n = h.a.SIGHASH_ALL | h.a.SIGHASH_FORKID, s = f.a.SCRIPT_ENABLE_SIGHASH_FORKID) {
                    const a = this.tx.txIns[t], o = a.script;
                    if (void 0 === i && o.isPubKeyHashIn() && (i = 0), void 0 === i) throw new Error("cannot sign unknown script type for input " + t);
                    const c = a.txHashBuf, u = a.txOutNum;
                    r || (r = this.uTxOutMap.get(c, u));
                    const d = r.script, l = this.getSig(e, n, t, d, s);
                    return this.fillSig(t, i, l), this;
                }
                async asyncSignTxIn(t, e, r, i, n = h.a.SIGHASH_ALL | h.a.SIGHASH_FORKID, s = f.a.SCRIPT_ENABLE_SIGHASH_FORKID) {
                    const a = this.tx.txIns[t], o = a.script;
                    if (void 0 === i && o.isPubKeyHashIn() && (i = 0), void 0 === i) throw new Error("cannot sign unknown script type for input " + t);
                    const c = a.txHashBuf, u = a.txOutNum;
                    r || (r = this.uTxOutMap.get(c, u));
                    const d = r.script, l = await this.asyncGetSig(e, n, t, d, s);
                    return this.fillSig(t, i, l), this;
                }
                signWithKeyPairs(t) {
                    const e = {};
                    for (const r of t)e[i.a.fromPubKey(r.pubKey).toString()] = r;
                    for(const t1 in this.tx.txIns){
                        const r1 = this.tx.txIns[t1], i1 = this.sigOperations.get(r1.txHashBuf, r1.txOutNum);
                        for (const n of i1){
                            const { nScriptChunk: i2 , type: s , addressStr: a , nHashType: h  } = n, c = e[a];
                            if (!c) {
                                n.log = "cannot find keyPair for addressStr " + a;
                                continue;
                            }
                            const u = this.uTxOutMap.get(r1.txHashBuf, r1.txOutNum);
                            if ("sig" === s) this.signTxIn(~~t1, c, u, i2, h), n.log = "successfully inserted signature";
                            else {
                                if ("pubKey" !== s) {
                                    n.log = "cannot perform operation of type " + s;
                                    continue;
                                }
                                r1.script.chunks[i2] = (new o.a).writeBuffer(c.pubKey.toBuffer()).chunks[0], r1.setScript(r1.script), n.log = "successfully inserted public key";
                            }
                        }
                    }
                    return this;
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        r.d(e, "a", function() {
            return c;
        });
        var i = r(48), n = r(1), s = r(38), a = r(4), o = r(15), h = r(2);
        class c extends a.a {
            constructor(t, e, r, i){
                super({
                    tx: t,
                    txOutMap: e,
                    errStr: r,
                    interp: i
                });
            }
            verify(t = s.a.SCRIPT_ENABLE_SIGHASH_FORKID) {
                return !this.checkStr() && !this.verifyStr(t);
            }
            async asyncVerify(t) {
                const e = await this.asyncVerifyStr(t);
                return !this.checkStr() && !e;
            }
            static verify(t, e, r) {
                return new c(t, e).verify(r);
            }
            static asyncVerify(t, e, r) {
                return new c(t, e).asyncVerify(r);
            }
            checkStr() {
                if (0 === this.tx.txIns.length || 0 === this.tx.txInsVi.toNumber()) return this.errStr = "transaction txIns empty", this.errStr;
                if (0 === this.tx.txOuts.length || 0 === this.tx.txOutsVi.toNumber()) return this.errStr = "transaction txOuts empty", this.errStr;
                if (this.tx.toBuffer().length > i.a.MAX_BLOCK_SIZE) return this.errStr = "transaction over the maximum block size", this.errStr;
                let t = new n.a(0);
                for(let e = 0; e < this.tx.txOuts.length; e++){
                    const r = this.tx.txOuts[e];
                    if (r.valueBn.lt(0)) return this.errStr = "transaction txOut " + e + " negative", this.errStr;
                    if (r.valueBn.gt(o.a.MAX_MONEY)) return this.errStr = "transaction txOut " + e + " greater than MAX_MONEY", this.errStr;
                    if (t = t.add(r.valueBn), t.gt(o.a.MAX_MONEY)) return this.errStr = "transaction txOut " + e + " total output greater than MAX_MONEY", this.errStr;
                }
                const e1 = {};
                for(let t1 = 0; t1 < this.tx.txIns.length; t1++){
                    const r1 = this.tx.txIns[t1], i1 = r1.txHashBuf.toString("hex") + ":" + r1.txOutNum;
                    if (void 0 !== e1[i1]) return this.errStr = "transaction input " + t1 + " duplicate input", this.errStr;
                    e1[i1] = !0;
                }
                if (this.tx.isCoinbase()) {
                    const t2 = this.tx.txIns[0].script.toBuffer();
                    if (t2.length < 2 || t2.length > 100) return this.errStr = "coinbase trasaction script size invalid", this.errStr;
                } else for(let t3 = 0; t3 < this.tx.txIns.length; t3++)if (this.tx.txIns[t3].hasNullInput()) return this.errStr = "transaction input " + t3 + " has null input", this.errStr;
                return !1;
            }
            verifyStr(t) {
                for(let e = 0; e < this.tx.txIns.length; e++)if (!this.verifyNIn(e, t)) return this.errStr = "input " + e + " failed script verify", this.errStr;
                return !1;
            }
            async asyncVerifyStr(t) {
                for(let e = 0; e < this.tx.txIns.length; e++){
                    if (!await this.asyncVerifyNIn(e, t)) return this.errStr = "input " + e + " failed script verify", this.errStr;
                }
                return !1;
            }
            verifyNIn(t, e) {
                const r = this.tx.txIns[t], i = r.script, n = this.txOutMap.get(r.txHashBuf, r.txOutNum);
                if (!n) return console.log("output " + r.txOutNum + " not found"), !1;
                const a = n.script, o = n.valueBn;
                this.interp = new s.a;
                return this.interp.verify(i, a, this.tx, t, e, o);
            }
            async asyncVerifyNIn(t, e) {
                const r = this.tx.txIns[t], i = r.script, n = this.txOutMap.get(r.txHashBuf, r.txOutNum);
                if (!n) return console.log("output " + r.txOutNum + " not found"), !1;
                const a = n.script, o = n.valueBn;
                this.interp = new s.a;
                const c = await h.a.asyncObjectMethod(this.interp, "verify", [
                    i,
                    a,
                    this.tx,
                    t,
                    e,
                    o
                ]);
                return JSON.parse(c.resbuf.toString());
            }
            getDebugObject() {
                return {
                    errStr: this.errStr,
                    interpFailure: this.interp ? this.interp.getDebugObject() : void 0
                };
            }
            getDebugString() {
                return JSON.stringify(this.getDebugObject(), null, 2);
            }
        }
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return h;
            });
            var i = r(27), n = r(18), s = r(3), a = r(16), o = r(2);
            class h {
                static encrypt(e, r, n) {
                    const a = i.a.encrypt(e, r, n), o = s.a.sha256Hmac(a, r);
                    return t.concat([
                        o,
                        a
                    ]);
                }
                static async asyncEncrypt(t, e, r) {
                    r || (r = a.a.getRandomBuffer(16));
                    const i = [
                        t,
                        e,
                        r
                    ];
                    return (await o.a.asyncClassMethod(h, "encrypt", i)).resbuf;
                }
                static decrypt(t, e) {
                    if (t.length < 64) throw new Error("The encrypted data must be at least 256+128+128 bits, which is the length of the Hmac plus the iv plus the smallest encrypted data size");
                    const r = t.slice(0, 32);
                    t = t.slice(32, t.length);
                    const a = s.a.sha256Hmac(t, e);
                    if (!Object(n.a)(r, a)) throw new Error("Message authentication failed - Hmacs are not equivalent");
                    return i.a.decrypt(t, e);
                }
                static async asyncDecrypt(t, e) {
                    const r = [
                        t,
                        e
                    ];
                    return (await o.a.asyncClassMethod(h, "decrypt", r)).resbuf;
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return f;
            });
            var i = r(27), n = r(18), s = r(3), a = r(22), o = r(11), h = r(8), c = r(16), u = r(2);
            class f {
                static ivkEkM(t, e) {
                    const r = t.bn, i = e.point.mul(r), n = new h.a(i).toBuffer(), a = s.a.sha512(n);
                    return {
                        iv: a.slice(0, 16),
                        kE: a.slice(16, 32),
                        kM: a.slice(32, 64)
                    };
                }
                static electrumEncrypt(e, r, n, o = !1) {
                    if (!t.isBuffer(e)) throw new Error("messageBuf must be a buffer");
                    let h;
                    null === n && (n = a.a.fromRandom()), o || (h = n.pubKey.toDer(!0));
                    const { iv: c , kE: u , kM: d  } = f.ivkEkM(n.privKey, r), l = i.a.encrypt(e, u, c, !1), p = t.from("BIE1");
                    let b;
                    b = h ? t.concat([
                        p,
                        h,
                        l
                    ]) : t.concat([
                        p,
                        l
                    ]);
                    const m = s.a.sha256Hmac(b, d);
                    return t.concat([
                        b,
                        m
                    ]);
                }
                static electrumDecrypt(e, r, n = null) {
                    if (!t.isBuffer(e)) throw new Error("encBuf must be a buffer");
                    if (!e.slice(0, 4).equals(t.from("BIE1"))) throw new Error("Invalid Magic");
                    let a = 4;
                    if (null === n) {
                        const t1 = e.slice(4, 37);
                        n = h.a.fromDer(t1), a = 37;
                    }
                    const { iv: o , kE: c , kM: u  } = f.ivkEkM(r, n), d = e.slice(a, e.length - 32), l = e.slice(e.length - 32, e.length), p = s.a.sha256Hmac(e.slice(0, e.length - 32), u);
                    if (!l.equals(p)) throw new Error("Invalid checksum");
                    return i.a.decrypt(d, c, o);
                }
                static bitcoreEncrypt(e, r, n, o) {
                    n || (n = a.a.fromRandom());
                    const h = n.privKey.bn, c = n.pubKey.toDer(!0), u = r.point.mul(h).getX().toBuffer({
                        size: 32
                    }), f = s.a.sha512(u), d = f.slice(0, 32), l = f.slice(32, 64), p = i.a.encrypt(e, d, o), b = s.a.sha256Hmac(p, l);
                    return t.concat([
                        c,
                        p,
                        b
                    ]);
                }
                static async asyncBitcoreEncrypt(t, e, r, i) {
                    r || (r = await a.a.asyncFromRandom()), i || (i = c.a.getRandomBuffer(16));
                    const n = [
                        t,
                        e,
                        r,
                        i
                    ];
                    return (await u.a.asyncClassMethod(f, "bitcoreEncrypt", n)).resbuf;
                }
                static bitcoreDecrypt(t, e) {
                    const r = e.bn, a = h.a.fromDer(t.slice(0, 33)).point.mul(r);
                    if (a.eq(new o.a)) throw new Error("P equals 0");
                    const c = a.getX().toBuffer({
                        size: 32
                    }), u = s.a.sha512(c), f = u.slice(0, 32), d = u.slice(32, 64), l = t.slice(33, t.length - 32), p = t.slice(t.length - 32, t.length), b = s.a.sha256Hmac(l, d);
                    if (!Object(n.a)(p, b)) throw new Error("Invalid checksum");
                    return i.a.decrypt(l, f);
                }
                static async asyncBitcoreDecrypt(t, e) {
                    const r = [
                        t,
                        e
                    ];
                    return (await u.a.asyncClassMethod(f, "bitcoreDecrypt", r)).resbuf;
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        var i = e;
        i.version = r(100).version, i.utils = r(31), i.rand = r(56), i.curve = r(57), i.curves = r(59), i.ec = r(104);
    },
    function(t, e, r) {
        "use strict";
        (function(e, i) {
            var n = r(21).Buffer, s = e.crypto || e.msCrypto;
            s && s.getRandomValues ? t.exports = function(t, e) {
                if (t > 4294967295) throw new RangeError("requested too many random bytes");
                var r = n.allocUnsafe(t);
                if (t > 0) {
                    if (t > 65536) for(var a = 0; a < t; a += 65536)s.getRandomValues(r.slice(a, a + 65536));
                    else s.getRandomValues(r);
                }
                if ("function" == typeof e) return i.nextTick(function() {
                    e(null, r);
                });
                return r;
            } : t.exports = function() {
                throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
            };
        }).call(this, r(33), r(26));
    },
    function(t, e, r) {
        e.pbkdf2 = r(108), e.pbkdf2Sync = r(64);
    },
    function(t, e, r) {
        "use strict";
        r.d(e, "a", function() {
            return i;
        });
        const i = {
            value: [
                "abandon",
                "ability",
                "able",
                "about",
                "above",
                "absent",
                "absorb",
                "abstract",
                "absurd",
                "abuse",
                "access",
                "accident",
                "account",
                "accuse",
                "achieve",
                "acid",
                "acoustic",
                "acquire",
                "across",
                "act",
                "action",
                "actor",
                "actress",
                "actual",
                "adapt",
                "add",
                "addict",
                "address",
                "adjust",
                "admit",
                "adult",
                "advance",
                "advice",
                "aerobic",
                "affair",
                "afford",
                "afraid",
                "again",
                "age",
                "agent",
                "agree",
                "ahead",
                "aim",
                "air",
                "airport",
                "aisle",
                "alarm",
                "album",
                "alcohol",
                "alert",
                "alien",
                "all",
                "alley",
                "allow",
                "almost",
                "alone",
                "alpha",
                "already",
                "also",
                "alter",
                "always",
                "amateur",
                "amazing",
                "among",
                "amount",
                "amused",
                "analyst",
                "anchor",
                "ancient",
                "anger",
                "angle",
                "angry",
                "animal",
                "ankle",
                "announce",
                "annual",
                "another",
                "answer",
                "antenna",
                "antique",
                "anxiety",
                "any",
                "apart",
                "apology",
                "appear",
                "apple",
                "approve",
                "april",
                "arch",
                "arctic",
                "area",
                "arena",
                "argue",
                "arm",
                "armed",
                "armor",
                "army",
                "around",
                "arrange",
                "arrest",
                "arrive",
                "arrow",
                "art",
                "artefact",
                "artist",
                "artwork",
                "ask",
                "aspect",
                "assault",
                "asset",
                "assist",
                "assume",
                "asthma",
                "athlete",
                "atom",
                "attack",
                "attend",
                "attitude",
                "attract",
                "auction",
                "audit",
                "august",
                "aunt",
                "author",
                "auto",
                "autumn",
                "average",
                "avocado",
                "avoid",
                "awake",
                "aware",
                "away",
                "awesome",
                "awful",
                "awkward",
                "axis",
                "baby",
                "bachelor",
                "bacon",
                "badge",
                "bag",
                "balance",
                "balcony",
                "ball",
                "bamboo",
                "banana",
                "banner",
                "bar",
                "barely",
                "bargain",
                "barrel",
                "base",
                "basic",
                "basket",
                "battle",
                "beach",
                "bean",
                "beauty",
                "because",
                "become",
                "beef",
                "before",
                "begin",
                "behave",
                "behind",
                "believe",
                "below",
                "belt",
                "bench",
                "benefit",
                "best",
                "betray",
                "better",
                "between",
                "beyond",
                "bicycle",
                "bid",
                "bike",
                "bind",
                "biology",
                "bird",
                "birth",
                "bitter",
                "black",
                "blade",
                "blame",
                "blanket",
                "blast",
                "bleak",
                "bless",
                "blind",
                "blood",
                "blossom",
                "blouse",
                "blue",
                "blur",
                "blush",
                "board",
                "boat",
                "body",
                "boil",
                "bomb",
                "bone",
                "bonus",
                "book",
                "boost",
                "border",
                "boring",
                "borrow",
                "boss",
                "bottom",
                "bounce",
                "box",
                "boy",
                "bracket",
                "brain",
                "brand",
                "brass",
                "brave",
                "bread",
                "breeze",
                "brick",
                "bridge",
                "brief",
                "bright",
                "bring",
                "brisk",
                "broccoli",
                "broken",
                "bronze",
                "broom",
                "brother",
                "brown",
                "brush",
                "bubble",
                "buddy",
                "budget",
                "buffalo",
                "build",
                "bulb",
                "bulk",
                "bullet",
                "bundle",
                "bunker",
                "burden",
                "burger",
                "burst",
                "bus",
                "business",
                "busy",
                "butter",
                "buyer",
                "buzz",
                "cabbage",
                "cabin",
                "cable",
                "cactus",
                "cage",
                "cake",
                "call",
                "calm",
                "camera",
                "camp",
                "can",
                "canal",
                "cancel",
                "candy",
                "cannon",
                "canoe",
                "canvas",
                "canyon",
                "capable",
                "capital",
                "captain",
                "car",
                "carbon",
                "card",
                "cargo",
                "carpet",
                "carry",
                "cart",
                "case",
                "cash",
                "casino",
                "castle",
                "casual",
                "cat",
                "catalog",
                "catch",
                "category",
                "cattle",
                "caught",
                "cause",
                "caution",
                "cave",
                "ceiling",
                "celery",
                "cement",
                "census",
                "century",
                "cereal",
                "certain",
                "chair",
                "chalk",
                "champion",
                "change",
                "chaos",
                "chapter",
                "charge",
                "chase",
                "chat",
                "cheap",
                "check",
                "cheese",
                "chef",
                "cherry",
                "chest",
                "chicken",
                "chief",
                "child",
                "chimney",
                "choice",
                "choose",
                "chronic",
                "chuckle",
                "chunk",
                "churn",
                "cigar",
                "cinnamon",
                "circle",
                "citizen",
                "city",
                "civil",
                "claim",
                "clap",
                "clarify",
                "claw",
                "clay",
                "clean",
                "clerk",
                "clever",
                "click",
                "client",
                "cliff",
                "climb",
                "clinic",
                "clip",
                "clock",
                "clog",
                "close",
                "cloth",
                "cloud",
                "clown",
                "club",
                "clump",
                "cluster",
                "clutch",
                "coach",
                "coast",
                "coconut",
                "code",
                "coffee",
                "coil",
                "coin",
                "collect",
                "color",
                "column",
                "combine",
                "come",
                "comfort",
                "comic",
                "common",
                "company",
                "concert",
                "conduct",
                "confirm",
                "congress",
                "connect",
                "consider",
                "control",
                "convince",
                "cook",
                "cool",
                "copper",
                "copy",
                "coral",
                "core",
                "corn",
                "correct",
                "cost",
                "cotton",
                "couch",
                "country",
                "couple",
                "course",
                "cousin",
                "cover",
                "coyote",
                "crack",
                "cradle",
                "craft",
                "cram",
                "crane",
                "crash",
                "crater",
                "crawl",
                "crazy",
                "cream",
                "credit",
                "creek",
                "crew",
                "cricket",
                "crime",
                "crisp",
                "critic",
                "crop",
                "cross",
                "crouch",
                "crowd",
                "crucial",
                "cruel",
                "cruise",
                "crumble",
                "crunch",
                "crush",
                "cry",
                "crystal",
                "cube",
                "culture",
                "cup",
                "cupboard",
                "curious",
                "current",
                "curtain",
                "curve",
                "cushion",
                "custom",
                "cute",
                "cycle",
                "dad",
                "damage",
                "damp",
                "dance",
                "danger",
                "daring",
                "dash",
                "daughter",
                "dawn",
                "day",
                "deal",
                "debate",
                "debris",
                "decade",
                "december",
                "decide",
                "decline",
                "decorate",
                "decrease",
                "deer",
                "defense",
                "define",
                "defy",
                "degree",
                "delay",
                "deliver",
                "demand",
                "demise",
                "denial",
                "dentist",
                "deny",
                "depart",
                "depend",
                "deposit",
                "depth",
                "deputy",
                "derive",
                "describe",
                "desert",
                "design",
                "desk",
                "despair",
                "destroy",
                "detail",
                "detect",
                "develop",
                "device",
                "devote",
                "diagram",
                "dial",
                "diamond",
                "diary",
                "dice",
                "diesel",
                "diet",
                "differ",
                "digital",
                "dignity",
                "dilemma",
                "dinner",
                "dinosaur",
                "direct",
                "dirt",
                "disagree",
                "discover",
                "disease",
                "dish",
                "dismiss",
                "disorder",
                "display",
                "distance",
                "divert",
                "divide",
                "divorce",
                "dizzy",
                "doctor",
                "document",
                "dog",
                "doll",
                "dolphin",
                "domain",
                "donate",
                "donkey",
                "donor",
                "door",
                "dose",
                "double",
                "dove",
                "draft",
                "dragon",
                "drama",
                "drastic",
                "draw",
                "dream",
                "dress",
                "drift",
                "drill",
                "drink",
                "drip",
                "drive",
                "drop",
                "drum",
                "dry",
                "duck",
                "dumb",
                "dune",
                "during",
                "dust",
                "dutch",
                "duty",
                "dwarf",
                "dynamic",
                "eager",
                "eagle",
                "early",
                "earn",
                "earth",
                "easily",
                "east",
                "easy",
                "echo",
                "ecology",
                "economy",
                "edge",
                "edit",
                "educate",
                "effort",
                "egg",
                "eight",
                "either",
                "elbow",
                "elder",
                "electric",
                "elegant",
                "element",
                "elephant",
                "elevator",
                "elite",
                "else",
                "embark",
                "embody",
                "embrace",
                "emerge",
                "emotion",
                "employ",
                "empower",
                "empty",
                "enable",
                "enact",
                "end",
                "endless",
                "endorse",
                "enemy",
                "energy",
                "enforce",
                "engage",
                "engine",
                "enhance",
                "enjoy",
                "enlist",
                "enough",
                "enrich",
                "enroll",
                "ensure",
                "enter",
                "entire",
                "entry",
                "envelope",
                "episode",
                "equal",
                "equip",
                "era",
                "erase",
                "erode",
                "erosion",
                "error",
                "erupt",
                "escape",
                "essay",
                "essence",
                "estate",
                "eternal",
                "ethics",
                "evidence",
                "evil",
                "evoke",
                "evolve",
                "exact",
                "example",
                "excess",
                "exchange",
                "excite",
                "exclude",
                "excuse",
                "execute",
                "exercise",
                "exhaust",
                "exhibit",
                "exile",
                "exist",
                "exit",
                "exotic",
                "expand",
                "expect",
                "expire",
                "explain",
                "expose",
                "express",
                "extend",
                "extra",
                "eye",
                "eyebrow",
                "fabric",
                "face",
                "faculty",
                "fade",
                "faint",
                "faith",
                "fall",
                "false",
                "fame",
                "family",
                "famous",
                "fan",
                "fancy",
                "fantasy",
                "farm",
                "fashion",
                "fat",
                "fatal",
                "father",
                "fatigue",
                "fault",
                "favorite",
                "feature",
                "february",
                "federal",
                "fee",
                "feed",
                "feel",
                "female",
                "fence",
                "festival",
                "fetch",
                "fever",
                "few",
                "fiber",
                "fiction",
                "field",
                "figure",
                "file",
                "film",
                "filter",
                "final",
                "find",
                "fine",
                "finger",
                "finish",
                "fire",
                "firm",
                "first",
                "fiscal",
                "fish",
                "fit",
                "fitness",
                "fix",
                "flag",
                "flame",
                "flash",
                "flat",
                "flavor",
                "flee",
                "flight",
                "flip",
                "float",
                "flock",
                "floor",
                "flower",
                "fluid",
                "flush",
                "fly",
                "foam",
                "focus",
                "fog",
                "foil",
                "fold",
                "follow",
                "food",
                "foot",
                "force",
                "forest",
                "forget",
                "fork",
                "fortune",
                "forum",
                "forward",
                "fossil",
                "foster",
                "found",
                "fox",
                "fragile",
                "frame",
                "frequent",
                "fresh",
                "friend",
                "fringe",
                "frog",
                "front",
                "frost",
                "frown",
                "frozen",
                "fruit",
                "fuel",
                "fun",
                "funny",
                "furnace",
                "fury",
                "future",
                "gadget",
                "gain",
                "galaxy",
                "gallery",
                "game",
                "gap",
                "garage",
                "garbage",
                "garden",
                "garlic",
                "garment",
                "gas",
                "gasp",
                "gate",
                "gather",
                "gauge",
                "gaze",
                "general",
                "genius",
                "genre",
                "gentle",
                "genuine",
                "gesture",
                "ghost",
                "giant",
                "gift",
                "giggle",
                "ginger",
                "giraffe",
                "girl",
                "give",
                "glad",
                "glance",
                "glare",
                "glass",
                "glide",
                "glimpse",
                "globe",
                "gloom",
                "glory",
                "glove",
                "glow",
                "glue",
                "goat",
                "goddess",
                "gold",
                "good",
                "goose",
                "gorilla",
                "gospel",
                "gossip",
                "govern",
                "gown",
                "grab",
                "grace",
                "grain",
                "grant",
                "grape",
                "grass",
                "gravity",
                "great",
                "green",
                "grid",
                "grief",
                "grit",
                "grocery",
                "group",
                "grow",
                "grunt",
                "guard",
                "guess",
                "guide",
                "guilt",
                "guitar",
                "gun",
                "gym",
                "habit",
                "hair",
                "half",
                "hammer",
                "hamster",
                "hand",
                "happy",
                "harbor",
                "hard",
                "harsh",
                "harvest",
                "hat",
                "have",
                "hawk",
                "hazard",
                "head",
                "health",
                "heart",
                "heavy",
                "hedgehog",
                "height",
                "hello",
                "helmet",
                "help",
                "hen",
                "hero",
                "hidden",
                "high",
                "hill",
                "hint",
                "hip",
                "hire",
                "history",
                "hobby",
                "hockey",
                "hold",
                "hole",
                "holiday",
                "hollow",
                "home",
                "honey",
                "hood",
                "hope",
                "horn",
                "horror",
                "horse",
                "hospital",
                "host",
                "hotel",
                "hour",
                "hover",
                "hub",
                "huge",
                "human",
                "humble",
                "humor",
                "hundred",
                "hungry",
                "hunt",
                "hurdle",
                "hurry",
                "hurt",
                "husband",
                "hybrid",
                "ice",
                "icon",
                "idea",
                "identify",
                "idle",
                "ignore",
                "ill",
                "illegal",
                "illness",
                "image",
                "imitate",
                "immense",
                "immune",
                "impact",
                "impose",
                "improve",
                "impulse",
                "inch",
                "include",
                "income",
                "increase",
                "index",
                "indicate",
                "indoor",
                "industry",
                "infant",
                "inflict",
                "inform",
                "inhale",
                "inherit",
                "initial",
                "inject",
                "injury",
                "inmate",
                "inner",
                "innocent",
                "input",
                "inquiry",
                "insane",
                "insect",
                "inside",
                "inspire",
                "install",
                "intact",
                "interest",
                "into",
                "invest",
                "invite",
                "involve",
                "iron",
                "island",
                "isolate",
                "issue",
                "item",
                "ivory",
                "jacket",
                "jaguar",
                "jar",
                "jazz",
                "jealous",
                "jeans",
                "jelly",
                "jewel",
                "job",
                "join",
                "joke",
                "journey",
                "joy",
                "judge",
                "juice",
                "jump",
                "jungle",
                "junior",
                "junk",
                "just",
                "kangaroo",
                "keen",
                "keep",
                "ketchup",
                "key",
                "kick",
                "kid",
                "kidney",
                "kind",
                "kingdom",
                "kiss",
                "kit",
                "kitchen",
                "kite",
                "kitten",
                "kiwi",
                "knee",
                "knife",
                "knock",
                "know",
                "lab",
                "label",
                "labor",
                "ladder",
                "lady",
                "lake",
                "lamp",
                "language",
                "laptop",
                "large",
                "later",
                "latin",
                "laugh",
                "laundry",
                "lava",
                "law",
                "lawn",
                "lawsuit",
                "layer",
                "lazy",
                "leader",
                "leaf",
                "learn",
                "leave",
                "lecture",
                "left",
                "leg",
                "legal",
                "legend",
                "leisure",
                "lemon",
                "lend",
                "length",
                "lens",
                "leopard",
                "lesson",
                "letter",
                "level",
                "liar",
                "liberty",
                "library",
                "license",
                "life",
                "lift",
                "light",
                "like",
                "limb",
                "limit",
                "link",
                "lion",
                "liquid",
                "list",
                "little",
                "live",
                "lizard",
                "load",
                "loan",
                "lobster",
                "local",
                "lock",
                "logic",
                "lonely",
                "long",
                "loop",
                "lottery",
                "loud",
                "lounge",
                "love",
                "loyal",
                "lucky",
                "luggage",
                "lumber",
                "lunar",
                "lunch",
                "luxury",
                "lyrics",
                "machine",
                "mad",
                "magic",
                "magnet",
                "maid",
                "mail",
                "main",
                "major",
                "make",
                "mammal",
                "man",
                "manage",
                "mandate",
                "mango",
                "mansion",
                "manual",
                "maple",
                "marble",
                "march",
                "margin",
                "marine",
                "market",
                "marriage",
                "mask",
                "mass",
                "master",
                "match",
                "material",
                "math",
                "matrix",
                "matter",
                "maximum",
                "maze",
                "meadow",
                "mean",
                "measure",
                "meat",
                "mechanic",
                "medal",
                "media",
                "melody",
                "melt",
                "member",
                "memory",
                "mention",
                "menu",
                "mercy",
                "merge",
                "merit",
                "merry",
                "mesh",
                "message",
                "metal",
                "method",
                "middle",
                "midnight",
                "milk",
                "million",
                "mimic",
                "mind",
                "minimum",
                "minor",
                "minute",
                "miracle",
                "mirror",
                "misery",
                "miss",
                "mistake",
                "mix",
                "mixed",
                "mixture",
                "mobile",
                "model",
                "modify",
                "mom",
                "moment",
                "monitor",
                "monkey",
                "monster",
                "month",
                "moon",
                "moral",
                "more",
                "morning",
                "mosquito",
                "mother",
                "motion",
                "motor",
                "mountain",
                "mouse",
                "move",
                "movie",
                "much",
                "muffin",
                "mule",
                "multiply",
                "muscle",
                "museum",
                "mushroom",
                "music",
                "must",
                "mutual",
                "myself",
                "mystery",
                "myth",
                "naive",
                "name",
                "napkin",
                "narrow",
                "nasty",
                "nation",
                "nature",
                "near",
                "neck",
                "need",
                "negative",
                "neglect",
                "neither",
                "nephew",
                "nerve",
                "nest",
                "net",
                "network",
                "neutral",
                "never",
                "news",
                "next",
                "nice",
                "night",
                "noble",
                "noise",
                "nominee",
                "noodle",
                "normal",
                "north",
                "nose",
                "notable",
                "note",
                "nothing",
                "notice",
                "novel",
                "now",
                "nuclear",
                "number",
                "nurse",
                "nut",
                "oak",
                "obey",
                "object",
                "oblige",
                "obscure",
                "observe",
                "obtain",
                "obvious",
                "occur",
                "ocean",
                "october",
                "odor",
                "off",
                "offer",
                "office",
                "often",
                "oil",
                "okay",
                "old",
                "olive",
                "olympic",
                "omit",
                "once",
                "one",
                "onion",
                "online",
                "only",
                "open",
                "opera",
                "opinion",
                "oppose",
                "option",
                "orange",
                "orbit",
                "orchard",
                "order",
                "ordinary",
                "organ",
                "orient",
                "original",
                "orphan",
                "ostrich",
                "other",
                "outdoor",
                "outer",
                "output",
                "outside",
                "oval",
                "oven",
                "over",
                "own",
                "owner",
                "oxygen",
                "oyster",
                "ozone",
                "pact",
                "paddle",
                "page",
                "pair",
                "palace",
                "palm",
                "panda",
                "panel",
                "panic",
                "panther",
                "paper",
                "parade",
                "parent",
                "park",
                "parrot",
                "party",
                "pass",
                "patch",
                "path",
                "patient",
                "patrol",
                "pattern",
                "pause",
                "pave",
                "payment",
                "peace",
                "peanut",
                "pear",
                "peasant",
                "pelican",
                "pen",
                "penalty",
                "pencil",
                "people",
                "pepper",
                "perfect",
                "permit",
                "person",
                "pet",
                "phone",
                "photo",
                "phrase",
                "physical",
                "piano",
                "picnic",
                "picture",
                "piece",
                "pig",
                "pigeon",
                "pill",
                "pilot",
                "pink",
                "pioneer",
                "pipe",
                "pistol",
                "pitch",
                "pizza",
                "place",
                "planet",
                "plastic",
                "plate",
                "play",
                "please",
                "pledge",
                "pluck",
                "plug",
                "plunge",
                "poem",
                "poet",
                "point",
                "polar",
                "pole",
                "police",
                "pond",
                "pony",
                "pool",
                "popular",
                "portion",
                "position",
                "possible",
                "post",
                "potato",
                "pottery",
                "poverty",
                "powder",
                "power",
                "practice",
                "praise",
                "predict",
                "prefer",
                "prepare",
                "present",
                "pretty",
                "prevent",
                "price",
                "pride",
                "primary",
                "print",
                "priority",
                "prison",
                "private",
                "prize",
                "problem",
                "process",
                "produce",
                "profit",
                "program",
                "project",
                "promote",
                "proof",
                "property",
                "prosper",
                "protect",
                "proud",
                "provide",
                "public",
                "pudding",
                "pull",
                "pulp",
                "pulse",
                "pumpkin",
                "punch",
                "pupil",
                "puppy",
                "purchase",
                "purity",
                "purpose",
                "purse",
                "push",
                "put",
                "puzzle",
                "pyramid",
                "quality",
                "quantum",
                "quarter",
                "question",
                "quick",
                "quit",
                "quiz",
                "quote",
                "rabbit",
                "raccoon",
                "race",
                "rack",
                "radar",
                "radio",
                "rail",
                "rain",
                "raise",
                "rally",
                "ramp",
                "ranch",
                "random",
                "range",
                "rapid",
                "rare",
                "rate",
                "rather",
                "raven",
                "raw",
                "razor",
                "ready",
                "real",
                "reason",
                "rebel",
                "rebuild",
                "recall",
                "receive",
                "recipe",
                "record",
                "recycle",
                "reduce",
                "reflect",
                "reform",
                "refuse",
                "region",
                "regret",
                "regular",
                "reject",
                "relax",
                "release",
                "relief",
                "rely",
                "remain",
                "remember",
                "remind",
                "remove",
                "render",
                "renew",
                "rent",
                "reopen",
                "repair",
                "repeat",
                "replace",
                "report",
                "require",
                "rescue",
                "resemble",
                "resist",
                "resource",
                "response",
                "result",
                "retire",
                "retreat",
                "return",
                "reunion",
                "reveal",
                "review",
                "reward",
                "rhythm",
                "rib",
                "ribbon",
                "rice",
                "rich",
                "ride",
                "ridge",
                "rifle",
                "right",
                "rigid",
                "ring",
                "riot",
                "ripple",
                "risk",
                "ritual",
                "rival",
                "river",
                "road",
                "roast",
                "robot",
                "robust",
                "rocket",
                "romance",
                "roof",
                "rookie",
                "room",
                "rose",
                "rotate",
                "rough",
                "round",
                "route",
                "royal",
                "rubber",
                "rude",
                "rug",
                "rule",
                "run",
                "runway",
                "rural",
                "sad",
                "saddle",
                "sadness",
                "safe",
                "sail",
                "salad",
                "salmon",
                "salon",
                "salt",
                "salute",
                "same",
                "sample",
                "sand",
                "satisfy",
                "satoshi",
                "sauce",
                "sausage",
                "save",
                "say",
                "scale",
                "scan",
                "scare",
                "scatter",
                "scene",
                "scheme",
                "school",
                "science",
                "scissors",
                "scorpion",
                "scout",
                "scrap",
                "screen",
                "script",
                "scrub",
                "sea",
                "search",
                "season",
                "seat",
                "second",
                "secret",
                "section",
                "security",
                "seed",
                "seek",
                "segment",
                "select",
                "sell",
                "seminar",
                "senior",
                "sense",
                "sentence",
                "series",
                "service",
                "session",
                "settle",
                "setup",
                "seven",
                "shadow",
                "shaft",
                "shallow",
                "share",
                "shed",
                "shell",
                "sheriff",
                "shield",
                "shift",
                "shine",
                "ship",
                "shiver",
                "shock",
                "shoe",
                "shoot",
                "shop",
                "short",
                "shoulder",
                "shove",
                "shrimp",
                "shrug",
                "shuffle",
                "shy",
                "sibling",
                "sick",
                "side",
                "siege",
                "sight",
                "sign",
                "silent",
                "silk",
                "silly",
                "silver",
                "similar",
                "simple",
                "since",
                "sing",
                "siren",
                "sister",
                "situate",
                "six",
                "size",
                "skate",
                "sketch",
                "ski",
                "skill",
                "skin",
                "skirt",
                "skull",
                "slab",
                "slam",
                "sleep",
                "slender",
                "slice",
                "slide",
                "slight",
                "slim",
                "slogan",
                "slot",
                "slow",
                "slush",
                "small",
                "smart",
                "smile",
                "smoke",
                "smooth",
                "snack",
                "snake",
                "snap",
                "sniff",
                "snow",
                "soap",
                "soccer",
                "social",
                "sock",
                "soda",
                "soft",
                "solar",
                "soldier",
                "solid",
                "solution",
                "solve",
                "someone",
                "song",
                "soon",
                "sorry",
                "sort",
                "soul",
                "sound",
                "soup",
                "source",
                "south",
                "space",
                "spare",
                "spatial",
                "spawn",
                "speak",
                "special",
                "speed",
                "spell",
                "spend",
                "sphere",
                "spice",
                "spider",
                "spike",
                "spin",
                "spirit",
                "split",
                "spoil",
                "sponsor",
                "spoon",
                "sport",
                "spot",
                "spray",
                "spread",
                "spring",
                "spy",
                "square",
                "squeeze",
                "squirrel",
                "stable",
                "stadium",
                "staff",
                "stage",
                "stairs",
                "stamp",
                "stand",
                "start",
                "state",
                "stay",
                "steak",
                "steel",
                "stem",
                "step",
                "stereo",
                "stick",
                "still",
                "sting",
                "stock",
                "stomach",
                "stone",
                "stool",
                "story",
                "stove",
                "strategy",
                "street",
                "strike",
                "strong",
                "struggle",
                "student",
                "stuff",
                "stumble",
                "style",
                "subject",
                "submit",
                "subway",
                "success",
                "such",
                "sudden",
                "suffer",
                "sugar",
                "suggest",
                "suit",
                "summer",
                "sun",
                "sunny",
                "sunset",
                "super",
                "supply",
                "supreme",
                "sure",
                "surface",
                "surge",
                "surprise",
                "surround",
                "survey",
                "suspect",
                "sustain",
                "swallow",
                "swamp",
                "swap",
                "swarm",
                "swear",
                "sweet",
                "swift",
                "swim",
                "swing",
                "switch",
                "sword",
                "symbol",
                "symptom",
                "syrup",
                "system",
                "table",
                "tackle",
                "tag",
                "tail",
                "talent",
                "talk",
                "tank",
                "tape",
                "target",
                "task",
                "taste",
                "tattoo",
                "taxi",
                "teach",
                "team",
                "tell",
                "ten",
                "tenant",
                "tennis",
                "tent",
                "term",
                "test",
                "text",
                "thank",
                "that",
                "theme",
                "then",
                "theory",
                "there",
                "they",
                "thing",
                "this",
                "thought",
                "three",
                "thrive",
                "throw",
                "thumb",
                "thunder",
                "ticket",
                "tide",
                "tiger",
                "tilt",
                "timber",
                "time",
                "tiny",
                "tip",
                "tired",
                "tissue",
                "title",
                "toast",
                "tobacco",
                "today",
                "toddler",
                "toe",
                "together",
                "toilet",
                "token",
                "tomato",
                "tomorrow",
                "tone",
                "tongue",
                "tonight",
                "tool",
                "tooth",
                "top",
                "topic",
                "topple",
                "torch",
                "tornado",
                "tortoise",
                "toss",
                "total",
                "tourist",
                "toward",
                "tower",
                "town",
                "toy",
                "track",
                "trade",
                "traffic",
                "tragic",
                "train",
                "transfer",
                "trap",
                "trash",
                "travel",
                "tray",
                "treat",
                "tree",
                "trend",
                "trial",
                "tribe",
                "trick",
                "trigger",
                "trim",
                "trip",
                "trophy",
                "trouble",
                "truck",
                "true",
                "truly",
                "trumpet",
                "trust",
                "truth",
                "try",
                "tube",
                "tuition",
                "tumble",
                "tuna",
                "tunnel",
                "turkey",
                "turn",
                "turtle",
                "twelve",
                "twenty",
                "twice",
                "twin",
                "twist",
                "two",
                "type",
                "typical",
                "ugly",
                "umbrella",
                "unable",
                "unaware",
                "uncle",
                "uncover",
                "under",
                "undo",
                "unfair",
                "unfold",
                "unhappy",
                "uniform",
                "unique",
                "unit",
                "universe",
                "unknown",
                "unlock",
                "until",
                "unusual",
                "unveil",
                "update",
                "upgrade",
                "uphold",
                "upon",
                "upper",
                "upset",
                "urban",
                "urge",
                "usage",
                "use",
                "used",
                "useful",
                "useless",
                "usual",
                "utility",
                "vacant",
                "vacuum",
                "vague",
                "valid",
                "valley",
                "valve",
                "van",
                "vanish",
                "vapor",
                "various",
                "vast",
                "vault",
                "vehicle",
                "velvet",
                "vendor",
                "venture",
                "venue",
                "verb",
                "verify",
                "version",
                "very",
                "vessel",
                "veteran",
                "viable",
                "vibrant",
                "vicious",
                "victory",
                "video",
                "view",
                "village",
                "vintage",
                "violin",
                "virtual",
                "virus",
                "visa",
                "visit",
                "visual",
                "vital",
                "vivid",
                "vocal",
                "voice",
                "void",
                "volcano",
                "volume",
                "vote",
                "voyage",
                "wage",
                "wagon",
                "wait",
                "walk",
                "wall",
                "walnut",
                "want",
                "warfare",
                "warm",
                "warrior",
                "wash",
                "wasp",
                "waste",
                "water",
                "wave",
                "way",
                "wealth",
                "weapon",
                "wear",
                "weasel",
                "weather",
                "web",
                "wedding",
                "weekend",
                "weird",
                "welcome",
                "west",
                "wet",
                "whale",
                "what",
                "wheat",
                "wheel",
                "when",
                "where",
                "whip",
                "whisper",
                "wide",
                "width",
                "wife",
                "wild",
                "will",
                "win",
                "window",
                "wine",
                "wing",
                "wink",
                "winner",
                "winter",
                "wire",
                "wisdom",
                "wise",
                "wish",
                "witness",
                "wolf",
                "woman",
                "wonder",
                "wood",
                "wool",
                "word",
                "work",
                "world",
                "worry",
                "worth",
                "wrap",
                "wreck",
                "wrestle",
                "wrist",
                "write",
                "wrong",
                "yard",
                "year",
                "yellow",
                "you",
                "young",
                "youth",
                "zebra",
                "zero",
                "zone",
                "zoo"
            ],
            space: " "
        };
    },
    function(t, e, r) {
        "use strict";
        (function(t) {
            r.d(e, "a", function() {
                return s;
            });
            var i = r(3), n = r(4);
            class s extends n.a {
                constructor(t, e, r, i){
                    super({
                        hashBuf: t,
                        buf: e,
                        merkle1: r,
                        merkle2: i
                    });
                }
                hash() {
                    if (this.hashBuf) return this.hashBuf;
                    if (this.buf) return i.a.sha256Sha256(this.buf);
                    const e = this.merkle1.hash(), r = this.merkle2.hash();
                    return this.buf = t.concat([
                        e,
                        r
                    ]), i.a.sha256Sha256(this.buf);
                }
                fromBuffers(t) {
                    if (t.length < 1) throw new Error("buffers must have a length");
                    t = t.slice();
                    const e = Math.log2(t.length);
                    if (!Number.isInteger(e)) {
                        const r = t[t.length - 1], i = Math.pow(2, Math.ceil(e));
                        for(let e1 = t.length; e1 < i; e1++)t.push(r);
                    }
                    const r1 = t.slice(0, t.length / 2), i1 = t.slice(t.length / 2);
                    return this.fromBufferArrays(r1, i1), this;
                }
                static fromBuffers(t) {
                    return (new this).fromBuffers(t);
                }
                fromBufferArrays(t, e) {
                    if (1 === t.length) return this.merkle1 = new s(void 0, t[0]), this.merkle2 = new s(void 0, e[0]), this;
                    const r = t.slice(0, t.length / 2), i = t.slice(t.length / 2);
                    this.merkle1 = (new s).fromBufferArrays(r, i);
                    const n = e.slice(0, e.length / 2), a = e.slice(e.length / 2);
                    return this.merkle2 = (new s).fromBufferArrays(n, a), this;
                }
                static fromBufferArrays(t, e) {
                    return (new this).fromBufferArrays(t, e);
                }
                leavesNum() {
                    if (this.merkle1) return this.merkle1.leavesNum() + this.merkle2.leavesNum();
                    if (this.buf) return 1;
                    throw new Error("invalid number of leaves");
                }
            }
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        r.r(e), (function(t) {
            r.d(e, "deps", function() {
                return j;
            });
            var i = r(28);
            r.d(e, "Address", function() {
                return i.a;
            });
            var n = r(60);
            r.d(e, "Bip32", function() {
                return n.a;
            });
            var s = r(61);
            r.d(e, "Bip39", function() {
                return s.a;
            });
            var a = r(1);
            r.d(e, "Bn", function() {
                return a.a;
            });
            var o = r(12);
            r.d(e, "Br", function() {
                return o.a;
            });
            var h = r(77);
            r.d(e, "Bsm", function() {
                return h.a;
            });
            var c = r(6);
            r.d(e, "Bw", function() {
                return c.a;
            });
            var u = r(44);
            r.d(e, "Base58", function() {
                return u.a;
            });
            var f = r(24);
            r.d(e, "Base58Check", function() {
                return f.a;
            });
            var d = r(48);
            r.d(e, "Block", function() {
                return d.a;
            });
            var l = r(37);
            r.d(e, "BlockHeader", function() {
                return l.a;
            });
            var p = r(19);
            r.d(e, "Constants", function() {
                return p.a;
            }), r.d(e, "getConstants", function() {
                return p.b;
            });
            var b = r(29);
            r.d(e, "Ecdsa", function() {
                return b.a;
            });
            var m = r(3);
            r.d(e, "Hash", function() {
                return m.a;
            });
            var g = r(38);
            r.d(e, "Interp", function() {
                return g.a;
            });
            var y = r(22);
            r.d(e, "KeyPair", function() {
                return y.a;
            });
            var w = r(0);
            r.d(e, "OpCode", function() {
                return w.a;
            });
            var _ = r(11);
            r.d(e, "Point", function() {
                return _.a;
            });
            var v = r(23);
            r.d(e, "PrivKey", function() {
                return v.a;
            });
            var S = r(8);
            r.d(e, "PubKey", function() {
                return S.a;
            });
            var O = r(16);
            r.d(e, "Random", function() {
                return O.a;
            });
            var E = r(9);
            r.d(e, "Script", function() {
                return E.a;
            });
            var I = r(5);
            r.d(e, "Sig", function() {
                return I.a;
            });
            var B = r(46);
            r.d(e, "SigOperations", function() {
                return B.a;
            });
            var P = r(4);
            r.d(e, "Struct", function() {
                return P.a;
            });
            var R = r(15);
            r.d(e, "Tx", function() {
                return R.a;
            });
            var k = r(78);
            r.d(e, "TxBuilder", function() {
                return k.a;
            });
            var A = r(13);
            r.d(e, "TxIn", function() {
                return A.a;
            });
            var N = r(20);
            r.d(e, "TxOut", function() {
                return N.a;
            });
            var x = r(47);
            r.d(e, "TxOutMap", function() {
                return x.a;
            });
            var M = r(79);
            r.d(e, "TxVerifier", function() {
                return M.a;
            });
            var T = r(10);
            r.d(e, "VarInt", function() {
                return T.a;
            });
            var C = r(2);
            r.d(e, "Workers", function() {
                return C.a;
            });
            var L = r(45);
            r.d(e, "WorkersResult", function() {
                return L.a;
            });
            var H = r(18);
            r.d(e, "cmp", function() {
                return H.a;
            });
            var U = r(80);
            r.d(e, "Ach", function() {
                return U.a;
            });
            var F = r(39);
            r.d(e, "Aes", function() {
                return F.a;
            });
            var D = r(27);
            r.d(e, "Aescbc", function() {
                return D.a;
            });
            var K = r(40);
            r.d(e, "Cbc", function() {
                return K.a;
            });
            var V = r(81);
            r.d(e, "Ecies", function() {
                return V.a;
            });
            const j = {
                Buffer: t
            };
        }).call(this, r(7).Buffer);
    },
    function(t, e, r) {
        "use strict";
        e.byteLength = function(t) {
            var e = c(t), r = e[0], i = e[1];
            return 3 * (r + i) / 4 - i;
        }, e.toByteArray = function(t) {
            var e, r, i = c(t), a = i[0], o = i[1], h = new s(function(t, e, r) {
                return 3 * (e + r) / 4 - r;
            }(0, a, o)), u = 0, f = o > 0 ? a - 4 : a;
            for(r = 0; r < f; r += 4)e = n[t.charCodeAt(r)] << 18 | n[t.charCodeAt(r + 1)] << 12 | n[t.charCodeAt(r + 2)] << 6 | n[t.charCodeAt(r + 3)], h[u++] = e >> 16 & 255, h[u++] = e >> 8 & 255, h[u++] = 255 & e;
            2 === o && (e = n[t.charCodeAt(r)] << 2 | n[t.charCodeAt(r + 1)] >> 4, h[u++] = 255 & e);
            1 === o && (e = n[t.charCodeAt(r)] << 10 | n[t.charCodeAt(r + 1)] << 4 | n[t.charCodeAt(r + 2)] >> 2, h[u++] = e >> 8 & 255, h[u++] = 255 & e);
            return h;
        }, e.fromByteArray = function(t) {
            for(var e, r = t.length, n = r % 3, s = [], a = 0, o = r - n; a < o; a += 16383)s.push(u(t, a, a + 16383 > o ? o : a + 16383));
            1 === n ? (e = t[r - 1], s.push(i[e >> 2] + i[e << 4 & 63] + "==")) : 2 === n && (e = (t[r - 2] << 8) + t[r - 1], s.push(i[e >> 10] + i[e >> 4 & 63] + i[e << 2 & 63] + "="));
            return s.join("");
        };
        for(var i = [], n = [], s = "undefined" != typeof Uint8Array ? Uint8Array : Array, a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, h = a.length; o < h; ++o)i[o] = a[o], n[a.charCodeAt(o)] = o;
        function c(t) {
            var e = t.length;
            if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
            var r = t.indexOf("=");
            return -1 === r && (r = e), [
                r,
                r === e ? 0 : 4 - r % 4
            ];
        }
        function u(t, e, r) {
            for(var n, s, a = [], o = e; o < r; o += 3)n = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (255 & t[o + 2]), a.push(i[(s = n) >> 18 & 63] + i[s >> 12 & 63] + i[s >> 6 & 63] + i[63 & s]);
            return a.join("");
        }
        n["-".charCodeAt(0)] = 62, n["_".charCodeAt(0)] = 63;
    },
    function(t, e) {
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ e.read = function(t, e, r, i, n) {
            var s, a, o = 8 * n - i - 1, h = (1 << o) - 1, c = h >> 1, u = -7, f = r ? n - 1 : 0, d = r ? -1 : 1, l = t[e + f];
            for(f += d, s = l & (1 << -u) - 1, l >>= -u, u += o; u > 0; s = 256 * s + t[e + f], f += d, u -= 8);
            for(a = s & (1 << -u) - 1, s >>= -u, u += i; u > 0; a = 256 * a + t[e + f], f += d, u -= 8);
            if (0 === s) s = 1 - c;
            else {
                if (s === h) return a ? NaN : 1 / 0 * (l ? -1 : 1);
                a += Math.pow(2, i), s -= c;
            }
            return (l ? -1 : 1) * a * Math.pow(2, s - i);
        }, e.write = function(t, e, r, i, n, s) {
            var a, o, h, c = 8 * s - n - 1, u = (1 << c) - 1, f = u >> 1, d = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0, l = i ? 0 : s - 1, p = i ? 1 : -1, b = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
            for(e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, a = u) : (a = Math.floor(Math.log(e) / Math.LN2), e * (h = Math.pow(2, -a)) < 1 && (a--, h *= 2), (e += a + f >= 1 ? d / h : d * Math.pow(2, 1 - f)) * h >= 2 && (a++, h /= 2), a + f >= u ? (o = 0, a = u) : a + f >= 1 ? (o = (e * h - 1) * Math.pow(2, n), a += f) : (o = e * Math.pow(2, f - 1) * Math.pow(2, n), a = 0)); n >= 8; t[r + l] = 255 & o, l += p, o /= 256, n -= 8);
            for(a = a << n | o, c += n; c > 0; t[r + l] = 255 & a, l += p, a /= 256, c -= 8);
            t[r + l - p] |= 128 * b;
        };
    },
    function(t, e) {
        var r = {}.toString;
        t.exports = Array.isArray || function(t) {
            return "[object Array]" == r.call(t);
        };
    },
    function(t, e, r) {
        "use strict";
        var i = r(21).Buffer;
        t.exports = function(t) {
            if (t.length >= 255) throw new TypeError("Alphabet too long");
            for(var e = new Uint8Array(256), r = 0; r < e.length; r++)e[r] = 255;
            for(var n = 0; n < t.length; n++){
                var s = t.charAt(n), a = s.charCodeAt(0);
                if (255 !== e[a]) throw new TypeError(s + " is ambiguous");
                e[a] = n;
            }
            var o = t.length, h = t.charAt(0), c = Math.log(o) / Math.log(256), u = Math.log(256) / Math.log(o);
            function f(t) {
                if ("string" != typeof t) throw new TypeError("Expected String");
                if (0 === t.length) return i.alloc(0);
                var r = 0;
                if (" " !== t[r]) {
                    for(var n = 0, s = 0; t[r] === h;)n++, r++;
                    for(var a = (t.length - r) * c + 1 >>> 0, u = new Uint8Array(a); t[r];){
                        var f = e[t.charCodeAt(r)];
                        if (255 === f) return;
                        for(var d = 0, l = a - 1; (0 !== f || d < s) && -1 !== l; l--, d++)f += o * u[l] >>> 0, u[l] = f % 256 >>> 0, f = f / 256 >>> 0;
                        if (0 !== f) throw new Error("Non-zero carry");
                        s = d, r++;
                    }
                    if (" " !== t[r]) {
                        for(var p = a - s; p !== a && 0 === u[p];)p++;
                        var b = i.allocUnsafe(n + (a - p));
                        b.fill(0, 0, n);
                        for(var m = n; p !== a;)b[m++] = u[p++];
                        return b;
                    }
                }
            }
            return {
                encode: function(e) {
                    if ((Array.isArray(e) || e instanceof Uint8Array) && (e = i.from(e)), !i.isBuffer(e)) throw new TypeError("Expected Buffer");
                    if (0 === e.length) return "";
                    for(var r = 0, n = 0, s = 0, a = e.length; s !== a && 0 === e[s];)s++, r++;
                    for(var c = (a - s) * u + 1 >>> 0, f = new Uint8Array(c); s !== a;){
                        for(var d = e[s], l = 0, p = c - 1; (0 !== d || l < n) && -1 !== p; p--, l++)d += 256 * f[p] >>> 0, f[p] = d % o >>> 0, d = d / o >>> 0;
                        if (0 !== d) throw new Error("Non-zero carry");
                        n = l, s++;
                    }
                    for(var b = c - n; b !== c && 0 === f[b];)b++;
                    for(var m = h.repeat(r); b < c; ++b)m += t.charAt(f[b]);
                    return m;
                },
                decodeUnsafe: f,
                decode: function(t) {
                    var e = f(t);
                    if (e) return e;
                    throw new Error("Non-base" + o + " character");
                }
            };
        };
    },
    function(t, e) {
        t.exports = function(t) {
            return t.webpackPolyfill || (t.deprecate = function() {}, t.paths = [], t.children || (t.children = []), Object.defineProperty(t, "loaded", {
                enumerable: !0,
                get: function() {
                    return t.l;
                }
            }), Object.defineProperty(t, "id", {
                enumerable: !0,
                get: function() {
                    return t.i;
                }
            }), t.webpackPolyfill = 1), t;
        };
    },
    function(t, e) {},
    function(t, e, r) {
        "use strict";
        e.sha1 = r(95), e.sha224 = r(96), e.sha256 = r(53), e.sha384 = r(97), e.sha512 = r(54);
    },
    function(t, e, r) {
        "use strict";
        var i = r(25), n = r(43), s = r(52), a = i.rotl32, o = i.sum32, h = i.sum32_5, c = s.ft_1, u = n.BlockHash, f = [
            1518500249,
            1859775393,
            2400959708,
            3395469782
        ];
        function d() {
            if (!(this instanceof d)) return new d;
            u.call(this), this.h = [
                1732584193,
                4023233417,
                2562383102,
                271733878,
                3285377520
            ], this.W = new Array(80);
        }
        i.inherits(d, u), t.exports = d, d.blockSize = 512, d.outSize = 160, d.hmacStrength = 80, d.padLength = 64, d.prototype._update = function(t, e) {
            for(var r = this.W, i = 0; i < 16; i++)r[i] = t[e + i];
            for(; i < r.length; i++)r[i] = a(r[i - 3] ^ r[i - 8] ^ r[i - 14] ^ r[i - 16], 1);
            var n = this.h[0], s = this.h[1], u = this.h[2], d = this.h[3], l = this.h[4];
            for(i = 0; i < r.length; i++){
                var p = ~~(i / 20), b = h(a(n, 5), c(p, s, u, d), l, r[i], f[p]);
                l = d, d = u, u = a(s, 30), s = n, n = b;
            }
            this.h[0] = o(this.h[0], n), this.h[1] = o(this.h[1], s), this.h[2] = o(this.h[2], u), this.h[3] = o(this.h[3], d), this.h[4] = o(this.h[4], l);
        }, d.prototype._digest = function(t) {
            return "hex" === t ? i.toHex32(this.h, "big") : i.split32(this.h, "big");
        };
    },
    function(t, e, r) {
        "use strict";
        var i = r(25), n = r(53);
        function s() {
            if (!(this instanceof s)) return new s;
            n.call(this), this.h = [
                3238371032,
                914150663,
                812702999,
                4144912697,
                4290775857,
                1750603025,
                1694076839,
                3204075428
            ];
        }
        i.inherits(s, n), t.exports = s, s.blockSize = 512, s.outSize = 224, s.hmacStrength = 192, s.padLength = 64, s.prototype._digest = function(t) {
            return "hex" === t ? i.toHex32(this.h.slice(0, 7), "big") : i.split32(this.h.slice(0, 7), "big");
        };
    },
    function(t, e, r) {
        "use strict";
        var i = r(25), n = r(54);
        function s() {
            if (!(this instanceof s)) return new s;
            n.call(this), this.h = [
                3418070365,
                3238371032,
                1654270250,
                914150663,
                2438529370,
                812702999,
                355462360,
                4144912697,
                1731405415,
                4290775857,
                2394180231,
                1750603025,
                3675008525,
                1694076839,
                1203062813,
                3204075428
            ];
        }
        i.inherits(s, n), t.exports = s, s.blockSize = 1024, s.outSize = 384, s.hmacStrength = 192, s.padLength = 128, s.prototype._digest = function(t) {
            return "hex" === t ? i.toHex32(this.h.slice(0, 12), "big") : i.split32(this.h.slice(0, 12), "big");
        };
    },
    function(t, e, r) {
        "use strict";
        var i = r(25), n = r(43), s = i.rotl32, a = i.sum32, o = i.sum32_3, h = i.sum32_4, c = n.BlockHash;
        function u() {
            if (!(this instanceof u)) return new u;
            c.call(this), this.h = [
                1732584193,
                4023233417,
                2562383102,
                271733878,
                3285377520
            ], this.endian = "little";
        }
        function f(t, e, r, i) {
            return t <= 15 ? e ^ r ^ i : t <= 31 ? e & r | ~e & i : t <= 47 ? (e | ~r) ^ i : t <= 63 ? e & i | r & ~i : e ^ (r | ~i);
        }
        function d(t) {
            return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
        }
        function l(t) {
            return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
        }
        i.inherits(u, c), e.ripemd160 = u, u.blockSize = 512, u.outSize = 160, u.hmacStrength = 192, u.padLength = 64, u.prototype._update = function(t, e) {
            for(var r = this.h[0], i = this.h[1], n = this.h[2], c = this.h[3], u = this.h[4], y = r, w = i, _ = n, v = c, S = u, O = 0; O < 80; O++){
                var E = a(s(h(r, f(O, i, n, c), t[p[O] + e], d(O)), m[O]), u);
                r = u, u = c, c = s(n, 10), n = i, i = E, E = a(s(h(y, f(79 - O, w, _, v), t[b[O] + e], l(O)), g[O]), S), y = S, S = v, v = s(_, 10), _ = w, w = E;
            }
            E = o(this.h[1], n, v), this.h[1] = o(this.h[2], c, S), this.h[2] = o(this.h[3], u, y), this.h[3] = o(this.h[4], r, w), this.h[4] = o(this.h[0], i, _), this.h[0] = E;
        }, u.prototype._digest = function(t) {
            return "hex" === t ? i.toHex32(this.h, "little") : i.split32(this.h, "little");
        };
        var p = [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            7,
            4,
            13,
            1,
            10,
            6,
            15,
            3,
            12,
            0,
            9,
            5,
            2,
            14,
            11,
            8,
            3,
            10,
            14,
            4,
            9,
            15,
            8,
            1,
            2,
            7,
            0,
            6,
            13,
            11,
            5,
            12,
            1,
            9,
            11,
            10,
            0,
            8,
            12,
            4,
            13,
            3,
            7,
            15,
            14,
            5,
            6,
            2,
            4,
            0,
            5,
            9,
            7,
            12,
            2,
            10,
            14,
            1,
            3,
            8,
            11,
            6,
            15,
            13
        ], b = [
            5,
            14,
            7,
            0,
            9,
            2,
            11,
            4,
            13,
            6,
            15,
            8,
            1,
            10,
            3,
            12,
            6,
            11,
            3,
            7,
            0,
            13,
            5,
            10,
            14,
            15,
            8,
            12,
            4,
            9,
            1,
            2,
            15,
            5,
            1,
            3,
            7,
            14,
            6,
            9,
            11,
            8,
            12,
            2,
            10,
            0,
            4,
            13,
            8,
            6,
            4,
            1,
            3,
            11,
            15,
            0,
            5,
            12,
            2,
            13,
            9,
            7,
            10,
            14,
            12,
            15,
            10,
            4,
            1,
            5,
            8,
            7,
            6,
            2,
            13,
            14,
            0,
            3,
            9,
            11
        ], m = [
            11,
            14,
            15,
            12,
            5,
            8,
            7,
            9,
            11,
            13,
            14,
            15,
            6,
            7,
            9,
            8,
            7,
            6,
            8,
            13,
            11,
            9,
            7,
            15,
            7,
            12,
            15,
            9,
            11,
            7,
            13,
            12,
            11,
            13,
            6,
            7,
            14,
            9,
            13,
            15,
            14,
            8,
            13,
            6,
            5,
            12,
            7,
            5,
            11,
            12,
            14,
            15,
            14,
            15,
            9,
            8,
            9,
            14,
            5,
            6,
            8,
            6,
            5,
            12,
            9,
            15,
            5,
            11,
            6,
            8,
            13,
            12,
            5,
            12,
            13,
            14,
            11,
            8,
            5,
            6
        ], g = [
            8,
            9,
            9,
            11,
            13,
            15,
            15,
            5,
            7,
            7,
            8,
            11,
            14,
            14,
            12,
            6,
            9,
            13,
            15,
            7,
            12,
            8,
            9,
            11,
            7,
            7,
            12,
            7,
            6,
            15,
            13,
            11,
            9,
            7,
            15,
            11,
            8,
            6,
            6,
            14,
            12,
            13,
            5,
            14,
            13,
            13,
            7,
            5,
            15,
            5,
            8,
            11,
            14,
            14,
            6,
            14,
            6,
            9,
            12,
            9,
            12,
            5,
            15,
            8,
            8,
            5,
            12,
            9,
            12,
            5,
            14,
            6,
            8,
            13,
            6,
            5,
            15,
            13,
            11,
            11
        ];
    },
    function(t, e, r) {
        "use strict";
        var i = r(25), n = r(30);
        function s(t, e, r) {
            if (!(this instanceof s)) return new s(t, e, r);
            this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(i.toArray(e, r));
        }
        t.exports = s, s.prototype._init = function(t) {
            t.length > this.blockSize && (t = (new this.Hash).update(t).digest()), n(t.length <= this.blockSize);
            for(var e = t.length; e < this.blockSize; e++)t.push(0);
            for(e = 0; e < t.length; e++)t[e] ^= 54;
            for(this.inner = (new this.Hash).update(t), e = 0; e < t.length; e++)t[e] ^= 106;
            this.outer = (new this.Hash).update(t);
        }, s.prototype.update = function(t, e) {
            return this.inner.update(t, e), this;
        }, s.prototype.digest = function(t) {
            return this.outer.update(this.inner.digest()), this.outer.digest(t);
        };
    },
    function(t) {
        t.exports = JSON.parse('{"name":"bitcoin-elliptic","version":"7.0.1","description":"EC cryptography","main":"lib/elliptic.js","files":["lib"],"scripts":{"jscs":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","jshint":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","lint":"npm run jscs && npm run jshint","unit":"istanbul test _mocha --reporter=spec test/index.js","test":"npm run lint && npm run unit","version":"grunt dist && git add dist/"},"repository":{"type":"git","url":"git@github.com:moneybutton/elliptic"},"keywords":["EC","Elliptic","curve","Cryptography"],"author":"Fedor Indutny <fedor@indutny.com>","contributors":[{"name":"Ryan X. Charles","email":"ryanxcharles@gmail.com"}],"license":"MIT","bugs":{"url":"https://github.com/indutny/elliptic/issues"},"homepage":"https://github.com/moneybutton/elliptic","devDependencies":{"brfs":"^2.0.2","coveralls":"^3.0.8","grunt":"^1.0.4","grunt-browserify":"^5.0.0","grunt-cli":"^1.2.0","grunt-contrib-connect":"^2.1.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^4.0.1","grunt-mocha-istanbul":"^5.0.2","grunt-saucelabs":"^9.0.1","istanbul":"^0.4.2","jscs":"^3.0.7","jshint":"^2.11.1","mocha":"^7.1.2"},"dependencies":{"bn.js":"^5.1.1","brorand":"^1.0.1","hash.js":"^1.0.0","hmac-drbg":"^1.0.0","inherits":"^2.0.1","minimalistic-assert":"^1.0.0","minimalistic-crypto-utils":"^1.0.0"},"_resolved":"https://registry.npmjs.org/bitcoin-elliptic/-/bitcoin-elliptic-7.0.1.tgz","_integrity":"sha512-eJIERwXIIjJK7gfVoevk0G1CbYbxezZ6ePZXIxngjyI+QQHXWqXMbY+gpxsND8FCLvWl050fw6W+PVZge5fBHw==","_from":"bitcoin-elliptic@7.0.1"}');
    },
    function(t, e) {},
    function(t, e, r) {
        "use strict";
        var i = r(31), n = r(14), s = r(17), a = r(58), o = i.assert;
        function h(t) {
            a.call(this, "short", t), this.a = new n(t.a, 16).toRed(this.red), this.b = new n(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = 0 === this.a.fromRed().cmpn(0), this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3), this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
        }
        function c(t, e, r, i) {
            a.BasePoint.call(this, t, "affine"), null === e && null === r ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new n(e, 16), this.y = new n(r, 16), i && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
        }
        function u(t, e, r, i) {
            a.BasePoint.call(this, t, "jacobian"), null === e && null === r && null === i ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new n(0)) : (this.x = new n(e, 16), this.y = new n(r, 16), this.z = new n(i, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
        }
        s(h, a), t.exports = h, h.prototype._getEndomorphism = function(t) {
            if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
                var e, r;
                if (t.beta) e = new n(t.beta, 16).toRed(this.red);
                else {
                    var i = this._getEndoRoots(this.p);
                    e = (e = i[0].cmp(i[1]) < 0 ? i[0] : i[1]).toRed(this.red);
                }
                if (t.lambda) r = new n(t.lambda, 16);
                else {
                    var s = this._getEndoRoots(this.n);
                    0 === this.g.mul(s[0]).x.cmp(this.g.x.redMul(e)) ? r = s[0] : (r = s[1], o(0 === this.g.mul(r).x.cmp(this.g.x.redMul(e))));
                }
                return {
                    beta: e,
                    lambda: r,
                    basis: t.basis ? t.basis.map(function(t) {
                        return {
                            a: new n(t.a, 16),
                            b: new n(t.b, 16)
                        };
                    }) : this._getEndoBasis(r)
                };
            }
        }, h.prototype._getEndoRoots = function(t) {
            var e = t === this.p ? this.red : n.mont(t), r = new n(2).toRed(e).redInvm(), i = r.redNeg(), s = new n(3).toRed(e).redNeg().redSqrt().redMul(r);
            return [
                i.redAdd(s).fromRed(),
                i.redSub(s).fromRed()
            ];
        }, h.prototype._getEndoBasis = function(t) {
            for(var e, r, i, s, a, o, h, c, u, f = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), d = t, l = this.n.clone(), p = new n(1), b = new n(0), m = new n(0), g = new n(1), y = 0; 0 !== d.cmpn(0);){
                var w = l.div(d);
                c = l.sub(w.mul(d)), u = m.sub(w.mul(p));
                var _ = g.sub(w.mul(b));
                if (!i && c.cmp(f) < 0) e = h.neg(), r = p, i = c.neg(), s = u;
                else if (i && 2 == ++y) break;
                h = c, l = d, d = c, m = p, p = u, g = b, b = _;
            }
            a = c.neg(), o = u;
            var v = i.sqr().add(s.sqr());
            return a.sqr().add(o.sqr()).cmp(v) >= 0 && (a = e, o = r), i.negative && (i = i.neg(), s = s.neg()), a.negative && (a = a.neg(), o = o.neg()), [
                {
                    a: i,
                    b: s
                },
                {
                    a: a,
                    b: o
                }
            ];
        }, h.prototype._endoSplit = function(t) {
            var e = this.endo.basis, r = e[0], i = e[1], n = i.b.mul(t).divRound(this.n), s = r.b.neg().mul(t).divRound(this.n), a = n.mul(r.a), o = s.mul(i.a), h = n.mul(r.b), c = s.mul(i.b);
            return {
                k1: t.sub(a).sub(o),
                k2: h.add(c).neg()
            };
        }, h.prototype.pointFromX = function(t, e) {
            (t = new n(t, 16)).red || (t = t.toRed(this.red));
            var r = t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b), i = r.redSqrt();
            if (0 !== i.redSqr().redSub(r).cmp(this.zero)) throw new Error("invalid point");
            var s = i.fromRed().isOdd();
            return (e && !s || !e && s) && (i = i.redNeg()), this.point(t, i);
        }, h.prototype.validate = function(t) {
            if (t.inf) return !0;
            var e = t.x, r = t.y, i = this.a.redMul(e), n = e.redSqr().redMul(e).redIAdd(i).redIAdd(this.b);
            return 0 === r.redSqr().redISub(n).cmpn(0);
        }, h.prototype._endoWnafMulAdd = function(t, e, r) {
            for(var i = this._endoWnafT1, n = this._endoWnafT2, s = 0; s < t.length; s++){
                var a = this._endoSplit(e[s]), o = t[s], h = o._getBeta();
                a.k1.negative && (a.k1.ineg(), o = o.neg(!0)), a.k2.negative && (a.k2.ineg(), h = h.neg(!0)), i[2 * s] = o, i[2 * s + 1] = h, n[2 * s] = a.k1, n[2 * s + 1] = a.k2;
            }
            for(var c = this._wnafMulAdd(1, i, n, 2 * s, r), u = 0; u < 2 * s; u++)i[u] = null, n[u] = null;
            return c;
        }, s(c, a.BasePoint), h.prototype.point = function(t, e, r) {
            return new c(this, t, e, r);
        }, h.prototype.pointFromJSON = function(t, e) {
            return c.fromJSON(this, t, e);
        }, c.prototype._getBeta = function() {
            if (this.curve.endo) {
                var t = this.precomputed;
                if (t && t.beta) return t.beta;
                var e = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
                if (t) {
                    var r = this.curve, i = function(t) {
                        return r.point(t.x.redMul(r.endo.beta), t.y);
                    };
                    t.beta = e, e.precomputed = {
                        beta: null,
                        naf: t.naf && {
                            wnd: t.naf.wnd,
                            points: t.naf.points.map(i)
                        },
                        doubles: t.doubles && {
                            step: t.doubles.step,
                            points: t.doubles.points.map(i)
                        }
                    };
                }
                return e;
            }
        }, c.prototype.toJSON = function() {
            return this.precomputed ? [
                this.x,
                this.y,
                this.precomputed && {
                    doubles: this.precomputed.doubles && {
                        step: this.precomputed.doubles.step,
                        points: this.precomputed.doubles.points.slice(1)
                    },
                    naf: this.precomputed.naf && {
                        wnd: this.precomputed.naf.wnd,
                        points: this.precomputed.naf.points.slice(1)
                    }
                }
            ] : [
                this.x,
                this.y
            ];
        }, c.fromJSON = function(t, e, r) {
            "string" == typeof e && (e = JSON.parse(e));
            var i = t.point(e[0], e[1], r);
            if (!e[2]) return i;
            function n(e) {
                return t.point(e[0], e[1], r);
            }
            var s = e[2];
            return i.precomputed = {
                beta: null,
                doubles: s.doubles && {
                    step: s.doubles.step,
                    points: [
                        i
                    ].concat(s.doubles.points.map(n))
                },
                naf: s.naf && {
                    wnd: s.naf.wnd,
                    points: [
                        i
                    ].concat(s.naf.points.map(n))
                }
            }, i;
        }, c.prototype.inspect = function() {
            return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
        }, c.prototype.isInfinity = function() {
            return this.inf;
        }, c.prototype.add = function(t) {
            if (this.inf) return t;
            if (t.inf) return this;
            if (this.eq(t)) return this.dbl();
            if (this.neg().eq(t)) return this.curve.point(null, null);
            if (0 === this.x.cmp(t.x)) return this.curve.point(null, null);
            var e = this.y.redSub(t.y);
            0 !== e.cmpn(0) && (e = e.redMul(this.x.redSub(t.x).redInvm()));
            var r = e.redSqr().redISub(this.x).redISub(t.x), i = e.redMul(this.x.redSub(r)).redISub(this.y);
            return this.curve.point(r, i);
        }, c.prototype.dbl = function() {
            if (this.inf) return this;
            var t = this.y.redAdd(this.y);
            if (0 === t.cmpn(0)) return this.curve.point(null, null);
            var e = this.curve.a, r = this.x.redSqr(), i = t.redInvm(), n = r.redAdd(r).redIAdd(r).redIAdd(e).redMul(i), s = n.redSqr().redISub(this.x.redAdd(this.x)), a = n.redMul(this.x.redSub(s)).redISub(this.y);
            return this.curve.point(s, a);
        }, c.prototype.getX = function() {
            return this.x.fromRed();
        }, c.prototype.getY = function() {
            return this.y.fromRed();
        }, c.prototype.mul = function(t) {
            return t = new n(t, 16), this.isInfinity() ? this : this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve.endo ? this.curve._endoWnafMulAdd([
                this
            ], [
                t
            ]) : this.curve._wnafMul(this, t);
        }, c.prototype.mulAdd = function(t, e, r) {
            var i = [
                this,
                e
            ], n = [
                t,
                r
            ];
            return this.curve.endo ? this.curve._endoWnafMulAdd(i, n) : this.curve._wnafMulAdd(1, i, n, 2);
        }, c.prototype.jmulAdd = function(t, e, r) {
            var i = [
                this,
                e
            ], n = [
                t,
                r
            ];
            return this.curve.endo ? this.curve._endoWnafMulAdd(i, n, !0) : this.curve._wnafMulAdd(1, i, n, 2, !0);
        }, c.prototype.eq = function(t) {
            return this === t || this.inf === t.inf && (this.inf || 0 === this.x.cmp(t.x) && 0 === this.y.cmp(t.y));
        }, c.prototype.neg = function(t) {
            if (this.inf) return this;
            var e = this.curve.point(this.x, this.y.redNeg());
            if (t && this.precomputed) {
                var r = this.precomputed, i = function(t) {
                    return t.neg();
                };
                e.precomputed = {
                    naf: r.naf && {
                        wnd: r.naf.wnd,
                        points: r.naf.points.map(i)
                    },
                    doubles: r.doubles && {
                        step: r.doubles.step,
                        points: r.doubles.points.map(i)
                    }
                };
            }
            return e;
        }, c.prototype.toJ = function() {
            return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one);
        }, s(u, a.BasePoint), h.prototype.jpoint = function(t, e, r) {
            return new u(this, t, e, r);
        }, u.prototype.toP = function() {
            if (this.isInfinity()) return this.curve.point(null, null);
            var t = this.z.redInvm(), e = t.redSqr(), r = this.x.redMul(e), i = this.y.redMul(e).redMul(t);
            return this.curve.point(r, i);
        }, u.prototype.neg = function() {
            return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
        }, u.prototype.add = function(t) {
            if (this.isInfinity()) return t;
            if (t.isInfinity()) return this;
            var e = t.z.redSqr(), r = this.z.redSqr(), i = this.x.redMul(e), n = t.x.redMul(r), s = this.y.redMul(e.redMul(t.z)), a = t.y.redMul(r.redMul(this.z)), o = i.redSub(n), h = s.redSub(a);
            if (0 === o.cmpn(0)) return 0 !== h.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
            var c = o.redSqr(), u = c.redMul(o), f = i.redMul(c), d = h.redSqr().redIAdd(u).redISub(f).redISub(f), l = h.redMul(f.redISub(d)).redISub(s.redMul(u)), p = this.z.redMul(t.z).redMul(o);
            return this.curve.jpoint(d, l, p);
        }, u.prototype.mixedAdd = function(t) {
            if (this.isInfinity()) return t.toJ();
            if (t.isInfinity()) return this;
            var e = this.z.redSqr(), r = this.x, i = t.x.redMul(e), n = this.y, s = t.y.redMul(e).redMul(this.z), a = r.redSub(i), o = n.redSub(s);
            if (0 === a.cmpn(0)) return 0 !== o.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
            var h = a.redSqr(), c = h.redMul(a), u = r.redMul(h), f = o.redSqr().redIAdd(c).redISub(u).redISub(u), d = o.redMul(u.redISub(f)).redISub(n.redMul(c)), l = this.z.redMul(a);
            return this.curve.jpoint(f, d, l);
        }, u.prototype.dblp = function(t) {
            if (0 === t) return this;
            if (this.isInfinity()) return this;
            if (!t) return this.dbl();
            if (this.curve.zeroA || this.curve.threeA) {
                for(var e = this, r = 0; r < t; r++)e = e.dbl();
                return e;
            }
            var i = this.curve.a, n = this.curve.tinv, s = this.x, a = this.y, o = this.z, h = o.redSqr().redSqr(), c = a.redAdd(a);
            for(r = 0; r < t; r++){
                var u = s.redSqr(), f = c.redSqr(), d = f.redSqr(), l = u.redAdd(u).redIAdd(u).redIAdd(i.redMul(h)), p = s.redMul(f), b = l.redSqr().redISub(p.redAdd(p)), m = p.redISub(b), g = l.redMul(m);
                g = g.redIAdd(g).redISub(d);
                var y = c.redMul(o);
                r + 1 < t && (h = h.redMul(d)), s = b, o = y, c = g;
            }
            return this.curve.jpoint(s, c.redMul(n), o);
        }, u.prototype.dbl = function() {
            return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
        }, u.prototype._zeroDbl = function() {
            var t, e, r;
            if (this.zOne) {
                var i = this.x.redSqr(), n = this.y.redSqr(), s = n.redSqr(), a = this.x.redAdd(n).redSqr().redISub(i).redISub(s);
                a = a.redIAdd(a);
                var o = i.redAdd(i).redIAdd(i), h = o.redSqr().redISub(a).redISub(a), c = s.redIAdd(s);
                c = (c = c.redIAdd(c)).redIAdd(c), t = h, e = o.redMul(a.redISub(h)).redISub(c), r = this.y.redAdd(this.y);
            } else {
                var u = this.x.redSqr(), f = this.y.redSqr(), d = f.redSqr(), l = this.x.redAdd(f).redSqr().redISub(u).redISub(d);
                l = l.redIAdd(l);
                var p = u.redAdd(u).redIAdd(u), b = p.redSqr(), m = d.redIAdd(d);
                m = (m = m.redIAdd(m)).redIAdd(m), t = b.redISub(l).redISub(l), e = p.redMul(l.redISub(t)).redISub(m), r = (r = this.y.redMul(this.z)).redIAdd(r);
            }
            return this.curve.jpoint(t, e, r);
        }, u.prototype._threeDbl = function() {
            var t, e, r;
            if (this.zOne) {
                var i = this.x.redSqr(), n = this.y.redSqr(), s = n.redSqr(), a = this.x.redAdd(n).redSqr().redISub(i).redISub(s);
                a = a.redIAdd(a);
                var o = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a), h = o.redSqr().redISub(a).redISub(a);
                t = h;
                var c = s.redIAdd(s);
                c = (c = c.redIAdd(c)).redIAdd(c), e = o.redMul(a.redISub(h)).redISub(c), r = this.y.redAdd(this.y);
            } else {
                var u = this.z.redSqr(), f = this.y.redSqr(), d = this.x.redMul(f), l = this.x.redSub(u).redMul(this.x.redAdd(u));
                l = l.redAdd(l).redIAdd(l);
                var p = d.redIAdd(d), b = (p = p.redIAdd(p)).redAdd(p);
                t = l.redSqr().redISub(b), r = this.y.redAdd(this.z).redSqr().redISub(f).redISub(u);
                var m = f.redSqr();
                m = (m = (m = m.redIAdd(m)).redIAdd(m)).redIAdd(m), e = l.redMul(p.redISub(t)).redISub(m);
            }
            return this.curve.jpoint(t, e, r);
        }, u.prototype._dbl = function() {
            var t = this.curve.a, e = this.x, r = this.y, i = this.z, n = i.redSqr().redSqr(), s = e.redSqr(), a = r.redSqr(), o = s.redAdd(s).redIAdd(s).redIAdd(t.redMul(n)), h = e.redAdd(e), c = (h = h.redIAdd(h)).redMul(a), u = o.redSqr().redISub(c.redAdd(c)), f = c.redISub(u), d = a.redSqr();
            d = (d = (d = d.redIAdd(d)).redIAdd(d)).redIAdd(d);
            var l = o.redMul(f).redISub(d), p = r.redAdd(r).redMul(i);
            return this.curve.jpoint(u, l, p);
        }, u.prototype.trpl = function() {
            if (!this.curve.zeroA) return this.dbl().add(this);
            var t = this.x.redSqr(), e = this.y.redSqr(), r = this.z.redSqr(), i = e.redSqr(), n = t.redAdd(t).redIAdd(t), s = n.redSqr(), a = this.x.redAdd(e).redSqr().redISub(t).redISub(i), o = (a = (a = (a = a.redIAdd(a)).redAdd(a).redIAdd(a)).redISub(s)).redSqr(), h = i.redIAdd(i);
            h = (h = (h = h.redIAdd(h)).redIAdd(h)).redIAdd(h);
            var c = n.redIAdd(a).redSqr().redISub(s).redISub(o).redISub(h), u = e.redMul(c);
            u = (u = u.redIAdd(u)).redIAdd(u);
            var f = this.x.redMul(o).redISub(u);
            f = (f = f.redIAdd(f)).redIAdd(f);
            var d = this.y.redMul(c.redMul(h.redISub(c)).redISub(a.redMul(o)));
            d = (d = (d = d.redIAdd(d)).redIAdd(d)).redIAdd(d);
            var l = this.z.redAdd(a).redSqr().redISub(r).redISub(o);
            return this.curve.jpoint(f, d, l);
        }, u.prototype.mul = function(t, e) {
            return t = new n(t, e), this.curve._wnafMul(this, t);
        }, u.prototype.eq = function(t) {
            if ("affine" === t.type) return this.eq(t.toJ());
            if (this === t) return !0;
            var e = this.z.redSqr(), r = t.z.redSqr();
            if (0 !== this.x.redMul(r).redISub(t.x.redMul(e)).cmpn(0)) return !1;
            var i = e.redMul(this.z), n = r.redMul(t.z);
            return 0 === this.y.redMul(n).redISub(t.y.redMul(i)).cmpn(0);
        }, u.prototype.eqXToP = function(t) {
            var e = this.z.redSqr(), r = t.toRed(this.curve.red).redMul(e);
            if (0 === this.x.cmp(r)) return !0;
            for(var i = t.clone(), n = this.curve.redN.redMul(e);;){
                if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0) return !1;
                if (r.redIAdd(n), 0 === this.x.cmp(r)) return !0;
            }
        }, u.prototype.inspect = function() {
            return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
        }, u.prototype.isInfinity = function() {
            return 0 === this.z.cmpn(0);
        };
    },
    function(t, e) {
        t.exports = {
            doubles: {
                step: 4,
                points: [
                    [
                        "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
                        "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
                    ],
                    [
                        "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
                        "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
                    ],
                    [
                        "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
                        "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
                    ],
                    [
                        "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
                        "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
                    ],
                    [
                        "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
                        "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
                    ],
                    [
                        "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
                        "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
                    ],
                    [
                        "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
                        "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
                    ],
                    [
                        "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
                        "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
                    ],
                    [
                        "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
                        "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
                    ],
                    [
                        "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
                        "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
                    ],
                    [
                        "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
                        "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
                    ],
                    [
                        "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
                        "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
                    ],
                    [
                        "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
                        "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
                    ],
                    [
                        "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
                        "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
                    ],
                    [
                        "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
                        "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
                    ],
                    [
                        "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
                        "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
                    ],
                    [
                        "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
                        "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
                    ],
                    [
                        "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
                        "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
                    ],
                    [
                        "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
                        "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
                    ],
                    [
                        "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
                        "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
                    ],
                    [
                        "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
                        "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
                    ],
                    [
                        "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
                        "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
                    ],
                    [
                        "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
                        "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
                    ],
                    [
                        "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
                        "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
                    ],
                    [
                        "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
                        "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
                    ],
                    [
                        "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
                        "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
                    ],
                    [
                        "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
                        "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
                    ],
                    [
                        "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
                        "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
                    ],
                    [
                        "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
                        "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
                    ],
                    [
                        "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
                        "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
                    ],
                    [
                        "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
                        "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
                    ],
                    [
                        "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
                        "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
                    ],
                    [
                        "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
                        "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
                    ],
                    [
                        "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
                        "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
                    ],
                    [
                        "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
                        "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
                    ],
                    [
                        "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
                        "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
                    ],
                    [
                        "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
                        "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
                    ],
                    [
                        "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
                        "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
                    ],
                    [
                        "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
                        "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
                    ],
                    [
                        "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
                        "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
                    ],
                    [
                        "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
                        "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
                    ],
                    [
                        "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
                        "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
                    ],
                    [
                        "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
                        "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
                    ],
                    [
                        "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
                        "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
                    ],
                    [
                        "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
                        "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
                    ],
                    [
                        "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
                        "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
                    ],
                    [
                        "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
                        "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
                    ],
                    [
                        "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
                        "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
                    ],
                    [
                        "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
                        "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
                    ],
                    [
                        "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
                        "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
                    ],
                    [
                        "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
                        "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
                    ],
                    [
                        "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
                        "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
                    ],
                    [
                        "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
                        "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
                    ],
                    [
                        "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
                        "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
                    ],
                    [
                        "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
                        "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
                    ],
                    [
                        "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
                        "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
                    ],
                    [
                        "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
                        "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
                    ],
                    [
                        "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
                        "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
                    ],
                    [
                        "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
                        "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
                    ],
                    [
                        "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
                        "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
                    ],
                    [
                        "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
                        "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
                    ],
                    [
                        "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
                        "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
                    ],
                    [
                        "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
                        "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
                    ],
                    [
                        "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
                        "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
                    ],
                    [
                        "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
                        "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
                    ]
                ]
            },
            naf: {
                wnd: 7,
                points: [
                    [
                        "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
                        "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
                    ],
                    [
                        "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
                        "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
                    ],
                    [
                        "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
                        "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
                    ],
                    [
                        "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
                        "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
                    ],
                    [
                        "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
                        "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
                    ],
                    [
                        "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
                        "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
                    ],
                    [
                        "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
                        "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
                    ],
                    [
                        "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
                        "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
                    ],
                    [
                        "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
                        "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
                    ],
                    [
                        "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
                        "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
                    ],
                    [
                        "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
                        "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
                    ],
                    [
                        "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
                        "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
                    ],
                    [
                        "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
                        "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
                    ],
                    [
                        "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
                        "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
                    ],
                    [
                        "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
                        "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
                    ],
                    [
                        "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
                        "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
                    ],
                    [
                        "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
                        "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
                    ],
                    [
                        "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
                        "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
                    ],
                    [
                        "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
                        "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
                    ],
                    [
                        "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
                        "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
                    ],
                    [
                        "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
                        "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
                    ],
                    [
                        "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
                        "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
                    ],
                    [
                        "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
                        "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
                    ],
                    [
                        "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
                        "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
                    ],
                    [
                        "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
                        "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
                    ],
                    [
                        "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
                        "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
                    ],
                    [
                        "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
                        "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
                    ],
                    [
                        "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
                        "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
                    ],
                    [
                        "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
                        "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
                    ],
                    [
                        "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
                        "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
                    ],
                    [
                        "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
                        "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
                    ],
                    [
                        "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
                        "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
                    ],
                    [
                        "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
                        "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
                    ],
                    [
                        "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
                        "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
                    ],
                    [
                        "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
                        "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
                    ],
                    [
                        "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
                        "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
                    ],
                    [
                        "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
                        "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
                    ],
                    [
                        "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
                        "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
                    ],
                    [
                        "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
                        "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
                    ],
                    [
                        "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
                        "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
                    ],
                    [
                        "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
                        "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
                    ],
                    [
                        "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
                        "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
                    ],
                    [
                        "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
                        "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
                    ],
                    [
                        "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
                        "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
                    ],
                    [
                        "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
                        "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
                    ],
                    [
                        "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
                        "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
                    ],
                    [
                        "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
                        "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
                    ],
                    [
                        "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
                        "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
                    ],
                    [
                        "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
                        "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
                    ],
                    [
                        "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
                        "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
                    ],
                    [
                        "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
                        "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
                    ],
                    [
                        "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
                        "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
                    ],
                    [
                        "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
                        "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
                    ],
                    [
                        "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
                        "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
                    ],
                    [
                        "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
                        "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
                    ],
                    [
                        "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
                        "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
                    ],
                    [
                        "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
                        "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
                    ],
                    [
                        "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
                        "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
                    ],
                    [
                        "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
                        "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
                    ],
                    [
                        "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
                        "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
                    ],
                    [
                        "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
                        "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
                    ],
                    [
                        "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
                        "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
                    ],
                    [
                        "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
                        "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
                    ],
                    [
                        "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
                        "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
                    ],
                    [
                        "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
                        "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
                    ],
                    [
                        "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
                        "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
                    ],
                    [
                        "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
                        "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
                    ],
                    [
                        "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
                        "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
                    ],
                    [
                        "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
                        "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
                    ],
                    [
                        "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
                        "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
                    ],
                    [
                        "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
                        "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
                    ],
                    [
                        "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
                        "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
                    ],
                    [
                        "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
                        "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
                    ],
                    [
                        "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
                        "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
                    ],
                    [
                        "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
                        "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
                    ],
                    [
                        "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
                        "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
                    ],
                    [
                        "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
                        "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
                    ],
                    [
                        "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
                        "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
                    ],
                    [
                        "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
                        "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
                    ],
                    [
                        "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
                        "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
                    ],
                    [
                        "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
                        "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
                    ],
                    [
                        "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
                        "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
                    ],
                    [
                        "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
                        "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
                    ],
                    [
                        "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
                        "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
                    ],
                    [
                        "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
                        "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
                    ],
                    [
                        "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
                        "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
                    ],
                    [
                        "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
                        "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
                    ],
                    [
                        "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
                        "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
                    ],
                    [
                        "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
                        "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
                    ],
                    [
                        "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
                        "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
                    ],
                    [
                        "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
                        "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
                    ],
                    [
                        "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
                        "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
                    ],
                    [
                        "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
                        "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
                    ],
                    [
                        "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
                        "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
                    ],
                    [
                        "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
                        "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
                    ],
                    [
                        "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
                        "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
                    ],
                    [
                        "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
                        "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
                    ],
                    [
                        "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
                        "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
                    ],
                    [
                        "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
                        "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
                    ],
                    [
                        "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
                        "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
                    ],
                    [
                        "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
                        "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
                    ],
                    [
                        "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
                        "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
                    ],
                    [
                        "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
                        "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
                    ],
                    [
                        "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
                        "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
                    ],
                    [
                        "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
                        "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
                    ],
                    [
                        "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
                        "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
                    ],
                    [
                        "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
                        "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
                    ],
                    [
                        "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
                        "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
                    ],
                    [
                        "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
                        "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
                    ],
                    [
                        "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
                        "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
                    ],
                    [
                        "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
                        "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
                    ],
                    [
                        "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
                        "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
                    ],
                    [
                        "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
                        "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
                    ],
                    [
                        "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
                        "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
                    ],
                    [
                        "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
                        "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
                    ],
                    [
                        "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
                        "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
                    ],
                    [
                        "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
                        "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
                    ],
                    [
                        "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
                        "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
                    ],
                    [
                        "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
                        "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
                    ],
                    [
                        "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
                        "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
                    ],
                    [
                        "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
                        "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
                    ],
                    [
                        "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
                        "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
                    ],
                    [
                        "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
                        "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
                    ],
                    [
                        "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
                        "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
                    ],
                    [
                        "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
                        "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
                    ],
                    [
                        "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
                        "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
                    ],
                    [
                        "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
                        "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
                    ]
                ]
            }
        };
    },
    function(t, e, r) {
        "use strict";
        var i = r(14), n = r(105), s = r(31), a = r(59), o = r(56), h = s.assert, c = r(106), u = r(107);
        function f(t) {
            if (!(this instanceof f)) return new f(t);
            "string" == typeof t && (h(a.hasOwnProperty(t), "Unknown curve " + t), t = a[t]), t instanceof a.PresetCurve && (t = {
                curve: t
            }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
        }
        t.exports = f, f.prototype.keyPair = function(t) {
            return new c(this, t);
        }, f.prototype.keyFromPrivate = function(t, e) {
            return c.fromPrivate(this, t, e);
        }, f.prototype.keyFromPublic = function(t, e) {
            return c.fromPublic(this, t, e);
        }, f.prototype.genKeyPair = function(t) {
            t || (t = {});
            for(var e = new n({
                hash: this.hash,
                pers: t.pers,
                persEnc: t.persEnc || "utf8",
                entropy: t.entropy || o(this.hash.hmacStrength),
                entropyEnc: t.entropy && t.entropyEnc || "utf8",
                nonce: this.n.toArray()
            }), r = this.n.byteLength(), s = this.n.sub(new i(2));;){
                var a = new i(e.generate(r));
                if (!(a.cmp(s) > 0)) return a.iaddn(1), this.keyFromPrivate(a);
            }
        }, f.prototype._truncateToN = function(t, e) {
            var r = 8 * t.byteLength() - this.n.bitLength();
            return r > 0 && (t = t.ushrn(r)), !e && t.cmp(this.n) >= 0 ? t.sub(this.n) : t;
        }, f.prototype.sign = function(t, e, r, s) {
            "object" == typeof r && (s = r, r = null), s || (s = {}), e = this.keyFromPrivate(e, r), t = this._truncateToN(new i(t, 16));
            for(var a = this.n.byteLength(), o = e.getPrivate().toArray("be", a), h = t.toArray("be", a), c = new n({
                hash: this.hash,
                entropy: o,
                nonce: h,
                pers: s.pers,
                persEnc: s.persEnc || "utf8"
            }), f = this.n.sub(new i(1)), d = 0;; d++){
                var l = s.k ? s.k(d) : new i(c.generate(this.n.byteLength()));
                if (!((l = this._truncateToN(l, !0)).cmpn(1) <= 0 || l.cmp(f) >= 0)) {
                    var p = this.g.mul(l);
                    if (!p.isInfinity()) {
                        var b = p.getX(), m = b.umod(this.n);
                        if (0 !== m.cmpn(0)) {
                            var g = l.invm(this.n).mul(m.mul(e.getPrivate()).iadd(t));
                            if (0 !== (g = g.umod(this.n)).cmpn(0)) {
                                var y = (p.getY().isOdd() ? 1 : 0) | (0 !== b.cmp(m) ? 2 : 0);
                                return s.canonical && g.cmp(this.nh) > 0 && (g = this.n.sub(g), y ^= 1), new u({
                                    r: m,
                                    s: g,
                                    recoveryParam: y
                                });
                            }
                        }
                    }
                }
            }
        }, f.prototype.verify = function(t, e, r, n) {
            t = this._truncateToN(new i(t, 16)), r = this.keyFromPublic(r, n);
            var s = (e = new u(e, "hex")).r, a = e.s;
            if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return !1;
            if (a.cmpn(1) < 0 || a.cmp(this.n) >= 0) return !1;
            var o, h = a.invm(this.n), c = h.mul(t).umod(this.n), f = h.mul(s).umod(this.n);
            return this.curve._maxwellTrick ? !(o = this.g.jmulAdd(c, r.getPublic(), f)).isInfinity() && o.eqXToP(s) : !(o = this.g.mulAdd(c, r.getPublic(), f)).isInfinity() && 0 === o.getX().umod(this.n).cmp(s);
        }, f.prototype.recoverPubKey = function(t, e, r, n) {
            h((3 & r) === r, "The recovery param is more than two bits"), e = new u(e, n);
            var s = this.n, a = new i(t), o = e.r, c = e.s, f = 1 & r, d = r >> 1;
            if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && d) throw new Error("Unable to find sencond key candinate");
            o = d ? this.curve.pointFromX(o.add(this.curve.n), f) : this.curve.pointFromX(o, f);
            var l = e.r.invm(s), p = s.sub(a).mul(l).umod(s), b = c.mul(l).umod(s);
            return this.g.mulAdd(p, o, b);
        }, f.prototype.getKeyRecoveryParam = function(t, e, r, i) {
            if (null !== (e = new u(e, i)).recoveryParam) return e.recoveryParam;
            for(var n = 0; n < 4; n++){
                var s;
                try {
                    s = this.recoverPubKey(t, e, n);
                } catch (t1) {
                    continue;
                }
                if (s.eq(r)) return n;
            }
            throw new Error("Unable to find valid recovery factor");
        };
    },
    function(t, e, r) {
        "use strict";
        var i = r(32), n = r(55), s = r(30);
        function a(t) {
            if (!(this instanceof a)) return new a(t);
            this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
            var e = n.toArray(t.entropy, t.entropyEnc || "hex"), r = n.toArray(t.nonce, t.nonceEnc || "hex"), i = n.toArray(t.pers, t.persEnc || "hex");
            s(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, i);
        }
        t.exports = a, a.prototype._init = function(t, e, r) {
            var i = t.concat(e).concat(r);
            this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
            for(var n = 0; n < this.V.length; n++)this.K[n] = 0, this.V[n] = 1;
            this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656;
        }, a.prototype._hmac = function() {
            return new i.hmac(this.hash, this.K);
        }, a.prototype._update = function(t) {
            var e = this._hmac().update(this.V).update([
                0
            ]);
            t && (e = e.update(t)), this.K = e.digest(), this.V = this._hmac().update(this.V).digest(), t && (this.K = this._hmac().update(this.V).update([
                1
            ]).update(t).digest(), this.V = this._hmac().update(this.V).digest());
        }, a.prototype.reseed = function(t, e, r, i) {
            "string" != typeof e && (i = r, r = e, e = null), t = n.toArray(t, e), r = n.toArray(r, i), s(t.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(t.concat(r || [])), this._reseed = 1;
        }, a.prototype.generate = function(t, e, r, i) {
            if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
            "string" != typeof e && (i = r, r = e, e = null), r && (r = n.toArray(r, i || "hex"), this._update(r));
            for(var s = []; s.length < t;)this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
            var a = s.slice(0, t);
            return this._update(r), this._reseed++, n.encode(a, e);
        };
    },
    function(t, e, r) {
        "use strict";
        var i = r(14), n = r(31).assert;
        function s(t, e) {
            this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
        }
        t.exports = s, s.fromPublic = function(t, e, r) {
            return e instanceof s ? e : new s(t, {
                pub: e,
                pubEnc: r
            });
        }, s.fromPrivate = function(t, e, r) {
            return e instanceof s ? e : new s(t, {
                priv: e,
                privEnc: r
            });
        }, s.prototype.validate = function() {
            var t = this.getPublic();
            return t.isInfinity() ? {
                result: !1,
                reason: "Invalid public key"
            } : t.validate() ? t.mul(this.ec.curve.n).isInfinity() ? {
                result: !0,
                reason: null
            } : {
                result: !1,
                reason: "Public key * N != O"
            } : {
                result: !1,
                reason: "Public key is not a point"
            };
        }, s.prototype.getPublic = function(t, e) {
            return "string" == typeof t && (e = t, t = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), e ? this.pub.encode(e, t) : this.pub;
        }, s.prototype.getPrivate = function(t) {
            return "hex" === t ? this.priv.toString(16, 2) : this.priv;
        }, s.prototype._importPrivate = function(t, e) {
            this.priv = new i(t, e || 16), this.priv = this.priv.umod(this.ec.curve.n);
        }, s.prototype._importPublic = function(t, e) {
            if (t.x || t.y) return "mont" === this.ec.curve.type ? n(t.x, "Need x coordinate") : "short" !== this.ec.curve.type && "edwards" !== this.ec.curve.type || n(t.x && t.y, "Need both x and y coordinate"), void (this.pub = this.ec.curve.point(t.x, t.y));
            this.pub = this.ec.curve.decodePoint(t, e);
        }, s.prototype.derive = function(t) {
            return t.mul(this.priv).getX();
        }, s.prototype.sign = function(t, e, r) {
            return this.ec.sign(t, this, e, r);
        }, s.prototype.verify = function(t, e) {
            return this.ec.verify(t, e, this);
        }, s.prototype.inspect = function() {
            return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
        };
    },
    function(t, e, r) {
        "use strict";
        var i = r(14), n = r(31), s = n.assert;
        function a(t, e) {
            if (t instanceof a) return t;
            this._importDER(t, e) || (s(t.r && t.s, "Signature without r or s"), this.r = new i(t.r, 16), this.s = new i(t.s, 16), void 0 === t.recoveryParam ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
        }
        function o() {
            this.place = 0;
        }
        function h(t, e) {
            var r = t[e.place++];
            if (!(128 & r)) return r;
            for(var i = 15 & r, n = 0, s = 0, a = e.place; s < i; s++, a++)n <<= 8, n |= t[a];
            return e.place = a, n;
        }
        function c(t) {
            for(var e = 0, r = t.length - 1; !t[e] && !(128 & t[e + 1]) && e < r;)e++;
            return 0 === e ? t : t.slice(e);
        }
        function u(t, e) {
            if (e < 128) t.push(e);
            else {
                var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
                for(t.push(128 | r); --r;)t.push(e >>> (r << 3) & 255);
                t.push(e);
            }
        }
        t.exports = a, a.prototype._importDER = function(t, e) {
            t = n.toArray(t, e);
            var r = new o;
            if (48 !== t[r.place++]) return !1;
            if (h(t, r) + r.place !== t.length) return !1;
            if (2 !== t[r.place++]) return !1;
            var s = h(t, r), a = t.slice(r.place, s + r.place);
            if (r.place += s, 2 !== t[r.place++]) return !1;
            var c = h(t, r);
            if (t.length !== c + r.place) return !1;
            var u = t.slice(r.place, c + r.place);
            return 0 === a[0] && 128 & a[1] && (a = a.slice(1)), 0 === u[0] && 128 & u[1] && (u = u.slice(1)), this.r = new i(a), this.s = new i(u), this.recoveryParam = null, !0;
        }, a.prototype.toDER = function(t) {
            var e = this.r.toArray(), r = this.s.toArray();
            for(128 & e[0] && (e = [
                0
            ].concat(e)), 128 & r[0] && (r = [
                0
            ].concat(r)), e = c(e), r = c(r); !(r[0] || 128 & r[1]);)r = r.slice(1);
            var i = [
                2
            ];
            u(i, e.length), (i = i.concat(e)).push(2), u(i, r.length);
            var s = i.concat(r), a = [
                48
            ];
            return u(a, s.length), a = a.concat(s), n.encode(a, t);
        };
    },
    function(t, e, r) {
        (function(e, i) {
            var n, s = r(21).Buffer, a = r(62), o = r(63), h = r(64), c = r(76), u = e.crypto && e.crypto.subtle, f = {
                sha: "SHA-1",
                "sha-1": "SHA-1",
                sha1: "SHA-1",
                sha256: "SHA-256",
                "sha-256": "SHA-256",
                sha384: "SHA-384",
                "sha-384": "SHA-384",
                "sha-512": "SHA-512",
                sha512: "SHA-512"
            }, d = [];
            function l(t, e, r, i, n) {
                return u.importKey("raw", t, {
                    name: "PBKDF2"
                }, !1, [
                    "deriveBits"
                ]).then(function(t) {
                    return u.deriveBits({
                        name: "PBKDF2",
                        salt: e,
                        iterations: r,
                        hash: {
                            name: n
                        }
                    }, t, i << 3);
                }).then(function(t) {
                    return s.from(t);
                });
            }
            t.exports = function(t, r, p, b, m, g) {
                "function" == typeof m && (g = m, m = void 0);
                var y = f[(m = m || "sha1").toLowerCase()];
                if (!y || "function" != typeof e.Promise) return i.nextTick(function() {
                    var e;
                    try {
                        e = h(t, r, p, b, m);
                    } catch (t1) {
                        return g(t1);
                    }
                    g(null, e);
                });
                if (a(p, b), t = c(t, o, "Password"), r = c(r, o, "Salt"), "function" != typeof g) throw new Error("No callback provided to pbkdf2");
                !function(t, e) {
                    t.then(function(t) {
                        i.nextTick(function() {
                            e(null, t);
                        });
                    }, function(t) {
                        i.nextTick(function() {
                            e(t);
                        });
                    });
                }((function(t) {
                    if (e.process && !e.process.browser) return Promise.resolve(!1);
                    if (!u || !u.importKey || !u.deriveBits) return Promise.resolve(!1);
                    if (void 0 !== d[t]) return d[t];
                    var r = l(n = n || s.alloc(8), n, 10, 128, t).then(function() {
                        return !0;
                    }).catch(function() {
                        return !1;
                    });
                    return d[t] = r, r;
                })(y).then(function(e) {
                    return e ? l(t, r, p, b, y) : h(t, r, p, b, m);
                }), g);
            };
        }).call(this, r(33), r(26));
    },
    function(t, e, r) {
        var i = r(110);
        t.exports = function(t) {
            return (new i).update(t).digest();
        };
    },
    function(t, e, r) {
        "use strict";
        var i = r(17), n = r(65), s = r(21).Buffer, a = new Array(16);
        function o() {
            n.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
        }
        function h(t, e) {
            return t << e | t >>> 32 - e;
        }
        function c(t, e, r, i, n, s, a) {
            return h(t + (e & r | ~e & i) + n + s | 0, a) + e | 0;
        }
        function u(t, e, r, i, n, s, a) {
            return h(t + (e & i | r & ~i) + n + s | 0, a) + e | 0;
        }
        function f(t, e, r, i, n, s, a) {
            return h(t + (e ^ r ^ i) + n + s | 0, a) + e | 0;
        }
        function d(t, e, r, i, n, s, a) {
            return h(t + (r ^ (e | ~i)) + n + s | 0, a) + e | 0;
        }
        i(o, n), o.prototype._update = function() {
            for(var t = a, e = 0; e < 16; ++e)t[e] = this._block.readInt32LE(4 * e);
            var r = this._a, i = this._b, n = this._c, s = this._d;
            r = c(r, i, n, s, t[0], 3614090360, 7), s = c(s, r, i, n, t[1], 3905402710, 12), n = c(n, s, r, i, t[2], 606105819, 17), i = c(i, n, s, r, t[3], 3250441966, 22), r = c(r, i, n, s, t[4], 4118548399, 7), s = c(s, r, i, n, t[5], 1200080426, 12), n = c(n, s, r, i, t[6], 2821735955, 17), i = c(i, n, s, r, t[7], 4249261313, 22), r = c(r, i, n, s, t[8], 1770035416, 7), s = c(s, r, i, n, t[9], 2336552879, 12), n = c(n, s, r, i, t[10], 4294925233, 17), i = c(i, n, s, r, t[11], 2304563134, 22), r = c(r, i, n, s, t[12], 1804603682, 7), s = c(s, r, i, n, t[13], 4254626195, 12), n = c(n, s, r, i, t[14], 2792965006, 17), r = u(r, i = c(i, n, s, r, t[15], 1236535329, 22), n, s, t[1], 4129170786, 5), s = u(s, r, i, n, t[6], 3225465664, 9), n = u(n, s, r, i, t[11], 643717713, 14), i = u(i, n, s, r, t[0], 3921069994, 20), r = u(r, i, n, s, t[5], 3593408605, 5), s = u(s, r, i, n, t[10], 38016083, 9), n = u(n, s, r, i, t[15], 3634488961, 14), i = u(i, n, s, r, t[4], 3889429448, 20), r = u(r, i, n, s, t[9], 568446438, 5), s = u(s, r, i, n, t[14], 3275163606, 9), n = u(n, s, r, i, t[3], 4107603335, 14), i = u(i, n, s, r, t[8], 1163531501, 20), r = u(r, i, n, s, t[13], 2850285829, 5), s = u(s, r, i, n, t[2], 4243563512, 9), n = u(n, s, r, i, t[7], 1735328473, 14), r = f(r, i = u(i, n, s, r, t[12], 2368359562, 20), n, s, t[5], 4294588738, 4), s = f(s, r, i, n, t[8], 2272392833, 11), n = f(n, s, r, i, t[11], 1839030562, 16), i = f(i, n, s, r, t[14], 4259657740, 23), r = f(r, i, n, s, t[1], 2763975236, 4), s = f(s, r, i, n, t[4], 1272893353, 11), n = f(n, s, r, i, t[7], 4139469664, 16), i = f(i, n, s, r, t[10], 3200236656, 23), r = f(r, i, n, s, t[13], 681279174, 4), s = f(s, r, i, n, t[0], 3936430074, 11), n = f(n, s, r, i, t[3], 3572445317, 16), i = f(i, n, s, r, t[6], 76029189, 23), r = f(r, i, n, s, t[9], 3654602809, 4), s = f(s, r, i, n, t[12], 3873151461, 11), n = f(n, s, r, i, t[15], 530742520, 16), r = d(r, i = f(i, n, s, r, t[2], 3299628645, 23), n, s, t[0], 4096336452, 6), s = d(s, r, i, n, t[7], 1126891415, 10), n = d(n, s, r, i, t[14], 2878612391, 15), i = d(i, n, s, r, t[5], 4237533241, 21), r = d(r, i, n, s, t[12], 1700485571, 6), s = d(s, r, i, n, t[3], 2399980690, 10), n = d(n, s, r, i, t[10], 4293915773, 15), i = d(i, n, s, r, t[1], 2240044497, 21), r = d(r, i, n, s, t[8], 1873313359, 6), s = d(s, r, i, n, t[15], 4264355552, 10), n = d(n, s, r, i, t[6], 2734768916, 15), i = d(i, n, s, r, t[13], 1309151649, 21), r = d(r, i, n, s, t[4], 4149444226, 6), s = d(s, r, i, n, t[11], 3174756917, 10), n = d(n, s, r, i, t[2], 718787259, 15), i = d(i, n, s, r, t[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + i | 0, this._c = this._c + n | 0, this._d = this._d + s | 0;
        }, o.prototype._digest = function() {
            this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
            var t = s.allocUnsafe(16);
            return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
        }, t.exports = o;
    },
    function(t, e, r) {
        (e = t.exports = r(66)).Stream = e, e.Readable = e, e.Writable = r(71), e.Duplex = r(35), e.Transform = r(73), e.PassThrough = r(118), e.finished = r(50), e.pipeline = r(119);
    },
    function(t, e) {},
    function(t, e, r) {
        "use strict";
        function i(t, e) {
            var r = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var i = Object.getOwnPropertySymbols(t);
                e && (i = i.filter(function(e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable;
                })), r.push.apply(r, i);
            }
            return r;
        }
        function n(t, e, r) {
            return e in t ? Object.defineProperty(t, e, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = r, t;
        }
        function s(t, e) {
            for(var r = 0; r < e.length; r++){
                var i = e[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
            }
        }
        var a = r(7).Buffer, o = r(114).inspect, h = o && o.custom || "inspect";
        t.exports = function() {
            function t() {
                !function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                }(this, t), this.head = null, this.tail = null, this.length = 0;
            }
            var e, r, c;
            return e = t, r = [
                {
                    key: "push",
                    value: function(t) {
                        var e = {
                            data: t,
                            next: null
                        };
                        this.length > 0 ? this.tail.next = e : this.head = e, this.tail = e, ++this.length;
                    }
                },
                {
                    key: "unshift",
                    value: function(t) {
                        var e = {
                            data: t,
                            next: this.head
                        };
                        0 === this.length && (this.tail = e), this.head = e, ++this.length;
                    }
                },
                {
                    key: "shift",
                    value: function() {
                        if (0 !== this.length) {
                            var t = this.head.data;
                            return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
                        }
                    }
                },
                {
                    key: "clear",
                    value: function() {
                        this.head = this.tail = null, this.length = 0;
                    }
                },
                {
                    key: "join",
                    value: function(t) {
                        if (0 === this.length) return "";
                        for(var e = this.head, r = "" + e.data; e = e.next;)r += t + e.data;
                        return r;
                    }
                },
                {
                    key: "concat",
                    value: function(t) {
                        if (0 === this.length) return a.alloc(0);
                        for(var e, r, i, n = a.allocUnsafe(t >>> 0), s = this.head, o = 0; s;)e = s.data, r = n, i = o, a.prototype.copy.call(e, r, i), o += s.data.length, s = s.next;
                        return n;
                    }
                },
                {
                    key: "consume",
                    value: function(t, e) {
                        var r;
                        return t < this.head.data.length ? (r = this.head.data.slice(0, t), this.head.data = this.head.data.slice(t)) : r = t === this.head.data.length ? this.shift() : e ? this._getString(t) : this._getBuffer(t), r;
                    }
                },
                {
                    key: "first",
                    value: function() {
                        return this.head.data;
                    }
                },
                {
                    key: "_getString",
                    value: function(t) {
                        var e = this.head, r = 1, i = e.data;
                        for(t -= i.length; e = e.next;){
                            var n = e.data, s = t > n.length ? n.length : t;
                            if (s === n.length ? i += n : i += n.slice(0, t), 0 == (t -= s)) {
                                s === n.length ? (++r, e.next ? this.head = e.next : this.head = this.tail = null) : (this.head = e, e.data = n.slice(s));
                                break;
                            }
                            ++r;
                        }
                        return this.length -= r, i;
                    }
                },
                {
                    key: "_getBuffer",
                    value: function(t) {
                        var e = a.allocUnsafe(t), r = this.head, i = 1;
                        for(r.data.copy(e), t -= r.data.length; r = r.next;){
                            var n = r.data, s = t > n.length ? n.length : t;
                            if (n.copy(e, e.length - t, 0, s), 0 == (t -= s)) {
                                s === n.length ? (++i, r.next ? this.head = r.next : this.head = this.tail = null) : (this.head = r, r.data = n.slice(s));
                                break;
                            }
                            ++i;
                        }
                        return this.length -= i, e;
                    }
                },
                {
                    key: h,
                    value: function(t, e) {
                        return o(this, function(t) {
                            for(var e = 1; e < arguments.length; e++){
                                var r = null != arguments[e] ? arguments[e] : {};
                                e % 2 ? i(Object(r), !0).forEach(function(e) {
                                    n(t, e, r[e]);
                                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : i(Object(r)).forEach(function(e) {
                                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e));
                                });
                            }
                            return t;
                        }({}, e, {
                            depth: 0,
                            customInspect: !1
                        }));
                    }
                }
            ], s(e.prototype, r), c && s(e, c), t;
        }();
    },
    function(t, e) {},
    function(t, e, r) {
        (function(e) {
            function r(t) {
                try {
                    if (!e.localStorage) return !1;
                } catch (t1) {
                    return !1;
                }
                var r = e.localStorage[t];
                return null != r && "true" === String(r).toLowerCase();
            }
            t.exports = function(t, e) {
                if (r("noDeprecation")) return t;
                var i = !1;
                return function() {
                    if (!i) {
                        if (r("throwDeprecation")) throw new Error(e);
                        r("traceDeprecation") ? console.trace(e) : console.warn(e), i = !0;
                    }
                    return t.apply(this, arguments);
                };
            };
        }).call(this, r(33));
    },
    function(t, e, r) {
        "use strict";
        (function(e) {
            var i;
            function n(t, e, r) {
                return e in t ? Object.defineProperty(t, e, {
                    value: r,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = r, t;
            }
            var s = r(50), a = Symbol("lastResolve"), o = Symbol("lastReject"), h = Symbol("error"), c = Symbol("ended"), u = Symbol("lastPromise"), f = Symbol("handlePromise"), d = Symbol("stream");
            function l(t, e) {
                return {
                    value: t,
                    done: e
                };
            }
            function p(t) {
                var e = t[a];
                if (null !== e) {
                    var r = t[d].read();
                    null !== r && (t[u] = null, t[a] = null, t[o] = null, e(l(r, !1)));
                }
            }
            function b(t) {
                e.nextTick(p, t);
            }
            var m = Object.getPrototypeOf(function() {}), g = Object.setPrototypeOf((n(i = {
                get stream () {
                    return this[d];
                },
                next: function() {
                    var t = this, r = this[h];
                    if (null !== r) return Promise.reject(r);
                    if (this[c]) return Promise.resolve(l(void 0, !0));
                    if (this[d].destroyed) return new Promise(function(r, i) {
                        e.nextTick(function() {
                            t[h] ? i(t[h]) : r(l(void 0, !0));
                        });
                    });
                    var i, n = this[u];
                    if (n) i = new Promise(function(t, e) {
                        return function(r, i) {
                            t.then(function() {
                                e[c] ? r(l(void 0, !0)) : e[f](r, i);
                            }, i);
                        };
                    }(n, this));
                    else {
                        var s = this[d].read();
                        if (null !== s) return Promise.resolve(l(s, !1));
                        i = new Promise(this[f]);
                    }
                    return this[u] = i, i;
                }
            }, Symbol.asyncIterator, function() {
                return this;
            }), n(i, "return", function() {
                var t = this;
                return new Promise(function(e, r) {
                    t[d].destroy(null, function(t) {
                        t ? r(t) : e(l(void 0, !0));
                    });
                });
            }), i), m);
            t.exports = function(t) {
                var e, r = Object.create(g, (n(e = {}, d, {
                    value: t,
                    writable: !0
                }), n(e, a, {
                    value: null,
                    writable: !0
                }), n(e, o, {
                    value: null,
                    writable: !0
                }), n(e, h, {
                    value: null,
                    writable: !0
                }), n(e, c, {
                    value: t._readableState.endEmitted,
                    writable: !0
                }), n(e, f, {
                    value: function(t, e) {
                        var i = r[d].read();
                        i ? (r[u] = null, r[a] = null, r[o] = null, t(l(i, !1))) : (r[a] = t, r[o] = e);
                    },
                    writable: !0
                }), e));
                return r[u] = null, s(t, function(t) {
                    if (t && "ERR_STREAM_PREMATURE_CLOSE" !== t.code) {
                        var e = r[o];
                        return null !== e && (r[u] = null, r[a] = null, r[o] = null, e(t)), void (r[h] = t);
                    }
                    var i = r[a];
                    null !== i && (r[u] = null, r[a] = null, r[o] = null, i(l(void 0, !0))), r[c] = !0;
                }), t.on("readable", b.bind(null, r)), r;
            };
        }).call(this, r(26));
    },
    function(t, e) {
        t.exports = function() {
            throw new Error("Readable.from is not available in the browser");
        };
    },
    function(t, e, r) {
        "use strict";
        t.exports = n;
        var i = r(73);
        function n(t) {
            if (!(this instanceof n)) return new n(t);
            i.call(this, t);
        }
        r(17)(n, i), n.prototype._transform = function(t, e, r) {
            r(null, t);
        };
    },
    function(t, e, r) {
        "use strict";
        var i;
        var n = r(34).codes, s = n.ERR_MISSING_ARGS, a = n.ERR_STREAM_DESTROYED;
        function o(t) {
            if (t) throw t;
        }
        function h(t, e, n, s) {
            s = function(t) {
                var e = !1;
                return function() {
                    e || (e = !0, t.apply(void 0, arguments));
                };
            }(s);
            var o = !1;
            t.on("close", function() {
                o = !0;
            }), void 0 === i && (i = r(50)), i(t, {
                readable: e,
                writable: n
            }, function(t) {
                if (t) return s(t);
                o = !0, s();
            });
            var h = !1;
            return function(e) {
                if (!o && !h) return h = !0, function(t) {
                    return t.setHeader && "function" == typeof t.abort;
                }(t) ? t.abort() : "function" == typeof t.destroy ? t.destroy() : void s(e || new a("pipe"));
            };
        }
        function c(t) {
            t();
        }
        function u(t, e) {
            return t.pipe(e);
        }
        function f(t) {
            return t.length ? "function" != typeof t[t.length - 1] ? o : t.pop() : o;
        }
        t.exports = function() {
            for(var t = arguments.length, e = new Array(t), r = 0; r < t; r++)e[r] = arguments[r];
            var i, n = f(e);
            if (Array.isArray(e[0]) && (e = e[0]), e.length < 2) throw new s("streams");
            var a = e.map(function(t, r) {
                var s = r < e.length - 1;
                return h(t, s, r > 0, function(t) {
                    i || (i = t), t && a.forEach(c), s || (a.forEach(c), n(i));
                });
            });
            return e.reduce(u);
        };
    },
    function(t, e, r) {
        "use strict";
        var i = r(7).Buffer, n = r(17), s = r(65), a = new Array(16), o = [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            7,
            4,
            13,
            1,
            10,
            6,
            15,
            3,
            12,
            0,
            9,
            5,
            2,
            14,
            11,
            8,
            3,
            10,
            14,
            4,
            9,
            15,
            8,
            1,
            2,
            7,
            0,
            6,
            13,
            11,
            5,
            12,
            1,
            9,
            11,
            10,
            0,
            8,
            12,
            4,
            13,
            3,
            7,
            15,
            14,
            5,
            6,
            2,
            4,
            0,
            5,
            9,
            7,
            12,
            2,
            10,
            14,
            1,
            3,
            8,
            11,
            6,
            15,
            13
        ], h = [
            5,
            14,
            7,
            0,
            9,
            2,
            11,
            4,
            13,
            6,
            15,
            8,
            1,
            10,
            3,
            12,
            6,
            11,
            3,
            7,
            0,
            13,
            5,
            10,
            14,
            15,
            8,
            12,
            4,
            9,
            1,
            2,
            15,
            5,
            1,
            3,
            7,
            14,
            6,
            9,
            11,
            8,
            12,
            2,
            10,
            0,
            4,
            13,
            8,
            6,
            4,
            1,
            3,
            11,
            15,
            0,
            5,
            12,
            2,
            13,
            9,
            7,
            10,
            14,
            12,
            15,
            10,
            4,
            1,
            5,
            8,
            7,
            6,
            2,
            13,
            14,
            0,
            3,
            9,
            11
        ], c = [
            11,
            14,
            15,
            12,
            5,
            8,
            7,
            9,
            11,
            13,
            14,
            15,
            6,
            7,
            9,
            8,
            7,
            6,
            8,
            13,
            11,
            9,
            7,
            15,
            7,
            12,
            15,
            9,
            11,
            7,
            13,
            12,
            11,
            13,
            6,
            7,
            14,
            9,
            13,
            15,
            14,
            8,
            13,
            6,
            5,
            12,
            7,
            5,
            11,
            12,
            14,
            15,
            14,
            15,
            9,
            8,
            9,
            14,
            5,
            6,
            8,
            6,
            5,
            12,
            9,
            15,
            5,
            11,
            6,
            8,
            13,
            12,
            5,
            12,
            13,
            14,
            11,
            8,
            5,
            6
        ], u = [
            8,
            9,
            9,
            11,
            13,
            15,
            15,
            5,
            7,
            7,
            8,
            11,
            14,
            14,
            12,
            6,
            9,
            13,
            15,
            7,
            12,
            8,
            9,
            11,
            7,
            7,
            12,
            7,
            6,
            15,
            13,
            11,
            9,
            7,
            15,
            11,
            8,
            6,
            6,
            14,
            12,
            13,
            5,
            14,
            13,
            13,
            7,
            5,
            15,
            5,
            8,
            11,
            14,
            14,
            6,
            14,
            6,
            9,
            12,
            9,
            12,
            5,
            15,
            8,
            8,
            5,
            12,
            9,
            12,
            5,
            14,
            6,
            8,
            13,
            6,
            5,
            15,
            13,
            11,
            11
        ], f = [
            0,
            1518500249,
            1859775393,
            2400959708,
            2840853838
        ], d = [
            1352829926,
            1548603684,
            1836072691,
            2053994217,
            0
        ];
        function l() {
            s.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
        }
        function p(t, e) {
            return t << e | t >>> 32 - e;
        }
        function b(t, e, r, i, n, s, a, o) {
            return p(t + (e ^ r ^ i) + s + a | 0, o) + n | 0;
        }
        function m(t, e, r, i, n, s, a, o) {
            return p(t + (e & r | ~e & i) + s + a | 0, o) + n | 0;
        }
        function g(t, e, r, i, n, s, a, o) {
            return p(t + ((e | ~r) ^ i) + s + a | 0, o) + n | 0;
        }
        function y(t, e, r, i, n, s, a, o) {
            return p(t + (e & i | r & ~i) + s + a | 0, o) + n | 0;
        }
        function w(t, e, r, i, n, s, a, o) {
            return p(t + (e ^ (r | ~i)) + s + a | 0, o) + n | 0;
        }
        n(l, s), l.prototype._update = function() {
            for(var t = a, e = 0; e < 16; ++e)t[e] = this._block.readInt32LE(4 * e);
            for(var r = 0 | this._a, i = 0 | this._b, n = 0 | this._c, s = 0 | this._d, l = 0 | this._e, _ = 0 | this._a, v = 0 | this._b, S = 0 | this._c, O = 0 | this._d, E = 0 | this._e, I = 0; I < 80; I += 1){
                var B, P;
                I < 16 ? (B = b(r, i, n, s, l, t[o[I]], f[0], c[I]), P = w(_, v, S, O, E, t[h[I]], d[0], u[I])) : I < 32 ? (B = m(r, i, n, s, l, t[o[I]], f[1], c[I]), P = y(_, v, S, O, E, t[h[I]], d[1], u[I])) : I < 48 ? (B = g(r, i, n, s, l, t[o[I]], f[2], c[I]), P = g(_, v, S, O, E, t[h[I]], d[2], u[I])) : I < 64 ? (B = y(r, i, n, s, l, t[o[I]], f[3], c[I]), P = m(_, v, S, O, E, t[h[I]], d[3], u[I])) : (B = w(r, i, n, s, l, t[o[I]], f[4], c[I]), P = b(_, v, S, O, E, t[h[I]], d[4], u[I])), r = l, l = s, s = p(n, 10), n = i, i = B, _ = E, E = O, O = p(S, 10), S = v, v = P;
            }
            var R = this._b + n + O | 0;
            this._b = this._c + s + E | 0, this._c = this._d + l + _ | 0, this._d = this._e + r + v | 0, this._e = this._a + i + S | 0, this._a = R;
        }, l.prototype._digest = function() {
            this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
            var t = i.alloc ? i.alloc(20) : new i(20);
            return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
        }, t.exports = l;
    },
    function(t, e, r) {
        (e = t.exports = function(t) {
            t = t.toLowerCase();
            var r = e[t];
            if (!r) throw new Error(t + " is not supported (we accept pull requests)");
            return new r;
        }).sha = r(122), e.sha1 = r(123), e.sha224 = r(124), e.sha256 = r(74), e.sha384 = r(125), e.sha512 = r(75);
    },
    function(t, e, r) {
        var i = r(17), n = r(36), s = r(21).Buffer, a = [
            1518500249,
            1859775393,
            -1894007588,
            -899497514
        ], o = new Array(80);
        function h() {
            this.init(), this._w = o, n.call(this, 64, 56);
        }
        function c(t) {
            return t << 30 | t >>> 2;
        }
        function u(t, e, r, i) {
            return 0 === t ? e & r | ~e & i : 2 === t ? e & r | e & i | r & i : e ^ r ^ i;
        }
        i(h, n), h.prototype.init = function() {
            return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
        }, h.prototype._update = function(t) {
            for(var e, r = this._w, i = 0 | this._a, n = 0 | this._b, s = 0 | this._c, o = 0 | this._d, h = 0 | this._e, f = 0; f < 16; ++f)r[f] = t.readInt32BE(4 * f);
            for(; f < 80; ++f)r[f] = r[f - 3] ^ r[f - 8] ^ r[f - 14] ^ r[f - 16];
            for(var d = 0; d < 80; ++d){
                var l = ~~(d / 20), p = 0 | ((e = i) << 5 | e >>> 27) + u(l, n, s, o) + h + r[d] + a[l];
                h = o, o = s, s = c(n), n = i, i = p;
            }
            this._a = i + this._a | 0, this._b = n + this._b | 0, this._c = s + this._c | 0, this._d = o + this._d | 0, this._e = h + this._e | 0;
        }, h.prototype._hash = function() {
            var t = s.allocUnsafe(20);
            return t.writeInt32BE(0 | this._a, 0), t.writeInt32BE(0 | this._b, 4), t.writeInt32BE(0 | this._c, 8), t.writeInt32BE(0 | this._d, 12), t.writeInt32BE(0 | this._e, 16), t;
        }, t.exports = h;
    },
    function(t, e, r) {
        var i = r(17), n = r(36), s = r(21).Buffer, a = [
            1518500249,
            1859775393,
            -1894007588,
            -899497514
        ], o = new Array(80);
        function h() {
            this.init(), this._w = o, n.call(this, 64, 56);
        }
        function c(t) {
            return t << 5 | t >>> 27;
        }
        function u(t) {
            return t << 30 | t >>> 2;
        }
        function f(t, e, r, i) {
            return 0 === t ? e & r | ~e & i : 2 === t ? e & r | e & i | r & i : e ^ r ^ i;
        }
        i(h, n), h.prototype.init = function() {
            return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
        }, h.prototype._update = function(t) {
            for(var e, r = this._w, i = 0 | this._a, n = 0 | this._b, s = 0 | this._c, o = 0 | this._d, h = 0 | this._e, d = 0; d < 16; ++d)r[d] = t.readInt32BE(4 * d);
            for(; d < 80; ++d)r[d] = (e = r[d - 3] ^ r[d - 8] ^ r[d - 14] ^ r[d - 16]) << 1 | e >>> 31;
            for(var l = 0; l < 80; ++l){
                var p = ~~(l / 20), b = c(i) + f(p, n, s, o) + h + r[l] + a[p] | 0;
                h = o, o = s, s = u(n), n = i, i = b;
            }
            this._a = i + this._a | 0, this._b = n + this._b | 0, this._c = s + this._c | 0, this._d = o + this._d | 0, this._e = h + this._e | 0;
        }, h.prototype._hash = function() {
            var t = s.allocUnsafe(20);
            return t.writeInt32BE(0 | this._a, 0), t.writeInt32BE(0 | this._b, 4), t.writeInt32BE(0 | this._c, 8), t.writeInt32BE(0 | this._d, 12), t.writeInt32BE(0 | this._e, 16), t;
        }, t.exports = h;
    },
    function(t, e, r) {
        var i = r(17), n = r(74), s = r(36), a = r(21).Buffer, o = new Array(64);
        function h() {
            this.init(), this._w = o, s.call(this, 64, 56);
        }
        i(h, n), h.prototype.init = function() {
            return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
        }, h.prototype._hash = function() {
            var t = a.allocUnsafe(28);
            return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
        }, t.exports = h;
    },
    function(t, e, r) {
        var i = r(17), n = r(75), s = r(36), a = r(21).Buffer, o = new Array(160);
        function h() {
            this.init(), this._w = o, s.call(this, 128, 112);
        }
        i(h, n), h.prototype.init = function() {
            return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
        }, h.prototype._hash = function() {
            var t = a.allocUnsafe(48);
            function e(e, r, i) {
                t.writeInt32BE(e, i), t.writeInt32BE(r, i + 4);
            }
            return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t;
        }, t.exports = h;
    },
    function(t, e) {
        function r(t) {
            var e, r, i;
            this._tables[0][0][0] || this._precompute();
            var n = this._tables[0][4], s = this._tables[1], a = t.length, o = 1;
            if (4 !== a && 6 !== a && 8 !== a) throw new Error("invalid aes key size");
            this._key = [
                r = t.slice(0),
                i = []
            ];
            for(var h = a; h < 4 * a + 28; h++)e = r[h - 1], (h % a == 0 || 8 === a && h % a == 4) && (e = n[e >>> 24] << 24 ^ n[e >> 16 & 255] << 16 ^ n[e >> 8 & 255] << 8 ^ n[255 & e], h % a == 0 && (e = e << 8 ^ e >>> 24 ^ o << 24, o = o << 1 ^ 283 * (o >> 7))), r[h] = r[h - a] ^ e;
            for(var c = 0; h; c++, h--)e = r[3 & c ? h : h - 4], i[c] = h <= 4 || c < 4 ? e : s[0][n[e >>> 24]] ^ s[1][n[e >> 16 & 255]] ^ s[2][n[e >> 8 & 255]] ^ s[3][n[255 & e]];
        }
        t.exports = r, r.prototype = {
            encrypt: function(t) {
                return this._crypt(t, 0);
            },
            decrypt: function(t) {
                return this._crypt(t, 1);
            },
            _tables: [
                [
                    new Uint32Array(256),
                    new Uint32Array(256),
                    new Uint32Array(256),
                    new Uint32Array(256),
                    new Uint32Array(256)
                ],
                [
                    new Uint32Array(256),
                    new Uint32Array(256),
                    new Uint32Array(256),
                    new Uint32Array(256),
                    new Uint32Array(256)
                ]
            ],
            _precompute: function() {
                var t, e, r, i, n, s, a, o, h = this._tables[0], c = this._tables[1], u = h[4], f = c[4], d = new Uint8Array(256), l = new Uint8Array(256);
                for(t = 0; t < 256; t++)l[(d[t] = t << 1 ^ 283 * (t >> 7)) ^ t] = t;
                for(e = r = 0; !u[e]; e ^= i || 1, r = l[r] || 1)for(s = (s = r ^ r << 1 ^ r << 2 ^ r << 3 ^ r << 4) >> 8 ^ 255 & s ^ 99, u[e] = s, f[s] = e, o = 16843009 * d[n = d[i = d[e]]] ^ 65537 * n ^ 257 * i ^ 16843008 * e, a = 257 * d[s] ^ 16843008 * s, t = 0; t < 4; t++)h[t][e] = a = a << 24 ^ a >>> 8, c[t][s] = o = o << 24 ^ o >>> 8;
            },
            _crypt: function(t, e) {
                if (4 !== t.length) throw new Error("invalid aes block size");
                var r, i, n, s, a = this._key[e], o = t[0] ^ a[0], h = t[e ? 3 : 1] ^ a[1], c = t[2] ^ a[2], u = t[e ? 1 : 3] ^ a[3], f = a.length / 4 - 2, d = 4, l = new Uint32Array(4), p = this._tables[e], b = p[0], m = p[1], g = p[2], y = p[3], w = p[4];
                for(s = 0; s < f; s++)r = b[o >>> 24] ^ m[h >> 16 & 255] ^ g[c >> 8 & 255] ^ y[255 & u] ^ a[d], i = b[h >>> 24] ^ m[c >> 16 & 255] ^ g[u >> 8 & 255] ^ y[255 & o] ^ a[d + 1], n = b[c >>> 24] ^ m[u >> 16 & 255] ^ g[o >> 8 & 255] ^ y[255 & h] ^ a[d + 2], u = b[u >>> 24] ^ m[o >> 16 & 255] ^ g[h >> 8 & 255] ^ y[255 & c] ^ a[d + 3], d += 4, o = r, h = i, c = n;
                for(s = 0; s < 4; s++)l[e ? 3 & -s : s] = w[o >>> 24] << 24 ^ w[h >> 16 & 255] << 16 ^ w[c >> 8 & 255] << 8 ^ w[255 & u] ^ a[d++], r = o, o = h, h = c, c = u, u = r;
                return l;
            }
        };
    }
]);
void 0 === $239a085fc78b1aab$var$Bitcoin && console.error("esm-webpack-plugin: nothing exported!");
const $239a085fc78b1aab$export$73974d1f547d9d48 = $239a085fc78b1aab$var$Bitcoin.Address, $239a085fc78b1aab$export$c54ea3204cb8ac0 = $239a085fc78b1aab$var$Bitcoin.Bip32, $239a085fc78b1aab$export$703359f8afd6d609 = $239a085fc78b1aab$var$Bitcoin.Bip39, $239a085fc78b1aab$export$54018b34676f3073 = $239a085fc78b1aab$var$Bitcoin.Bn, $239a085fc78b1aab$export$9130f216d904f5ea = $239a085fc78b1aab$var$Bitcoin.Br, $239a085fc78b1aab$export$39820382f459b134 = $239a085fc78b1aab$var$Bitcoin.Bsm, $239a085fc78b1aab$export$e8fff5073f618ff8 = $239a085fc78b1aab$var$Bitcoin.Bw, $239a085fc78b1aab$export$45a587635c9954b2 = $239a085fc78b1aab$var$Bitcoin.Base58, $239a085fc78b1aab$export$bf8861ca8adc1a86 = $239a085fc78b1aab$var$Bitcoin.Base58Check, $239a085fc78b1aab$export$d96a8827a60d6b69 = $239a085fc78b1aab$var$Bitcoin.Block, $239a085fc78b1aab$export$9f2731c1db586d53 = $239a085fc78b1aab$var$Bitcoin.BlockHeader, $239a085fc78b1aab$export$a002182e51710d39 = $239a085fc78b1aab$var$Bitcoin.Constants, $239a085fc78b1aab$export$27d7c37b6c928f6c = $239a085fc78b1aab$var$Bitcoin.getConstants, $239a085fc78b1aab$export$734eef2e33e9d398 = $239a085fc78b1aab$var$Bitcoin.Ecdsa, $239a085fc78b1aab$export$ab85ecd77ce6a5cd = $239a085fc78b1aab$var$Bitcoin.Hash, $239a085fc78b1aab$export$ffdcc01fcf7d1c85 = $239a085fc78b1aab$var$Bitcoin.Interp, $239a085fc78b1aab$export$fe6d1b0debb52693 = $239a085fc78b1aab$var$Bitcoin.KeyPair, $239a085fc78b1aab$export$f3c97cc147df656 = $239a085fc78b1aab$var$Bitcoin.OpCode, $239a085fc78b1aab$export$baf26146a414f24a = $239a085fc78b1aab$var$Bitcoin.Point, $239a085fc78b1aab$export$6b158b3b249cbe74 = $239a085fc78b1aab$var$Bitcoin.PrivKey, $239a085fc78b1aab$export$852017f4734e111c = $239a085fc78b1aab$var$Bitcoin.PubKey, $239a085fc78b1aab$export$a92776769f460054 = $239a085fc78b1aab$var$Bitcoin.Random, $239a085fc78b1aab$export$2f8b47a141e57afc = $239a085fc78b1aab$var$Bitcoin.Script, $239a085fc78b1aab$export$bf50bed631ed9c4f = $239a085fc78b1aab$var$Bitcoin.Sig, $239a085fc78b1aab$export$f962a42ecbd3d9b9 = $239a085fc78b1aab$var$Bitcoin.SigOperations, $239a085fc78b1aab$export$eabc71f011df675a = $239a085fc78b1aab$var$Bitcoin.Struct, $239a085fc78b1aab$export$6040fcd2f49bbf1d = $239a085fc78b1aab$var$Bitcoin.Tx, $239a085fc78b1aab$export$7af18d40a3317626 = $239a085fc78b1aab$var$Bitcoin.TxBuilder, $239a085fc78b1aab$export$f46d60fbb5b5f94e = $239a085fc78b1aab$var$Bitcoin.TxIn, $239a085fc78b1aab$export$1f2c440f85fcbb32 = $239a085fc78b1aab$var$Bitcoin.TxOut, $239a085fc78b1aab$export$63373fafa12645e3 = $239a085fc78b1aab$var$Bitcoin.TxOutMap, $239a085fc78b1aab$export$18b1a8f7a3ce63c5 = $239a085fc78b1aab$var$Bitcoin.TxVerifier, $239a085fc78b1aab$export$4867cf6b1188708d = $239a085fc78b1aab$var$Bitcoin.VarInt, $239a085fc78b1aab$export$6c55f72bfe8b71ce = $239a085fc78b1aab$var$Bitcoin.Workers, $239a085fc78b1aab$export$fb7c8b5810a08d19 = $239a085fc78b1aab$var$Bitcoin.WorkersResult, $239a085fc78b1aab$export$6154dcdb7d23e37b = $239a085fc78b1aab$var$Bitcoin.cmp, $239a085fc78b1aab$export$205af294de50b195 = $239a085fc78b1aab$var$Bitcoin.Ach, $239a085fc78b1aab$export$ce362afade5377af = $239a085fc78b1aab$var$Bitcoin.Aes, $239a085fc78b1aab$export$1b7a86b971d48906 = $239a085fc78b1aab$var$Bitcoin.Aescbc, $239a085fc78b1aab$export$739f0aa89fd3ecac = $239a085fc78b1aab$var$Bitcoin.Cbc, $239a085fc78b1aab$export$630c01fb7f2714a5 = $239a085fc78b1aab$var$Bitcoin.Ecies, $239a085fc78b1aab$export$a23f992de0d45ff0 = $239a085fc78b1aab$var$Bitcoin.deps;




var $4apJo = parcelRequire("4apJo");


const $279a86245ff8c81d$export$b691916706e0e9cc = (pushData, schemaEncoding)=>{
    if (!pushData) throw new Error(`cannot get cell value of: ${pushData}`);
    else if (schemaEncoding === "string") return pushData["s"] ? pushData.s : pushData.ls || "";
    else if (schemaEncoding === "hex") return pushData["h"] ? pushData.h : pushData.lh || "";
    else if (schemaEncoding === "number") return parseInt(pushData["h"] ? pushData.h : pushData.lh || "0", 16);
    else if (schemaEncoding === "file") return `bitfs://${pushData["f"] ? pushData.f : pushData.lf}`;
    return (pushData["b"] ? pushData.b : pushData.lb) || "";
};
const $279a86245ff8c81d$export$238b4e54af8fe886 = function(cc) {
    return cc.cell[0] && cc.cell[1] && cc.cell[0].op === 0 && cc.cell[1].op && cc.cell[1].op === 106 || cc.cell[0].op === 106;
};
const $279a86245ff8c81d$export$23dbc584560299c3 = (dataObj, protocolName, data)=>{
    if (!dataObj[protocolName]) dataObj[protocolName] = [
        data
    ];
    else {
        if (!Array.isArray(dataObj[protocolName])) {
            const prevData = dataObj[protocolName];
            dataObj[protocolName] = [];
            dataObj[protocolName][0] = prevData;
        }
        dataObj[protocolName][dataObj[protocolName].length] = data;
    }
};
const $279a86245ff8c81d$export$9c363cd18b34077b = function(protocolName, querySchema, dataObj, cell, tx) {
    // loop over the schema
    const obj = {};
    // Does not have the required number of fields
    const length = querySchema.length + 1;
    if (cell.length < length) throw new Error(`${protocolName} requires at least ${length} fields including the prefix: ${tx.tx.h}`);
    for (const [idx, schemaField] of Object.entries(querySchema)){
        const x = parseInt(idx, 10);
        const [field] = Object.keys(schemaField);
        const [schemaEncoding] = Object.values(schemaField);
        obj[field] = $279a86245ff8c81d$export$b691916706e0e9cc(cell[x + 1], schemaEncoding);
    }
    $279a86245ff8c81d$export$23dbc584560299c3(dataObj, protocolName, obj);
};
const $279a86245ff8c81d$export$ca4d6504ca148ae4 = function(data) {
    const regex = "(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+/]{3}=)?";
    return new RegExp(`^${regex}$`, "gi").test(data);
};
const $279a86245ff8c81d$export$bced8d2aada2d1c9 = async (msgBuffer)=>{
    const hash = await ((0, $hiCjL$crypto.webcrypto) || window.crypto).subtle.digest("SHA-256", msgBuffer);
    return (0, $hiCjL$buffer.Buffer).from(hash);
};


const $428d5dc1cd339f93$var$address = "15PciHG22SNLQJXMoSUaWVi7WSqc7hCfva";
const $428d5dc1cd339f93$var$querySchema = [
    {
        algorithm: "string"
    },
    {
        address: "string"
    },
    {
        signature: "binary"
    },
    [
        {
            index: "binary"
        }
    ]
];
const $428d5dc1cd339f93$var$getFileBuffer = async function(bitfsRef) {
    let fileBuffer = (0, $hiCjL$buffer.Buffer).from("");
    try {
        const result = await (0, (/*@__PURE__*/$parcel$interopDefault($4apJo)))(`https://x.bitfs.network/${bitfsRef}`, {});
        fileBuffer = await result.buffer();
    } catch (e) {
        console.error(e);
    }
    return fileBuffer;
};
const $428d5dc1cd339f93$var$validateSignature = async function(aipObj, cell, tape) {
    if (!Array.isArray(tape) || tape.length < 3) throw new Error("AIP requires at least 3 cells including the prefix");
    let cellIndex = -1;
    tape.forEach((cc, index)=>{
        if (cc.cell === cell) cellIndex = index;
    });
    if (cellIndex === -1) throw new Error("AIP could not find cell in tape");
    let usingIndexes = aipObj.index || [];
    const signatureValues = [
        "6a"
    ] // OP_RETURN - is included in AIP
    ;
    for(let i = 0; i < cellIndex; i++){
        const cellContainer = tape[i];
        if (!(0, $279a86245ff8c81d$export$238b4e54af8fe886)(cellContainer)) {
            for(let nc = 0; nc < cellContainer.cell.length; nc++){
                const statement = cellContainer.cell[nc];
                // add the value as hex
                if (statement.h) signatureValues.push(statement.h);
                else if (statement.f) {
                    // file reference - we need to get the file from bitfs
                    const fileBuffer = await $428d5dc1cd339f93$var$getFileBuffer(statement.f);
                    signatureValues.push(fileBuffer.toString("hex"));
                } else if (statement.b) // no hex? try base64
                signatureValues.push((0, $hiCjL$buffer.Buffer).from(statement.b, "base64").toString("hex"));
                else if (statement.s) signatureValues.push((0, $hiCjL$buffer.Buffer).from(statement.s).toString("hex"));
            }
            signatureValues.push("7c") // | hex
            ;
        }
    }
    if (aipObj.hashing_algorithm) // when using HAIP, we need to parse the indexes in a non standard way
    // indexLength is byte size of the indexes being described
    {
        if (aipObj.index_unit_size) {
            const indexLength = aipObj.index_unit_size * 2;
            usingIndexes = [];
            const indexes = cell[6].h;
            for(let i1 = 0; i1 < indexes.length; i1 += indexLength)usingIndexes.push(parseInt(indexes.substr(i1, indexLength), 16));
            aipObj.index = usingIndexes;
        }
    }
    const signatureBufferStatements = [];
    // check whether we need to only sign some indexes
    if (usingIndexes.length > 0) usingIndexes.forEach((index)=>{
        signatureBufferStatements.push((0, $hiCjL$buffer.Buffer).from(signatureValues[index], "hex"));
    });
    else // add all the values to the signature buffer
    signatureValues.forEach((statement)=>{
        signatureBufferStatements.push((0, $hiCjL$buffer.Buffer).from(statement, "hex"));
    });
    let messageBuffer;
    if (aipObj.hashing_algorithm) {
        // this is actually Hashed-AIP (HAIP) and works a bit differently
        if (!aipObj.index_unit_size) // remove OP_RETURN - will be added by Script.buildDataOut
        signatureBufferStatements.shift();
        const dataScript = (0, $239a085fc78b1aab$export$2f8b47a141e57afc).fromSafeDataArray(signatureBufferStatements);
        let dataBuffer = (0, $hiCjL$buffer.Buffer).from(dataScript.toHex(), "hex");
        if (aipObj.index_unit_size) // the indexed buffer should not contain the OP_RETURN opcode, but this
        // is added by the buildDataOut function automatically. Remove it.
        dataBuffer = dataBuffer.slice(1);
        messageBuffer = await (0, $279a86245ff8c81d$export$bced8d2aada2d1c9)((0, $hiCjL$buffer.Buffer).from(dataBuffer.toString("hex")));
    } else // regular AIP
    messageBuffer = (0, $hiCjL$buffer.Buffer).concat([
        ...signatureBufferStatements
    ]);
    // AIOP uses address, HAIP uses signing_address field names
    const adressString = aipObj.address || aipObj.signing_address;
    // verify aip signature
    try {
        aipObj.verified = (0, $239a085fc78b1aab$export$39820382f459b134).verify(messageBuffer, aipObj.signature || "", (0, $239a085fc78b1aab$export$73974d1f547d9d48).fromString(adressString));
    } catch (e) {
        aipObj.verified = false;
    }
    // Try if this is a Twetch compatible AIP signature
    if (!aipObj.verified) {
        // Twetch signs a UTF-8 buffer of the hex string of a sha256 hash of the message
        // Without 0x06 (OP_RETURN) and without 0x7c at the end, the trailing pipe ("|")
        messageBuffer = (0, $hiCjL$buffer.Buffer).concat([
            ...signatureBufferStatements.slice(1, signatureBufferStatements.length - 1)
        ]);
        const buff = await (0, $279a86245ff8c81d$export$bced8d2aada2d1c9)(messageBuffer);
        messageBuffer = (0, $hiCjL$buffer.Buffer).from(buff.toString("hex"));
        try {
            aipObj.verified = (0, $239a085fc78b1aab$export$39820382f459b134).verify(messageBuffer, aipObj.signature || "", (0, $239a085fc78b1aab$export$73974d1f547d9d48).fromString(adressString));
        } catch (e1) {
            aipObj.verified = false;
        }
    }
    return aipObj.verified || false;
};
let $428d5dc1cd339f93$export$6c117c038f18b127;
(function(SIGPROTO) {
    SIGPROTO["HAIP"] = "HAIP";
    SIGPROTO["AIP"] = "AIP";
    SIGPROTO["BITCOM_HASHED"] = "BITCOM_HASHED";
})($428d5dc1cd339f93$export$6c117c038f18b127 || ($428d5dc1cd339f93$export$6c117c038f18b127 = {}));
const $428d5dc1cd339f93$export$f0079d0908cdbf96 = async function(useQuerySchema, protocol, dataObj, cell, tape, tx) {
    // loop over the schema
    const aipObj = {};
    // Does not have the required number of fields
    if (cell.length < 4) throw new Error("AIP requires at least 4 fields including the prefix " + tx);
    for (const [idx, schemaField] of Object.entries(useQuerySchema)){
        const x = parseInt(idx, 10);
        let schemaEncoding;
        let aipField;
        if (schemaField instanceof Array) {
            // signature indexes are specified
            schemaEncoding = schemaField[0].index;
            [aipField] = Object.keys(schemaField[0]);
            // run through the rest of the fields in this cell, should be de indexes
            const fieldData = [];
            for(let i = x + 1; i < cell.length; i++)if (cell[i].h && Array.isArray(fieldData)) fieldData.push(parseInt(cell[i].h || "", 16));
            aipObj[aipField] = fieldData;
            continue;
        } else {
            [aipField] = Object.keys(schemaField);
            [schemaEncoding] = Object.values(schemaField);
        }
        aipObj[aipField] = (0, $279a86245ff8c81d$export$b691916706e0e9cc)(cell[x + 1], schemaEncoding) || "";
    }
    // There is an issue where some services add the signature as binary to the transaction
    // whereas others add the signature as base64. This will confuse bob and the parser and
    // the signature will not be verified. When the signature is added in binary cell[3].s is
    // binary, otherwise cell[3].s contains the base64 signature and should be used.
    if (cell[0].s === $428d5dc1cd339f93$var$address && cell[3].s && (0, $279a86245ff8c81d$export$ca4d6504ca148ae4)(cell[3].s)) aipObj.signature = cell[3].s;
    if (!aipObj.signature) throw new Error("AIP requires a signature " + tx);
    await $428d5dc1cd339f93$var$validateSignature(aipObj, cell, tape);
    (0, $279a86245ff8c81d$export$23dbc584560299c3)(dataObj, protocol, aipObj);
};
const $428d5dc1cd339f93$var$handler = async ({ dataObj: dataObj , cell: cell , tape: tape , tx: tx  })=>{
    if (!tape) throw new Error("Invalid AIP transaction. tape is required");
    if (!tx) throw new Error("Invalid AIP transaction. tx is required");
    return await $428d5dc1cd339f93$export$f0079d0908cdbf96($428d5dc1cd339f93$var$querySchema, "AIP", dataObj, cell, tape, tx);
};
const $428d5dc1cd339f93$export$474d593e43f12abd = {
    name: "AIP",
    address: $428d5dc1cd339f93$var$address,
    querySchema: $428d5dc1cd339f93$var$querySchema,
    handler: $428d5dc1cd339f93$var$handler
};



const $b1f3a975f62840fa$var$address = "19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut";
const $b1f3a975f62840fa$var$querySchema = [
    {
        content: [
            "string",
            "binary",
            "file"
        ]
    },
    {
        "content-type": "string"
    },
    {
        encoding: "string"
    },
    {
        filename: "string"
    }
];
const $b1f3a975f62840fa$var$handler = function({ dataObj: dataObj , cell: cell , tx: tx  }) {
    const encodingMap = new Map();
    encodingMap.set("utf8", "string");
    encodingMap.set("text", "string") // invalid but people use it :(
    ;
    encodingMap.set("gzip", "binary") // invalid but people use it :(
    ;
    encodingMap.set("text/plain", "string");
    encodingMap.set("image/png", "binary");
    encodingMap.set("image/jpeg", "binary");
    if (!cell[1] || !cell[2]) throw new Error(`Invalid B tx: ${tx}`);
    // Check pushdata length + 1 for protocol prefix
    if (cell.length > $b1f3a975f62840fa$var$querySchema.length + 1) throw new Error("Invalid B tx. Too many fields.");
    // Make sure there are not more fields than possible
    const bObj = {};
    // loop over the schema
    for (const [idx, schemaField] of Object.entries($b1f3a975f62840fa$var$querySchema)){
        const x = parseInt(idx, 10);
        const bField = Object.keys(schemaField)[0];
        let schemaEncoding = Object.values(schemaField)[0];
        if (bField === "content") {
            // If the encoding is ommitted, try to infer from content-type instead of breaking
            if (cell[1].f) // this is file reference to B files
            schemaEncoding = "file";
            else if ((!cell[3] || !cell[3].s) && cell[2].s) {
                schemaEncoding = encodingMap.get(cell[2].s);
                if (!schemaEncoding) {
                    console.warn("Problem inferring encoding. Malformed B data.", cell);
                    return;
                }
                // add the missing encoding field
                if (!cell[3]) cell[3] = {
                    h: "",
                    b: "",
                    s: "",
                    i: 0,
                    ii: 0
                };
                cell[3].s = schemaEncoding === "string" ? "utf-8" : "binary";
            } else schemaEncoding = cell[3] && cell[3].s ? encodingMap.get(cell[3].s.replace("-", "").toLowerCase()) : null;
        }
        // encoding is not required
        if (bField === "encoding" && !cell[x + 1]) continue;
        // filename is not required
        if (bField === "filename" && !cell[x + 1]) continue;
        // check for malformed syntax
        if (!cell || !cell[x + 1]) throw new Error("malformed B syntax " + cell);
        // set field value from either s, b, ls, or lb depending on encoding and availability
        const data = cell[x + 1];
        bObj[bField] = (0, $279a86245ff8c81d$export$b691916706e0e9cc)(data, schemaEncoding);
    }
    (0, $279a86245ff8c81d$export$23dbc584560299c3)(dataObj, "B", bObj);
};
const $b1f3a975f62840fa$export$ef35774e6d314e91 = {
    name: "B",
    address: $b1f3a975f62840fa$var$address,
    querySchema: $b1f3a975f62840fa$var$querySchema,
    handler: $b1f3a975f62840fa$var$handler
};



const $d3a83c24449b7487$var$address = "1BAPSuaPnfGnSBM3GLV9yhxUdYe4vGbdMT";
const $d3a83c24449b7487$var$querySchema = [
    {
        type: "string"
    },
    {
        hash: "string"
    },
    {
        sequence: "string"
    }
];
const $d3a83c24449b7487$export$c3c52e219617878 = ({ dataObj: dataObj , cell: cell , tx: tx  })=>{
    if (!tx) throw new Error(`Invalid BAP tx, tx required`);
    (0, $279a86245ff8c81d$export$9c363cd18b34077b)("BAP", $d3a83c24449b7487$var$querySchema, dataObj, cell, tx);
};
const $d3a83c24449b7487$export$5935ea4bf04c4453 = {
    name: "BAP",
    address: $d3a83c24449b7487$var$address,
    querySchema: $d3a83c24449b7487$var$querySchema,
    handler: $d3a83c24449b7487$export$c3c52e219617878
};


var $690c1e68ac12266a$exports = {};
"use strict";
Object.defineProperty($690c1e68ac12266a$exports, "__esModule", {
    value: true
});
$690c1e68ac12266a$exports.BoostUtilsHelper = $690c1e68ac12266a$exports.BoostPowMetadata = $690c1e68ac12266a$exports.BoostPowJobProof = $690c1e68ac12266a$exports.BoostPowJob = $690c1e68ac12266a$exports.BoostPowString = $690c1e68ac12266a$exports.Puzzle = $690c1e68ac12266a$exports.Output = $690c1e68ac12266a$exports.Utils = $690c1e68ac12266a$exports.Metadata = $690c1e68ac12266a$exports.Redeem = $690c1e68ac12266a$exports.Job = $690c1e68ac12266a$exports.bsv = $690c1e68ac12266a$exports.work = $690c1e68ac12266a$exports.UInt64Big = $690c1e68ac12266a$exports.UInt32Big = $690c1e68ac12266a$exports.UInt32Little = $690c1e68ac12266a$exports.UInt16Little = $690c1e68ac12266a$exports.Int32Little = $690c1e68ac12266a$exports.Digest32 = $690c1e68ac12266a$exports.Digest20 = $690c1e68ac12266a$exports.Difficulty = $690c1e68ac12266a$exports.Bytes = void 0;
var $2bc0b4e409e4db7b$exports = {};

var $2bc0b4e409e4db7b$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";
Object.defineProperty($2bc0b4e409e4db7b$exports, "__esModule", {
    value: true
});
$2bc0b4e409e4db7b$exports.Job = void 0;

var $5St76 = parcelRequire("5St76");

var $c5i4c = parcelRequire("c5i4c");

var $7HMvJ = parcelRequire("7HMvJ");

var $kmTqg = parcelRequire("kmTqg");

var $iYsCg = parcelRequire("iYsCg");

var $7fdzx = parcelRequire("7fdzx");
var $1cf58cdc35e3ee2d$exports = {};
"use strict";
Object.defineProperty($1cf58cdc35e3ee2d$exports, "__esModule", {
    value: true
});
$1cf58cdc35e3ee2d$exports.Difficulty = void 0;

var $3KCZ8 = parcelRequire("3KCZ8");

var $7HMvJ = parcelRequire("7HMvJ");
class $1cf58cdc35e3ee2d$var$Difficulty {
    constructor(diff){
        this.diff = diff;
    }
    valid() {
        return this.diff > 0;
    }
    static fromBits(bits) {
        return new $1cf58cdc35e3ee2d$var$Difficulty($3KCZ8.Utils.difficulty(bits));
    }
    static fromHex(hex) {
        let bits = $7HMvJ.UInt32Little.fromHex(hex);
        if (bits) return this.fromBits(bits.number);
    }
    get number() {
        return this.diff;
    }
    get bits() {
        return $3KCZ8.Utils.difficulty2bits(this.diff);
    }
    get buffer() {
        return $7HMvJ.UInt32Little.fromNumber(this.bits).buffer;
    }
    get hex() {
        return this.buffer.toString("hex");
    }
    get string() {
        return this.hex;
    }
    get target() {
        return $3KCZ8.Utils.getTargetDifficulty(this.bits);
    }
}
$1cf58cdc35e3ee2d$exports.Difficulty = $1cf58cdc35e3ee2d$var$Difficulty;



var $8bhzx = parcelRequire("8bhzx");
var $9590091d29a867b1$exports = {};

var $9590091d29a867b1$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";
Object.defineProperty($9590091d29a867b1$exports, "__esModule", {
    value: true
});
$9590091d29a867b1$exports.Metadata = void 0;

var $5St76 = parcelRequire("5St76");

var $3KCZ8 = parcelRequire("3KCZ8");

var $7HMvJ = parcelRequire("7HMvJ");

var $3hHgz = parcelRequire("3hHgz");
var $fbef638501d7a8dd$exports = {};
"use strict";
Object.defineProperty($fbef638501d7a8dd$exports, "__esModule", {
    value: true
});
$fbef638501d7a8dd$exports.UInt64Big = void 0;

var $3KCZ8 = parcelRequire("3KCZ8");
class $fbef638501d7a8dd$var$UInt64Big {
    constructor(data){
        this.data = data;
    }
    get hex() {
        return this.data.toString("hex");
    }
    get buffer() {
        return this.data;
    }
    get string() {
        return this.utf8;
    }
    get utf8() {
        return $3KCZ8.Utils.trimBufferString(this.data, true);
    }
}
$fbef638501d7a8dd$exports.UInt64Big = $fbef638501d7a8dd$var$UInt64Big;



var $iYsCg = parcelRequire("iYsCg");
var $6fb0416f7363d29e$exports = {};
"use strict";
Object.defineProperty($6fb0416f7363d29e$exports, "__esModule", {
    value: true
});
$6fb0416f7363d29e$exports.Digest20 = void 0;

var $3KCZ8 = parcelRequire("3KCZ8");
class $6fb0416f7363d29e$var$Digest20 {
    constructor(data){
        this.data = data;
    }
    get hex() {
        return this.data.toString("hex");
    }
    get buffer() {
        return this.data;
    }
    get string() {
        return this.utf8;
    }
    get utf8() {
        return $3KCZ8.Utils.trimBufferString(this.data, true);
    }
    equals(d) {
        return this.data.equals(d.buffer);
    }
}
$6fb0416f7363d29e$exports.Digest20 = $6fb0416f7363d29e$var$Digest20;



var $7fdzx = parcelRequire("7fdzx");
class $9590091d29a867b1$var$Metadata {
    constructor(Tag, MinerPubKeyHash, ExtraNonce1, ExtraNonce2, UserNonce, AdditionalData){
        this.Tag = Tag;
        this.MinerPubKeyHash = MinerPubKeyHash;
        this.ExtraNonce1 = ExtraNonce1;
        this.ExtraNonce2 = ExtraNonce2;
        this.UserNonce = UserNonce;
        this.AdditionalData = AdditionalData;
    }
    static fromObject(params) {
        return new $9590091d29a867b1$var$Metadata(new $7fdzx.Bytes($9590091d29a867b1$require$Buffer.from(params.tag, "hex")), new $6fb0416f7363d29e$exports.Digest20($3KCZ8.Utils.createBufferAndPad(params.minerPubKeyHash, 20, false)), new $3hHgz.UInt32Big($3KCZ8.Utils.createBufferAndPad(params.extraNonce1, 4, false)), new $fbef638501d7a8dd$exports.UInt64Big($3KCZ8.Utils.createBufferAndPad(params.extraNonce2, 8, false)), new $7HMvJ.UInt32Little($3KCZ8.Utils.createBufferAndPad(params.userNonce, 4, false)), new $7fdzx.Bytes($9590091d29a867b1$require$Buffer.from(params.additionalData, "hex")));
    }
    static fromBuffer(params) {
        return new $9590091d29a867b1$var$Metadata(new $7fdzx.Bytes(params.tag), new $6fb0416f7363d29e$exports.Digest20(params.minerPubKeyHash), new $3hHgz.UInt32Big(params.extraNonce1), new $fbef638501d7a8dd$exports.UInt64Big(params.extraNonce2), new $7HMvJ.UInt32Little(params.userNonce), new $7fdzx.Bytes(params.additionalData));
    }
    get tag() {
        return this.Tag;
    }
    get minerPubKeyHash() {
        return this.MinerPubKeyHash;
    }
    get userNonce() {
        return this.UserNonce;
    }
    get extraNonce1() {
        return this.ExtraNonce1;
    }
    get extraNonce2() {
        return this.ExtraNonce2;
    }
    get additionalData() {
        return this.AdditionalData;
    }
    get getCoinbaseString() {
        return this.toString();
    }
    get hash() {
        return new $iYsCg.Digest32($5St76.crypto.Hash.sha256sha256(this.toBuffer()));
    }
    toString() {
        return this.toBuffer().toString("hex");
    }
    toObject() {
        return {
            tag: this.Tag.hex,
            minerPubKeyHash: this.minerPubKeyHash.hex,
            extraNonce1: this.extraNonce1.hex,
            extraNonce2: this.extraNonce2.hex,
            userNonce: this.userNonce.hex,
            additionalData: this.additionalData.hex
        };
    }
    toBuffer() {
        return $9590091d29a867b1$require$Buffer.concat([
            this.tag.buffer,
            this.minerPubKeyHash.buffer,
            this.extraNonce1.buffer,
            this.extraNonce2.buffer,
            this.userNonce.buffer,
            this.additionalData.buffer
        ]);
    }
    toHex() {
        return this.toBuffer().toString("hex");
    }
}
$9590091d29a867b1$exports.Metadata = $9590091d29a867b1$var$Metadata;



var $3KCZ8 = parcelRequire("3KCZ8");
var $97c32fe2d2793926$exports = {};
"use strict";
Object.defineProperty($97c32fe2d2793926$exports, "__esModule", {
    value: true
});
$97c32fe2d2793926$exports.Output = void 0;


var $iYsCg = parcelRequire("iYsCg");
// the Job class may represent a complete output in the blockchain but
// it may just be a script without other parameters. Output definitely has
// the satoshi value and outpoint set, which are both necessary for actually
// redeeming a Boost output.
class $97c32fe2d2793926$var$Output {
    constructor(job, value, txid, vout){
        this.script = job;
        if (value !== undefined) this._value = value;
        else if (job.value === undefined) throw "invalid output: missing parameter value";
        if (txid !== undefined) this._txid = txid;
        else if (job.txid === undefined) throw "invalid output: missing parameter txid";
        if (vout !== undefined) this._vout = vout;
        else if (job.vout === undefined) throw "invalid output: missing parameter vout";
    }
    static fromTransaction(tx, vout) {
        let j = $2bc0b4e409e4db7b$exports.Job.fromTransaction(tx, vout);
        if (j) return new $97c32fe2d2793926$var$Output(j);
    }
    get value() {
        if (this.script.value) return this.script.value;
        return this._value;
    }
    get txid() {
        if (this.script.txid) return $iYsCg.Digest32.fromHex(this.script.txid);
        return this._txid;
    }
    get vout() {
        if (this.script.vout) return this.script.vout;
        return this._vout;
    }
}
$97c32fe2d2793926$exports.Output = $97c32fe2d2793926$var$Output;


var $0ab2e73aadb4892c$exports = {};

var $0ab2e73aadb4892c$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";
Object.defineProperty($0ab2e73aadb4892c$exports, "__esModule", {
    value: true
});
$0ab2e73aadb4892c$exports.Puzzle = void 0;

var $5St76 = parcelRequire("5St76");

var $8bhzx = parcelRequire("8bhzx");

var $84cbf0bfa26f35a1$exports = {};

var $84cbf0bfa26f35a1$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";
Object.defineProperty($84cbf0bfa26f35a1$exports, "__esModule", {
    value: true
});
$84cbf0bfa26f35a1$exports.Redeem = void 0;

var $5St76 = parcelRequire("5St76");

var $8bhzx = parcelRequire("8bhzx");

var $3KCZ8 = parcelRequire("3KCZ8");

var $7HMvJ = parcelRequire("7HMvJ");

var $3hHgz = parcelRequire("3hHgz");


var $7fdzx = parcelRequire("7fdzx");
/**
 * Responsible for redeem script proof that work was done.
 * This gets combined with BoostPowJobModel
 */ class $84cbf0bfa26f35a1$var$Redeem {
    constructor(Signature, MinerPubKey, Time, ExtraNonce1, ExtraNonce2, Nonce, MinerPubKeyHash, GeneralPurposeBits, // Optional tx information attached or not
    Txid, Vin, SpentTxid, SpentVout){
        this.Signature = Signature;
        this.MinerPubKey = MinerPubKey;
        this.Time = Time;
        this.ExtraNonce1 = ExtraNonce1;
        this.ExtraNonce2 = ExtraNonce2;
        this.Nonce = Nonce;
        this.MinerPubKeyHash = MinerPubKeyHash;
        this.GeneralPurposeBits = GeneralPurposeBits;
        this.Txid = Txid;
        this.Vin = Vin;
        this.SpentTxid = SpentTxid;
        this.SpentVout = SpentVout;
    }
    static fromObject(params) {
        if (params.signature.length > 166) throw new Error("signature too large. Max 83 bytes.");
        if (params.minerPubKey.length != 66 && params.minerPubKey.length != 130) throw new Error("minerPubKey too large. Max 65 bytes.");
        if (params.nonce.length > 8) throw new Error("nonce too large. Max 4 bytes.");
        if (params.extraNonce1.length > 8) throw new Error("extraNonce1 too large. Max 4 bytes.");
        let minerPubKey = $84cbf0bfa26f35a1$require$Buffer.from(params.minerPubKey, "hex");
        let minerPubKeyHash;
        if (params.minerPubKeyHash) {
            if (params.minerPubKeyHash.length != 40) throw new Error("minerPubKeyHash too large. Max 20 bytes.");
            minerPubKeyHash = new $6fb0416f7363d29e$exports.Digest20($84cbf0bfa26f35a1$require$Buffer.from(params.minerPubKeyHash, "hex"));
        }
        let generalPurposeBits;
        if (params.generalPurposeBits) {
            if (params.generalPurposeBits.length > 8) throw new Error("generalPurposeBits too large. Max 8 bytes.");
            generalPurposeBits = new $7HMvJ.UInt32Little($3KCZ8.Utils.createBufferAndPad(params.generalPurposeBits, 4, false));
            if (params.extraNonce2.length > 32) throw new Error("extraNonce2 too large. Max 32 bytes.");
        } else {
            if (params.extraNonce2.length != 16) throw new Error("extraNonce2 too large. Max 8 bytes.");
        }
        return new $84cbf0bfa26f35a1$var$Redeem(new $7fdzx.Bytes($84cbf0bfa26f35a1$require$Buffer.from(params.signature, "hex")), new $7fdzx.Bytes(minerPubKey), new $7HMvJ.UInt32Little($3KCZ8.Utils.createBufferAndPad(params.time, 4, false)), new $3hHgz.UInt32Big($3KCZ8.Utils.createBufferAndPad(params.extraNonce1, 4, false)), new $7fdzx.Bytes($84cbf0bfa26f35a1$require$Buffer.from(params.extraNonce2, "hex")), new $7HMvJ.UInt32Little($3KCZ8.Utils.createBufferAndPad(params.nonce, 4, false)), minerPubKeyHash, generalPurposeBits);
    }
    static fromSolution(signature, minerPubKey, solution, minerPubKeyHash) {
        return new $84cbf0bfa26f35a1$var$Redeem(signature, minerPubKey, solution.Time, solution.ExtraNonce1, solution.ExtraNonce2, solution.Nonce, minerPubKeyHash, solution.GeneralPurposeBits);
    }
    get time() {
        return this.Time;
    }
    get generalPurposeBits() {
        return this.GeneralPurposeBits;
    }
    get extraNonce1() {
        return this.ExtraNonce1;
    }
    get extraNonce2() {
        return this.ExtraNonce2;
    }
    get nonce() {
        return this.Nonce;
    }
    // Should add bsv.Address version and string version too
    get minerPubKeyHash() {
        return this.MinerPubKeyHash;
    }
    get signature() {
        return this.Signature;
    }
    get minerPubKey() {
        return this.MinerPubKey;
    }
    isContract() {
        return !this.MinerPubKeyHash;
    }
    isBounty() {
        return !!this.MinerPubKeyHash;
    }
    get solution() {
        return new $8bhzx.Solution(this.time, this.extraNonce1, this.extraNonce2, this.nonce, this.generalPurposeBits);
    }
    toObject() {
        let obj = {
            // Output to string first, then flip endianness so we do not accidentally modify underlying buffer
            signature: this.signature.hex,
            minerPubKey: this.minerPubKey.hex,
            time: this.time.hex,
            nonce: this.nonce.hex,
            extraNonce1: this.extraNonce1.hex,
            extraNonce2: this.extraNonce2.hex
        };
        if (this.generalPurposeBits) obj["generalPurposeBits"] = this.generalPurposeBits.hex;
        if (this.minerPubKeyHash) obj["minerPubKeyHash"] = this.minerPubKeyHash.hex;
        return obj;
    }
    toScript() {
        let buildOut = $5St76.Script();
        // Add signature
        buildOut.add(this.signature.buffer);
        // Add miner pub key
        buildOut.add(this.minerPubKey.buffer);
        // Add miner nonce
        buildOut.add(this.nonce.buffer);
        // Add time
        buildOut.add(this.time.buffer);
        // Add extra nonce2
        buildOut.add(this.extraNonce2.buffer);
        // Add extra nonce 1
        buildOut.add(this.extraNonce1.buffer);
        if (this.generalPurposeBits) buildOut.add(this.generalPurposeBits.buffer);
        if (this.minerPubKeyHash) buildOut.add(this.minerPubKeyHash.buffer);
        return buildOut;
    }
    static fromTransaction(tx) {
        if (!tx) return undefined;
        let inp = 0;
        for (const input of tx.inputs){
            try {
                return $84cbf0bfa26f35a1$var$Redeem.fromScript(input.script, tx.hash, inp, input.prevTxId.toString("hex"), input.outputIndex);
            } catch (ex) {
            // Skip and try another output
            }
            inp++;
        }
        return undefined;
    }
    static fromRawTransaction(rawtx) {
        if (!rawtx || rawtx === "") return undefined;
        const tx = new $5St76.Transaction(rawtx);
        return $84cbf0bfa26f35a1$var$Redeem.fromTransaction(tx);
    }
    static fromScript(script, txid, vin, spentTxid, spentVout) {
        let signature;
        let minerPubKey;
        let time;
        let nonce;
        let extraNonce1;
        let extraNonce2;
        let minerPubKeyHash;
        let generalPurposeBits;
        if (7 === script.chunks.length && // signature
        script.chunks[0].len && // minerPubKey
        script.chunks[1].len && // nonce
        script.chunks[2].len && // time
        script.chunks[3].len && // extra Nonce 2
        script.chunks[4].len && // extra Nonce 1
        script.chunks[5].len && // minerPubKeyHash
        script.chunks[6].len) minerPubKeyHash = new $6fb0416f7363d29e$exports.Digest20(script.chunks[6].buf);
        else if (8 === script.chunks.length && // signature
        script.chunks[0].len && // minerPubKey
        script.chunks[1].len && // nonce
        script.chunks[2].len && // time
        script.chunks[3].len && (// extra Nonce 2
        script.chunks[4].buf && script.chunks[4].len <= 20 || script.chunks[4].opcodenum == $5St76.Opcode.OP_0 || script.chunks[4].opcodenum == $5St76.Opcode.OP_1NEGATE || script.chunks[4].opcodenum >= $5St76.Opcode.OP_1 && script.chunks[6].opcodenum <= $5St76.Opcode.OP_16) && // extra Nonce 1
        script.chunks[5].len && // generalPurposeBits
        script.chunks[6].len && // minerPubKeyHash
        script.chunks[7].len) {
            generalPurposeBits = new $7HMvJ.UInt32Little(script.chunks[6].buf);
            minerPubKeyHash = new $6fb0416f7363d29e$exports.Digest20(script.chunks[7].buf);
        } else throw new Error("Not valid Boost Proof");
        signature = new $7fdzx.Bytes(script.chunks[0].buf);
        minerPubKey = new $7fdzx.Bytes(script.chunks[1].buf);
        nonce = new $7HMvJ.UInt32Little(script.chunks[2].buf);
        time = new $7HMvJ.UInt32Little(script.chunks[3].buf);
        extraNonce2 = new $7fdzx.Bytes($3KCZ8.Utils.fromOpCode(script.chunks[4]));
        extraNonce1 = new $3hHgz.UInt32Big(script.chunks[5].buf);
        return new $84cbf0bfa26f35a1$var$Redeem(signature, minerPubKey, time, extraNonce1, extraNonce2, nonce, minerPubKeyHash, generalPurposeBits, txid, vin, spentTxid, spentVout);
    }
    static fromHex(asm, txid, vin, spentTxid, spentVout) {
        return $84cbf0bfa26f35a1$var$Redeem.fromScript(new $5St76.Script(asm), txid, vin, spentTxid, spentVout);
    }
    static fromASM(asm, txid, vin, spentTxid, spentVout) {
        return $84cbf0bfa26f35a1$var$Redeem.fromScript(new $5St76.Script.fromASM(asm), txid, vin, spentTxid, spentVout);
    }
    // Optional attached information if available
    get txInpoint() {
        return {
            txid: this.Txid,
            vin: this.Vin
        };
    }
    // Optional attached information if available
    get txid() {
        return this.Txid;
    }
    // Optional attached information if available
    get vin() {
        return this.Vin;
    }
    get spentTxid() {
        return this.SpentTxid;
    }
    // Optional attached information if available
    get spentVout() {
        return this.SpentVout;
    }
    static fromASM2(str, txid, vin) {
        return $84cbf0bfa26f35a1$var$Redeem.fromHex(str, txid, vin);
    }
    toString() {
        return this.toScript().toString();
    }
    toBuffer() {
        return this.toScript().toBuffer();
    }
    static fromBuffer(b) {
        return $84cbf0bfa26f35a1$var$Redeem.fromScript($5St76.Script.fromBuffer(b));
    }
    static fromString(str, txid, vin) {
        return $84cbf0bfa26f35a1$var$Redeem.fromHex(str, txid, vin);
    }
    // the expected size of a complete script.
    static expectedSize(is_boundy, use_general_purpose_bits, compressed_pubkey) {
        return 96 + (compressed_pubkey ? 34 : 66) + (is_boundy ? 21 : 0) + (use_general_purpose_bits ? 5 : 0);
    }
}
$84cbf0bfa26f35a1$exports.Redeem = $84cbf0bfa26f35a1$var$Redeem;




var $7fdzx = parcelRequire("7fdzx");
var $5e9668fed80c706e$exports = {};

var $5e9668fed80c706e$require$Buffer = $hiCjL$buffer.Buffer;
"use strict";
Object.defineProperty($5e9668fed80c706e$exports, "__esModule", {
    value: true
});
$5e9668fed80c706e$exports.verify = $5e9668fed80c706e$exports.sign = $5e9668fed80c706e$exports.writeIncompleteTransaction = $5e9668fed80c706e$exports.writeTransaction = $5e9668fed80c706e$exports.serializedSize = $5e9668fed80c706e$exports.estimateTransactionSize = void 0;

var $5St76 = parcelRequire("5St76");

var $iYsCg = parcelRequire("iYsCg");

var $c5i4c = parcelRequire("c5i4c");

var $7HMvJ = parcelRequire("7HMvJ");
function $5e9668fed80c706e$var$varIntSize(n) {
    if (n < 253) return 1;
    if (n < 0x10000) return 3;
    if (n < 0x100000000) return 5;
    return 9;
}
// (step 2) given an incomplete transaction, we determine the expected size here.
// this is used to determine the fee.
function $5e9668fed80c706e$var$estimateTransactionSize(x) {
    let size = 8 + $5e9668fed80c706e$var$varIntSize(x.outputs.length) + $5e9668fed80c706e$var$varIntSize(x.inputs.length);
    for (let input of x.inputs)size += 40 + $5e9668fed80c706e$var$varIntSize(input.scriptSize) + input.scriptSize;
    for (let output of x.outputs)size += 8 + $5e9668fed80c706e$var$varIntSize(output.script.length) + output.script.length;
    return size;
}
$5e9668fed80c706e$exports.estimateTransactionSize = $5e9668fed80c706e$var$estimateTransactionSize;
function $5e9668fed80c706e$var$serializedSize(x) {
    let size = 8 + $5e9668fed80c706e$var$varIntSize(x.outputs.length) + $5e9668fed80c706e$var$varIntSize(x.inputs.length);
    for (let input of x.inputs)size += 40 + $5e9668fed80c706e$var$varIntSize(input.script.length) + input.script.length;
    for (let output of x.outputs)size += 8 + $5e9668fed80c706e$var$varIntSize(output.script.length) + output.script.length;
    return size;
}
$5e9668fed80c706e$exports.serializedSize = $5e9668fed80c706e$var$serializedSize;
class $5e9668fed80c706e$var$Writer {
    constructor(size){
        this.position = 0;
        this.buf = $5e9668fed80c706e$require$Buffer.alloc(Number(size));
    }
    write_buffer(b) {
        b.copy(this.buf, this.position);
        this.position += b.length;
    }
    write_var_int(n) {
        var buf;
        if (n < 253) {
            buf = $5e9668fed80c706e$require$Buffer.alloc(1);
            buf.writeUInt8(n, 0);
        } else if (n < 0x10000) {
            buf = $5e9668fed80c706e$require$Buffer.alloc(3);
            buf.writeUInt8(253, 0);
            buf.writeUInt16LE(n, 1);
        } else if (n < 0x100000000) {
            buf = $5e9668fed80c706e$require$Buffer.alloc(5);
            buf.writeUInt8(254, 0);
            buf.writeUInt32LE(n, 1);
        } else {
            buf = $5e9668fed80c706e$require$Buffer.alloc(9);
            buf.writeUInt8(255, 0);
            buf.writeInt32LE(n & -1, 1);
            buf.writeUInt32LE(Math.floor(n / 0x100000000), 5);
        }
        this.write_buffer(buf);
    }
    write_input(i) {
        this.write_buffer(i.prevTxId instanceof $5e9668fed80c706e$require$Buffer ? i.prevTxId : (i.prevTxId instanceof $iYsCg.Digest32 ? i.prevTxId : $iYsCg.Digest32.fromHex(i.prevTxId)).buffer);
        this.write_buffer((i.outputIndex instanceof $7HMvJ.UInt32Little ? i.outputIndex : $7HMvJ.UInt32Little.fromNumber(i.outputIndex)).buffer);
        let script = i.script instanceof $5e9668fed80c706e$require$Buffer ? i.script : $5e9668fed80c706e$require$Buffer.from(i.script, "hex");
        this.write_var_int(script.length);
        this.write_buffer(script);
        this.write_buffer((i.outputIndex instanceof $7HMvJ.UInt32Little ? i.outputIndex : $7HMvJ.UInt32Little.fromNumber(!i.outputIndex ? 0xffffffff : i.outputIndex)).buffer);
    }
    write_satoshis(n) {
        this.write_buffer($5St76.crypto.BN.fromNumber(n).toBuffer({
            size: 8
        }).reverse());
    }
    write_output(o) {
        this.write_satoshis(o.satoshis);
        let script = o.script instanceof $5e9668fed80c706e$require$Buffer ? o.script : $5e9668fed80c706e$require$Buffer.from(o.script, "hex");
        this.write_var_int(script.length);
        this.write_buffer(script);
    }
    write_transaction(tx) {
        this.write_buffer((tx.version instanceof $c5i4c.Int32Little ? tx.version : $7HMvJ.UInt32Little.fromNumber(tx.version)).buffer);
        this.write_var_int(tx.inputs.length);
        for (let input of tx.inputs)this.write_input(input);
        this.write_var_int(tx.outputs.length);
        for (let output of tx.outputs)this.write_output(output);
        this.write_buffer((tx.locktime instanceof $7HMvJ.UInt32Little ? tx.locktime : $7HMvJ.UInt32Little.fromNumber(!tx.locktime ? 0 : tx.locktime)).buffer);
    }
}
// write a transaction in the format given above to a buffer
function $5e9668fed80c706e$var$writeTransaction(tx) {
    let w = new $5e9668fed80c706e$var$Writer($5e9668fed80c706e$var$serializedSize(tx));
    w.write_transaction(tx);
    return w.buf;
}
$5e9668fed80c706e$exports.writeTransaction = $5e9668fed80c706e$var$writeTransaction;
// (step 4) write incomplete transaction for signing.
function $5e9668fed80c706e$var$writeIncompleteTransaction(tx) {
    let inputs = [];
    for (let input of tx.inputs)inputs.push({
        prevTxId: input.prevTxId,
        outputIndex: input.outputIndex,
        script: $5e9668fed80c706e$require$Buffer.alloc(0),
        sequenceNumber: input.sequenceNumber
    });
    return $5e9668fed80c706e$var$writeTransaction({
        version: tx.version,
        inputs: inputs,
        outputs: tx.outputs,
        locktime: tx.locktime
    });
}
$5e9668fed80c706e$exports.writeIncompleteTransaction = $5e9668fed80c706e$var$writeIncompleteTransaction;
function $5e9668fed80c706e$var$sign(wif, doc, sigtype = $5St76.crypto.Signature.SIGHASH_ALL | $5St76.crypto.Signature.SIGHASH_FORKID, flags = $5St76.Script.Interpreter.SCRIPT_VERIFY_MINIMALDATA | $5St76.Script.Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID | $5St76.Script.Interpreter.SCRIPT_ENABLE_MAGNETIC_OPCODES | $5St76.Script.Interpreter.SCRIPT_ENABLE_MONOLITH_OPCODES) {
    let tx = doc.incompleteTransaction instanceof $5St76.Transaction || doc.incompleteTransaction instanceof $5e9668fed80c706e$require$Buffer ? doc.incompleteTransaction : $5e9668fed80c706e$var$writeIncompleteTransaction(doc.incompleteTransaction);
    return $5e9668fed80c706e$require$Buffer.concat([
        $5St76.Transaction.Sighash.sign(new $5St76.Transaction(tx), new $5St76.PrivateKey(wif), sigtype, doc.inputIndex, new $5St76.Script(doc.scriptCode), new $5St76.crypto.BN(doc.satoshis), flags).toBuffer(),
        $5e9668fed80c706e$require$Buffer.from([
            sigtype & 0xff
        ])
    ]);
}
$5e9668fed80c706e$exports.sign = $5e9668fed80c706e$var$sign;
function $5e9668fed80c706e$var$verify(pubkey, sig, doc, flags = $5St76.Script.Interpreter.SCRIPT_VERIFY_MINIMALDATA | $5St76.Script.Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID | $5St76.Script.Interpreter.SCRIPT_ENABLE_MAGNETIC_OPCODES | $5St76.Script.Interpreter.SCRIPT_ENABLE_MONOLITH_OPCODES) {
    let tx = doc.incompleteTransaction instanceof $5St76.Transaction || doc.incompleteTransaction instanceof $5e9668fed80c706e$require$Buffer ? doc.incompleteTransaction : $5e9668fed80c706e$var$writeIncompleteTransaction(doc.incompleteTransaction);
    let pub = pubkey instanceof $5e9668fed80c706e$require$Buffer ? $5St76.PublicKey.fromBuffer(pubkey) : pubkey;
    return $5St76.Transaction.Sighash.verify(new $5St76.Transaction(tx), new $5St76.crypto.Signature.fromTxFormat(sig), pub, doc.inputIndex, new $5St76.Script(doc.scriptCode), new $5St76.crypto.BN(doc.satoshis), flags);
}
$5e9668fed80c706e$exports.verify = $5e9668fed80c706e$var$verify;


// Puzzle represents a Boost output that has had a private key assigned to it.
// This may have happened before or after the output was created, depending on
// whether it has a contract or bounty format.
class $0ab2e73aadb4892c$var$Puzzle {
    constructor(output, k){
        let key = new $5St76.PrivateKey(k);
        let pub = key.toPublicKey();
        let address = new $6fb0416f7363d29e$exports.Digest20($0ab2e73aadb4892c$require$Buffer.from($5St76.Address.fromPublicKey(pub, key.network).toObject().hash, "hex"));
        if (output.script.minerPubKeyHash) {
            if (!address.equals(output.script.minerPubKeyHash)) throw "invalid parameters";
        } else this._address = address;
        this.output = output;
        this.key = key;
        this.pubkey = new $7fdzx.Bytes(pub.toBuffer());
    }
    get address() {
        if (this._address) return this._address;
        return this.output.script.minerPubKeyHash;
    }
    get workPuzzle() {
        return $2bc0b4e409e4db7b$exports.Job.puzzle(this.output.script, this._address);
    }
    // create a redeem script for this output.
    redeem(solution, // the incomplete tx that will be signed (the input scripts are missing)
    incomplete_transaction, // the index of the input script that we are creating.
    input_index, sigtype = $5St76.crypto.Signature.SIGHASH_ALL | $5St76.crypto.Signature.SIGHASH_FORKID, flags = $5St76.Script.Interpreter.SCRIPT_VERIFY_MINIMALDATA | $5St76.Script.Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID | $5St76.Script.Interpreter.SCRIPT_ENABLE_MAGNETIC_OPCODES | $5St76.Script.Interpreter.SCRIPT_ENABLE_MONOLITH_OPCODES) {
        if (!new $8bhzx.Proof(this.workPuzzle, solution).valid()) throw new Error("invalid solution");
        return $84cbf0bfa26f35a1$exports.Redeem.fromSolution(new $7fdzx.Bytes($5e9668fed80c706e$exports.sign(this.key, {
            satoshis: this.output.value,
            scriptCode: this.output.script.toScript(),
            inputIndex: input_index,
            incompleteTransaction: incomplete_transaction
        }, sigtype, flags)), this.pubkey, solution, this._address);
    }
    expectedRedeemScriptSize() {
        return $84cbf0bfa26f35a1$exports.Redeem.expectedSize(this.output.script.isBounty(), this.output.script.scriptVersion == 2, this.key.compressed);
    }
    createRedeemTransaction(solution, receiveAddress, sats_per_byte, op_return = [
        "boostpow",
        "proof"
    ]) {
        // step 1. create incomplete transaction.
        let tx = {
            version: 1,
            inputs: [
                {
                    prevTxId: this.output.txid.buffer,
                    outputIndex: this.output.vout,
                    scriptSize: this.expectedRedeemScriptSize()
                }
            ],
            outputs: [
                {
                    satoshis: 0,
                    script: $5St76.Script(new $5St76.Address(receiveAddress)).toBuffer()
                },
                {
                    satoshis: 0,
                    script: $5St76.Script.buildSafeDataOut(op_return).toBuffer()
                }
            ]
        };
        // steps 2 - 3: get fee
        let fee = Math.ceil($5e9668fed80c706e$exports.estimateTransactionSize(tx) * sats_per_byte);
        if (fee > this.output.value) throw "not enough sats to be worth it";
        tx.outputs[0].satoshis = this.output.value - fee;
        // steps 4 - 6
        return $5e9668fed80c706e$exports.writeTransaction({
            version: 1,
            inputs: [
                {
                    prevTxId: this.output.txid.buffer,
                    outputIndex: this.output.vout,
                    script: this.redeem(solution, tx, 0).toBuffer()
                }
            ],
            outputs: tx.outputs
        });
    }
}
$0ab2e73aadb4892c$exports.Puzzle = $0ab2e73aadb4892c$var$Puzzle;


class $2bc0b4e409e4db7b$var$Job {
    constructor(// The hash of the content to be boosted.
    Content, // how much it is to be boosted.
    Difficulty, // corresponds to the version field in a bitcoin block header.
    // when we use ASICBoost, only half these bytes are avalable
    // to be whatever the user wants.
    Category, // Up to 20 bytes. One tag per boost.
    Tag, // Hold whatever other information you want here.
    AdditionalData, // used to ensure no two boosts have the same script unless
    // the user wants it.
    UserNonce, // whether we are using version 1 of the script or version 2,
    // which enables ASICBoost.
    useGeneralPurposeBits, // the address of the miner will completed this boost.
    // used to ensure that other miners cannot steal the miner's nonce
    // for themselves.
    //
    // Optional because boost bounty adds it in the redeem script instead
    // of the locking script. If it is present, then his is a boost
    // contract script.
    MinerPubKeyHash, // Optional tx information attached or not
    Txid, Vout, Value){
        this.Content = Content;
        this.Difficulty = Difficulty;
        this.Category = Category;
        this.Tag = Tag;
        this.AdditionalData = AdditionalData;
        this.UserNonce = UserNonce;
        this.useGeneralPurposeBits = useGeneralPurposeBits;
        this.MinerPubKeyHash = MinerPubKeyHash;
        this.Txid = Txid;
        this.Vout = Vout;
        this.Value = Value;
    }
    get category() {
        return this.Category;
    }
    get content() {
        return this.Content;
    }
    get tag() {
        return this.Tag;
    }
    get additionalData() {
        return this.AdditionalData;
    }
    get userNonce() {
        return this.UserNonce;
    }
    get difficulty() {
        return this.Difficulty;
    }
    get bits() {
        return $7HMvJ.UInt32Little.fromNumber($3KCZ8.Utils.difficulty2bits(this.difficulty));
    }
    get minerPubKeyHash() {
        return this.MinerPubKeyHash;
    }
    get id() {
        return this.scriptHash;
    }
    get scriptVersion() {
        if (this.useGeneralPurposeBits) return 2;
        return 1;
    }
    get useASICBoost() {
        return this.scriptVersion > 1;
    }
    isContract() {
        return !!this.MinerPubKeyHash;
    }
    isBounty() {
        return !this.MinerPubKeyHash;
    }
    // the 16 bits of category that can be set by the user.
    get magicNumber() {
        return $kmTqg.UInt16Little.fromNumber($3KCZ8.Utils.magicNumber(this.category.number));
    }
    static fromObject(params) {
        if (params.content && params.content.length > 64) throw new Error("content too large. Max 32 bytes.");
        if (params.diff <= 0 || isNaN(params.diff) || typeof params.diff !== "number") throw new Error("diff must be a positive number.");
        let category;
        if (params.category) {
            if (params.category.length > 8) throw new Error("category too large. Max 4 bytes.");
            category = new $c5i4c.Int32Little($3KCZ8.Utils.createBufferAndPad(params.category, 4, false));
        } else category = $c5i4c.Int32Little.fromNumber(0);
        if (params.tag && params.tag.length > 40) throw new Error("tag too large. Max 20 bytes.");
        if (params.userNonce && params.userNonce.length > 8) throw new Error("userNonce too large. Max 4 bytes.");
        let userNonce;
        if (!params.userNonce) {
            let getRandomInt = (max)=>{
                return Math.floor(Math.random() * max);
            };
            let tempBuffer = $2bc0b4e409e4db7b$require$Buffer.from([
                getRandomInt(0xff),
                getRandomInt(0xff),
                getRandomInt(0xff),
                getRandomInt(0xff)
            ]);
            userNonce = tempBuffer.toString("hex");
        } else userNonce = params.userNonce;
        let minerPubKeyHash;
        if (params.minerPubKeyHash) {
            if (params.minerPubKeyHash.length > 40) throw new Error("minerPubKeyHash too large. Max 4 bytes.");
            minerPubKeyHash = new $7fdzx.Bytes($2bc0b4e409e4db7b$require$Buffer.from(params.minerPubKeyHash, "hex"));
        }
        return new $2bc0b4e409e4db7b$var$Job(new $iYsCg.Digest32($3KCZ8.Utils.createBufferAndPad(params.content, 32)), params.diff, category, new $7fdzx.Bytes(params.tag ? $2bc0b4e409e4db7b$require$Buffer.from(params.tag, "hex") : $2bc0b4e409e4db7b$require$Buffer.alloc(0)), new $7fdzx.Bytes(params.additionalData ? $2bc0b4e409e4db7b$require$Buffer.from(params.additionalData, "hex") : $2bc0b4e409e4db7b$require$Buffer.alloc(0)), new $7HMvJ.UInt32Little($3KCZ8.Utils.createBufferAndPad(userNonce, 4, false)), params.useGeneralPurposeBits ? params.useGeneralPurposeBits : false, minerPubKeyHash);
    }
    toObject() {
        if (this.minerPubKeyHash) return {
            content: this.content.hex,
            diff: this.difficulty,
            category: this.category.hex,
            tag: this.tag.hex,
            additionalData: this.additionalData.hex,
            userNonce: this.userNonce.hex,
            minerPubKeyHash: this.minerPubKeyHash.hex,
            useGeneralPurposeBits: this.useGeneralPurposeBits
        };
        else return {
            content: this.content.hex,
            diff: this.difficulty,
            category: this.category.hex,
            tag: this.tag.hex,
            additionalData: this.additionalData.hex,
            userNonce: this.userNonce.hex,
            useGeneralPurposeBits: this.useGeneralPurposeBits
        };
    }
    toHex() {
        return this.toScript().toHex();
    }
    toBuffer() {
        return this.toScript().toBuffer();
    }
    toOpCode(num) {
        if (num.length == 1) {
            if (num[0] >= 1 && num[0] <= 16) return $5St76.Opcode.OP_1 + (num[0] - 1);
            if (num[0] == 0x81) return $5St76.Opcode.OP_1NEGATE;
        }
        return num;
    }
    toScript() {
        let buildOut = $5St76.Script();
        buildOut.add(this.toOpCode($2bc0b4e409e4db7b$require$Buffer.from("boostpow", "utf8")));
        buildOut.add($5St76.Opcode.OP_DROP);
        if (this.minerPubKeyHash) buildOut.add(this.toOpCode(this.minerPubKeyHash.buffer));
        buildOut.add(this.toOpCode(this.category.buffer));
        buildOut.add(this.toOpCode(this.content.buffer));
        buildOut.add(this.toOpCode(this.bits.buffer));
        buildOut.add(this.toOpCode(this.tag.buffer));
        buildOut.add(this.toOpCode(this.userNonce.buffer));
        buildOut.add(this.toOpCode(this.additionalData.buffer));
        // Add the rest of the script
        for (const op of $2bc0b4e409e4db7b$var$Job.scriptOperations(this.useGeneralPurposeBits))buildOut.add(op);
        // Return script
        return buildOut;
    }
    static remainingOperationsMatchExactly(remainingChunks, start, expectedOps) {
        let i = 0;
        if (remainingChunks.length - start !== expectedOps.length) return false;
        while(i < remainingChunks.length - start){
            if (// If it's a buffer, then ensure the value matches expect length
            remainingChunks[start + i].buf && remainingChunks[start + i].len === expectedOps[i].length || remainingChunks[start + i].buf === undefined && expectedOps[i] === remainingChunks[start + i].opcodenum) i++;
            else return false;
        }
        return true;
    }
    static readScript(script, txid, vout, value) {
        let category;
        let content;
        let diff;
        let tag;
        let additionalData;
        let userNonce;
        let minerPubKeyHash;
        let useGeneralPurposeBits;
        if (!(script.chunks[0].buf.toString("utf8") === "boostpow" && // Drop the identifier
        script.chunks[1].opcodenum === $5St76.Opcode.OP_DROP)) throw new Error('Invalid: no "boostpow" flag');
        let is_bounty;
        if (// Category
        script.chunks[2].buf && script.chunks[2].opcodenum === 4) is_bounty = true;
        else if (// minerPubKeyHash
        script.chunks[2].buf && script.chunks[2].opcodenum === 20) is_bounty = false;
        else throw new Error("Invalid: could not detect bounty or contract pattern");
        if (is_bounty) {
            if (// Content
            script.chunks[3].buf && script.chunks[3].len === 32 && // Target
            script.chunks[4].buf && script.chunks[4].len === 4 && (// Tag
            script.chunks[5].buf && script.chunks[5].len <= 20 || script.chunks[5].opcodenum == $5St76.Opcode.OP_0 || script.chunks[5].opcodenum == $5St76.Opcode.OP_1NEGATE || script.chunks[5].opcodenum >= $5St76.Opcode.OP_1 && script.chunks[5].opcodenum <= $5St76.Opcode.OP_16) && // User Nonce
            script.chunks[6].buf && script.chunks[6].len === 4 && // Additional Data
            (script.chunks[7].buf || script.chunks[7].opcodenum == $5St76.Opcode.OP_0 || script.chunks[7].opcodenum == $5St76.Opcode.OP_1NEGATE || script.chunks[7].opcodenum >= $5St76.Opcode.OP_1 && script.chunks[7].opcodenum <= $5St76.Opcode.OP_16)) {
                if ($2bc0b4e409e4db7b$var$Job.remainingOperationsMatchExactly(script.chunks, 8, $2bc0b4e409e4db7b$var$Job.scriptOperationsV1NoASICBoost())) useGeneralPurposeBits = false;
                else if ($2bc0b4e409e4db7b$var$Job.remainingOperationsMatchExactly(script.chunks, 8, $2bc0b4e409e4db7b$var$Job.scriptOperationsV2ASICBoost())) useGeneralPurposeBits = true;
                else throw new Error("Invalid script program");
                category = new $c5i4c.Int32Little($3KCZ8.Utils.fromOpCode(script.chunks[2]));
                content = new $iYsCg.Digest32($3KCZ8.Utils.fromOpCode(script.chunks[3]));
                let targetHex = ($3KCZ8.Utils.fromOpCode(script.chunks[4]).toString("hex").match(/../g) || []).reverse().join("");
                let targetInt = parseInt(targetHex, 16);
                diff = $3KCZ8.Utils.difficulty(targetInt);
                tag = new $7fdzx.Bytes($3KCZ8.Utils.fromOpCode(script.chunks[5]));
                userNonce = new $7HMvJ.UInt32Little($3KCZ8.Utils.fromOpCode(script.chunks[6]));
                additionalData = new $7fdzx.Bytes($3KCZ8.Utils.fromOpCode(script.chunks[7]));
            } else throw new Error("Not valid Boost Output");
        } else {
            if (// Category
            script.chunks[3].buf && script.chunks[3].opcodenum === 4 && // Content
            script.chunks[4].buf && script.chunks[4].len === 32 && // Target
            script.chunks[5].buf && script.chunks[5].len === 4 && (// Tag
            script.chunks[6].buf && script.chunks[6].len <= 20 || script.chunks[6].opcodenum == $5St76.Opcode.OP_0 || script.chunks[6].opcodenum == $5St76.Opcode.OP_1NEGATE || script.chunks[6].opcodenum >= $5St76.Opcode.OP_1 && script.chunks[6].opcodenum <= $5St76.Opcode.OP_16) && // User Nonce
            script.chunks[7].buf && script.chunks[7].len === 4 && // Additional Data
            (script.chunks[8].buf || script.chunks[8].opcodenum == $5St76.Opcode.OP_0 || script.chunks[8].opcodenum == $5St76.Opcode.OP_1NEGATE || script.chunks[8].opcodenum >= $5St76.Opcode.OP_1 && script.chunks[8].opcodenum <= $5St76.Opcode.OP_16)) {
                if ($2bc0b4e409e4db7b$var$Job.remainingOperationsMatchExactly(script.chunks, 9, $2bc0b4e409e4db7b$var$Job.scriptOperationsV1NoASICBoost())) useGeneralPurposeBits = false;
                else if ($2bc0b4e409e4db7b$var$Job.remainingOperationsMatchExactly(script.chunks, 9, $2bc0b4e409e4db7b$var$Job.scriptOperationsV2ASICBoost())) useGeneralPurposeBits = true;
                else throw new Error("Not valid Boost Output");
                minerPubKeyHash = new $7fdzx.Bytes($3KCZ8.Utils.fromOpCode(script.chunks[2]));
                category = new $c5i4c.Int32Little($3KCZ8.Utils.fromOpCode(script.chunks[3]));
                content = new $iYsCg.Digest32($3KCZ8.Utils.fromOpCode(script.chunks[4]));
                let targetHex1 = ($3KCZ8.Utils.fromOpCode(script.chunks[5]).toString("hex").match(/../g) || []).reverse().join("");
                let targetInt1 = parseInt(targetHex1, 16);
                diff = $3KCZ8.Utils.difficulty(targetInt1);
                tag = new $7fdzx.Bytes($3KCZ8.Utils.fromOpCode(script.chunks[6]));
                userNonce = new $7HMvJ.UInt32Little($3KCZ8.Utils.fromOpCode(script.chunks[7]));
                additionalData = new $7fdzx.Bytes($3KCZ8.Utils.fromOpCode(script.chunks[8]));
            } else throw new Error("Invalid boost format");
        }
        return new $2bc0b4e409e4db7b$var$Job(content, diff, category, tag, additionalData, userNonce, useGeneralPurposeBits, minerPubKeyHash, txid, vout, value);
    }
    static fromHex(asm, txid, vout, value) {
        return $2bc0b4e409e4db7b$var$Job.readScript(new $5St76.Script(asm), txid, vout, value);
    }
    static fromASM(asm, txid, vout, value) {
        return $2bc0b4e409e4db7b$var$Job.readScript(new $5St76.Script.fromASM(asm), txid, vout, value);
    }
    static fromBuffer(b, txid, vout, value) {
        return $2bc0b4e409e4db7b$var$Job.readScript(new $5St76.Script.fromBuffer(b), txid, vout, value);
    }
    toASM() {
        const makeHex = this.toHex();
        const makeAsm = new $5St76.Script(makeHex);
        return makeAsm.toASM();
    }
    static fromASM4(str, txid, vout, value) {
        return $2bc0b4e409e4db7b$var$Job.fromHex(str, txid, vout, value);
    }
    static fromASM2(str, txid, vout, value) {
        return $2bc0b4e409e4db7b$var$Job.fromHex(str, txid, vout, value);
    }
    toString() {
        const makeHex = this.toHex();
        const makeAsm = new $5St76.Script(makeHex);
        return makeAsm.toString();
    }
    static fromString(str, txid, vout, value) {
        return $2bc0b4e409e4db7b$var$Job.fromHex(str, txid, vout, value);
    }
    // Optional attached information if available
    get txOutpoint() {
        return {
            txid: this.txid,
            vout: this.vout,
            value: this.value
        };
    }
    // Optional attached information if available
    get txid() {
        return this.Txid;
    }
    // Optional attached information if available
    get vout() {
        return this.Vout;
    }
    // Optional attached information if available
    get value() {
        return this.Value;
    }
    get scriptHash() {
        const hex = this.toHex();
        const buffer = $2bc0b4e409e4db7b$require$Buffer.from(hex, "hex");
        return $5St76.crypto.Hash.sha256(buffer).reverse().toString("hex");
    }
    static fromTransaction(t, vout = 0) {
        if (!t) return undefined;
        let tx = new $5St76.Transaction(t);
        if (vout > tx.outputs.length - 1 || vout < 0 || vout === undefined || vout === null) return undefined;
        if (tx.outputs[vout].script && tx.outputs[vout].script.chunks[0].buf && tx.outputs[vout].script.chunks[0].buf.toString("hex") === $2bc0b4e409e4db7b$require$Buffer.from("boostpow", "utf8").toString("hex")) return $2bc0b4e409e4db7b$var$Job.readScript(tx.outputs[vout].script, tx.hash, vout, tx.outputs[vout].satoshis);
        return undefined;
    }
    static fromTransactionGetAllOutputs(tx) {
        if (!tx) return [];
        const boostJobs = [];
        let o = 0;
        for (const out of tx.outputs){
            if (out.script && out.script.chunks[0].buf && out.script.chunks[0].buf.toString("hex") === $2bc0b4e409e4db7b$require$Buffer.from("boostpow", "utf8").toString("hex")) boostJobs.push($2bc0b4e409e4db7b$var$Job.readScript(out.script, tx.hash, o, out.satoshis));
            o++;
        }
        return boostJobs;
    }
    static fromRawTransaction(rawtx, vout = 0) {
        if (isNaN(vout)) return undefined;
        const tx = new $5St76.Transaction(rawtx);
        return $2bc0b4e409e4db7b$var$Job.fromTransaction(tx, vout);
    }
    /**
     * Create a transaction fragment that can be modified to redeem the boost job
     *
     * @param boostPowJob Boost Job to redeem
     * @param boostPowJobProof Boost job proof to use to redeem
     * @param privateKey The private key string of the minerPubKeyHash
     */ static createRedeemTransaction(boostPowJob, boostPowJobProof, privateKeyStr, receiveAddressStr, sats_per_byte = .5) {
        const boostPowString = $2bc0b4e409e4db7b$var$Job.tryValidateJobProof(boostPowJob, boostPowJobProof);
        if (!boostPowString) throw new Error("createRedeemTransaction: Invalid Job Proof");
        if (boostPowJob.value === undefined) throw new Error("createRedeemTransaction: job requires satoshi value");
        if (boostPowJob.txid === undefined) throw new Error("createRedeemTransaction: job requires txid");
        if (boostPowJob.vout === undefined) throw new Error("createRedeemTransaction: job requires vout");
        return new $5St76.Transaction(new $0ab2e73aadb4892c$exports.Puzzle(new $97c32fe2d2793926$exports.Output(boostPowJob), privateKeyStr).createRedeemTransaction(boostPowJobProof.solution, receiveAddressStr, sats_per_byte));
    }
    static puzzle(boostPowJob, address) {
        let minerPubKeyHash;
        if (boostPowJob.isBounty() && address !== undefined) minerPubKeyHash = address;
        else if (boostPowJob.isContract() && address === undefined) minerPubKeyHash = boostPowJob.minerPubKeyHash;
        else throw "invalid";
        let meta_begin = new $7fdzx.Bytes($2bc0b4e409e4db7b$require$Buffer.concat([
            boostPowJob.tag.buffer,
            minerPubKeyHash.buffer
        ]));
        let meta_end = new $7fdzx.Bytes($2bc0b4e409e4db7b$require$Buffer.concat([
            boostPowJob.userNonce.buffer,
            boostPowJob.additionalData.buffer
        ]));
        return boostPowJob.useGeneralPurposeBits ? new $8bhzx.Puzzle(boostPowJob.category, boostPowJob.content, new $1cf58cdc35e3ee2d$exports.Difficulty(boostPowJob.difficulty), meta_begin, meta_end, $c5i4c.Int32Little.fromNumber($3KCZ8.Utils.generalPurposeBitsMask())) : new $8bhzx.Puzzle(boostPowJob.category, boostPowJob.content, new $1cf58cdc35e3ee2d$exports.Difficulty(boostPowJob.difficulty), meta_begin, meta_end);
    }
    static createBoostPowMetadata(boostPowJob, boostPowJobProof) {
        let minerPubKeyHash;
        if (boostPowJobProof.minerPubKeyHash) minerPubKeyHash = boostPowJobProof.minerPubKeyHash;
        else if (boostPowJob.minerPubKeyHash) minerPubKeyHash = boostPowJob.minerPubKeyHash;
        else throw "invalid proof";
        return $9590091d29a867b1$exports.Metadata.fromBuffer({
            tag: boostPowJob.tag.buffer,
            minerPubKeyHash: minerPubKeyHash.buffer,
            extraNonce1: boostPowJobProof.extraNonce1.buffer,
            extraNonce2: boostPowJobProof.extraNonce2.buffer,
            userNonce: boostPowJob.userNonce.buffer,
            additionalData: boostPowJob.additionalData.buffer
        });
    }
    static proof(boostPowJob, boostPowJobProof) {
        const meta = $2bc0b4e409e4db7b$var$Job.createBoostPowMetadata(boostPowJob, boostPowJobProof);
        let meta_begin = new $7fdzx.Bytes($2bc0b4e409e4db7b$require$Buffer.concat([
            meta.tag.buffer,
            meta.minerPubKeyHash.buffer
        ]));
        let meta_end = new $7fdzx.Bytes($2bc0b4e409e4db7b$require$Buffer.concat([
            meta.userNonce.buffer,
            meta.additionalData.buffer
        ]));
        let z;
        if (boostPowJob.useGeneralPurposeBits) z = new $8bhzx.Puzzle(boostPowJob.category, boostPowJob.content, new $1cf58cdc35e3ee2d$exports.Difficulty(boostPowJob.difficulty), meta_begin, meta_end, $c5i4c.Int32Little.fromNumber($3KCZ8.Utils.generalPurposeBitsMask()));
        else z = new $8bhzx.Puzzle(boostPowJob.category, boostPowJob.content, new $1cf58cdc35e3ee2d$exports.Difficulty(boostPowJob.difficulty), meta_begin, meta_end);
        return new $8bhzx.Proof(z, boostPowJobProof.solution);
    }
    static tryValidateJobProof(boostPowJob, boostPowJobProof) {
        let x = this.proof(boostPowJob, boostPowJobProof).string();
        if (!(x && x.valid())) return null;
        return {
            boostPowString: x,
            boostPowMetadata: $2bc0b4e409e4db7b$var$Job.createBoostPowMetadata(boostPowJob, boostPowJobProof)
        };
    }
    static loopOperation(loopIterations, generateFragmentInvoker) {
        let concatOps = [];
        for(let i = 0; i < loopIterations; i++)concatOps = concatOps.concat(generateFragmentInvoker());
        return concatOps;
    }
    static scriptOperations(useGeneralPurposeBits) {
        if (useGeneralPurposeBits) return this.scriptOperationsV2ASICBoost();
        return this.scriptOperationsV1NoASICBoost();
    }
    static scriptOperationsV1NoASICBoost() {
        return [
            // CAT SWAP
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            // {5} ROLL DUP TOALTSTACK CAT                // copy mining pool’s pubkey hash to alt stack. A copy remains on the stack.
            $5St76.Opcode.OP_5,
            $5St76.Opcode.OP_ROLL,
            $5St76.Opcode.OP_DUP,
            $5St76.Opcode.OP_TOALTSTACK,
            $5St76.Opcode.OP_CAT,
            // {2} PICK TOALTSTACK                         // copy target and push to altstack.
            $5St76.Opcode.OP_2,
            $5St76.Opcode.OP_PICK,
            $5St76.Opcode.OP_TOALTSTACK,
            // {5} ROLL SIZE {4} EQUALVERIFY CAT          // check size of extra_nonce_1
            $5St76.Opcode.OP_5,
            $5St76.Opcode.OP_ROLL,
            $5St76.Opcode.OP_SIZE,
            $5St76.Opcode.OP_4,
            $5St76.Opcode.OP_EQUALVERIFY,
            $5St76.Opcode.OP_CAT,
            // {5} ROLL SIZE {8} EQUALVERIFY CAT          // check size of extra_nonce_2
            $5St76.Opcode.OP_5,
            $5St76.Opcode.OP_ROLL,
            $5St76.Opcode.OP_SIZE,
            $5St76.Opcode.OP_8,
            $5St76.Opcode.OP_EQUALVERIFY,
            $5St76.Opcode.OP_CAT,
            // SWAP CAT HASH256                           // create metadata string and hash it.
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_HASH256,
            // SWAP TOALTSTACK CAT CAT                    // target to altstack.
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_TOALTSTACK,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_CAT,
            // SWAP SIZE {4} EQUALVERIFY CAT              // check size of timestamp.
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_SIZE,
            $5St76.Opcode.OP_4,
            $5St76.Opcode.OP_EQUALVERIFY,
            $5St76.Opcode.OP_CAT,
            // FROMALTSTACK CAT                           // attach target
            $5St76.Opcode.OP_FROMALTSTACK,
            $5St76.Opcode.OP_CAT,
            // SWAP SIZE {4} EQUALVERIFY CAT             // check size of nonce. Boost POW string is constructed.
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_SIZE,
            $5St76.Opcode.OP_4,
            $5St76.Opcode.OP_EQUALVERIFY,
            $5St76.Opcode.OP_CAT,
            // Take hash of work string and ensure that it is positive and minimally encoded.
            $5St76.Opcode.OP_HASH256,
            ...$2bc0b4e409e4db7b$var$Job.ensure_positive(),
            $5St76.Opcode.OP_FROMALTSTACK,
            ...$2bc0b4e409e4db7b$var$Job.expand_target(),
            ...$2bc0b4e409e4db7b$var$Job.ensure_positive(),
            // check that the hash of the Boost POW string is less than the target
            $5St76.Opcode.OP_LESSTHAN,
            $5St76.Opcode.OP_VERIFY,
            // check that the given address matches the pubkey and check signature.
            // DUP HASH160 FROMALTSTACK EQUALVERIFY CHECKSIG
            $5St76.Opcode.OP_DUP,
            $5St76.Opcode.OP_HASH160,
            $5St76.Opcode.OP_FROMALTSTACK,
            $5St76.Opcode.OP_EQUALVERIFY,
            $5St76.Opcode.OP_CHECKSIG
        ];
    }
    static scriptOperationsV2ASICBoost() {
        return [
            // CAT SWAP
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            // {5} ROLL DUP TOALTSTACK CAT                // copy mining pool’s pubkey hash to alt stack. A copy remains on the stack.
            $5St76.Opcode.OP_5,
            $5St76.Opcode.OP_ROLL,
            $5St76.Opcode.OP_DUP,
            $5St76.Opcode.OP_TOALTSTACK,
            $5St76.Opcode.OP_CAT,
            // {2} PICK TOALTSTACK                         // copy target and push to altstack.
            $5St76.Opcode.OP_2,
            $5St76.Opcode.OP_PICK,
            $5St76.Opcode.OP_TOALTSTACK,
            // {6} ROLL SIZE {4} EQUALVERIFY CAT          // check size of extra_nonce_1
            $5St76.Opcode.OP_6,
            $5St76.Opcode.OP_ROLL,
            $5St76.Opcode.OP_SIZE,
            $5St76.Opcode.OP_4,
            $5St76.Opcode.OP_EQUALVERIFY,
            $5St76.Opcode.OP_CAT,
            // {6} ROLL SIZE {8} EQUALVERIFY CAT          // check size of extra_nonce_2
            $5St76.Opcode.OP_6,
            $5St76.Opcode.OP_ROLL,
            $5St76.Opcode.OP_SIZE,
            $2bc0b4e409e4db7b$require$Buffer.from("0120", "hex"),
            $5St76.Opcode.OP_GREATERTHANOREQUAL,
            $5St76.Opcode.OP_VERIFY,
            $5St76.Opcode.OP_CAT,
            // SWAP CAT HASH256                           // create metadata string and hash it.
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_HASH256,
            // SWAP TOALTSTACK CAT CAT                    // target and content + merkleroot to altstack.
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_TOALTSTACK,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_TOALTSTACK,
            $2bc0b4e409e4db7b$require$Buffer.from("ff1f00e0", "hex"),
            $5St76.Opcode.OP_DUP,
            $5St76.Opcode.OP_INVERT,
            $5St76.Opcode.OP_TOALTSTACK,
            $5St76.Opcode.OP_AND,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_FROMALTSTACK,
            $5St76.Opcode.OP_AND,
            $5St76.Opcode.OP_OR,
            $5St76.Opcode.OP_FROMALTSTACK,
            $5St76.Opcode.OP_CAT,
            // SWAP SIZE {4} EQUALVERIFY CAT              // check size of timestamp.
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_SIZE,
            $5St76.Opcode.OP_4,
            $5St76.Opcode.OP_EQUALVERIFY,
            $5St76.Opcode.OP_CAT,
            // FROMALTSTACK CAT                           // attach target
            $5St76.Opcode.OP_FROMALTSTACK,
            $5St76.Opcode.OP_CAT,
            // SWAP SIZE {4} EQUALVERIFY CAT             // check size of nonce. Boost POW string is constructed.
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_SIZE,
            $5St76.Opcode.OP_4,
            $5St76.Opcode.OP_EQUALVERIFY,
            $5St76.Opcode.OP_CAT,
            // Take hash of work string and ensure that it is positive and minimally encoded.
            $5St76.Opcode.OP_HASH256,
            ...$2bc0b4e409e4db7b$var$Job.ensure_positive(),
            $5St76.Opcode.OP_FROMALTSTACK,
            ...$2bc0b4e409e4db7b$var$Job.expand_target(),
            ...$2bc0b4e409e4db7b$var$Job.ensure_positive(),
            // check that the hash of the Boost POW string is less than the target
            $5St76.Opcode.OP_LESSTHAN,
            $5St76.Opcode.OP_VERIFY,
            // check that the given address matches the pubkey and check signature.
            // DUP HASH160 FROMALTSTACK EQUALVERIFY CHECKSIG
            $5St76.Opcode.OP_DUP,
            $5St76.Opcode.OP_HASH160,
            $5St76.Opcode.OP_FROMALTSTACK,
            $5St76.Opcode.OP_EQUALVERIFY,
            $5St76.Opcode.OP_CHECKSIG
        ];
    }
    /*
    expand_target - transforms the uint32 exponential (compact) format for the difficulty target into the full uint256 value.
    */ static expand_target() {
        return [
            $5St76.Opcode.OP_SIZE,
            $5St76.Opcode.OP_4,
            $5St76.Opcode.OP_EQUALVERIFY,
            $5St76.Opcode.OP_3,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_DUP,
            $5St76.Opcode.OP_BIN2NUM,
            $5St76.Opcode.OP_3,
            $2bc0b4e409e4db7b$require$Buffer.from("21", "hex"),
            $5St76.Opcode.OP_WITHIN,
            $5St76.Opcode.OP_VERIFY,
            $5St76.Opcode.OP_TOALTSTACK,
            $5St76.Opcode.OP_DUP,
            $5St76.Opcode.OP_BIN2NUM,
            $5St76.Opcode.OP_0,
            $5St76.Opcode.OP_GREATERTHAN,
            $5St76.Opcode.OP_VERIFY,
            $2bc0b4e409e4db7b$require$Buffer.from("0000000000000000000000000000000000000000000000000000000000", "hex"),
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_FROMALTSTACK,
            $5St76.Opcode.OP_3,
            $5St76.Opcode.OP_SUB,
            $5St76.Opcode.OP_8,
            $5St76.Opcode.OP_MUL,
            $5St76.Opcode.OP_RSHIFT
        ];
    }
    /*
    Numbers in Bitcoin script are in little endian and the last bit is a sign bit.
    However, the target and the hash digest are both supposed to be positive
    numbers. Thus, we have to attach an extra byte of zeros to numbers if they
    would be treated as negative in Bitcoin script.
    */ static ensure_positive() {
        return [
            $2bc0b4e409e4db7b$require$Buffer.from("00", "hex"),
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_BIN2NUM
        ];
    }
    // reverse endianness. Cuz why not?
    static reverse32() {
        return [
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_1,
            $5St76.Opcode.OP_SPLIT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT,
            $5St76.Opcode.OP_SWAP,
            $5St76.Opcode.OP_CAT
        ];
    }
}
$2bc0b4e409e4db7b$exports.Job = $2bc0b4e409e4db7b$var$Job;


Object.defineProperty($690c1e68ac12266a$exports, "Job", {
    enumerable: true,
    get: function() {
        return $2bc0b4e409e4db7b$exports.Job;
    }
});
Object.defineProperty($690c1e68ac12266a$exports, "BoostPowJob", {
    enumerable: true,
    get: function() {
        return $2bc0b4e409e4db7b$exports.Job;
    }
});

Object.defineProperty($690c1e68ac12266a$exports, "Redeem", {
    enumerable: true,
    get: function() {
        return $84cbf0bfa26f35a1$exports.Redeem;
    }
});
Object.defineProperty($690c1e68ac12266a$exports, "BoostPowJobProof", {
    enumerable: true,
    get: function() {
        return $84cbf0bfa26f35a1$exports.Redeem;
    }
});

Object.defineProperty($690c1e68ac12266a$exports, "Metadata", {
    enumerable: true,
    get: function() {
        return $9590091d29a867b1$exports.Metadata;
    }
});
Object.defineProperty($690c1e68ac12266a$exports, "BoostPowMetadata", {
    enumerable: true,
    get: function() {
        return $9590091d29a867b1$exports.Metadata;
    }
});

var $3KCZ8 = parcelRequire("3KCZ8");
Object.defineProperty($690c1e68ac12266a$exports, "Utils", {
    enumerable: true,
    get: function() {
        return $3KCZ8.Utils;
    }
});
Object.defineProperty($690c1e68ac12266a$exports, "BoostUtilsHelper", {
    enumerable: true,
    get: function() {
        return $3KCZ8.Utils;
    }
});

var $7fdzx = parcelRequire("7fdzx");
Object.defineProperty($690c1e68ac12266a$exports, "Bytes", {
    enumerable: true,
    get: function() {
        return $7fdzx.Bytes;
    }
});

Object.defineProperty($690c1e68ac12266a$exports, "Difficulty", {
    enumerable: true,
    get: function() {
        return $1cf58cdc35e3ee2d$exports.Difficulty;
    }
});

Object.defineProperty($690c1e68ac12266a$exports, "Digest20", {
    enumerable: true,
    get: function() {
        return $6fb0416f7363d29e$exports.Digest20;
    }
});

var $iYsCg = parcelRequire("iYsCg");
Object.defineProperty($690c1e68ac12266a$exports, "Digest32", {
    enumerable: true,
    get: function() {
        return $iYsCg.Digest32;
    }
});

var $c5i4c = parcelRequire("c5i4c");
Object.defineProperty($690c1e68ac12266a$exports, "Int32Little", {
    enumerable: true,
    get: function() {
        return $c5i4c.Int32Little;
    }
});

var $kmTqg = parcelRequire("kmTqg");
Object.defineProperty($690c1e68ac12266a$exports, "UInt16Little", {
    enumerable: true,
    get: function() {
        return $kmTqg.UInt16Little;
    }
});

var $7HMvJ = parcelRequire("7HMvJ");
Object.defineProperty($690c1e68ac12266a$exports, "UInt32Little", {
    enumerable: true,
    get: function() {
        return $7HMvJ.UInt32Little;
    }
});

var $3hHgz = parcelRequire("3hHgz");
Object.defineProperty($690c1e68ac12266a$exports, "UInt32Big", {
    enumerable: true,
    get: function() {
        return $3hHgz.UInt32Big;
    }
});

Object.defineProperty($690c1e68ac12266a$exports, "UInt64Big", {
    enumerable: true,
    get: function() {
        return $fbef638501d7a8dd$exports.UInt64Big;
    }
});

$690c1e68ac12266a$exports.work = (parcelRequire("8bhzx"));

$690c1e68ac12266a$exports.bsv = (parcelRequire("5St76"));

Object.defineProperty($690c1e68ac12266a$exports, "Output", {
    enumerable: true,
    get: function() {
        return $97c32fe2d2793926$exports.Output;
    }
});

Object.defineProperty($690c1e68ac12266a$exports, "Puzzle", {
    enumerable: true,
    get: function() {
        return $0ab2e73aadb4892c$exports.Puzzle;
    }
});

var $57aEL = parcelRequire("57aEL");
Object.defineProperty($690c1e68ac12266a$exports, "BoostPowString", {
    enumerable: true,
    get: function() {
        return $57aEL.BoostPowString;
    }
});



const $fe9ce3718327b356$var$protocolIdentifier = "boostpow";
const $fe9ce3718327b356$export$a52badcaecf73796 = (cell)=>{
    // protocol identifier always in first pushdata
    return cell[0].s === $fe9ce3718327b356$var$protocolIdentifier;
};
const $fe9ce3718327b356$var$handler = ({ dataObj: dataObj , cell: cell , out: out , tx: tx  })=>{
    if (!tx || !cell[0] || !out) throw new Error(`Invalid BOOST tx. dataObj, cell, out and tx are required.`);
    // build ASM from either op codes and script chunks
    const asm = cell.map((c)=>c.ops ? c.ops : c.h || "").join(" ");
    if (asm) {
        const boostJob = (0, $690c1e68ac12266a$exports.BoostPowJob).fromASM(asm, tx.tx.h, out.i, out.e.v).toObject();
        (0, $279a86245ff8c81d$export$23dbc584560299c3)(dataObj, "BOOST", boostJob);
    }
};
const $fe9ce3718327b356$export$13c3c8ee12090ebc = {
    name: "BOOST",
    handler: $fe9ce3718327b356$var$handler,
    address: $fe9ce3718327b356$var$protocolIdentifier
};


var $0cc5414551be39c6$exports = {};

$parcel$export($0cc5414551be39c6$exports, "Decoder", () => $0cc5414551be39c6$export$f9de6ca0bc043724, (v) => $0cc5414551be39c6$export$f9de6ca0bc043724 = v);
function $704193ccc95285b2$export$78406e843f5312da(byte) {
    return "".concat(byte < 0 ? "-" : "", "0x").concat(Math.abs(byte).toString(16).padStart(2, "0"));
}


// ExtensionCodec to handle MessagePack extensions
/**
 * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.
 */ var $d38f898b336597d6$export$bcbeb236456bc779 = /** @class */ function() {
    function ExtData(type, data) {
        this.type = type;
        this.data = data;
    }
    return ExtData;
}();


// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type
var $cc782cda24f8f221$exports = {};

$parcel$export($cc782cda24f8f221$exports, "DecodeError", () => $cc782cda24f8f221$export$ef3eed12d06c0285, (v) => $cc782cda24f8f221$export$ef3eed12d06c0285 = v);
var $cc782cda24f8f221$var$__extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var $cc782cda24f8f221$export$ef3eed12d06c0285 = /** @class */ function(_super) {
    $cc782cda24f8f221$var$__extends(DecodeError, _super);
    function DecodeError(message) {
        var _this = _super.call(this, message) || this;
        // fix the prototype chain in a cross-platform way
        var proto = Object.create(DecodeError.prototype);
        Object.setPrototypeOf(_this, proto);
        Object.defineProperty(_this, "name", {
            configurable: true,
            enumerable: false,
            value: DecodeError.name
        });
        return _this;
    }
    return DecodeError;
}(Error);


// Integer Utility
var $e16ab28aaf2f0289$export$3314b2c271c86d70 = 4294967295;
function $e16ab28aaf2f0289$export$20f71c4c8b0f96c3(view, offset, value) {
    var high = value / 4294967296;
    var low = value; // high bits are truncated by DataView
    view.setUint32(offset, high);
    view.setUint32(offset + 4, low);
}
function $e16ab28aaf2f0289$export$8532a5209571c04a(view, offset, value) {
    var high = Math.floor(value / 4294967296);
    var low = value; // high bits are truncated by DataView
    view.setUint32(offset, high);
    view.setUint32(offset + 4, low);
}
function $e16ab28aaf2f0289$export$69825c7adcc820c6(view, offset) {
    var high = view.getInt32(offset);
    var low = view.getUint32(offset + 4);
    return high * 4294967296 + low;
}
function $e16ab28aaf2f0289$export$59a2dbf579ff9568(view, offset) {
    var high = view.getUint32(offset);
    var low = view.getUint32(offset + 4);
    return high * 4294967296 + low;
}


var $1ac84368d281e2c4$export$f18369fc203f4e13 = -1;
var $1ac84368d281e2c4$var$TIMESTAMP32_MAX_SEC = 4294967295; // 32-bit unsigned int
var $1ac84368d281e2c4$var$TIMESTAMP64_MAX_SEC = 17179869183; // 34-bit unsigned int
function $1ac84368d281e2c4$export$2fd05b828dd81159(_a) {
    var sec = _a.sec, nsec = _a.nsec;
    if (sec >= 0 && nsec >= 0 && sec <= $1ac84368d281e2c4$var$TIMESTAMP64_MAX_SEC) {
        // Here sec >= 0 && nsec >= 0
        if (nsec === 0 && sec <= $1ac84368d281e2c4$var$TIMESTAMP32_MAX_SEC) {
            // timestamp 32 = { sec32 (unsigned) }
            var rv = new Uint8Array(4);
            var view = new DataView(rv.buffer);
            view.setUint32(0, sec);
            return rv;
        } else {
            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }
            var secHigh = sec / 0x100000000;
            var secLow = sec & 0xffffffff;
            var rv = new Uint8Array(8);
            var view = new DataView(rv.buffer);
            // nsec30 | secHigh2
            view.setUint32(0, nsec << 2 | secHigh & 0x3);
            // secLow32
            view.setUint32(4, secLow);
            return rv;
        }
    } else {
        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }
        var rv = new Uint8Array(12);
        var view = new DataView(rv.buffer);
        view.setUint32(0, nsec);
        (0, $e16ab28aaf2f0289$export$8532a5209571c04a)(view, 4, sec);
        return rv;
    }
}
function $1ac84368d281e2c4$export$221d97b3b00b03c2(date) {
    var msec = date.getTime();
    var sec = Math.floor(msec / 1e3);
    var nsec = (msec - sec * 1e3) * 1e6;
    // Normalizes { sec, nsec } to ensure nsec is unsigned.
    var nsecInSec = Math.floor(nsec / 1e9);
    return {
        sec: sec + nsecInSec,
        nsec: nsec - nsecInSec * 1e9
    };
}
function $1ac84368d281e2c4$export$32420f352fe0fc83(object) {
    if (object instanceof Date) {
        var timeSpec = $1ac84368d281e2c4$export$221d97b3b00b03c2(object);
        return $1ac84368d281e2c4$export$2fd05b828dd81159(timeSpec);
    } else return null;
}
function $1ac84368d281e2c4$export$abfc8800a5159711(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    // data may be 32, 64, or 96 bits
    switch(data.byteLength){
        case 4:
            // timestamp 32 = { sec32 }
            var sec = view.getUint32(0);
            var nsec = 0;
            return {
                sec: sec,
                nsec: nsec
            };
        case 8:
            // timestamp 64 = { nsec30, sec34 }
            var nsec30AndSecHigh2 = view.getUint32(0);
            var secLow32 = view.getUint32(4);
            var sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;
            var nsec = nsec30AndSecHigh2 >>> 2;
            return {
                sec: sec,
                nsec: nsec
            };
        case 12:
            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }
            var sec = (0, $e16ab28aaf2f0289$export$69825c7adcc820c6)(view, 4);
            var nsec = view.getUint32(0);
            return {
                sec: sec,
                nsec: nsec
            };
        default:
            throw new (0, $cc782cda24f8f221$exports.DecodeError)("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(data.length));
    }
}
function $1ac84368d281e2c4$export$80b8ff9315e4298f(data) {
    var timeSpec = $1ac84368d281e2c4$export$abfc8800a5159711(data);
    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
}
var $1ac84368d281e2c4$export$8654479533463da1 = {
    type: $1ac84368d281e2c4$export$f18369fc203f4e13,
    encode: $1ac84368d281e2c4$export$32420f352fe0fc83,
    decode: $1ac84368d281e2c4$export$80b8ff9315e4298f
};


var $e661d09a11cfa477$export$12677a794dbd89d7 = /** @class */ function() {
    function ExtensionCodec() {
        // built-in extensions
        this.builtInEncoders = [];
        this.builtInDecoders = [];
        // custom extensions
        this.encoders = [];
        this.decoders = [];
        this.register((0, $1ac84368d281e2c4$export$8654479533463da1));
    }
    ExtensionCodec.prototype.register = function(_a) {
        var type = _a.type, encode = _a.encode, decode = _a.decode;
        if (type >= 0) {
            // custom extensions
            this.encoders[type] = encode;
            this.decoders[type] = decode;
        } else {
            // built-in extensions
            var index = 1 + type;
            this.builtInEncoders[index] = encode;
            this.builtInDecoders[index] = decode;
        }
    };
    ExtensionCodec.prototype.tryToEncode = function(object, context) {
        // built-in extensions
        for(var i = 0; i < this.builtInEncoders.length; i++){
            var encodeExt = this.builtInEncoders[i];
            if (encodeExt != null) {
                var data = encodeExt(object, context);
                if (data != null) {
                    var type = -1 - i;
                    return new (0, $d38f898b336597d6$export$bcbeb236456bc779)(type, data);
                }
            }
        }
        // custom extensions
        for(var i = 0; i < this.encoders.length; i++){
            var encodeExt = this.encoders[i];
            if (encodeExt != null) {
                var data = encodeExt(object, context);
                if (data != null) {
                    var type = i;
                    return new (0, $d38f898b336597d6$export$bcbeb236456bc779)(type, data);
                }
            }
        }
        if (object instanceof (0, $d38f898b336597d6$export$bcbeb236456bc779)) // to keep ExtData as is
        return object;
        return null;
    };
    ExtensionCodec.prototype.decode = function(data, type, context) {
        var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
        if (decodeExt) return decodeExt(data, type, context);
        else // decode() does not fail, returns ExtData instead.
        return new (0, $d38f898b336597d6$export$bcbeb236456bc779)(type, data);
    };
    ExtensionCodec.defaultCodec = new ExtensionCodec();
    return ExtensionCodec;
}();





var $38619a2e5bc8b048$var$_a, $38619a2e5bc8b048$var$_b, $38619a2e5bc8b048$var$_c;
var $38619a2e5bc8b048$var$TEXT_ENCODING_AVAILABLE = (typeof $hiCjL$process === "undefined" || (($38619a2e5bc8b048$var$_a = $hiCjL$process === null || $hiCjL$process === void 0 ? void 0 : $hiCjL$process.env) === null || $38619a2e5bc8b048$var$_a === void 0 ? void 0 : $38619a2e5bc8b048$var$_a["TEXT_ENCODING"]) !== "never") && typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined";
function $38619a2e5bc8b048$export$b61de95301265227(str) {
    var strLength = str.length;
    var byteLength = 0;
    var pos = 0;
    while(pos < strLength){
        var value = str.charCodeAt(pos++);
        if ((value & 0xffffff80) === 0) {
            // 1-byte
            byteLength++;
            continue;
        } else if ((value & 0xfffff800) === 0) // 2-bytes
        byteLength += 2;
        else {
            // handle surrogate pair
            if (value >= 0xd800 && value <= 0xdbff) // high surrogate
            {
                if (pos < strLength) {
                    var extra = str.charCodeAt(pos);
                    if ((extra & 0xfc00) === 0xdc00) {
                        ++pos;
                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
                    }
                }
            }
            if ((value & 0xffff0000) === 0) // 3-byte
            byteLength += 3;
            else // 4-byte
            byteLength += 4;
        }
    }
    return byteLength;
}
function $38619a2e5bc8b048$export$1042e4338f1ef853(str, output, outputOffset) {
    var strLength = str.length;
    var offset = outputOffset;
    var pos = 0;
    while(pos < strLength){
        var value = str.charCodeAt(pos++);
        if ((value & 0xffffff80) === 0) {
            // 1-byte
            output[offset++] = value;
            continue;
        } else if ((value & 0xfffff800) === 0) // 2-bytes
        output[offset++] = value >> 6 & 0x1f | 0xc0;
        else {
            // handle surrogate pair
            if (value >= 0xd800 && value <= 0xdbff) // high surrogate
            {
                if (pos < strLength) {
                    var extra = str.charCodeAt(pos);
                    if ((extra & 0xfc00) === 0xdc00) {
                        ++pos;
                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
                    }
                }
            }
            if ((value & 0xffff0000) === 0) {
                // 3-byte
                output[offset++] = value >> 12 & 0x0f | 0xe0;
                output[offset++] = value >> 6 & 0x3f | 0x80;
            } else {
                // 4-byte
                output[offset++] = value >> 18 & 0x07 | 0xf0;
                output[offset++] = value >> 12 & 0x3f | 0x80;
                output[offset++] = value >> 6 & 0x3f | 0x80;
            }
        }
        output[offset++] = value & 0x3f | 0x80;
    }
}
var $38619a2e5bc8b048$var$sharedTextEncoder = $38619a2e5bc8b048$var$TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;
var $38619a2e5bc8b048$export$ed34c0622b397238 = !$38619a2e5bc8b048$var$TEXT_ENCODING_AVAILABLE ? (0, $e16ab28aaf2f0289$export$3314b2c271c86d70) : typeof $hiCjL$process !== "undefined" && (($38619a2e5bc8b048$var$_b = $hiCjL$process === null || $hiCjL$process === void 0 ? void 0 : $hiCjL$process.env) === null || $38619a2e5bc8b048$var$_b === void 0 ? void 0 : $38619a2e5bc8b048$var$_b["TEXT_ENCODING"]) !== "force" ? 200 : 0;
function $38619a2e5bc8b048$var$utf8EncodeTEencode(str, output, outputOffset) {
    output.set($38619a2e5bc8b048$var$sharedTextEncoder.encode(str), outputOffset);
}
function $38619a2e5bc8b048$var$utf8EncodeTEencodeInto(str, output, outputOffset) {
    $38619a2e5bc8b048$var$sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
}
var $38619a2e5bc8b048$export$34cfdc82d430524 = ($38619a2e5bc8b048$var$sharedTextEncoder === null || $38619a2e5bc8b048$var$sharedTextEncoder === void 0 ? void 0 : $38619a2e5bc8b048$var$sharedTextEncoder.encodeInto) ? $38619a2e5bc8b048$var$utf8EncodeTEencodeInto : $38619a2e5bc8b048$var$utf8EncodeTEencode;
var $38619a2e5bc8b048$var$CHUNK_SIZE = 4096;
function $38619a2e5bc8b048$export$551117984c2adf4f(bytes, inputOffset, byteLength) {
    var offset = inputOffset;
    var end = offset + byteLength;
    var units = [];
    var result = "";
    while(offset < end){
        var byte1 = bytes[offset++];
        if ((byte1 & 0x80) === 0) // 1 byte
        units.push(byte1);
        else if ((byte1 & 0xe0) === 0xc0) {
            // 2 bytes
            var byte2 = bytes[offset++] & 0x3f;
            units.push((byte1 & 0x1f) << 6 | byte2);
        } else if ((byte1 & 0xf0) === 0xe0) {
            // 3 bytes
            var byte2 = bytes[offset++] & 0x3f;
            var byte3 = bytes[offset++] & 0x3f;
            units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);
        } else if ((byte1 & 0xf8) === 0xf0) {
            // 4 bytes
            var byte2 = bytes[offset++] & 0x3f;
            var byte3 = bytes[offset++] & 0x3f;
            var byte4 = bytes[offset++] & 0x3f;
            var unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;
            if (unit > 0xffff) {
                unit -= 0x10000;
                units.push(unit >>> 10 & 0x3ff | 0xd800);
                unit = 0xdc00 | unit & 0x3ff;
            }
            units.push(unit);
        } else units.push(byte1);
        if (units.length >= $38619a2e5bc8b048$var$CHUNK_SIZE) {
            result += String.fromCharCode.apply(String, units);
            units.length = 0;
        }
    }
    if (units.length > 0) result += String.fromCharCode.apply(String, units);
    return result;
}
var $38619a2e5bc8b048$var$sharedTextDecoder = $38619a2e5bc8b048$var$TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;
var $38619a2e5bc8b048$export$d866281c5a66d1ef = !$38619a2e5bc8b048$var$TEXT_ENCODING_AVAILABLE ? (0, $e16ab28aaf2f0289$export$3314b2c271c86d70) : typeof $hiCjL$process !== "undefined" && (($38619a2e5bc8b048$var$_c = $hiCjL$process === null || $hiCjL$process === void 0 ? void 0 : $hiCjL$process.env) === null || $38619a2e5bc8b048$var$_c === void 0 ? void 0 : $38619a2e5bc8b048$var$_c["TEXT_DECODER"]) !== "force" ? 200 : 0;
function $38619a2e5bc8b048$export$6ed79e41309992dc(bytes, inputOffset, byteLength) {
    var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
    return $38619a2e5bc8b048$var$sharedTextDecoder.decode(stringBytes);
}


function $49ca50dab122ad8b$export$f8d669c2a17882f2(buffer) {
    if (buffer instanceof Uint8Array) return buffer;
    else if (ArrayBuffer.isView(buffer)) return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    else if (buffer instanceof ArrayBuffer) return new Uint8Array(buffer);
    else // ArrayLike<number>
    return Uint8Array.from(buffer);
}
function $49ca50dab122ad8b$export$7277868462c1ba02(buffer) {
    if (buffer instanceof ArrayBuffer) return new DataView(buffer);
    var bufferView = $49ca50dab122ad8b$export$f8d669c2a17882f2(buffer);
    return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
}



var $bc349a5716e31b5c$var$DEFAULT_MAX_KEY_LENGTH = 16;
var $bc349a5716e31b5c$var$DEFAULT_MAX_LENGTH_PER_KEY = 16;
var $bc349a5716e31b5c$export$529b830450faf29c = /** @class */ function() {
    function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {
        if (maxKeyLength === void 0) maxKeyLength = $bc349a5716e31b5c$var$DEFAULT_MAX_KEY_LENGTH;
        if (maxLengthPerKey === void 0) maxLengthPerKey = $bc349a5716e31b5c$var$DEFAULT_MAX_LENGTH_PER_KEY;
        this.maxKeyLength = maxKeyLength;
        this.maxLengthPerKey = maxLengthPerKey;
        this.hit = 0;
        this.miss = 0;
        // avoid `new Array(N)`, which makes a sparse array,
        // because a sparse array is typically slower than a non-sparse array.
        this.caches = [];
        for(var i = 0; i < this.maxKeyLength; i++)this.caches.push([]);
    }
    CachedKeyDecoder.prototype.canBeCached = function(byteLength) {
        return byteLength > 0 && byteLength <= this.maxKeyLength;
    };
    CachedKeyDecoder.prototype.find = function(bytes, inputOffset, byteLength) {
        var records = this.caches[byteLength - 1];
        FIND_CHUNK: for(var _i = 0, records_1 = records; _i < records_1.length; _i++){
            var record = records_1[_i];
            var recordBytes = record.bytes;
            for(var j = 0; j < byteLength; j++){
                if (recordBytes[j] !== bytes[inputOffset + j]) continue FIND_CHUNK;
            }
            return record.str;
        }
        return null;
    };
    CachedKeyDecoder.prototype.store = function(bytes, value) {
        var records = this.caches[bytes.length - 1];
        var record = {
            bytes: bytes,
            str: value
        };
        if (records.length >= this.maxLengthPerKey) // `records` are full!
        // Set `record` to an arbitrary position.
        records[Math.random() * records.length | 0] = record;
        else records.push(record);
    };
    CachedKeyDecoder.prototype.decode = function(bytes, inputOffset, byteLength) {
        var cachedValue = this.find(bytes, inputOffset, byteLength);
        if (cachedValue != null) {
            this.hit++;
            return cachedValue;
        }
        this.miss++;
        var str = (0, $38619a2e5bc8b048$export$551117984c2adf4f)(bytes, inputOffset, byteLength);
        // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.
        var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
        this.store(slicedCopyOfBytes, str);
        return str;
    };
    return CachedKeyDecoder;
}();



var $0cc5414551be39c6$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var $0cc5414551be39c6$var$__generator = undefined && undefined.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var $0cc5414551be39c6$var$__asyncValues = undefined && undefined.__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
var $0cc5414551be39c6$var$__await = undefined && undefined.__await || function(v) {
    return this instanceof $0cc5414551be39c6$var$__await ? (this.v = v, this) : new $0cc5414551be39c6$var$__await(v);
};
var $0cc5414551be39c6$var$__asyncGenerator = undefined && undefined.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    function verb(n) {
        if (g[n]) i[n] = function(v) {
            return new Promise(function(a, b) {
                q.push([
                    n,
                    v,
                    a,
                    b
                ]) > 1 || resume(n, v);
            });
        };
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof $0cc5414551be39c6$var$__await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
};
var $0cc5414551be39c6$var$isValidMapKeyType = function(key) {
    var keyType = typeof key;
    return keyType === "string" || keyType === "number";
};
var $0cc5414551be39c6$var$HEAD_BYTE_REQUIRED = -1;
var $0cc5414551be39c6$var$EMPTY_VIEW = new DataView(new ArrayBuffer(0));
var $0cc5414551be39c6$var$EMPTY_BYTES = new Uint8Array($0cc5414551be39c6$var$EMPTY_VIEW.buffer);
var $0cc5414551be39c6$export$449c37eaf7093493 = function() {
    try {
        // IE11: The spec says it should throw RangeError,
        // IE11: but in IE11 it throws TypeError.
        $0cc5414551be39c6$var$EMPTY_VIEW.getInt8(0);
    } catch (e) {
        return e.constructor;
    }
    throw new Error("never reached");
}();
var $0cc5414551be39c6$var$MORE_DATA = new $0cc5414551be39c6$export$449c37eaf7093493("Insufficient data");
var $0cc5414551be39c6$var$sharedCachedKeyDecoder = new (0, $bc349a5716e31b5c$export$529b830450faf29c)();
var $0cc5414551be39c6$export$f9de6ca0bc043724 = /** @class */ function() {
    function Decoder(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {
        if (extensionCodec === void 0) extensionCodec = (0, $e661d09a11cfa477$export$12677a794dbd89d7).defaultCodec;
        if (context === void 0) context = undefined;
        if (maxStrLength === void 0) maxStrLength = (0, $e16ab28aaf2f0289$export$3314b2c271c86d70);
        if (maxBinLength === void 0) maxBinLength = (0, $e16ab28aaf2f0289$export$3314b2c271c86d70);
        if (maxArrayLength === void 0) maxArrayLength = (0, $e16ab28aaf2f0289$export$3314b2c271c86d70);
        if (maxMapLength === void 0) maxMapLength = (0, $e16ab28aaf2f0289$export$3314b2c271c86d70);
        if (maxExtLength === void 0) maxExtLength = (0, $e16ab28aaf2f0289$export$3314b2c271c86d70);
        if (keyDecoder === void 0) keyDecoder = $0cc5414551be39c6$var$sharedCachedKeyDecoder;
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxStrLength = maxStrLength;
        this.maxBinLength = maxBinLength;
        this.maxArrayLength = maxArrayLength;
        this.maxMapLength = maxMapLength;
        this.maxExtLength = maxExtLength;
        this.keyDecoder = keyDecoder;
        this.totalPos = 0;
        this.pos = 0;
        this.view = $0cc5414551be39c6$var$EMPTY_VIEW;
        this.bytes = $0cc5414551be39c6$var$EMPTY_BYTES;
        this.headByte = $0cc5414551be39c6$var$HEAD_BYTE_REQUIRED;
        this.stack = [];
    }
    Decoder.prototype.reinitializeState = function() {
        this.totalPos = 0;
        this.headByte = $0cc5414551be39c6$var$HEAD_BYTE_REQUIRED;
        this.stack.length = 0;
    // view, bytes, and pos will be re-initialized in setBuffer()
    };
    Decoder.prototype.setBuffer = function(buffer) {
        this.bytes = (0, $49ca50dab122ad8b$export$f8d669c2a17882f2)(buffer);
        this.view = (0, $49ca50dab122ad8b$export$7277868462c1ba02)(this.bytes);
        this.pos = 0;
    };
    Decoder.prototype.appendBuffer = function(buffer) {
        if (this.headByte === $0cc5414551be39c6$var$HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) this.setBuffer(buffer);
        else {
            var remainingData = this.bytes.subarray(this.pos);
            var newData = (0, $49ca50dab122ad8b$export$f8d669c2a17882f2)(buffer);
            // concat remainingData + newData
            var newBuffer = new Uint8Array(remainingData.length + newData.length);
            newBuffer.set(remainingData);
            newBuffer.set(newData, remainingData.length);
            this.setBuffer(newBuffer);
        }
    };
    Decoder.prototype.hasRemaining = function(size) {
        return this.view.byteLength - this.pos >= size;
    };
    Decoder.prototype.createExtraByteError = function(posToShow) {
        var _a = this, view = _a.view, pos = _a.pos;
        return new RangeError("Extra ".concat(view.byteLength - pos, " of ").concat(view.byteLength, " byte(s) found at buffer[").concat(posToShow, "]"));
    };
    /**
     * @throws {@link DecodeError}
     * @throws {@link RangeError}
     */ Decoder.prototype.decode = function(buffer) {
        this.reinitializeState();
        this.setBuffer(buffer);
        var object = this.doDecodeSync();
        if (this.hasRemaining(1)) throw this.createExtraByteError(this.pos);
        return object;
    };
    Decoder.prototype.decodeMulti = function(buffer) {
        return $0cc5414551be39c6$var$__generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    this.reinitializeState();
                    this.setBuffer(buffer);
                    _a.label = 1;
                case 1:
                    if (!this.hasRemaining(1)) return [
                        3 /*break*/ ,
                        3
                    ];
                    return [
                        4 /*yield*/ ,
                        this.doDecodeSync()
                    ];
                case 2:
                    _a.sent();
                    return [
                        3 /*break*/ ,
                        1
                    ];
                case 3:
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    };
    Decoder.prototype.decodeAsync = function(stream) {
        var stream_1, stream_1_1;
        var e_1, _a;
        return $0cc5414551be39c6$var$__awaiter(this, void 0, void 0, function() {
            var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;
            return $0cc5414551be39c6$var$__generator(this, function(_c) {
                switch(_c.label){
                    case 0:
                        decoded = false;
                        _c.label = 1;
                    case 1:
                        _c.trys.push([
                            1,
                            6,
                            7,
                            12
                        ]);
                        stream_1 = $0cc5414551be39c6$var$__asyncValues(stream);
                        _c.label = 2;
                    case 2:
                        return [
                            4 /*yield*/ ,
                            stream_1.next()
                        ];
                    case 3:
                        if (!(stream_1_1 = _c.sent(), !stream_1_1.done)) return [
                            3 /*break*/ ,
                            5
                        ];
                        buffer = stream_1_1.value;
                        if (decoded) throw this.createExtraByteError(this.totalPos);
                        this.appendBuffer(buffer);
                        try {
                            object = this.doDecodeSync();
                            decoded = true;
                        } catch (e) {
                            if (!(e instanceof $0cc5414551be39c6$export$449c37eaf7093493)) throw e; // rethrow
                        // fallthrough
                        }
                        this.totalPos += this.pos;
                        _c.label = 4;
                    case 4:
                        return [
                            3 /*break*/ ,
                            2
                        ];
                    case 5:
                        return [
                            3 /*break*/ ,
                            12
                        ];
                    case 6:
                        e_1_1 = _c.sent();
                        e_1 = {
                            error: e_1_1
                        };
                        return [
                            3 /*break*/ ,
                            12
                        ];
                    case 7:
                        _c.trys.push([
                            7,
                            ,
                            10,
                            11
                        ]);
                        if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return))) return [
                            3 /*break*/ ,
                            9
                        ];
                        return [
                            4 /*yield*/ ,
                            _a.call(stream_1)
                        ];
                    case 8:
                        _c.sent();
                        _c.label = 9;
                    case 9:
                        return [
                            3 /*break*/ ,
                            11
                        ];
                    case 10:
                        if (e_1) throw e_1.error;
                        return [
                            7 /*endfinally*/ 
                        ];
                    case 11:
                        return [
                            7 /*endfinally*/ 
                        ];
                    case 12:
                        if (decoded) {
                            if (this.hasRemaining(1)) throw this.createExtraByteError(this.totalPos);
                            return [
                                2 /*return*/ ,
                                object
                            ];
                        }
                        _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;
                        throw new RangeError("Insufficient data in parsing ".concat((0, $704193ccc95285b2$export$78406e843f5312da)(headByte), " at ").concat(totalPos, " (").concat(pos, " in the current buffer)"));
                }
            });
        });
    };
    Decoder.prototype.decodeArrayStream = function(stream) {
        return this.decodeMultiAsync(stream, true);
    };
    Decoder.prototype.decodeStream = function(stream) {
        return this.decodeMultiAsync(stream, false);
    };
    Decoder.prototype.decodeMultiAsync = function(stream, isArray) {
        return $0cc5414551be39c6$var$__asyncGenerator(this, arguments, function decodeMultiAsync_1() {
            var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;
            var e_3, _a;
            return $0cc5414551be39c6$var$__generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        isArrayHeaderRequired = isArray;
                        arrayItemsLeft = -1;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([
                            1,
                            13,
                            14,
                            19
                        ]);
                        stream_2 = $0cc5414551be39c6$var$__asyncValues(stream);
                        _b.label = 2;
                    case 2:
                        return [
                            4 /*yield*/ ,
                            $0cc5414551be39c6$var$__await(stream_2.next())
                        ];
                    case 3:
                        if (!(stream_2_1 = _b.sent(), !stream_2_1.done)) return [
                            3 /*break*/ ,
                            12
                        ];
                        buffer = stream_2_1.value;
                        if (isArray && arrayItemsLeft === 0) throw this.createExtraByteError(this.totalPos);
                        this.appendBuffer(buffer);
                        if (isArrayHeaderRequired) {
                            arrayItemsLeft = this.readArraySize();
                            isArrayHeaderRequired = false;
                            this.complete();
                        }
                        _b.label = 4;
                    case 4:
                        _b.trys.push([
                            4,
                            9,
                            ,
                            10
                        ]);
                        _b.label = 5;
                    case 5:
                        return [
                            4 /*yield*/ ,
                            $0cc5414551be39c6$var$__await(this.doDecodeSync())
                        ];
                    case 6:
                        return [
                            4 /*yield*/ ,
                            _b.sent()
                        ];
                    case 7:
                        _b.sent();
                        if (--arrayItemsLeft === 0) return [
                            3 /*break*/ ,
                            8
                        ];
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 8:
                        return [
                            3 /*break*/ ,
                            10
                        ];
                    case 9:
                        e_2 = _b.sent();
                        if (!(e_2 instanceof $0cc5414551be39c6$export$449c37eaf7093493)) throw e_2; // rethrow
                        return [
                            3 /*break*/ ,
                            10
                        ];
                    case 10:
                        this.totalPos += this.pos;
                        _b.label = 11;
                    case 11:
                        return [
                            3 /*break*/ ,
                            2
                        ];
                    case 12:
                        return [
                            3 /*break*/ ,
                            19
                        ];
                    case 13:
                        e_3_1 = _b.sent();
                        e_3 = {
                            error: e_3_1
                        };
                        return [
                            3 /*break*/ ,
                            19
                        ];
                    case 14:
                        _b.trys.push([
                            14,
                            ,
                            17,
                            18
                        ]);
                        if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return))) return [
                            3 /*break*/ ,
                            16
                        ];
                        return [
                            4 /*yield*/ ,
                            $0cc5414551be39c6$var$__await(_a.call(stream_2))
                        ];
                    case 15:
                        _b.sent();
                        _b.label = 16;
                    case 16:
                        return [
                            3 /*break*/ ,
                            18
                        ];
                    case 17:
                        if (e_3) throw e_3.error;
                        return [
                            7 /*endfinally*/ 
                        ];
                    case 18:
                        return [
                            7 /*endfinally*/ 
                        ];
                    case 19:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    Decoder.prototype.doDecodeSync = function() {
        DECODE: while(true){
            var headByte = this.readHeadByte();
            var object = void 0;
            if (headByte >= 0xe0) // negative fixint (111x xxxx) 0xe0 - 0xff
            object = headByte - 0x100;
            else if (headByte < 0xc0) {
                if (headByte < 0x80) // positive fixint (0xxx xxxx) 0x00 - 0x7f
                object = headByte;
                else if (headByte < 0x90) {
                    // fixmap (1000 xxxx) 0x80 - 0x8f
                    var size = headByte - 0x80;
                    if (size !== 0) {
                        this.pushMapState(size);
                        this.complete();
                        continue DECODE;
                    } else object = {};
                } else if (headByte < 0xa0) {
                    // fixarray (1001 xxxx) 0x90 - 0x9f
                    var size = headByte - 0x90;
                    if (size !== 0) {
                        this.pushArrayState(size);
                        this.complete();
                        continue DECODE;
                    } else object = [];
                } else {
                    // fixstr (101x xxxx) 0xa0 - 0xbf
                    var byteLength = headByte - 0xa0;
                    object = this.decodeUtf8String(byteLength, 0);
                }
            } else if (headByte === 0xc0) // nil
            object = null;
            else if (headByte === 0xc2) // false
            object = false;
            else if (headByte === 0xc3) // true
            object = true;
            else if (headByte === 0xca) // float 32
            object = this.readF32();
            else if (headByte === 0xcb) // float 64
            object = this.readF64();
            else if (headByte === 0xcc) // uint 8
            object = this.readU8();
            else if (headByte === 0xcd) // uint 16
            object = this.readU16();
            else if (headByte === 0xce) // uint 32
            object = this.readU32();
            else if (headByte === 0xcf) // uint 64
            object = this.readU64();
            else if (headByte === 0xd0) // int 8
            object = this.readI8();
            else if (headByte === 0xd1) // int 16
            object = this.readI16();
            else if (headByte === 0xd2) // int 32
            object = this.readI32();
            else if (headByte === 0xd3) // int 64
            object = this.readI64();
            else if (headByte === 0xd9) {
                // str 8
                var byteLength = this.lookU8();
                object = this.decodeUtf8String(byteLength, 1);
            } else if (headByte === 0xda) {
                // str 16
                var byteLength = this.lookU16();
                object = this.decodeUtf8String(byteLength, 2);
            } else if (headByte === 0xdb) {
                // str 32
                var byteLength = this.lookU32();
                object = this.decodeUtf8String(byteLength, 4);
            } else if (headByte === 0xdc) {
                // array 16
                var size = this.readU16();
                if (size !== 0) {
                    this.pushArrayState(size);
                    this.complete();
                    continue DECODE;
                } else object = [];
            } else if (headByte === 0xdd) {
                // array 32
                var size = this.readU32();
                if (size !== 0) {
                    this.pushArrayState(size);
                    this.complete();
                    continue DECODE;
                } else object = [];
            } else if (headByte === 0xde) {
                // map 16
                var size = this.readU16();
                if (size !== 0) {
                    this.pushMapState(size);
                    this.complete();
                    continue DECODE;
                } else object = {};
            } else if (headByte === 0xdf) {
                // map 32
                var size = this.readU32();
                if (size !== 0) {
                    this.pushMapState(size);
                    this.complete();
                    continue DECODE;
                } else object = {};
            } else if (headByte === 0xc4) {
                // bin 8
                var size = this.lookU8();
                object = this.decodeBinary(size, 1);
            } else if (headByte === 0xc5) {
                // bin 16
                var size = this.lookU16();
                object = this.decodeBinary(size, 2);
            } else if (headByte === 0xc6) {
                // bin 32
                var size = this.lookU32();
                object = this.decodeBinary(size, 4);
            } else if (headByte === 0xd4) // fixext 1
            object = this.decodeExtension(1, 0);
            else if (headByte === 0xd5) // fixext 2
            object = this.decodeExtension(2, 0);
            else if (headByte === 0xd6) // fixext 4
            object = this.decodeExtension(4, 0);
            else if (headByte === 0xd7) // fixext 8
            object = this.decodeExtension(8, 0);
            else if (headByte === 0xd8) // fixext 16
            object = this.decodeExtension(16, 0);
            else if (headByte === 0xc7) {
                // ext 8
                var size = this.lookU8();
                object = this.decodeExtension(size, 1);
            } else if (headByte === 0xc8) {
                // ext 16
                var size = this.lookU16();
                object = this.decodeExtension(size, 2);
            } else if (headByte === 0xc9) {
                // ext 32
                var size = this.lookU32();
                object = this.decodeExtension(size, 4);
            } else throw new (0, $cc782cda24f8f221$exports.DecodeError)("Unrecognized type byte: ".concat((0, $704193ccc95285b2$export$78406e843f5312da)(headByte)));
            this.complete();
            var stack = this.stack;
            while(stack.length > 0){
                // arrays and maps
                var state = stack[stack.length - 1];
                if (state.type === 0 /* State.ARRAY */ ) {
                    state.array[state.position] = object;
                    state.position++;
                    if (state.position === state.size) {
                        stack.pop();
                        object = state.array;
                    } else continue DECODE;
                } else if (state.type === 1 /* State.MAP_KEY */ ) {
                    if (!$0cc5414551be39c6$var$isValidMapKeyType(object)) throw new (0, $cc782cda24f8f221$exports.DecodeError)("The type of key must be string or number but " + typeof object);
                    if (object === "__proto__") throw new (0, $cc782cda24f8f221$exports.DecodeError)("The key __proto__ is not allowed");
                    state.key = object;
                    state.type = 2 /* State.MAP_VALUE */ ;
                    continue DECODE;
                } else {
                    // it must be `state.type === State.MAP_VALUE` here
                    state.map[state.key] = object;
                    state.readCount++;
                    if (state.readCount === state.size) {
                        stack.pop();
                        object = state.map;
                    } else {
                        state.key = null;
                        state.type = 1 /* State.MAP_KEY */ ;
                        continue DECODE;
                    }
                }
            }
            return object;
        }
    };
    Decoder.prototype.readHeadByte = function() {
        if (this.headByte === $0cc5414551be39c6$var$HEAD_BYTE_REQUIRED) this.headByte = this.readU8();
        return this.headByte;
    };
    Decoder.prototype.complete = function() {
        this.headByte = $0cc5414551be39c6$var$HEAD_BYTE_REQUIRED;
    };
    Decoder.prototype.readArraySize = function() {
        var headByte = this.readHeadByte();
        switch(headByte){
            case 0xdc:
                return this.readU16();
            case 0xdd:
                return this.readU32();
            default:
                if (headByte < 0xa0) return headByte - 0x90;
                else throw new (0, $cc782cda24f8f221$exports.DecodeError)("Unrecognized array type byte: ".concat((0, $704193ccc95285b2$export$78406e843f5312da)(headByte)));
        }
    };
    Decoder.prototype.pushMapState = function(size) {
        if (size > this.maxMapLength) throw new (0, $cc782cda24f8f221$exports.DecodeError)("Max length exceeded: map length (".concat(size, ") > maxMapLengthLength (").concat(this.maxMapLength, ")"));
        this.stack.push({
            type: 1 /* State.MAP_KEY */ ,
            size: size,
            key: null,
            readCount: 0,
            map: {}
        });
    };
    Decoder.prototype.pushArrayState = function(size) {
        if (size > this.maxArrayLength) throw new (0, $cc782cda24f8f221$exports.DecodeError)("Max length exceeded: array length (".concat(size, ") > maxArrayLength (").concat(this.maxArrayLength, ")"));
        this.stack.push({
            type: 0 /* State.ARRAY */ ,
            size: size,
            array: new Array(size),
            position: 0
        });
    };
    Decoder.prototype.decodeUtf8String = function(byteLength, headerOffset) {
        var _a;
        if (byteLength > this.maxStrLength) throw new (0, $cc782cda24f8f221$exports.DecodeError)("Max length exceeded: UTF-8 byte length (".concat(byteLength, ") > maxStrLength (").concat(this.maxStrLength, ")"));
        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) throw $0cc5414551be39c6$var$MORE_DATA;
        var offset = this.pos + headerOffset;
        var object;
        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) object = this.keyDecoder.decode(this.bytes, offset, byteLength);
        else if (byteLength > (0, $38619a2e5bc8b048$export$d866281c5a66d1ef)) object = (0, $38619a2e5bc8b048$export$6ed79e41309992dc)(this.bytes, offset, byteLength);
        else object = (0, $38619a2e5bc8b048$export$551117984c2adf4f)(this.bytes, offset, byteLength);
        this.pos += headerOffset + byteLength;
        return object;
    };
    Decoder.prototype.stateIsMapKey = function() {
        if (this.stack.length > 0) {
            var state = this.stack[this.stack.length - 1];
            return state.type === 1 /* State.MAP_KEY */ ;
        }
        return false;
    };
    Decoder.prototype.decodeBinary = function(byteLength, headOffset) {
        if (byteLength > this.maxBinLength) throw new (0, $cc782cda24f8f221$exports.DecodeError)("Max length exceeded: bin length (".concat(byteLength, ") > maxBinLength (").concat(this.maxBinLength, ")"));
        if (!this.hasRemaining(byteLength + headOffset)) throw $0cc5414551be39c6$var$MORE_DATA;
        var offset = this.pos + headOffset;
        var object = this.bytes.subarray(offset, offset + byteLength);
        this.pos += headOffset + byteLength;
        return object;
    };
    Decoder.prototype.decodeExtension = function(size, headOffset) {
        if (size > this.maxExtLength) throw new (0, $cc782cda24f8f221$exports.DecodeError)("Max length exceeded: ext length (".concat(size, ") > maxExtLength (").concat(this.maxExtLength, ")"));
        var extType = this.view.getInt8(this.pos + headOffset);
        var data = this.decodeBinary(size, headOffset + 1 /* extType */ );
        return this.extensionCodec.decode(data, extType, this.context);
    };
    Decoder.prototype.lookU8 = function() {
        return this.view.getUint8(this.pos);
    };
    Decoder.prototype.lookU16 = function() {
        return this.view.getUint16(this.pos);
    };
    Decoder.prototype.lookU32 = function() {
        return this.view.getUint32(this.pos);
    };
    Decoder.prototype.readU8 = function() {
        var value = this.view.getUint8(this.pos);
        this.pos++;
        return value;
    };
    Decoder.prototype.readI8 = function() {
        var value = this.view.getInt8(this.pos);
        this.pos++;
        return value;
    };
    Decoder.prototype.readU16 = function() {
        var value = this.view.getUint16(this.pos);
        this.pos += 2;
        return value;
    };
    Decoder.prototype.readI16 = function() {
        var value = this.view.getInt16(this.pos);
        this.pos += 2;
        return value;
    };
    Decoder.prototype.readU32 = function() {
        var value = this.view.getUint32(this.pos);
        this.pos += 4;
        return value;
    };
    Decoder.prototype.readI32 = function() {
        var value = this.view.getInt32(this.pos);
        this.pos += 4;
        return value;
    };
    Decoder.prototype.readU64 = function() {
        var value = (0, $e16ab28aaf2f0289$export$59a2dbf579ff9568)(this.view, this.pos);
        this.pos += 8;
        return value;
    };
    Decoder.prototype.readI64 = function() {
        var value = (0, $e16ab28aaf2f0289$export$69825c7adcc820c6)(this.view, this.pos);
        this.pos += 8;
        return value;
    };
    Decoder.prototype.readF32 = function() {
        var value = this.view.getFloat32(this.pos);
        this.pos += 4;
        return value;
    };
    Decoder.prototype.readF64 = function() {
        var value = this.view.getFloat64(this.pos);
        this.pos += 8;
        return value;
    };
    return Decoder;
}();


var $c563c5a7aeb14d63$export$ca6ec972f712a9eb = {};
function $c563c5a7aeb14d63$export$2f872c0f2117be69(buffer, options) {
    if (options === void 0) options = $c563c5a7aeb14d63$export$ca6ec972f712a9eb;
    var decoder = new (0, $0cc5414551be39c6$exports.Decoder)(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
    return decoder.decode(buffer);
}
function $c563c5a7aeb14d63$export$43cc91859d9fdc54(buffer, options) {
    if (options === void 0) options = $c563c5a7aeb14d63$export$ca6ec972f712a9eb;
    var decoder = new (0, $0cc5414551be39c6$exports.Decoder)(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
    return decoder.decodeMulti(buffer);
}




const $9bd6af03edb6e866$var$address = "1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5";
const $9bd6af03edb6e866$var$querySchema = [
    {
        cmd: {
            SET: [
                {
                    key: "string"
                },
                {
                    val: "string"
                }
            ],
            SELECT: [
                {
                    tx: "string"
                }
            ],
            ADD: [
                {
                    key: "string"
                },
                [
                    {
                        val: "string"
                    }
                ]
            ],
            DELETE: [
                {
                    key: "string"
                },
                [
                    {
                        val: "string"
                    }
                ]
            ],
            JSON: "string",
            REMOVE: [
                [
                    {
                        key: "string"
                    }
                ]
            ],
            CLEAR: [
                [
                    {
                        txid: "string"
                    }
                ]
            ]
        }
    }
];
const $9bd6af03edb6e866$var$processADD = function(cell, mapObj) {
    let last = null;
    for (const pushdataContainer of cell){
        // ignore MAP command
        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) continue;
        const pushdata = pushdataContainer.s;
        if (pushdataContainer.i === 2) {
            // Key name
            mapObj[pushdata] = [];
            last = pushdata;
        } else if (last && Array.isArray(mapObj[last])) mapObj[last].push(pushdata);
    }
};
const $9bd6af03edb6e866$var$proccessDELETE = function(cell, mapObj) {
    let last = null;
    for (const pushdataContainer of cell){
        // ignore MAP command
        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) continue;
        const pushdata = pushdataContainer.s;
        if (pushdataContainer.i === 2) {
            // Key name
            mapObj[pushdata] = [];
            last = pushdata;
        } else if (last) mapObj[last].push(pushdata);
    }
};
const $9bd6af03edb6e866$var$processSELECT = function(cell, mapObj) {
    // TODO
    // console.log('MAP SELECT');
    for (const pushdataContainer of cell)// ignore MAP command
    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {
        mapObj.SELECT = "TODO";
        continue;
    }
};
const $9bd6af03edb6e866$var$processMSGPACK = function(cell, mapObj) {
    for (const pushdataContainer of cell){
        // ignore MAP command
        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) continue;
        if (pushdataContainer.i === 2) try {
            if (!(0, $c563c5a7aeb14d63$export$2f872c0f2117be69)) throw new Error("Msgpack is required but not loaded");
            const buff = (0, $hiCjL$buffer.Buffer).from(pushdataContainer.b, "base64");
            mapObj = (0, $c563c5a7aeb14d63$export$2f872c0f2117be69)(buff);
        } catch (e) {
            mapObj = {};
        }
    }
    return mapObj;
};
const $9bd6af03edb6e866$var$processJSON = function(cell, mapObj) {
    for (const pushdataContainer of cell){
        // ignore MAP command
        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) continue;
        if (pushdataContainer.i === 2) try {
            mapObj = JSON.parse(pushdataContainer.s);
        } catch (e) {
            mapObj = {};
        }
    }
    return mapObj;
};
const $9bd6af03edb6e866$var$processSET = function(cell, mapObj) {
    let last = null;
    for (const pushdataContainer of cell){
        // ignore MAP command
        if (!pushdataContainer.s || pushdataContainer.i === 0 || pushdataContainer.i === 1) continue;
        const pushdata = pushdataContainer.s;
        if (pushdataContainer.i % 2 === 0) {
            // key
            mapObj[pushdata] = "";
            last = pushdata;
        } else {
            // value
            if (!last) throw new Error(`malformed MAP syntax. Cannot parse.${last}`);
            mapObj[last] = pushdata;
        }
    }
};
const $9bd6af03edb6e866$var$handler = function({ dataObj: dataObj , cell: cell , tx: tx  }) {
    // Validate
    if (cell[0].s !== $9bd6af03edb6e866$var$address || !cell[1] || !cell[1].s || !cell[2] || !cell[2].s) throw new Error(`Invalid MAP record: ${tx}`);
    let mapObj = {};
    // parse the protocol separator
    const commands = [];
    let commandSeparator = 0;
    for(let i = 1; i < cell.length; i++)if (cell[i].s === ":::") commandSeparator++;
    else {
        if (!commands[commandSeparator]) commands[commandSeparator] = [];
        cell[i].i = commands[commandSeparator].length + 1;
        commands[commandSeparator].push(cell[i]);
    }
    // Get the MAP command key name from the query schema
    const mapCmdKey = Object.keys($9bd6af03edb6e866$var$querySchema[0])[0];
    // Add the firt MAP command in the response object
    mapObj[mapCmdKey] = commands[0][0].s;
    commands.forEach((cc)=>{
        // re-add the MAP address
        cc.unshift({
            s: $9bd6af03edb6e866$var$address,
            i: 0
        });
        const command = cc[1].s;
        // Individual parsing rules for each MAP command
        switch(command){
            // Also check for SELECT commands and strip off the <SELECT> <TXID> part and run it through
            case "ADD":
                $9bd6af03edb6e866$var$processADD(cc, mapObj);
                break;
            case "REMOVE":
                mapObj.key = cc[2].s;
                break;
            case "DELETE":
                $9bd6af03edb6e866$var$proccessDELETE(cc, mapObj);
                break;
            case "CLEAR":
                break;
            case "SELECT":
                $9bd6af03edb6e866$var$processSELECT(cc, mapObj);
                break;
            case "MSGPACK":
                mapObj = $9bd6af03edb6e866$var$processMSGPACK(cc, mapObj);
                break;
            case "JSON":
                mapObj = $9bd6af03edb6e866$var$processJSON(cc, mapObj);
                break;
            case "SET":
                $9bd6af03edb6e866$var$processSET(cc, mapObj);
                break;
            default:
        }
    });
    (0, $279a86245ff8c81d$export$23dbc584560299c3)(dataObj, "MAP", mapObj);
};
const $9bd6af03edb6e866$export$ce970371e0e850bc = {
    name: "MAP",
    address: $9bd6af03edb6e866$var$address,
    querySchema: $9bd6af03edb6e866$var$querySchema,
    handler: $9bd6af03edb6e866$var$handler
};




const $f0b6b08015c095ba$var$address = "meta";
const $f0b6b08015c095ba$var$querySchema = [
    {
        address: "string"
    },
    {
        parent: "string"
    },
    {
        name: "string"
    }
];
const $f0b6b08015c095ba$export$3eb18141230d6532 = async function(a, tx) {
    // Calculate the node ID
    const buf = (0, $hiCjL$buffer.Buffer).from(a + tx);
    const hashBuf = await (0, $279a86245ff8c81d$export$bced8d2aada2d1c9)(buf);
    return hashBuf.toString("hex");
};
const $f0b6b08015c095ba$var$handler = async ({ dataObj: dataObj , cell: cell , tx: tx  })=>{
    if (!cell.length || cell[0].s !== "meta" || !cell[1] || !cell[1].s || !cell[2] || !cell[2].s || !tx) throw new Error("Invalid Metanet tx " + tx);
    // For now, we just copy from MOM keys later if available, or keep BOB format
    const nodeId = await $f0b6b08015c095ba$export$3eb18141230d6532(cell[1].s, tx.tx.h);
    // Described this node
    const node = {
        a: cell[1].s,
        tx: tx.tx.h,
        id: nodeId
    };
    let parent = {};
    if (tx.in) {
        const parentId = await $f0b6b08015c095ba$export$3eb18141230d6532(tx.in[0].e.a, cell[2].s);
        // Parent node
        parent = {
            a: tx.in[0].e.a,
            tx: cell[2].s,
            id: parentId
        };
    }
    if (!dataObj.METANET) dataObj.METANET = [];
    dataObj.METANET.push({
        node: node,
        parent: parent
    });
};
const $f0b6b08015c095ba$export$7830a85a59ca4593 = {
    name: "METANET",
    address: $f0b6b08015c095ba$var$address,
    querySchema: $f0b6b08015c095ba$var$querySchema,
    handler: $f0b6b08015c095ba$var$handler
};




var $a848c63a70228885$require$Buffer = $hiCjL$buffer.Buffer;
// 21e8 does not use the first pushdata for id
// in fact there is no id since the 21e8 is designed for difficulty and can be changed
// instead we use the static part of the script to indentfy the transaction
// TODO - the OP_X_PLACEHOLDER is the number of bytes to push onto the stack and must match difficulty size
const $a848c63a70228885$var$_21e8Script = "OP_SIZE <OP_X_PLACEHOLDER> OP_PICK OP_SHA256 OP_SWAP OP_SPLIT OP_DROP OP_EQUALVERIFY OP_DROP OP_CHECKSIG".split(" ");
const $a848c63a70228885$export$35263eb1836849b4 = (cell)=>{
    if (cell.length !== 12) // wrong length
    return false;
    // match exact script
    const ops = [
        ...cell
    ].map((c)=>c.ops).splice(2, cell.length);
    // calculate target byte length
    const target = (0, $279a86245ff8c81d$export$b691916706e0e9cc)(cell[1], "hex");
    const targetOpSize = $a848c63a70228885$require$Buffer.from(target).byteLength;
    // replace the placeholder opcode with actual
    ops[1] = `OP_${targetOpSize}`;
    $a848c63a70228885$var$_21e8Script[1] = `OP_${targetOpSize}`;
    // protocol identifier always in first pushdata
    return ops.join() === $a848c63a70228885$var$_21e8Script.join();
};
const $a848c63a70228885$var$handler = ({ dataObj: dataObj , cell: cell , out: out  })=>{
    if (!cell[0] || !out) throw new Error(`Invalid 21e8 tx. dataObj, cell, out and tx are required.`);
    // assemble asm
    // make sure first piece matches a txid
    // 2nd piece matches any difficulty. set some resonable limit in bytes if there isnt one documented somewhere
    // next
    const txid = (0, $279a86245ff8c81d$export$b691916706e0e9cc)(cell[0], "hex");
    const target = (0, $279a86245ff8c81d$export$b691916706e0e9cc)(cell[1], "hex");
    if (!target) throw new Error(`Invalid 21e8 target.` + JSON.stringify(cell[0], null, 2));
    const difficulty = $a848c63a70228885$require$Buffer.from(target, "hex").byteLength;
    const _21e8Obj = {
        target: target,
        difficulty: difficulty,
        value: out.e.v,
        txid: txid
    };
    (0, $279a86245ff8c81d$export$23dbc584560299c3)(dataObj, "21E8", _21e8Obj);
};
const $a848c63a70228885$export$85479a00ad164ad6 = {
    name: "21E8",
    handler: $a848c63a70228885$var$handler
};



const $5c895b8133860e52$var$protocolMap = new Map([]);
const $5c895b8133860e52$var$protocolHandlers = new Map();
const $5c895b8133860e52$var$protocolQuerySchemas = new Map();
const $5c895b8133860e52$var$defaultProtocols = [
    (0, $428d5dc1cd339f93$export$474d593e43f12abd),
    (0, $b1f3a975f62840fa$export$ef35774e6d314e91),
    (0, $d3a83c24449b7487$export$5935ea4bf04c4453),
    (0, $9bd6af03edb6e866$export$ce970371e0e850bc),
    (0, $f0b6b08015c095ba$export$7830a85a59ca4593)
];
// prepare protocol map, handlers and schemas
$5c895b8133860e52$var$defaultProtocols.forEach((protocol)=>{
    if (protocol.address) $5c895b8133860e52$var$protocolMap.set(protocol.address, protocol.name);
    $5c895b8133860e52$var$protocolHandlers.set(protocol.name, protocol.handler);
    if (protocol.querySchema) $5c895b8133860e52$var$protocolQuerySchemas.set(protocol.name, protocol.querySchema);
});
class $5c895b8133860e52$export$894a720e71f90b3c {
    constructor(){
        // initial default protocol handlers in this instantiation
        this.protocolMap = $5c895b8133860e52$var$protocolMap;
        this.protocolHandlers = $5c895b8133860e52$var$protocolHandlers;
        this.protocolQuerySchemas = $5c895b8133860e52$var$protocolQuerySchemas;
    }
    addProtocolHandler({ name: name , address: address , querySchema: querySchema , handler: handler  }) {
        if (address) this.protocolMap.set(address, name);
        this.protocolHandlers.set(name, handler);
        if (querySchema) this.protocolQuerySchemas.set(name, querySchema);
    }
    transformTx = async (tx)=>{
        if (!tx || !tx["in"] || !tx["out"]) throw new Error("Cannot process tx");
        // This will become our nicely formatted response object
        const dataObj = {};
        for (const [key, val] of Object.entries(tx)){
            if (key === "out") // loop over the outputs
            for (const out of tx.out){
                const { tape: tape  } = out;
                if (tape?.some((cc)=>(0, $279a86245ff8c81d$export$238b4e54af8fe886)(cc))) // loop over tape
                for (const cellContainer of tape){
                    // Skip the OP_RETURN / OP_FALSE OP_RETURN cell
                    if ((0, $279a86245ff8c81d$export$238b4e54af8fe886)(cellContainer)) continue;
                    const { cell: cell  } = cellContainer;
                    if (!cell) throw new Error("empty cell while parsing");
                    const prefix = cell[0].s;
                    await this.process(this.protocolMap.get(prefix || "") || "", {
                        cell: cell,
                        dataObj: dataObj,
                        tape: tape,
                        out: out,
                        tx: tx
                    });
                }
                else {
                    // No OP_RETURN in this tape
                    // Check for boostpow and 21e8
                    if (tape?.some((cc)=>{
                        const { cell: cell  } = cc;
                        if (this.protocolHandlers.has((0, $fe9ce3718327b356$export$13c3c8ee12090ebc).name) && (0, $fe9ce3718327b356$export$a52badcaecf73796)(cell)) // 'found boost'
                        return true;
                        if (this.protocolHandlers.has((0, $a848c63a70228885$export$85479a00ad164ad6).name) && (0, $a848c63a70228885$export$35263eb1836849b4)(cell)) // 'found 21e8'
                        return true;
                    })) // find the cell array
                    // loop over tape
                    for (const cellContainer1 of tape){
                        const { cell: cell1  } = cellContainer1;
                        // Skip the OP_RETURN / OP_FALSE OP_RETURN cell
                        if (!cell1) throw new Error("empty cell while parsing");
                        let protocolName = "";
                        if ((0, $fe9ce3718327b356$export$a52badcaecf73796)(cell1)) protocolName = (0, $fe9ce3718327b356$export$13c3c8ee12090ebc).name;
                        else if ((0, $a848c63a70228885$export$35263eb1836849b4)(cell1)) protocolName = (0, $a848c63a70228885$export$85479a00ad164ad6).name;
                        else continue;
                        this.process(protocolName, {
                            tx: tx,
                            cell: cell1,
                            dataObj: dataObj,
                            tape: tape,
                            out: out
                        });
                    }
                    else this.processUnknown(key, dataObj, out);
                }
            }
            else if (key === "in") // TODO: Boost check inputs to see if this is a tx solving a puzzle
            // TODO: 21e8 check inputs to see if this is a tx solving a puzzle
            dataObj[key] = val.map((v)=>{
                const r = {
                    ...v
                };
                delete r.tape;
                return r;
            });
            else // known key, just write it retaining original type
            dataObj[key] = val;
        }
        // If this is a MOM planaria it will have metanet keys available
        if (dataObj["METANET"] && tx.parent) {
            const meta = {
                ancestor: tx.ancestor,
                parent: tx.parent,
                child: tx.child,
                head: tx.head
            };
            dataObj.METANET.push(meta);
            // remove parent and node from root level for (MOM data)
            delete dataObj.ancestor;
            delete dataObj.child;
            delete dataObj.parent;
            delete dataObj.head;
            delete dataObj.node;
        }
        return dataObj;
    };
    processUnknown = (key, dataObj, out)=>{
        // no known non-OP_RETURN scripts
        if (key && !dataObj[key]) dataObj[key] = [];
        dataObj[key].push({
            i: out.i,
            e: out.e
        });
    };
    process = async (protocolName, { cell: cell , dataObj: dataObj , tape: tape , out: out , tx: tx  })=>{
        if (this.protocolHandlers.has(protocolName) && typeof this.protocolHandlers.get(protocolName) === "function") {
            const handler = this.protocolHandlers.get(protocolName);
            if (handler) /* eslint-disable no-await-in-loop */ await handler({
                dataObj: dataObj,
                cell: cell,
                tape: tape,
                out: out,
                tx: tx
            });
        } else (0, $279a86245ff8c81d$export$23dbc584560299c3)(dataObj, protocolName, cell);
    };
}
const $5c895b8133860e52$export$b2a90e318402f6bc = async (tx)=>{
    const b = new $5c895b8133860e52$export$894a720e71f90b3c();
    return b.transformTx(tx);
};


if (typeof window !== "undefined") window.bmap = {
    TransformTx: $5c895b8133860e52$export$b2a90e318402f6bc
};


//# sourceMappingURL=bmap.cjs.map
