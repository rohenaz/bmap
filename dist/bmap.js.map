{"mappings":"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","sources":["src/bmap.ts","src/protocols/aip.ts","src/utils.ts","src/protocols/b.ts","src/protocols/bap.ts","src/protocols/bitcom.ts","src/protocols/bitcomHashed.ts","src/protocols/psp.ts","src/paymail.ts","src/protocols/bitkey.ts","src/protocols/bitpic.ts","src/protocols/boost.ts","src/protocols/haip.ts","src/protocols/map.ts","src/protocols/metanet.ts","src/protocols/ord.ts","src/protocols/ron.ts","src/protocols/symre.ts","src/protocols/_21e8.ts"],"sourcesContent":["import { parse } from 'bpu-ts'\r\nimport {\r\n    BmapTx,\r\n    BobTx,\r\n    Handler,\r\n    HandlerProps,\r\n    In,\r\n    MetaNet,\r\n    MomTx,\r\n    Out,\r\n    Protocol,\r\n    ScriptChecker,\r\n} from '../types/common'\r\nimport { AIP } from './protocols/aip'\r\nimport { B } from './protocols/b'\r\nimport { BAP } from './protocols/bap'\r\nimport { BITCOM } from './protocols/bitcom'\r\nimport { BITCOM_HASHED } from './protocols/bitcomHashed'\r\nimport { BITKEY } from './protocols/bitkey'\r\nimport { BITPIC } from './protocols/bitpic'\r\nimport { BOOST } from './protocols/boost'\r\nimport { HAIP } from './protocols/haip'\r\nimport { MAP } from './protocols/map'\r\nimport { METANET } from './protocols/metanet'\r\nimport { Ord } from './protocols/ord'\r\nimport { PSP } from './protocols/psp'\r\nimport { RON } from './protocols/ron'\r\nimport { SYMRE } from './protocols/symre'\r\nimport { _21E8 } from './protocols/_21e8'\r\nimport {\r\n    checkOpFalseOpReturn,\r\n    isObjectArray,\r\n    isStringArray,\r\n    saveProtocolData,\r\n} from './utils'\r\n\r\n// Names of enabled protocols\r\nconst enabledProtocols = new Map<string, string>([])\r\n// Protocol Handlers\r\nconst protocolHandlers = new Map<string, Handler>([])\r\n// Script checkers are intentionally minimalistic detection functions for identifying matching scripts for a given protocol. Only if a checker returns true is a handler called for processing.\r\nconst protocolScriptCheckers = new Map<string, ScriptChecker>([])\r\nconst protocolOpReturnSchemas = new Map<string, Object[]>()\r\n\r\nexport const allProtocols = [\r\n    AIP,\r\n    B,\r\n    BAP,\r\n    MAP,\r\n    METANET,\r\n    BOOST,\r\n    _21E8,\r\n    BITCOM,\r\n    BITKEY,\r\n    BITPIC,\r\n    HAIP,\r\n    BITCOM_HASHED,\r\n    PSP,\r\n    RON,\r\n    SYMRE,\r\n    Ord,\r\n]\r\n\r\nexport const supportedProtocols = allProtocols.map((p) => p.name)\r\nexport const defaultProtocols = [AIP, B, BAP, MAP, METANET, Ord]\r\n\r\n// prepare protocol map, handlers and schemas\r\ndefaultProtocols.forEach((protocol) => {\r\n    if (protocol.address) {\r\n        enabledProtocols.set(protocol.address, protocol.name)\r\n    }\r\n    protocolHandlers.set(protocol.name, protocol.handler)\r\n    if (protocol.opReturnSchema) {\r\n        protocolOpReturnSchemas.set(protocol.name, protocol.opReturnSchema)\r\n    }\r\n    if (protocol.scriptChecker) {\r\n        protocolScriptCheckers.set(protocol.name, protocol.scriptChecker)\r\n    }\r\n})\r\n\r\n// Takes a BOB formatted op_return transaction\r\nexport class BMAP {\r\n    enabledProtocols: Map<string, string>\r\n\r\n    protocolHandlers: Map<string, Handler>\r\n\r\n    protocolScriptCheckers: Map<string, ScriptChecker>\r\n\r\n    protocolOpReturnSchemas: Map<string, Object[]>\r\n\r\n    constructor() {\r\n        // initial default protocol handlers in this instantiation\r\n        this.enabledProtocols = enabledProtocols\r\n        this.protocolHandlers = protocolHandlers\r\n        this.protocolScriptCheckers = protocolScriptCheckers\r\n        this.protocolOpReturnSchemas = protocolOpReturnSchemas\r\n    }\r\n\r\n    addProtocolHandler({\r\n        name,\r\n        address,\r\n        opReturnSchema,\r\n        handler,\r\n        scriptChecker,\r\n    }: Protocol) {\r\n        if (address) {\r\n            this.enabledProtocols.set(address, name)\r\n        }\r\n        this.protocolHandlers.set(name, handler)\r\n        if (opReturnSchema) {\r\n            this.protocolOpReturnSchemas.set(name, opReturnSchema)\r\n        }\r\n        if (scriptChecker) {\r\n            this.protocolScriptCheckers.set(name, scriptChecker)\r\n        }\r\n    }\r\n\r\n    transformTx = async (tx: BobTx | MomTx): Promise<BmapTx> => {\r\n        if (!tx || !tx['in'] || !tx['out']) {\r\n            throw new Error('Cannot process tx')\r\n        }\r\n\r\n        // This will become our nicely formatted response object\r\n        const dataObj: Partial<BobTx> = {}\r\n\r\n        for (const [key, val] of Object.entries(tx)) {\r\n            if (key === 'out') {\r\n                // loop over the outputs\r\n                for (const out of tx.out) {\r\n                    const { tape } = out\r\n\r\n                    if (tape?.some((cc) => checkOpFalseOpReturn(cc))) {\r\n                        // loop over tape\r\n                        for (const cellContainer of tape) {\r\n                            // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\r\n                            if (checkOpFalseOpReturn(cellContainer)) {\r\n                                continue\r\n                            }\r\n\r\n                            const { cell } = cellContainer\r\n                            if (!cell) {\r\n                                throw new Error('empty cell while parsing')\r\n                            }\r\n\r\n                            const prefix = cell[0].s\r\n\r\n                            await this.process(\r\n                                this.enabledProtocols.get(prefix || '') ||\r\n                                    prefix ||\r\n                                    '',\r\n                                {\r\n                                    cell,\r\n                                    dataObj: dataObj as BmapTx,\r\n                                    tape,\r\n                                    out,\r\n                                    tx,\r\n                                }\r\n                            )\r\n                        }\r\n                    } else {\r\n                        // No OP_FALSE OP_RETURN in this tape\r\n                        const boostChecker = this.protocolScriptCheckers.get(\r\n                            BOOST.name\r\n                        )\r\n                        const _21e8Checker = this.protocolScriptCheckers.get(\r\n                            _21E8.name\r\n                        )\r\n                        const ordChecker = this.protocolScriptCheckers.get(\r\n                            Ord.name\r\n                        )\r\n\r\n                        // Check for boostpow and 21e8\r\n                        if (\r\n                            tape?.some((cc) => {\r\n                                const { cell } = cc\r\n                                if (boostChecker && boostChecker(cell)) {\r\n                                    // 'found boost'\r\n                                    return true\r\n                                }\r\n                                if (_21e8Checker && _21e8Checker(cell)) {\r\n                                    // 'found 21e8'\r\n                                    return true\r\n                                }\r\n                                if (ordChecker && ordChecker(cell)) {\r\n                                    // 'found 1sat ordinal'\r\n                                    return true\r\n                                }\r\n                            })\r\n                        ) {\r\n                            // find the cell array\r\n                            // loop over tape\r\n                            for (const cellContainer of tape) {\r\n                                const { cell } = cellContainer\r\n                                // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\r\n                                if (!cell) {\r\n                                    throw new Error('empty cell while parsing')\r\n                                }\r\n                                let protocolName = ''\r\n                                if (boostChecker && boostChecker(cell)) {\r\n                                    protocolName = BOOST.name\r\n                                } else if (_21e8Checker && _21e8Checker(cell)) {\r\n                                    protocolName = _21E8.name\r\n                                } else if (ordChecker && ordChecker(cell)) {\r\n                                    protocolName = Ord.name\r\n                                } else {\r\n                                    // nothing found\r\n                                    continue\r\n                                }\r\n\r\n                                this.process(protocolName, {\r\n                                    tx,\r\n                                    cell,\r\n                                    dataObj: dataObj as BmapTx,\r\n                                    tape,\r\n                                    out,\r\n                                })\r\n                            }\r\n                        } else {\r\n                            this.processUnknown(key, dataObj, out)\r\n                        }\r\n                    }\r\n                }\r\n            } else if (key === 'in') {\r\n                // TODO: Boost check inputs to see if this is a tx solving a puzzle\r\n                // TODO: 21e8 check inputs to see if this is a tx solving a puzzle\r\n                dataObj[key] = val.map((v: In) => {\r\n                    const r = { ...v }\r\n                    delete r.tape\r\n                    return r\r\n                })\r\n            } else {\r\n                // known key, just write it retaining original type\r\n                dataObj[key] = val\r\n            }\r\n        }\r\n\r\n        // If this is a MOM planaria it will have metanet keys available\r\n        if (dataObj['METANET'] && (tx as MomTx).parent) {\r\n            const meta = {\r\n                ancestor: (tx as MomTx).ancestor,\r\n                parent: (tx as MomTx).parent,\r\n                child: (tx as MomTx).child,\r\n                head: (tx as MomTx).head,\r\n            } as MetaNet\r\n\r\n            ;(dataObj.METANET as MetaNet[]).push(meta)\r\n            // remove parent and node from root level for (MOM data)\r\n            delete dataObj.ancestor\r\n            delete dataObj.child\r\n            delete dataObj.parent\r\n            delete dataObj.head\r\n            delete dataObj.node\r\n        }\r\n\r\n        return dataObj as BmapTx\r\n    }\r\n\r\n    processUnknown = (key: string, dataObj: Partial<BmapTx>, out: Out) => {\r\n        // no known non-OP_RETURN scripts\r\n        if (key && !dataObj[key]) {\r\n            dataObj[key] = []\r\n        }\r\n\r\n        ;(dataObj[key] as Out[]).push({\r\n            i: out.i,\r\n            e: out.e,\r\n            tape: [],\r\n        })\r\n    }\r\n\r\n    process = async (\r\n        protocolName: string,\r\n        { cell, dataObj, tape, out, tx }: HandlerProps\r\n    ) => {\r\n        if (\r\n            this.protocolHandlers.has(protocolName) &&\r\n            typeof this.protocolHandlers.get(protocolName) === 'function'\r\n        ) {\r\n            const handler = this.protocolHandlers.get(protocolName)\r\n            if (handler) {\r\n                /* eslint-disable no-await-in-loop */\r\n                await handler({\r\n                    dataObj: dataObj,\r\n                    cell,\r\n                    tape,\r\n                    out,\r\n                    tx,\r\n                })\r\n            }\r\n        } else {\r\n            saveProtocolData(dataObj, protocolName, cell)\r\n        }\r\n    }\r\n}\r\n\r\nexport const fetchRawTx = async (txid: string): Promise<string> => {\r\n    const url = 'https://api.whatsonchain.com/v1/bsv/main/tx/' + txid + '/hex'\r\n\r\n    console.log('hitting', url)\r\n\r\n    const res = await fetch(url)\r\n    return await res.text()\r\n}\r\n\r\nexport const bobFromRawTx = async (rawTx: string): Promise<BobTx> => {\r\n    const bpuTx = await parse({\r\n        tx: { r: rawTx },\r\n        split: [\r\n            {\r\n                token: { op: 106 },\r\n                include: 'l',\r\n            },\r\n            {\r\n                token: { op: 0 },\r\n                include: 'l',\r\n            },\r\n            {\r\n                token: { s: '|' },\r\n            },\r\n        ],\r\n    })\r\n    return bpuTx as BobTx\r\n}\r\n\r\n// TransformTx\r\n// tx - a raw hex string or a Bob/Bmap/Mom transaction object\r\n// protocols - the handlers you want to load and use to process the tx\r\n// reducing the number of supported protocols may improve transform speed\r\n// at the expense of detecting more data protocols\r\nexport const TransformTx = async (\r\n    tx: BobTx | string | MomTx | BmapTx,\r\n    protocols?: string[] | Protocol[]\r\n) => {\r\n    if (typeof tx === 'string') {\r\n        let rawTx: string | undefined\r\n        // if it a txid or  complete transaction hex?\r\n        if (tx.length === 64) {\r\n            // txid - fetch raw tx\r\n            rawTx = await fetchRawTx(tx)\r\n        }\r\n\r\n        if (Buffer.from(tx).byteLength <= 146) {\r\n            throw new Error('Invalid rawTx')\r\n        }\r\n\r\n        if (!rawTx) {\r\n            rawTx = tx\r\n        }\r\n\r\n        // TODO: Double check 146 is intended to be minimum possible byte length for a tx\r\n        const bobTx = await bobFromRawTx(rawTx)\r\n\r\n        if (bobTx) {\r\n            tx = bobTx\r\n        } else {\r\n            throw new Error(`Invalid txid`)\r\n        }\r\n    }\r\n\r\n    const b = new BMAP()\r\n\r\n    // if protocols are specified\r\n    if (protocols) {\r\n        // wipe out defaults\r\n        b.enabledProtocols.clear()\r\n        if (isStringArray(protocols)) {\r\n            // set enabled protocols\r\n            for (const protocol of allProtocols) {\r\n                if ((protocols as string[])?.includes(protocol.name)) {\r\n                    b.addProtocolHandler(protocol)\r\n                }\r\n            }\r\n        } else if (isObjectArray(protocols)) {\r\n            for (const p of protocols) {\r\n                const protocol = p as Protocol\r\n                if (protocol) {\r\n                    b.addProtocolHandler(protocol)\r\n                }\r\n            }\r\n        } else {\r\n            throw new Error(\r\n                `Invalid protocol array. Must be either an array of protocol names (string[]), or Protocol objects (Protocol[]).`\r\n            )\r\n        }\r\n    }\r\n\r\n    return b.transformTx(tx)\r\n}\r\n","import { Address, Bsm, Script } from '@ts-bitcoin/core'\r\nimport { Buffer } from 'buffer'\r\nimport fetch from 'node-fetch'\r\nimport { BobTx, Cell, HandlerProps, Protocol, Tape } from '../../types/common'\r\nimport { AIP as AIPType } from '../../types/protocols/aip'\r\nimport { HAIP as HAIPType } from '../../types/protocols/haip'\r\n\r\nimport {\r\n    cellValue,\r\n    checkOpFalseOpReturn,\r\n    isBase64,\r\n    saveProtocolData,\r\n    sha256,\r\n} from '../utils'\r\n\r\nconst address = '15PciHG22SNLQJXMoSUaWVi7WSqc7hCfva'\r\n\r\nconst opReturnSchema = [\r\n    { algorithm: 'string' },\r\n    { address: 'string' },\r\n    { signature: 'binary' },\r\n    [{ index: 'binary' }],\r\n]\r\n\r\nconst getFileBuffer = async function (bitfsRef: string) {\r\n    let fileBuffer = Buffer.from('')\r\n    try {\r\n        const result = await fetch(`https://x.bitfs.network/${bitfsRef}`, {})\r\n        fileBuffer = await result.buffer()\r\n    } catch (e) {\r\n        console.error(e)\r\n    }\r\n\r\n    return fileBuffer\r\n}\r\n\r\nconst validateSignature = async function (\r\n    aipObj: Partial<AIPType | HAIPType>,\r\n    cell: Cell[],\r\n    tape: Tape[]\r\n): Promise<boolean> {\r\n    if (!Array.isArray(tape) || tape.length < 3) {\r\n        throw new Error('AIP requires at least 3 cells including the prefix')\r\n    }\r\n\r\n    let cellIndex = -1\r\n    tape.forEach((cc, index) => {\r\n        if (cc.cell === cell) {\r\n            cellIndex = index\r\n        }\r\n    })\r\n    if (cellIndex === -1) {\r\n        throw new Error('AIP could not find cell in tape')\r\n    }\r\n\r\n    let usingIndexes: number[] = aipObj.index || []\r\n    const signatureValues = ['6a'] // OP_RETURN - is included in AIP\r\n    for (let i = 0; i < cellIndex; i++) {\r\n        const cellContainer = tape[i]\r\n        if (!checkOpFalseOpReturn(cellContainer)) {\r\n            for (let nc = 0; nc < cellContainer.cell.length; nc++) {\r\n                const statement = cellContainer.cell[nc]\r\n                // add the value as hex\r\n                if (statement.h) {\r\n                    signatureValues.push(statement.h)\r\n                } else if (statement.f) {\r\n                    // file reference - we need to get the file from bitfs\r\n                    const fileBuffer = await getFileBuffer(statement.f)\r\n                    signatureValues.push(fileBuffer.toString('hex'))\r\n                } else if (statement.b) {\r\n                    // no hex? try base64\r\n                    signatureValues.push(\r\n                        Buffer.from(statement.b, 'base64').toString('hex')\r\n                    )\r\n                } else {\r\n                    if (statement.s) {\r\n                        signatureValues.push(\r\n                            Buffer.from(statement.s).toString('hex')\r\n                        )\r\n                    }\r\n                }\r\n            }\r\n            signatureValues.push('7c') // | hex\r\n        }\r\n    }\r\n\r\n    if (aipObj.hashing_algorithm) {\r\n        // when using HAIP, we need to parse the indexes in a non standard way\r\n        // indexLength is byte size of the indexes being described\r\n        if (aipObj.index_unit_size) {\r\n            const indexLength = aipObj.index_unit_size * 2\r\n            usingIndexes = []\r\n            const indexes = cell[6].h as string\r\n            for (let i = 0; i < indexes.length; i += indexLength) {\r\n                usingIndexes.push(parseInt(indexes.substr(i, indexLength), 16))\r\n            }\r\n            aipObj.index = usingIndexes\r\n        }\r\n    }\r\n\r\n    const signatureBufferStatements: Buffer[] = []\r\n    // check whether we need to only sign some indexes\r\n    if (usingIndexes.length > 0) {\r\n        usingIndexes.forEach((index) => {\r\n            signatureBufferStatements.push(\r\n                Buffer.from(signatureValues[index], 'hex')\r\n            )\r\n        })\r\n    } else {\r\n        // add all the values to the signature buffer\r\n        signatureValues.forEach((statement) => {\r\n            signatureBufferStatements.push(Buffer.from(statement, 'hex'))\r\n        })\r\n    }\r\n\r\n    let messageBuffer: Buffer | string\r\n    if (aipObj.hashing_algorithm) {\r\n        // this is actually Hashed-AIP (HAIP) and works a bit differently\r\n        if (!aipObj.index_unit_size) {\r\n            // remove OP_RETURN - will be added by Script.buildDataOut\r\n            signatureBufferStatements.shift()\r\n        }\r\n        const dataScript = Script.fromSafeDataArray(signatureBufferStatements)\r\n        let dataBuffer = Buffer.from(dataScript.toHex(), 'hex')\r\n        if (aipObj.index_unit_size) {\r\n            // the indexed buffer should not contain the OP_RETURN opcode, but this\r\n            // is added by the buildDataOut function automatically. Remove it.\r\n            dataBuffer = dataBuffer.slice(1)\r\n        }\r\n        messageBuffer = await sha256(Buffer.from(dataBuffer.toString('hex')))\r\n    } else {\r\n        // regular AIP\r\n        messageBuffer = Buffer.concat([...signatureBufferStatements])\r\n    }\r\n\r\n    // AIOP uses address, HAIP uses signing_address field names\r\n    const adressString =\r\n        (aipObj as AIPType).address || (aipObj as HAIPType).signing_address\r\n    // verify aip signature\r\n    try {\r\n        aipObj.verified = Bsm.verify(\r\n            messageBuffer,\r\n            aipObj.signature || '',\r\n            Address.fromString(adressString)\r\n        )\r\n    } catch (e) {\r\n        aipObj.verified = false\r\n    }\r\n\r\n    // Try if this is a Twetch compatible AIP signature\r\n    if (!aipObj.verified) {\r\n        // Twetch signs a UTF-8 buffer of the hex string of a sha256 hash of the message\r\n        // Without 0x06 (OP_RETURN) and without 0x7c at the end, the trailing pipe (\"|\")\r\n\r\n        messageBuffer = Buffer.concat([\r\n            ...signatureBufferStatements.slice(\r\n                1,\r\n                signatureBufferStatements.length - 1\r\n            ),\r\n        ])\r\n        const buff = await sha256(messageBuffer)\r\n        messageBuffer = Buffer.from(buff.toString('hex'))\r\n        try {\r\n            aipObj.verified = Bsm.verify(\r\n                messageBuffer,\r\n                aipObj.signature || '',\r\n                Address.fromString(adressString)\r\n            )\r\n        } catch (e) {\r\n            aipObj.verified = false\r\n        }\r\n    }\r\n\r\n    return aipObj.verified || false\r\n}\r\n\r\nexport const enum SIGPROTO {\r\n    HAIP = 'HAIP',\r\n    AIP = 'AIP',\r\n    BITCOM_HASHED = 'BITCOM_HASHED',\r\n    PSP = 'PSP',\r\n}\r\n\r\nexport const AIPhandler = async function (\r\n    useOpReturnSchema: Object[],\r\n    protocol: SIGPROTO,\r\n    dataObj: Object,\r\n    cell: Cell[],\r\n    tape: Tape[],\r\n    tx: BobTx\r\n) {\r\n    // loop over the schema\r\n    const aipObj: { [key: string]: number | number[] | string } = {}\r\n\r\n    // Does not have the required number of fields\r\n    if (cell.length < 4) {\r\n        throw new Error(\r\n            'AIP requires at least 4 fields including the prefix ' + tx\r\n        )\r\n    }\r\n\r\n    for (const [idx, schemaField] of Object.entries(useOpReturnSchema)) {\r\n        const x = parseInt(idx, 10)\r\n\r\n        let schemaEncoding\r\n        let aipField: keyof AIPType\r\n        if (schemaField instanceof Array) {\r\n            // signature indexes are specified\r\n            schemaEncoding = schemaField[0].index\r\n            ;[aipField] = Object.keys(schemaField[0]) as (keyof AIPType)[]\r\n            // run through the rest of the fields in this cell, should be de indexes\r\n            const fieldData: number[] = []\r\n            for (let i = x + 1; i < cell.length; i++) {\r\n                if (cell[i].h && Array.isArray(fieldData)) {\r\n                    fieldData.push(parseInt(cell[i].h || '', 16))\r\n                }\r\n            }\r\n            aipObj[aipField] = fieldData\r\n            continue\r\n        } else {\r\n            ;[aipField] = Object.keys(schemaField) as (keyof AIPType)[]\r\n            ;[schemaEncoding] = Object.values(schemaField)\r\n        }\r\n\r\n        aipObj[aipField] = cellValue(cell[x + 1], schemaEncoding) || ''\r\n    }\r\n\r\n    // There is an issue where some services add the signature as binary to the transaction\r\n    // whereas others add the signature as base64. This will confuse bob and the parser and\r\n    // the signature will not be verified. When the signature is added in binary cell[3].s is\r\n    // binary, otherwise cell[3].s contains the base64 signature and should be used.\r\n    if (cell[0].s === address && cell[3].s && isBase64(cell[3].s)) {\r\n        aipObj.signature = cell[3].s\r\n    }\r\n\r\n    if (!aipObj.signature) {\r\n        throw new Error('AIP requires a signature ' + tx)\r\n    }\r\n\r\n    if (!(await validateSignature(aipObj as Partial<AIPType>, cell, tape))) {\r\n        // throw new Error('AIP requires a valid signature', tx);\r\n    }\r\n\r\n    saveProtocolData(dataObj, protocol, aipObj)\r\n}\r\n\r\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\r\n    if (!tape) {\r\n        throw new Error('Invalid AIP transaction. tape is required')\r\n    }\r\n    if (!tx) {\r\n        throw new Error('Invalid AIP transaction. tx is required')\r\n    }\r\n    return await AIPhandler(\r\n        opReturnSchema,\r\n        SIGPROTO.AIP,\r\n        dataObj,\r\n        cell,\r\n        tape,\r\n        tx\r\n    )\r\n}\r\n\r\nexport const AIP: Protocol = {\r\n    name: 'AIP',\r\n    address,\r\n    opReturnSchema,\r\n    handler,\r\n}\r\n","import { Buffer } from 'buffer'\r\nimport crypto from 'crypto'\r\nimport { BobTx, Cell, Tape } from '../types/common'\r\n\r\nexport const isStringArray = (arr: Array<any>): boolean => {\r\n    return (\r\n        arr.length > 0 &&\r\n        arr.every((value) => {\r\n            return typeof value === 'string'\r\n        })\r\n    )\r\n}\r\nexport const isObjectArray = (arr: Array<any>): boolean => {\r\n    return (\r\n        arr.length > 0 &&\r\n        arr.every((value) => {\r\n            return value === 'object'\r\n        })\r\n    )\r\n}\r\n/**\r\n * returns the BOB cell value for a given encoding\r\n *\r\n * @param pushData\r\n * @param schemaEncoding\r\n * @returns {string|number}\r\n */\r\nexport const cellValue = (\r\n    pushData: Cell,\r\n    schemaEncoding?: string\r\n): string | number => {\r\n    if (!pushData) {\r\n        throw new Error(`cannot get cell value of: ${pushData}`)\r\n    } else if (schemaEncoding === 'string') {\r\n        return pushData['s'] ? pushData.s : pushData.ls || ''\r\n    } else if (schemaEncoding === 'hex') {\r\n        return pushData['h']\r\n            ? pushData.h\r\n            : pushData.lh ||\r\n                  (pushData['b']\r\n                      ? Buffer.from(pushData.b, 'base64').toString('hex')\r\n                      : pushData.lb &&\r\n                        Buffer.from(pushData.lb, 'base64').toString('hex')) ||\r\n                  ''\r\n    } else if (schemaEncoding === 'number') {\r\n        return parseInt(pushData['h'] ? pushData.h : pushData.lh || '0', 16)\r\n    } else if (schemaEncoding === 'file') {\r\n        return `bitfs://${pushData['f'] ? pushData.f : pushData.lf}`\r\n    }\r\n\r\n    return (pushData['b'] ? pushData.b : pushData.lb) || ''\r\n}\r\n\r\n/**\r\n * Check a cell starts with OP_FALSE OP_RETURN -or- OP_RETURN\r\n *\r\n * @param cc\r\n * @returns {boolean}\r\n */\r\nexport const checkOpFalseOpReturn = function (cc: Tape) {\r\n    return (\r\n        (cc.cell[0] &&\r\n            cc.cell[1] &&\r\n            cc.cell[0].op === 0 &&\r\n            cc.cell[1].op &&\r\n            cc.cell[1].op === 106) ||\r\n        cc.cell[0].op === 106\r\n    )\r\n}\r\n\r\n/**\r\n * Helper function to store protocol data\r\n *\r\n * @param dataObj\r\n * @param protocolName\r\n * @param data\r\n */\r\nexport const saveProtocolData = (\r\n    dataObj: { [key: string]: any },\r\n    protocolName: string,\r\n    data: any\r\n) => {\r\n    if (!dataObj[protocolName]) {\r\n        dataObj[protocolName] = [data]\r\n    } else {\r\n        if (!Array.isArray(dataObj[protocolName])) {\r\n            const prevData = dataObj[protocolName]\r\n            dataObj[protocolName] = []\r\n            dataObj[protocolName][0] = prevData\r\n        }\r\n        dataObj[protocolName][dataObj[protocolName].length] = data\r\n    }\r\n}\r\n\r\n/**\r\n * BMAP default handler to work with query schema's\r\n *\r\n * @param opReturnSchema\r\n * @param protocolName\r\n * @param dataObj\r\n * @param cell\r\n * @param tape\r\n * @param tx\r\n */\r\nexport const bmapOpReturnSchemaHandler = function (\r\n    protocolName: string,\r\n    opReturnSchema: Object[],\r\n    dataObj: Object,\r\n    cell: Cell[],\r\n    tx: BobTx\r\n) {\r\n    // loop over the schema\r\n    const obj: { [key: string]: any } = {}\r\n\r\n    // Does not have the required number of fields\r\n    const length = opReturnSchema.length + 1\r\n    if (cell.length < length) {\r\n        throw new Error(\r\n            `${protocolName} requires at least ${length} fields including the prefix: ${tx.tx.h}`\r\n        )\r\n    }\r\n\r\n    for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\r\n        const x = parseInt(idx, 10)\r\n\r\n        const [field] = Object.keys(schemaField)\r\n        const [schemaEncoding] = Object.values(schemaField)\r\n        obj[field] = cellValue(cell[x + 1], schemaEncoding)\r\n    }\r\n\r\n    saveProtocolData(dataObj, protocolName, obj)\r\n}\r\n\r\n/**\r\n * Check whether the given data is base64\r\n *\r\n * @param data\r\n * @returns {boolean}\r\n */\r\nexport const isBase64 = function (data: string) {\r\n    const regex =\r\n        '(?:[A-Za-z0-9+\\\\/]{4})*(?:[A-Za-z0-9+\\\\/]{2}==|[A-Za-z0-9+/]{3}=)?'\r\n    return new RegExp(`^${regex}$`, 'gi').test(data)\r\n}\r\n\r\n// hashes a message buffer, returns the hash as a buffer\r\nexport const sha256 = async (msgBuffer: Buffer) => {\r\n    let hash: ArrayBuffer\r\n\r\n    if (crypto.subtle) {\r\n        hash = await crypto.subtle.digest('SHA-256', msgBuffer)\r\n        return Buffer.from(hash)\r\n    }\r\n    // }\r\n    return Buffer.from(new ArrayBuffer(0))\r\n}\r\n","import { HandlerProps, Protocol } from '../../types/common'\r\nimport { cellValue, saveProtocolData } from '../utils'\r\n\r\nconst address = '19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut'\r\n\r\nconst opReturnSchema = [\r\n    { content: ['string', 'binary', 'file'] },\r\n    { 'content-type': 'string' },\r\n    { encoding: 'string' }, // we use this field to determine content character encoding. If encoding is not a valid character encoding (gzip), we assume it is binary\r\n    { filename: 'string' },\r\n]\r\n\r\nconst handler = function ({ dataObj, cell, tx }: HandlerProps): void {\r\n    const encodingMap = new Map<string, string>()\r\n    encodingMap.set('utf8', 'string')\r\n    encodingMap.set('text', 'string') // invalid but people use it :(\r\n    encodingMap.set('gzip', 'binary') // invalid but people use it :(\r\n    encodingMap.set('text/plain', 'string')\r\n    encodingMap.set('image/png', 'binary')\r\n    encodingMap.set('image/jpeg', 'binary')\r\n\r\n    if (!cell[1] || !cell[2]) {\r\n        throw new Error(`Invalid B tx: ${tx}`)\r\n    }\r\n\r\n    // Check pushdata length + 1 for protocol prefix\r\n    if (cell.length > opReturnSchema.length + 1) {\r\n        throw new Error('Invalid B tx. Too many fields.')\r\n    }\r\n\r\n    // Make sure there are not more fields than possible\r\n\r\n    const bObj: { [key: string]: string | number | undefined } = {}\r\n    // loop over the schema\r\n    for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\r\n        const x = parseInt(idx, 10)\r\n        const bField = Object.keys(schemaField)[0]\r\n        let schemaEncoding = Object.values(schemaField)[0]\r\n        if (bField === 'content') {\r\n            // If the encoding is ommitted, try to infer from content-type instead of breaking\r\n            if (cell[1].f) {\r\n                // this is file reference to B files\r\n                schemaEncoding = 'file'\r\n            } else if ((!cell[3] || !cell[3].s) && cell[2].s) {\r\n                schemaEncoding = encodingMap.get(cell[2].s)\r\n                if (!schemaEncoding) {\r\n                    console.warn(\r\n                        'Problem inferring encoding. Malformed B data.',\r\n                        cell\r\n                    )\r\n                    return\r\n                }\r\n\r\n                // add the missing encoding field\r\n                if (!cell[3]) {\r\n                    cell[3] = { h: '', b: '', s: '', i: 0, ii: 0 }\r\n                }\r\n                cell[3].s = schemaEncoding === 'string' ? 'utf-8' : 'binary'\r\n            } else {\r\n                schemaEncoding =\r\n                    cell[3] && cell[3].s\r\n                        ? encodingMap.get(\r\n                              cell[3].s.replace('-', '').toLowerCase()\r\n                          )\r\n                        : null\r\n            }\r\n        }\r\n\r\n        // encoding is not required\r\n        if (bField === 'encoding' && !cell[x + 1]) {\r\n            // encoding omitted\r\n            continue\r\n        }\r\n\r\n        // filename is not required\r\n        if (bField === 'filename' && !cell[x + 1]) {\r\n            // filename omitted\r\n            continue\r\n        }\r\n\r\n        // check for malformed syntax\r\n        if (!cell || !cell[x + 1]) {\r\n            throw new Error('malformed B syntax ' + cell)\r\n        }\r\n\r\n        // set field value from either s, b, ls, or lb depending on encoding and availability\r\n        const data = cell[x + 1]\r\n        bObj[bField] = cellValue(data, schemaEncoding)\r\n    }\r\n\r\n    saveProtocolData(dataObj, 'B', bObj)\r\n}\r\n\r\nexport const B: Protocol = {\r\n    name: 'B',\r\n    address,\r\n    opReturnSchema,\r\n    handler,\r\n}\r\n","import { HandlerProps, Protocol } from '../../types/common'\r\nimport { bmapOpReturnSchemaHandler } from '../utils'\r\n\r\nconst address = '1BAPSuaPnfGnSBM3GLV9yhxUdYe4vGbdMT'\r\n\r\nconst opReturnSchema = [\r\n    { type: 'string' },\r\n    { hash: 'string' },\r\n    { sequence: 'string' },\r\n]\r\n\r\nexport const handler = ({ dataObj, cell, tx }: HandlerProps) => {\r\n    if (!tx) {\r\n        throw new Error(`Invalid BAP tx, tx required`)\r\n    }\r\n    bmapOpReturnSchemaHandler('BAP', opReturnSchema, dataObj, cell, tx)\r\n}\r\n\r\nexport const BAP: Protocol = {\r\n    name: 'BAP',\r\n    address,\r\n    opReturnSchema,\r\n    handler,\r\n}\r\n","import { HandlerProps, Protocol } from '../../types/common'\r\nimport { saveProtocolData } from '../utils'\r\n\r\nconst protocolAddress = '$'\r\n\r\nconst opReturnSchema = [\r\n    {\r\n        su: [\r\n            { pubkey: 'string' },\r\n            { sign_position: 'string' },\r\n            { signature: 'string' },\r\n        ],\r\n        echo: [{ data: 'string' }, { to: 'string' }, { filename: 'string' }],\r\n        route: [\r\n            [\r\n                {\r\n                    add: [\r\n                        { bitcom_address: 'string' },\r\n                        { route_matcher: 'string' },\r\n                        { endpoint_template: 'string' },\r\n                    ],\r\n                },\r\n                {\r\n                    enable: [{ path: 'string' }],\r\n                },\r\n            ],\r\n        ],\r\n        useradd: [{ address: 'string' }],\r\n    },\r\n]\r\n\r\n// const handler = function (dataObj, protocolName, cell, tape, tx) {\r\nconst handler = ({ dataObj, cell }: HandlerProps) => {\r\n    if (!cell.length || !cell.every((c) => c.s)) {\r\n        throw new Error('Invalid Bitcom tx')\r\n    }\r\n\r\n    // gather up the string values\r\n    const bitcomObj = cell.map((c) => (c && c.s ? c.s : ''))\r\n\r\n    saveProtocolData(dataObj, 'BITCOM', bitcomObj)\r\n}\r\n\r\nexport const BITCOM: Protocol = {\r\n    name: 'BITCOM',\r\n    address: protocolAddress,\r\n    opReturnSchema,\r\n    handler,\r\n}\r\n","import { HandlerProps, Protocol } from '../../types/common'\r\nimport { SIGPROTO } from './aip'\r\nimport { PSPhandler } from './psp'\r\n\r\nconst address = '15igChEkUWgx4dsEcSuPitcLNZmNDfUvgA'\r\n\r\n// should be very similar to PSP\r\n// see https://bsvalias.org/05-verify-public-key-owner.html\r\n\r\n// TODO: Really need some documentation ro to verify what these fields are\r\nconst opReturnSchema = [\r\n    { hash: 'string' }, // sha256?\r\n    { signature: 'string' }, // not sure\r\n    { pubkey: 'binary' }, // not sure\r\n    { paymail: 'string' },\r\n]\r\n\r\nconst handler = async ({ dataObj, cell, tape }: HandlerProps) => {\r\n    if (!tape) {\r\n        throw new Error(`Invalid BITCOM_HASHED tx. Bad tape`)\r\n    }\r\n\r\n    return await PSPhandler(\r\n        opReturnSchema,\r\n        SIGPROTO.BITCOM_HASHED,\r\n        dataObj,\r\n        cell,\r\n        tape\r\n    )\r\n}\r\n\r\nexport const BITCOM_HASHED: Protocol = {\r\n    name: 'BITCOM_HASHED',\r\n    address,\r\n    opReturnSchema,\r\n    handler,\r\n}\r\n","import { Address, Bsm, PubKey, Script } from '@ts-bitcoin/core'\r\nimport { Buffer } from 'buffer'\r\nimport { Cell, HandlerProps, Protocol, Tape } from '../../types/common'\r\nimport { BITCOM_HASHED } from '../../types/protocols/bitcomHashed'\r\nimport { PSP as PSPType } from '../../types/protocols/psp'\r\nimport { verifyPaymailPublicKey } from '../paymail'\r\nimport { cellValue, checkOpFalseOpReturn, saveProtocolData } from '../utils'\r\nimport { SIGPROTO } from './aip'\r\n\r\nconst address = '1signyCizp1VyBsJ5Ss2tEAgw7zCYNJu4'\r\n\r\nconst opReturnSchema = [\r\n    { signature: 'string' },\r\n    { pubkey: 'string' },\r\n    { paymail: 'string' },\r\n]\r\n\r\nconst validateSignature = (pspObj: PSPType, cell: Cell[], tape: Tape[]) => {\r\n    if (!Array.isArray(tape) || tape.length < 3) {\r\n        throw new Error('PSP requires at least 3 cells including the prefix')\r\n    }\r\n\r\n    let cellIndex = -1\r\n    tape.forEach((cc, index) => {\r\n        if (cc.cell === cell) {\r\n            cellIndex = index\r\n        }\r\n    })\r\n    if (cellIndex === -1) {\r\n        throw new Error('PSP could not find cell in tape')\r\n    }\r\n\r\n    const signatureBufferStatements = []\r\n    for (let i = 0; i < cellIndex; i++) {\r\n        const cellContainer = tape[i]\r\n        if (!checkOpFalseOpReturn(cellContainer)) {\r\n            cellContainer.cell.forEach((statement) => {\r\n                // add the value as hex\r\n                let value = statement.h\r\n                if (!value) {\r\n                    value = Buffer.from(\r\n                        statement.b as string,\r\n                        'base64'\r\n                    ).toString('hex')\r\n                }\r\n                if (!value) {\r\n                    value = Buffer.from(statement.s as string).toString('hex')\r\n                }\r\n                signatureBufferStatements.push(Buffer.from(value, 'hex'))\r\n            })\r\n            signatureBufferStatements.push(Buffer.from('7c', 'hex')) // | hex ????\r\n        }\r\n    }\r\n    const dataScript = Script.fromSafeDataArray(signatureBufferStatements)\r\n    const messageBuffer = Buffer.from(dataScript.toHex(), 'hex')\r\n\r\n    // verify psp signature\r\n    const publicKey = PubKey.fromString(pspObj.pubkey)\r\n    const signingAddress = Address.fromPubKey(publicKey)\r\n    try {\r\n        pspObj.verified = Bsm.verify(\r\n            messageBuffer,\r\n            pspObj.signature,\r\n            signingAddress\r\n        )\r\n    } catch (e) {\r\n        pspObj.verified = false\r\n    }\r\n\r\n    return pspObj.verified\r\n}\r\n\r\nconst handler = async ({ dataObj, cell, tape }: HandlerProps) => {\r\n    // Paymail Signature Protocol\r\n    // Validation\r\n    if (\r\n        !cell.length ||\r\n        cell[0].s !== address ||\r\n        !cell[1] ||\r\n        !cell[2] ||\r\n        !cell[3] ||\r\n        !cell[1].b ||\r\n        !cell[2].s ||\r\n        !cell[3].s ||\r\n        !tape\r\n    ) {\r\n        throw new Error(`Invalid Paymail Signature Protocol record`)\r\n    }\r\n\r\n    return await PSPhandler(opReturnSchema, SIGPROTO.PSP, dataObj, cell, tape)\r\n}\r\n\r\nexport const PSPhandler = async (\r\n    useOpReturnSchema: Object[],\r\n    protocol: SIGPROTO,\r\n    dataObj: Object,\r\n    cell: Cell[],\r\n    tape: Tape[]\r\n) => {\r\n    // loop over the schema\r\n    const pspObj: Partial<PSPType | BITCOM_HASHED> = {\r\n        verified: false,\r\n    }\r\n\r\n    // Does not have the required number of fields\r\n    if (cell.length < 4) {\r\n        throw new Error(\r\n            'PSP requires at least 4 fields including the prefix ' + cell\r\n        )\r\n    }\r\n\r\n    for (const [idx, schemaField] of Object.entries(useOpReturnSchema)) {\r\n        const x = parseInt(idx, 10)\r\n\r\n        const [pspField] = Object.keys(schemaField) as (keyof PSPType)[]\r\n        const [schemaEncoding] = Object.values(schemaField) as string[]\r\n\r\n        ;(pspObj as any)[pspField] = cellValue(cell[x + 1], schemaEncoding)\r\n    }\r\n\r\n    if (!pspObj.signature) {\r\n        throw new Error('PSP requires a signature ' + cell)\r\n    }\r\n\r\n    //  TODO: we can only check on PSP until we figure out the BITCOM_HASHED fields\r\n    //  verify signature\r\n    if (\r\n        protocol === SIGPROTO.PSP &&\r\n        !validateSignature(pspObj as PSPType, cell, tape)\r\n    ) {\r\n        throw new Error('PSP requires a valid signature ' + pspObj)\r\n    }\r\n\r\n    // check the paymail public key\r\n    if (pspObj.pubkey && pspObj.paymail) {\r\n        const paymailPublicKeyVerified = await verifyPaymailPublicKey(\r\n            pspObj.paymail,\r\n            pspObj.pubkey\r\n        )\r\n        pspObj.verified = (pspObj.verified &&\r\n            paymailPublicKeyVerified) as boolean\r\n    }\r\n\r\n    saveProtocolData(dataObj, protocol, pspObj)\r\n}\r\n\r\n// TODO: Add concept of validators so they can be passed in / reused more easily\r\nexport const PSP: Protocol = {\r\n    name: 'PSP',\r\n    address,\r\n    opReturnSchema,\r\n    handler,\r\n}\r\n","/// <reference path=\"../types/paymail-client/index.d.ts\"/>\r\nimport { PaymailClient } from '@moneybutton/paymail-client'\r\n/// <reference path=\"../types/paymail-client/index.d.ts\"/>\r\nexport { PaymailClient } from '@moneybutton/paymail-client'\r\n\r\nimport dns from 'dns'\r\nimport fetch from 'node-fetch'\r\n\r\nexport const verifyPaymailPublicKey = async function (\r\n    paymail: string,\r\n    publicKey: string\r\n): Promise<boolean> {\r\n    if (typeof window !== 'undefined') {\r\n        // Paymail client will use BrowserDns if dns is null here\r\n        // and isomorphic-fetch if fetch is null\r\n        const client = new PaymailClient()\r\n        return client.verifyPubkeyOwner(publicKey, paymail)\r\n    } else {\r\n        const client = new PaymailClient(dns, fetch)\r\n        return client.verifyPubkeyOwner(publicKey, paymail)\r\n    }\r\n}\r\n","import { Address, Bsm, PubKey } from '@ts-bitcoin/core'\r\nimport { Buffer } from 'buffer'\r\nimport { HandlerProps, Protocol } from '../../types/common'\r\nimport { cellValue, saveProtocolData, sha256 } from '../utils'\r\n\r\nconst address = '13SrNDkVzY5bHBRKNu5iXTQ7K7VqTh5tJC'\r\n\r\nconst opReturnSchema = [\r\n    { bitkey_signature: 'string' },\r\n    { user_signature: 'string' },\r\n    { paymail: 'string' },\r\n    { pubkey: 'string' },\r\n]\r\n\r\n// const handler = function (dataObj, cell, tape, tx) {\r\n// https://bitkey.network/how\r\nconst handler = async ({ dataObj, cell }: HandlerProps) => {\r\n    if (!cell.length) {\r\n        throw new Error('Invalid Bitkey tx')\r\n    }\r\n\r\n    const bitkeyObj: { [key: string]: string | boolean } = {}\r\n\r\n    // loop over the schema\r\n    for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\r\n        const x = parseInt(idx, 10)\r\n        const bitkeyField = Object.keys(schemaField)[0]\r\n        const schemaEncoding = Object.values(schemaField)[0]\r\n        bitkeyObj[bitkeyField] = cellValue(\r\n            cell[x + 1],\r\n            schemaEncoding\r\n        ) as string\r\n    }\r\n\r\n    const userAddress = Address.fromPubKey(\r\n        PubKey.fromString(bitkeyObj.pubkey as string)\r\n    ).toString()\r\n\r\n    // sha256( hex(paymail(USER)) | hex(pubkey(USER)) )\r\n    const paymailHex = Buffer.from(bitkeyObj.paymail as string).toString('hex')\r\n    const pubkeyHex = Buffer.from(bitkeyObj.pubkey as string).toString('hex')\r\n    const concatenated = paymailHex + pubkeyHex\r\n    const bitkeySignatureBuffer = await sha256(Buffer.from(concatenated, 'hex'))\r\n\r\n    const bitkeySignatureVerified = Bsm.verify(\r\n        bitkeySignatureBuffer,\r\n        bitkeyObj.bitkey_signature as string,\r\n        Address.fromString('13SrNDkVzY5bHBRKNu5iXTQ7K7VqTh5tJC')\r\n    )\r\n    const userSignatureVerified = Bsm.verify(\r\n        Buffer.from(bitkeyObj.pubkey as string),\r\n        bitkeyObj.user_signature as string,\r\n        Address.fromString(userAddress)\r\n    )\r\n    bitkeyObj.verified = bitkeySignatureVerified && userSignatureVerified\r\n\r\n    saveProtocolData(dataObj, 'BITKEY', bitkeyObj)\r\n}\r\n\r\nexport const BITKEY: Protocol = {\r\n    name: 'BITKEY',\r\n    address,\r\n    opReturnSchema,\r\n    handler,\r\n}\r\n","import { Address, Bsm, PubKey } from '@ts-bitcoin/core'\r\nimport { Buffer } from 'buffer'\r\nimport { HandlerProps, Protocol } from '../../types/common'\r\nimport { BITPIC as BITPICType } from '../../types/protocols/bitpic'\r\nimport { saveProtocolData, sha256 } from '../utils'\r\n\r\nconst protocolAddress = '18pAqbYqhzErT6Zk3a5dwxHtB9icv8jH2p'\r\n\r\nconst opReturnSchema = [\r\n    { paymail: 'string' },\r\n    { pubkey: 'binary' },\r\n    { signature: 'string' },\r\n]\r\n\r\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\r\n    // Validation\r\n    if (\r\n        cell[0].s !== protocolAddress ||\r\n        !cell[1] ||\r\n        !cell[2] ||\r\n        !cell[3] ||\r\n        !cell[1].s ||\r\n        !cell[2].b ||\r\n        !cell[3].s ||\r\n        !tape\r\n    ) {\r\n        throw new Error(`Invalid BITPIC record: ${tx}`)\r\n    }\r\n\r\n    const bitpicObj: BITPICType = {\r\n        paymail: cell[1].s,\r\n        pubkey: Buffer.from(cell[2].b, 'base64').toString('hex'),\r\n        signature: cell[3].s || '',\r\n        verified: false,\r\n    }\r\n\r\n    const b = tape[1].cell\r\n    if (b[0].s === '19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut') {\r\n        // verify bitpic signature\r\n\r\n        // TODO: Verification\r\n        // const pubkey = Buffer.from(cell[2].b, 'base64').toString('hex')\r\n        // const address = Address.fromPubKey(PubKey.fromString(pubkey)).toString()\r\n        // const hex = Buffer.from(hash, 'hex')\r\n        // const verified = Message.verify(hex, address, expected)\r\n        // return verified\r\n\r\n        // const expected = res.cell[3].s\r\n        // const paymail = res.cell[1].s\r\n        // const pubkey = Buffer.from(res.cell[2].b, \"base64\").toString(\"hex\")\r\n        // const address = new bsv.PublicKey(pubkey).toAddress().toString()\r\n        // const hex = Buffer.from(res.hash, \"hex\")\r\n        // const verified = Message.verify(hex, address, expected)\r\n        // return verified\r\n\r\n        try {\r\n            // TODO: bob transactions are missing this binary part, cannot verify signature\r\n            const bin = (cell[1].lb || cell[1].b) as string\r\n            const buf = Buffer.from(bin, 'base64')\r\n            const hashBuff = await sha256(buf)\r\n            const address = Address.fromPubKey(\r\n                PubKey.fromString(bitpicObj.pubkey as string)\r\n            )\r\n\r\n            bitpicObj.verified = Bsm.verify(\r\n                hashBuff,\r\n                bitpicObj.signature,\r\n                address\r\n            )\r\n        } catch (e) {\r\n            // failed verification\r\n            bitpicObj.verified = false\r\n        }\r\n    }\r\n\r\n    saveProtocolData(dataObj, 'BITPIC', bitpicObj)\r\n}\r\n\r\nexport const BITPIC: Protocol = {\r\n    name: 'BITPIC',\r\n    address: protocolAddress,\r\n    opReturnSchema,\r\n    handler,\r\n}\r\n","import { BoostPowJob } from 'boostpow'\r\nimport { Cell, HandlerProps, Protocol } from '../../types/common'\r\nimport { cellValue, saveProtocolData } from '../utils'\r\n\r\nconst protocolIdentifier = 'boostpow'\r\n\r\n/*\r\n{\r\n    hash: '0000000086915e291fe43f10bdd8232f65e6eb64628bbb4d128be3836c21b6cc',\r\n    content: '00000000000000000000000000000000000000000048656c6c6f20776f726c64',\r\n    bits: 486604799,\r\n    difficulty: 1,\r\n    metadataHash: \"acd8278e84b037c47565df65a981d72fb09be5262e8783d4cf4e42633615962a\",\r\n    time: 1305200806,\r\n    nonce: 3698479534,\r\n    category: 1,\r\n}\r\n*/\r\n\r\nconst scriptChecker = (cell: Cell[]) => {\r\n    // protocol identifier always in first pushdata\r\n    return cell[0].s === protocolIdentifier\r\n}\r\n\r\nconst handler = ({ dataObj, cell, out, tx }: HandlerProps): void => {\r\n    if (!tx || !cell[0] || !out) {\r\n        throw new Error(\r\n            `Invalid BOOST tx. dataObj, cell, out and tx are required.`\r\n        )\r\n    }\r\n\r\n    // build ASM from either op codes and script chunks\r\n    const asm = cell\r\n        .map((c) => (c.ops ? c.ops : cellValue(c, 'hex') || ''))\r\n        .join(' ')\r\n\r\n    if (asm) {\r\n        const boostJob = BoostPowJob.fromASM(\r\n            asm,\r\n            tx.tx.h,\r\n            out.i,\r\n            out.e.v\r\n        ).toObject()\r\n\r\n        saveProtocolData(dataObj, 'BOOST', boostJob)\r\n    }\r\n}\r\n\r\nexport const BOOST: Protocol = {\r\n    name: 'BOOST',\r\n    handler,\r\n    address: protocolIdentifier,\r\n    scriptChecker,\r\n}\r\n","import { HandlerProps, Protocol } from '../../types/common'\r\nimport { AIPhandler, SIGPROTO } from './aip'\r\n\r\nconst address = '1HA1P2exomAwCUycZHr8WeyFoy5vuQASE3'\r\n\r\nconst opReturnSchema = [\r\n    { hashing_algorithm: 'string' },\r\n    { signing_algorithm: 'string' },\r\n    { signing_address: 'string' },\r\n    { signature: 'string' },\r\n    { index_unit_size: 'number' },\r\n    [{ index: 'binary' }],\r\n]\r\n\r\n// https://github.com/torusJKL/BitcoinBIPs/blob/master/HAIP.md\r\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\r\n    if (!tape) {\r\n        throw new Error(`Invalid HAIP tx. Bad tape`)\r\n    }\r\n    if (!tx) {\r\n        throw new Error(`Invalid HAIP tx.`)\r\n    }\r\n    return await AIPhandler(\r\n        opReturnSchema,\r\n        SIGPROTO.HAIP,\r\n        dataObj,\r\n        cell,\r\n        tape,\r\n        tx\r\n    )\r\n}\r\n\r\nexport const HAIP: Protocol = {\r\n    name: 'HAIP',\r\n    address,\r\n    opReturnSchema,\r\n    handler,\r\n}\r\n","import { decode } from '@msgpack/msgpack'\r\nimport { Buffer } from 'buffer'\r\nimport { Cell, HandlerProps, Protocol } from '../../types/common'\r\nimport { MAP as MAPType } from '../../types/protocols/map'\r\nimport { saveProtocolData } from '../utils'\r\n\r\nconst address = '1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5'\r\n\r\nconst opReturnSchema = [\r\n    {\r\n        cmd: {\r\n            SET: [{ key: 'string' }, { val: 'string' }],\r\n            SELECT: [{ tx: 'string' }],\r\n            ADD: [{ key: 'string' }, [{ val: 'string' }]],\r\n            DELETE: [{ key: 'string' }, [{ val: 'string' }]],\r\n            JSON: 'string',\r\n            REMOVE: [[{ key: 'string' }]],\r\n            CLEAR: [[{ txid: 'string' }]],\r\n        },\r\n    },\r\n]\r\n\r\nconst processADD = function (cell: Cell[], mapObj: MAPType) {\r\n    let last = null\r\n    for (const pushdataContainer of cell) {\r\n        // ignore MAP command\r\n        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\r\n            continue\r\n        }\r\n        const pushdata = pushdataContainer.s as string\r\n        if (pushdataContainer.i === 2) {\r\n            // Key name\r\n            mapObj[pushdata] = []\r\n            last = pushdata\r\n        } else {\r\n            if (last && Array.isArray(mapObj[last])) {\r\n                ;(mapObj[last] as string[]).push(pushdata)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nconst proccessDELETE = function (cell: Cell[], mapObj: MAPType) {\r\n    let last = null\r\n    for (const pushdataContainer of cell) {\r\n        // ignore MAP command\r\n        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\r\n            continue\r\n        }\r\n        const pushdata = pushdataContainer.s as string\r\n        if (pushdataContainer.i === 2) {\r\n            // Key name\r\n            mapObj[pushdata] = []\r\n            last = pushdata\r\n        } else {\r\n            if (last) {\r\n                ;(mapObj[last] as string[]).push(pushdata)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nconst processSELECT = function (cell: Cell[], mapObj: MAPType) {\r\n    // TODO\r\n    // console.log('MAP SELECT');\r\n    for (const pushdataContainer of cell) {\r\n        // ignore MAP command\r\n        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\r\n            mapObj.SELECT = 'TODO'\r\n            continue\r\n        }\r\n    }\r\n}\r\n\r\nconst processMSGPACK = function (cell: Cell[], mapObj: MAPType) {\r\n    for (const pushdataContainer of cell) {\r\n        // ignore MAP command\r\n        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\r\n            continue\r\n        }\r\n        if (pushdataContainer.i === 2) {\r\n            try {\r\n                if (!decode) {\r\n                    throw new Error('Msgpack is required but not loaded')\r\n                }\r\n                const buff = Buffer.from(\r\n                    pushdataContainer.b as string,\r\n                    'base64'\r\n                )\r\n                mapObj = decode(buff) as MAPType\r\n            } catch (e) {\r\n                mapObj = {} as MAPType\r\n            }\r\n        }\r\n    }\r\n    return mapObj\r\n}\r\n\r\nconst processJSON = function (cell: Cell[], mapObj: MAPType) {\r\n    for (const pushdataContainer of cell) {\r\n        // ignore MAP command\r\n        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\r\n            continue\r\n        }\r\n        if (pushdataContainer.i === 2) {\r\n            try {\r\n                mapObj = JSON.parse(pushdataContainer.s as string)\r\n            } catch (e) {\r\n                mapObj = {} as MAPType\r\n            }\r\n        }\r\n    }\r\n    return mapObj\r\n}\r\n\r\nconst processSET = function (cell: Cell[], mapObj: MAPType) {\r\n    let last = null\r\n    for (const pushdataContainer of cell) {\r\n        // ignore MAP command\r\n        if (\r\n            !pushdataContainer.s ||\r\n            pushdataContainer.i === 0 ||\r\n            pushdataContainer.i === 1\r\n        ) {\r\n            continue\r\n        }\r\n\r\n        const pushdata = pushdataContainer.s\r\n        if (pushdataContainer.i % 2 === 0) {\r\n            // key\r\n            mapObj[pushdata] = ''\r\n            last = pushdata\r\n        } else {\r\n            // value\r\n            if (!last) {\r\n                throw new Error(`malformed MAP syntax. Cannot parse.${last}`)\r\n            }\r\n            mapObj[last] = pushdata\r\n        }\r\n    }\r\n}\r\n\r\nconst handler = function ({ dataObj, cell, tx }: HandlerProps) {\r\n    // Validate\r\n    if (\r\n        cell[0].s !== address ||\r\n        !cell[1] ||\r\n        !cell[1].s ||\r\n        !cell[2] ||\r\n        !cell[2].s\r\n    ) {\r\n        throw new Error(`Invalid MAP record: ${tx}`)\r\n    }\r\n\r\n    let mapObj = {} as MAPType\r\n\r\n    // parse the protocol separator\r\n    const commands: any[] = []\r\n    let commandSeparator = 0\r\n    for (let i = 1; i < cell.length; i++) {\r\n        if (cell[i].s === ':::') {\r\n            commandSeparator++\r\n        } else {\r\n            if (!commands[commandSeparator]) commands[commandSeparator] = []\r\n            cell[i].i = commands[commandSeparator].length + 1\r\n            commands[commandSeparator].push(cell[i])\r\n        }\r\n    }\r\n\r\n    // Get the MAP command key name from the query schema\r\n    const mapCmdKey = Object.keys(opReturnSchema[0])[0]\r\n\r\n    // Add the firt MAP command in the response object\r\n    mapObj[mapCmdKey] = commands[0][0].s\r\n\r\n    commands.forEach((cc) => {\r\n        // re-add the MAP address\r\n        cc.unshift({\r\n            s: address,\r\n            i: 0,\r\n        })\r\n\r\n        const command = cc[1].s\r\n        // Individual parsing rules for each MAP command\r\n        switch (command) {\r\n            // Also check for SELECT commands and strip off the <SELECT> <TXID> part and run it through\r\n            case 'ADD': {\r\n                processADD(cc, mapObj)\r\n                break\r\n            }\r\n            case 'REMOVE': {\r\n                mapObj.key = cc[2].s\r\n                break\r\n            }\r\n            case 'DELETE': {\r\n                proccessDELETE(cc, mapObj)\r\n                break\r\n            }\r\n            case 'CLEAR': {\r\n                // TODO\r\n                // console.log('MAP CLEAR');\r\n                break\r\n            }\r\n            case 'SELECT': {\r\n                processSELECT(cc, mapObj)\r\n                break\r\n            }\r\n            case 'MSGPACK': {\r\n                mapObj = processMSGPACK(cc, mapObj)\r\n                break\r\n            }\r\n            case 'JSON': {\r\n                mapObj = processJSON(cc, mapObj)\r\n                break\r\n            }\r\n            case 'SET': {\r\n                processSET(cc, mapObj)\r\n                break\r\n            }\r\n            default: {\r\n                // don't know what to do ...\r\n            }\r\n        }\r\n    })\r\n\r\n    saveProtocolData(dataObj, 'MAP', mapObj)\r\n}\r\n\r\nexport const MAP: Protocol = {\r\n    name: 'MAP',\r\n    address,\r\n    opReturnSchema,\r\n    handler,\r\n}\r\n","import { Buffer } from 'buffer'\r\nimport {\r\n    HandlerProps,\r\n    MetaNet,\r\n    MetanetNode,\r\n    Protocol,\r\n} from '../../types/common'\r\nimport { sha256 } from '../utils'\r\n\r\nconst address = 'meta'\r\n\r\nconst opReturnSchema = [\r\n    { address: 'string' },\r\n    { parent: 'string' },\r\n    { name: 'string' },\r\n]\r\n\r\nexport const getEnvSafeMetanetID = async function (a: string, tx: string) {\r\n    // Calculate the node ID\r\n    const buf = Buffer.from(a + tx)\r\n    const hashBuf = await sha256(buf)\r\n    return hashBuf.toString('hex')\r\n}\r\n\r\nconst handler = async ({ dataObj, cell, tx }: HandlerProps) => {\r\n    if (\r\n        !cell.length ||\r\n        cell[0].s !== 'meta' ||\r\n        !cell[1] ||\r\n        !cell[1].s ||\r\n        !cell[2] ||\r\n        !cell[2].s ||\r\n        !tx\r\n    ) {\r\n        throw new Error('Invalid Metanet tx ' + tx)\r\n    }\r\n    // For now, we just copy from MOM keys later if available, or keep BOB format\r\n\r\n    const nodeId = await getEnvSafeMetanetID(cell[1].s, tx.tx.h)\r\n    // Described this node\r\n    const node = {\r\n        a: cell[1].s,\r\n        tx: tx.tx.h,\r\n        id: nodeId,\r\n    }\r\n    let parent = {} as MetanetNode\r\n    if (tx.in) {\r\n        const parentId = await getEnvSafeMetanetID(tx.in[0].e.a, cell[2].s)\r\n        // Parent node\r\n        parent = {\r\n            a: tx.in[0].e.a,\r\n            tx: cell[2].s,\r\n            id: parentId,\r\n        }\r\n    }\r\n\r\n    if (!dataObj.METANET) {\r\n        dataObj.METANET = []\r\n    }\r\n    dataObj.METANET.push({\r\n        node,\r\n        parent,\r\n    } as MetaNet)\r\n}\r\n\r\nexport const METANET: Protocol = {\r\n    name: 'METANET',\r\n    address,\r\n    opReturnSchema,\r\n    handler,\r\n}\r\n","import { findIndex } from 'lodash'\r\nimport { Cell, HandlerProps, Protocol } from '../../types/common'\r\nimport { Ord as OrdType } from '../../types/protocols/ord'\r\nimport { cellValue, saveProtocolData } from '../utils'\r\n\r\n// const OrdScript =\r\n//     'OP_FALSE OP_IF 6F7264 OP_1 <CONTENT_TYPE_PLACEHOLDER> OP_0 <DATA_PLACEHOLDER> OP_ENDIF'.split(\r\n//         ' '\r\n//     )\r\n\r\nconst scriptChecker = (cell: Cell[]) => {\r\n    // TODO: What is the actual minimum length?\r\n    if (cell.length < 11) {\r\n        // wrong length\r\n        return false\r\n    }\r\n\r\n    // Find OP_IF wrapper\r\n    const startIdx = findIndex(cell, (c) => c.ops === 'OP_IF')\r\n    const endIdx = findIndex(\r\n        cell,\r\n        (c, i) => i > startIdx && c.ops === 'OP_ENDIF'\r\n    )\r\n    const ordScript = cell.slice(startIdx, endIdx)\r\n    const prevCell = cell[startIdx - 1]\r\n    return (\r\n        prevCell?.ops === 'OP_FALSE' &&\r\n        !!ordScript[0] &&\r\n        !!ordScript[1] &&\r\n        ordScript[1].s == 'ord'\r\n    )\r\n}\r\n\r\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\r\n    if (!cell[0] || !out) {\r\n        throw new Error(\r\n            `Invalid Ord tx. dataObj, cell, out and tx are required.`\r\n        )\r\n    }\r\n\r\n    // assemble asm\r\n    // make sure first piece matches a txid\r\n    // 2nd piece matches any difficulty. set some resonable limit in bytes if there isnt one documented somewhere\r\n    // next\r\n\r\n    // Find OP_IF wrapper\r\n    const startIdx = findIndex(cell, (c) => c.ops === 'OP_IF')\r\n    const endIdx = findIndex(\r\n        cell,\r\n        (c, i) => i > startIdx && c.ops === 'OP_ENDIF'\r\n    )\r\n    const ordScript = cell.slice(startIdx, endIdx)\r\n\r\n    if (!ordScript[0] || !ordScript[1] || ordScript[1].s != 'ord') {\r\n        throw new Error(`Invalid Ord tx. Prefix not found.`)\r\n    }\r\n\r\n    console.log({ ordScript })\r\n\r\n    let data: string | undefined\r\n    let contentType: string | undefined\r\n    ordScript.forEach((push, idx, all) => {\r\n        // content-type\r\n        if (push.ops === 'OP_1') {\r\n            contentType = cellValue(all[idx + 1], 'string') as string\r\n        }\r\n        // data\r\n        if (push.ops === 'OP_0') {\r\n            data = cellValue(all[idx + 1]) as string\r\n        }\r\n    })\r\n\r\n    if (!data) {\r\n        throw new Error(`Invalid Ord data.`)\r\n    }\r\n    if (!contentType) {\r\n        throw new Error(`Invalid Ord content type.`)\r\n    }\r\n\r\n    const OrdObj: OrdType = {\r\n        data,\r\n        contentType,\r\n    }\r\n\r\n    saveProtocolData(dataObj, 'Ord', OrdObj)\r\n}\r\n\r\nexport const Ord: Protocol = {\r\n    name: 'Ord',\r\n    handler,\r\n    scriptChecker,\r\n}\r\n","import { HandlerProps, Protocol } from '../../types/common'\r\nimport { saveProtocolData } from '../utils'\r\n\r\nconst address = '1GvFYzwtFix3qSAZhESQVTz9DeudHZNoh1'\r\n\r\nconst opReturnSchema = [\r\n    { pair: 'json' },\r\n    { address: 'string' },\r\n    { timestamp: 'string' },\r\n]\r\n\r\nconst handler = function ({ dataObj, cell, tx }: HandlerProps) {\r\n    if (\r\n        cell[0].s !== address ||\r\n        !cell[1] ||\r\n        !cell[2] ||\r\n        !cell[3] ||\r\n        !cell[1].s ||\r\n        !cell[2].s ||\r\n        !cell[3].s\r\n    ) {\r\n        throw new Error(`Invalid RON record ${tx?.tx.h}`)\r\n    }\r\n\r\n    const pair = JSON.parse(cell[1].s)\r\n    const timestamp = Number(cell[3].s)\r\n\r\n    saveProtocolData(dataObj, 'RON', {\r\n        pair,\r\n        address: cell[2].s,\r\n        timestamp,\r\n    })\r\n}\r\n\r\nexport const RON: Protocol = {\r\n    name: 'RON',\r\n    address,\r\n    opReturnSchema,\r\n    handler,\r\n}\r\n","import { HandlerProps } from '../../types/common'\r\nimport { saveProtocolData } from '../utils'\r\n\r\nconst address = '1SymRe7erxM46GByucUWnB9fEEMgo7spd'\r\n\r\nconst opReturnSchema = [{ url: 'string' }]\r\n\r\nconst handler = function ({ dataObj, cell, tx }: HandlerProps) {\r\n    if (cell[0].s !== address || !cell[1] || !cell[1].s) {\r\n        throw new Error(`Invalid SymRe tx: ${tx}`)\r\n    }\r\n\r\n    saveProtocolData(dataObj, 'SYMRE', { url: cell[1].s })\r\n}\r\n\r\nexport const SYMRE = {\r\n    name: 'SYMRE',\r\n    address,\r\n    opReturnSchema,\r\n    handler,\r\n}\r\n","import { Cell, HandlerProps, Protocol } from '../../types/common'\r\nimport { _21E8 as _21E8Type } from '../../types/protocols/_21e8'\r\nimport { cellValue, saveProtocolData } from '../utils'\r\n\r\n// 21e8 does not use the first pushdata for id\r\n// in fact there is no id since the 21e8 is designed for difficulty and can be changed\r\n// instead we use the static part of the script to indentfy the transaction\r\n// TODO - the OP_X_PLACEHOLDER is the number of bytes to push onto the stack and must match difficulty size\r\nconst _21e8Script =\r\n    'OP_SIZE <OP_X_PLACEHOLDER> OP_PICK OP_SHA256 OP_SWAP OP_SPLIT OP_DROP OP_EQUALVERIFY OP_DROP OP_CHECKSIG'.split(\r\n        ' '\r\n    )\r\n\r\nconst scriptChecker = (cell: Cell[]) => {\r\n    if (cell.length !== 12) {\r\n        // wrong length\r\n        return false\r\n    }\r\n\r\n    // match exact script\r\n    const ops = [...cell].map((c) => c.ops).splice(2, cell.length)\r\n\r\n    // calculate target byte length\r\n    const target = cellValue(cell[1], 'hex') as string\r\n    const targetOpSize = Buffer.from(target).byteLength\r\n\r\n    // replace the placeholder opcode with actual\r\n    ops[1] = `OP_${targetOpSize}`\r\n    _21e8Script[1] = `OP_${targetOpSize}`\r\n\r\n    // protocol identifier always in first pushdata\r\n    return ops.join() === _21e8Script.join()\r\n}\r\n\r\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\r\n    if (!cell[0] || !out) {\r\n        throw new Error(\r\n            `Invalid 21e8 tx. dataObj, cell, out and tx are required.`\r\n        )\r\n    }\r\n\r\n    // assemble asm\r\n    // make sure first piece matches a txid\r\n    // 2nd piece matches any difficulty. set some resonable limit in bytes if there isnt one documented somewhere\r\n    // next\r\n\r\n    const txid = cellValue(cell[0], 'hex') as string\r\n    const target = cellValue(cell[1], 'hex') as string\r\n    if (!target) {\r\n        throw new Error(\r\n            `Invalid 21e8 target.` + JSON.stringify(cell[0], null, 2)\r\n        )\r\n    }\r\n    const difficulty = Buffer.from(target, 'hex').byteLength\r\n\r\n    const _21e8Obj: _21E8Type = {\r\n        target,\r\n        difficulty,\r\n        value: out.e.v,\r\n        txid,\r\n    }\r\n\r\n    saveProtocolData(dataObj, '21E8', _21e8Obj)\r\n}\r\n\r\nexport const _21E8: Protocol = {\r\n    name: '21E8',\r\n    handler,\r\n    scriptChecker,\r\n}\r\n"],"names":[],"version":3,"file":"bmap.js.map","sourceRoot":"../"}