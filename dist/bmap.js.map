{"mappings":"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","sources":["src/bmap.ts","src/protocols/_21e8.ts","src/utils.ts","src/protocols/aip.ts","src/protocols/b.ts","src/protocols/bap.ts","src/protocols/bitcom.ts","src/protocols/bitcomHashed.ts","src/utils/signatureVerification.ts","src/protocols/bitkey.ts","src/protocols/bitpic.ts","src/protocols/haip.ts","src/protocols/map.ts","src/protocols/metanet.ts","src/protocols/ord.ts","src/protocols/ron.ts","src/protocols/symre.ts"],"sourcesContent":["import { type In, type Out, type Tape, parse } from \"bpu-ts\";\nimport type {\n\tBmapTx,\n\tBobTx,\n\tHandler,\n\tHandlerProps,\n\tMetaNet,\n\tMomTx,\n\tProtocol,\n\tScriptChecker,\n} from \"../types/common\";\nimport { _21E8 } from \"./protocols/_21e8\";\nimport { AIP } from \"./protocols/aip\";\nimport { B } from \"./protocols/b\";\nimport { BAP } from \"./protocols/bap\";\nimport { BITCOM } from \"./protocols/bitcom\";\nimport { BITCOM_HASHED } from \"./protocols/bitcomHashed\";\nimport { BITKEY } from \"./protocols/bitkey\";\nimport { BITPIC } from \"./protocols/bitpic\";\nimport { HAIP } from \"./protocols/haip\";\nimport { MAP } from \"./protocols/map\";\nimport { METANET } from \"./protocols/metanet\";\nimport { ORD } from \"./protocols/ord\";\nimport { RON } from \"./protocols/ron\";\nimport { SYMRE } from \"./protocols/symre\";\nimport {\n\tcheckOpFalseOpReturn,\n\tcheckOpReturn,\n\tisObjectArray,\n\tisStringArray,\n\tsaveProtocolData,\n} from \"./utils\";\n\n// Names of enabled protocols\nconst enabledProtocols = new Map<string, string>([]);\n// Protocol Handlers\nconst protocolHandlers = new Map<string, Handler>([]);\n// Script checkers are intentionally minimalistic detection functions for identifying matching scripts for a given protocol. Only if a checker returns true is a handler called for processing.\nconst protocolScriptCheckers = new Map<string, ScriptChecker>([]);\nconst protocolOpReturnSchemas = new Map<string, Object[]>();\n\nexport const allProtocols = [\n\tAIP,\n\tB,\n\tBAP,\n\tMAP,\n\tMETANET,\n\t_21E8,\n\tBITCOM,\n\tBITKEY,\n\tBITPIC,\n\tHAIP,\n\tBITCOM_HASHED,\n\tRON,\n\tSYMRE,\n\tORD,\n];\n\nexport const supportedProtocols = allProtocols.map((p) => p.name);\nexport const defaultProtocols = [AIP, B, BAP, MAP, METANET, ORD];\n\n// prepare protocol map, handlers and schemas\nfor (const protocol of defaultProtocols) {\n\tif (protocol.address) {\n\t\tenabledProtocols.set(protocol.address, protocol.name);\n\t}\n\tprotocolHandlers.set(protocol.name, protocol.handler);\n\tif (protocol.opReturnSchema) {\n\t\tprotocolOpReturnSchemas.set(protocol.name, protocol.opReturnSchema);\n\t}\n\tif (protocol.scriptChecker) {\n\t\tprotocolScriptCheckers.set(protocol.name, protocol.scriptChecker);\n\t}\n}\n\n// Takes a BOB formatted op_return transaction\nexport class BMAP {\n\tenabledProtocols: Map<string, string>;\n\n\tprotocolHandlers: Map<string, Handler>;\n\n\tprotocolScriptCheckers: Map<string, ScriptChecker>;\n\n\tprotocolOpReturnSchemas: Map<string, Object[]>;\n\n\tconstructor() {\n\t\t// initial default protocol handlers in this instantiation\n\t\tthis.enabledProtocols = enabledProtocols;\n\t\tthis.protocolHandlers = protocolHandlers;\n\t\tthis.protocolScriptCheckers = protocolScriptCheckers;\n\t\tthis.protocolOpReturnSchemas = protocolOpReturnSchemas;\n\t}\n\n\taddProtocolHandler({\n\t\tname,\n\t\taddress,\n\t\topReturnSchema,\n\t\thandler,\n\t\tscriptChecker,\n\t}: Protocol) {\n\t\tif (address) {\n\t\t\tthis.enabledProtocols.set(address, name);\n\t\t}\n\t\tthis.protocolHandlers.set(name, handler);\n\t\tif (opReturnSchema) {\n\t\t\tthis.protocolOpReturnSchemas.set(name, opReturnSchema);\n\t\t}\n\t\tif (scriptChecker) {\n\t\t\tthis.protocolScriptCheckers.set(name, scriptChecker);\n\t\t}\n\t}\n\n\ttransformTx = async (tx: BobTx | MomTx): Promise<BmapTx> => {\n\t\tif (!tx || !tx.in || !tx.out) {\n\t\t\tthrow new Error(\"Cannot process tx\");\n\t\t}\n\n\t\t// This will become our nicely formatted response object\n\t\tlet dataObj: Partial<BobTx> = {};\n\n\t\tfor (const [key, val] of Object.entries(tx)) {\n\t\t\tif (key === \"out\") {\n\t\t\t\t// loop over the outputs\n\t\t\t\tfor (const out of tx.out) {\n\t\t\t\t\tconst { tape } = out;\n\n\t\t\t\t\t// Process opReturn data\n\t\t\t\t\tif (tape?.some((cc) => checkOpReturn(cc))) {\n\t\t\t\t\t\tdataObj = await this.processDataProtocols(tape, out, tx, dataObj);\n\t\t\t\t\t}\n\n\t\t\t\t\t// No OP_FALSE OP_RETURN in this tape\n\t\t\t\t\tconst _21e8Checker = this.protocolScriptCheckers.get(_21E8.name);\n\t\t\t\t\tconst ordChecker = this.protocolScriptCheckers.get(ORD.name);\n\n\t\t\t\t\t// Check for 21e8 and ords\n\t\t\t\t\tif (\n\t\t\t\t\t\ttape?.some((cc) => {\n\t\t\t\t\t\t\tconst { cell } = cc;\n\t\t\t\t\t\t\tif (_21e8Checker?.(cell)) {\n\t\t\t\t\t\t\t\t// 'found 21e8'\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ordChecker?.(cell)) {\n\t\t\t\t\t\t\t\t// 'found 1sat ordinal'\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t) {\n\t\t\t\t\t\t// find the cell array\n\t\t\t\t\t\t// loop over tape\n\t\t\t\t\t\tfor (const cellContainer of tape) {\n\t\t\t\t\t\t\tconst { cell } = cellContainer;\n\t\t\t\t\t\t\t// Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n\t\t\t\t\t\t\tif (!cell) {\n\t\t\t\t\t\t\t\tthrow new Error(\"empty cell while parsing\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet protocolName = \"\";\n\t\t\t\t\t\t\tif (_21e8Checker?.(cell)) {\n\t\t\t\t\t\t\t\tprotocolName = _21E8.name;\n\t\t\t\t\t\t\t} else if (ordChecker?.(cell)) {\n\t\t\t\t\t\t\t\tprotocolName = ORD.name;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// nothing found\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.process(protocolName, {\n\t\t\t\t\t\t\t\ttx,\n\t\t\t\t\t\t\t\tcell,\n\t\t\t\t\t\t\t\tdataObj: dataObj as BmapTx,\n\t\t\t\t\t\t\t\ttape,\n\t\t\t\t\t\t\t\tout,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (key === \"in\") {\n\t\t\t\tdataObj[key] = val.map((v: In) => {\n\t\t\t\t\tconst r = { ...v } as any;\n\t\t\t\t\tdelete r.tape;\n\t\t\t\t\treturn r as In;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// known key, just write it retaining original type\n\t\t\t\tdataObj[key] = val;\n\t\t\t}\n\t\t}\n\n\t\t// If this is a MOM planaria it will have metanet keys available\n\t\tif (dataObj.METANET && (tx as MomTx).parent) {\n\t\t\tconst meta = {\n\t\t\t\tancestor: (tx as MomTx).ancestor,\n\t\t\t\tparent: (tx as MomTx).parent,\n\t\t\t\tchild: (tx as MomTx).child,\n\t\t\t\thead: (tx as MomTx).head,\n\t\t\t} as MetaNet;\n\t\t\t(dataObj.METANET as MetaNet[]).push(meta);\n\t\t\t// remove parent and node from root level for (MOM data)\n\t\t\tdelete dataObj.ancestor;\n\t\t\tdelete dataObj.child;\n\t\t\tdelete dataObj.parent;\n\t\t\tdelete dataObj.head;\n\t\t\tdelete dataObj.node;\n\t\t}\n\n\t\treturn dataObj as BmapTx;\n\t};\n\n\tprocessUnknown = (key: string, dataObj: Partial<BmapTx>, out: Out) => {\n\t\t// no known non-OP_RETURN scripts\n\t\tif (key && !dataObj[key]) {\n\t\t\tdataObj[key] = [];\n\t\t}\n\t\t(dataObj[key] as Out[]).push({\n\t\t\ti: out.i,\n\t\t\te: out.e,\n\t\t\ttape: [],\n\t\t});\n\t};\n\n\tprocess = async (\n\t\tprotocolName: string,\n\t\t{ cell, dataObj, tape, out, tx }: HandlerProps,\n\t) => {\n\t\tif (\n\t\t\tthis.protocolHandlers.has(protocolName) &&\n\t\t\ttypeof this.protocolHandlers.get(protocolName) === \"function\"\n\t\t) {\n\t\t\tconst handler = this.protocolHandlers.get(protocolName);\n\t\t\tif (handler) {\n\t\t\t\t/* eslint-disable no-await-in-loop */\n\t\t\t\tawait handler({\n\t\t\t\t\tdataObj: dataObj,\n\t\t\t\t\tcell,\n\t\t\t\t\ttape,\n\t\t\t\t\tout,\n\t\t\t\t\ttx,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tsaveProtocolData(dataObj, protocolName, cell);\n\t\t}\n\t};\n\n\tprocessDataProtocols = async (\n\t\ttape: Tape[],\n\t\tout: Out,\n\t\ttx: BobTx,\n\t\tdataObj: Partial<BobTx>,\n\t): Promise<Partial<BobTx>> => {\n\t\t// loop over tape\n\t\tfor (const cellContainer of tape) {\n\t\t\tconst { cell } = cellContainer;\n\t\t\tif (!cell) {\n\t\t\t\tthrow new Error(\"empty cell while parsing\");\n\t\t\t}\n\n\t\t\t// Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n\t\t\tif (checkOpFalseOpReturn(cellContainer)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst prefix = cell[0].s;\n\n\t\t\tif (prefix) {\n\t\t\t\tconst bitcomProtocol =\n\t\t\t\t\tthis.enabledProtocols.get(prefix) ||\n\t\t\t\t\tdefaultProtocols.filter((p) => p.name === prefix)[0]?.name;\n\t\t\t\tif (bitcomProtocol) {\n\t\t\t\t\tawait this.process(bitcomProtocol, {\n\t\t\t\t\t\tcell,\n\t\t\t\t\t\tdataObj: dataObj as BmapTx,\n\t\t\t\t\t\ttape,\n\t\t\t\t\t\tout,\n\t\t\t\t\t\ttx,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthis.processUnknown(prefix, dataObj, out);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dataObj;\n\t};\n}\n\nexport const fetchRawTx = async (txid: string): Promise<string> => {\n\tconst url = `https://api.whatsonchain.com/v1/bsv/main/tx/${txid}/hex`;\n\n\tconsole.log(\"hitting\", url);\n\n\tconst res = await fetch(url);\n\treturn await res.text();\n};\n\nexport const bobFromRawTx = async (rawTx: string): Promise<BobTx> => {\n\tconst bpuTx = await parse({\n\t\ttx: { r: rawTx },\n\t\tsplit: [\n\t\t\t{\n\t\t\t\ttoken: { op: 106 },\n\t\t\t\tinclude: \"l\",\n\t\t\t},\n\t\t\t{\n\t\t\t\ttoken: { s: \"|\" },\n\t\t\t},\n\t\t],\n\t});\n\treturn bpuTx as BobTx;\n};\n\n// TransformTx\n// tx - a raw hex string or a Bob/Bmap/Mom transaction object\n// protocols - the handlers you want to load and use to process the tx\n// reducing the number of supported protocols may improve transform speed\n// at the expense of detecting more data protocols\nexport const TransformTx = async (\n\ttx: BobTx | string | MomTx | BmapTx,\n\tprotocols?: string[] | Protocol[],\n) => {\n\tif (typeof tx === \"string\") {\n\t\tlet rawTx: string | undefined;\n\t\t// if it a txid or  complete transaction hex?\n\t\tif (tx.length === 64) {\n\t\t\t// txid - fetch raw tx\n\t\t\trawTx = await fetchRawTx(tx);\n\t\t}\n\n\t\tif (Buffer.from(tx).byteLength <= 146) {\n\t\t\tthrow new Error(\"Invalid rawTx\");\n\t\t}\n\n\t\tif (!rawTx) {\n\t\t\trawTx = tx;\n\t\t}\n\n\t\t// TODO: Double check 146 is intended to be minimum possible byte length for a tx\n\t\tconst bobTx = await bobFromRawTx(rawTx);\n\n\t\tif (bobTx) {\n\t\t\ttx = bobTx;\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid txid\");\n\t\t}\n\t}\n\n\tconst b = new BMAP();\n\n\t// if protocols are specified\n\tif (protocols) {\n\t\t// wipe out defaults\n\t\tb.enabledProtocols.clear();\n\t\tif (isStringArray(protocols)) {\n\t\t\t// set enabled protocols\n\t\t\tfor (const protocol of allProtocols) {\n\t\t\t\tif ((protocols as string[])?.includes(protocol.name)) {\n\t\t\t\t\tb.addProtocolHandler(protocol);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObjectArray(protocols)) {\n\t\t\tfor (const p of protocols) {\n\t\t\t\tconst protocol = p as Protocol;\n\t\t\t\tif (protocol) {\n\t\t\t\t\tb.addProtocolHandler(protocol);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t\"Invalid protocol array. Must be either an array of protocol names (string[]), or Protocol objects (Protocol[]).\",\n\t\t\t);\n\t\t}\n\t}\n\n\treturn b.transformTx(tx);\n};\n","import type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../../types/common\";\nimport type { _21E8 as _21E8Type } from \"../../types/protocols/_21e8\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\n// 21e8 does not use the first pushdata for id\n// in fact there is no id since the 21e8 is designed for difficulty and can be changed\n// instead we use the static part of the script to indentfy the transaction\n// TODO - the OP_X_PLACEHOLDER is the number of bytes to push onto the stack and must match difficulty size\nconst _21e8Script =\n\t\"OP_SIZE <OP_X_PLACEHOLDER> OP_PICK OP_SHA256 OP_SWAP OP_SPLIT OP_DROP OP_EQUALVERIFY OP_DROP OP_CHECKSIG\".split(\n\t\t\" \",\n\t);\n\nconst scriptChecker = (cell: Cell[]) => {\n\tif (cell.length !== 12) {\n\t\t// wrong length\n\t\treturn false;\n\t}\n\n\t// match exact script\n\tconst ops = [...cell].map((c) => c.ops).splice(2, cell.length);\n\n\t// calculate target byte length\n\tconst target = cellValue(cell[1], \"hex\") as string;\n\tconst targetOpSize = Buffer.from(target).byteLength;\n\n\t// replace the placeholder opcode with actual\n\tops[1] = `OP_${targetOpSize}`;\n\t_21e8Script[1] = `OP_${targetOpSize}`;\n\n\t// protocol identifier always in first pushdata\n\treturn ops.join() === _21e8Script.join();\n};\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n\tif (!cell[0] || !out) {\n\t\tthrow new Error(\"Invalid 21e8 tx. dataObj, cell, out and tx are required.\");\n\t}\n\n\t// assemble asm\n\t// make sure first piece matches a txid\n\t// 2nd piece matches any difficulty. set some resonable limit in bytes if there isnt one documented somewhere\n\t// next\n\n\tconst txid = cellValue(cell[0], \"hex\") as string;\n\tconst target = cellValue(cell[1], \"hex\") as string;\n\tif (!target) {\n\t\tthrow new Error(`Invalid 21e8 target. ${JSON.stringify(cell[0], null, 2)}`);\n\t}\n\tconst difficulty = Buffer.from(target, \"hex\").byteLength;\n\n\tconst _21e8Obj: _21E8Type = {\n\t\ttarget,\n\t\tdifficulty,\n\t\tvalue: out.e.v,\n\t\ttxid,\n\t};\n\n\tsaveProtocolData(dataObj, \"21E8\", _21e8Obj);\n};\n\nexport const _21E8: Protocol = {\n\tname: \"21E8\",\n\thandler,\n\tscriptChecker,\n};\n","import { Cell, Tape } from 'bpu-ts'\nimport { Buffer } from 'buffer'\nimport crypto from 'crypto'\nimport { BobTx } from '../types/common'\n\nexport const isStringArray = (arr: Array<any>): boolean => {\n    return (\n        arr.length > 0 &&\n        arr.every((value) => {\n            return typeof value === 'string'\n        })\n    )\n}\nexport const isObjectArray = (arr: Array<any>): boolean => {\n    return (\n        arr.length > 0 &&\n        arr.every((value) => {\n            return value === 'object'\n        })\n    )\n}\n/**\n * returns the BOB cell value for a given encoding\n *\n * @param pushData\n * @param schemaEncoding\n * @returns {string|number}\n */\nexport const cellValue = (\n    pushData: Cell,\n    schemaEncoding?: string\n): string | number => {\n    if (!pushData) {\n        throw new Error(`cannot get cell value of: ${pushData}`)\n    } else if (schemaEncoding === 'string') {\n        return pushData['s'] ? pushData.s : pushData.ls || ''\n    } else if (schemaEncoding === 'hex') {\n        return pushData['h']\n            ? pushData.h\n            : pushData.lh ||\n                  (pushData['b']\n                      ? Buffer.from(pushData.b, 'base64').toString('hex')\n                      : pushData.lb &&\n                        Buffer.from(pushData.lb, 'base64').toString('hex')) ||\n                  ''\n    } else if (schemaEncoding === 'number') {\n        return parseInt(pushData['h'] ? pushData.h : pushData.lh || '0', 16)\n    } else if (schemaEncoding === 'file') {\n        return `bitfs://${pushData['f'] ? pushData.f : pushData.lf}`\n    }\n\n    return (pushData['b'] ? pushData.b : pushData.lb) || ''\n}\n\n/**\n * Check if cells end with OP_RETURN\n */\nexport const checkOpReturn = (cc: Tape): boolean => {\n    return cc.cell.some((c: Cell) => c.op === 106)\n}\n\n/**\n * Check if cells end with OP_FALSE + OP_RETURN\n */\nexport const checkOpFalseOpReturn = (cc: Tape): boolean => {\n    if (cc.cell.length !== 2) {\n        return false\n    }\n    const opReturnIdx = cc.cell.findIndex((c) => c.op === 106)\n    if (opReturnIdx !== -1) {\n        return cc.cell[opReturnIdx - 1]?.op === 0\n    }\n    return false\n}\n\n/**\n * Helper function to store protocol data\n *\n * @param dataObj\n * @param protocolName\n * @param data\n */\nexport const saveProtocolData = (\n    dataObj: { [key: string]: any },\n    protocolName: string,\n    data: any\n) => {\n    if (!dataObj[protocolName]) {\n        dataObj[protocolName] = [data]\n    } else {\n        dataObj[protocolName].push(data)\n    }\n}\n\n/**\n * BMAP default handler to work with query schema's\n *\n * @param opReturnSchema\n * @param protocolName\n * @param dataObj\n * @param cell\n * @param tape\n * @param tx\n */\nexport const bmapOpReturnSchemaHandler = function (\n    protocolName: string,\n    opReturnSchema: Object[],\n    dataObj: Object,\n    cell: Cell[],\n    tx: BobTx\n) {\n    // loop over the schema\n    const obj: { [key: string]: any } = {}\n\n    // Does not have the required number of fields\n    const length = opReturnSchema.length + 1\n    if (cell.length < length) {\n        throw new Error(\n            `${protocolName} requires at least ${length} fields including the prefix: ${tx.tx.h}`\n        )\n    }\n\n    for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n        const x = parseInt(idx, 10)\n\n        const [field] = Object.keys(schemaField)\n        const [schemaEncoding] = Object.values(schemaField)\n        obj[field] = cellValue(cell[x + 1], schemaEncoding)\n    }\n\n    saveProtocolData(dataObj, protocolName, obj)\n}\n\n/**\n * Check whether the given data is base64\n *\n * @param data\n * @returns {boolean}\n */\nexport const isBase64 = function (data: string) {\n    const regex =\n        '(?:[A-Za-z0-9+\\\\/]{4})*(?:[A-Za-z0-9+\\\\/]{2}==|[A-Za-z0-9+/]{3}=)?'\n    return new RegExp(`^${regex}$`, 'gi').test(data)\n}\n\n// hashes a message buffer, returns the hash as a buffer\nexport const sha256 = async (msgBuffer: Buffer) => {\n    let hash: ArrayBuffer\n\n    if (crypto.subtle) {\n        hash = await crypto.subtle.digest('SHA-256', msgBuffer)\n        return Buffer.from(hash)\n    }\n    // }\n    return Buffer.from(new ArrayBuffer(0))\n}\n","import { Address, Bsm, Script } from \"@ts-bitcoin/core\";\nimport type { Cell, Tape } from \"bpu-ts\";\nimport { Buffer } from \"buffer\";\nimport fetch from \"node-fetch\";\nimport type { BobTx, HandlerProps, Protocol } from \"../../types/common\";\nimport type { AIP as AIPType } from \"../../types/protocols/aip\";\nimport type { HAIP as HAIPType } from \"../../types/protocols/haip\";\n\nimport {\n\tcellValue,\n\tcheckOpReturn,\n\tisBase64,\n\tsaveProtocolData,\n\tsha256,\n} from \"../utils\";\n\nconst address = \"15PciHG22SNLQJXMoSUaWVi7WSqc7hCfva\";\n\nconst opReturnSchema = [\n\t{ algorithm: \"string\" },\n\t{ address: \"string\" },\n\t{ signature: \"binary\" },\n\t[{ index: \"binary\" }],\n];\n\nconst getFileBuffer = async (bitfsRef: string) => {\n\tlet fileBuffer = Buffer.from(\"\");\n\ttry {\n\t\tconst result = await fetch(`https://x.bitfs.network/${bitfsRef}`, {});\n\t\tfileBuffer = await result.buffer();\n\t} catch (e) {\n\t\tconsole.error(e);\n\t}\n\n\treturn fileBuffer;\n};\n\nconst validateSignature = async (\n\taipObj: Partial<AIPType | HAIPType>,\n\tcell: Cell[],\n\ttape: Tape[],\n): Promise<boolean> => {\n\tif (!Array.isArray(tape) || tape.length < 3) {\n\t\tthrow new Error(\"AIP requires at least 3 cells including the prefix\");\n\t}\n\n\tlet cellIndex = -1;\n\ttape.forEach((cc, index) => {\n\t\tif (cc.cell === cell) {\n\t\t\tcellIndex = index;\n\t\t}\n\t});\n\tif (cellIndex === -1) {\n\t\tthrow new Error(\"AIP could not find cell in tape\");\n\t}\n\n\tlet usingIndexes: number[] = aipObj.index || [];\n\tconst signatureValues = [\"6a\"]; // OP_RETURN - is included in AIP\n\tfor (let i = 0; i < cellIndex; i++) {\n\t\tconst cellContainer = tape[i];\n\t\tif (!checkOpReturn(cellContainer)) {\n\t\t\tfor (let nc = 0; nc < cellContainer.cell.length; nc++) {\n\t\t\t\tconst statement = cellContainer.cell[nc];\n\t\t\t\t// add the value as hex\n\t\t\t\tif (statement.h) {\n\t\t\t\t\tsignatureValues.push(statement.h);\n\t\t\t\t} else if (statement.f) {\n\t\t\t\t\t// file reference - we need to get the file from bitfs\n\t\t\t\t\tconst fileBuffer = await getFileBuffer(statement.f);\n\t\t\t\t\tsignatureValues.push(fileBuffer.toString(\"hex\"));\n\t\t\t\t} else if (statement.b) {\n\t\t\t\t\t// no hex? try base64\n\t\t\t\t\tsignatureValues.push(\n\t\t\t\t\t\tBuffer.from(statement.b, \"base64\").toString(\"hex\"),\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tif (statement.s) {\n\t\t\t\t\t\tsignatureValues.push(Buffer.from(statement.s).toString(\"hex\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsignatureValues.push(\"7c\"); // | hex\n\t\t}\n\t}\n\n\tif (aipObj.hashing_algorithm) {\n\t\t// when using HAIP, we need to parse the indexes in a non standard way\n\t\t// indexLength is byte size of the indexes being described\n\t\tif (aipObj.index_unit_size) {\n\t\t\tconst indexLength = aipObj.index_unit_size * 2;\n\t\t\tusingIndexes = [];\n\t\t\tconst indexes = cell[6].h as string;\n\t\t\tfor (let i = 0; i < indexes.length; i += indexLength) {\n\t\t\t\tusingIndexes.push(parseInt(indexes.substr(i, indexLength), 16));\n\t\t\t}\n\t\t\taipObj.index = usingIndexes;\n\t\t}\n\t}\n\n\tconst signatureBufferStatements: Buffer[] = [];\n\t// check whether we need to only sign some indexes\n\tif (usingIndexes.length > 0) {\n\t\tfor (const index of usingIndexes) {\n\t\t\tsignatureBufferStatements.push(\n\t\t\t\tBuffer.from(signatureValues[index], \"hex\"),\n\t\t\t);\n\t\t}\n\t} else {\n\t\t// add all the values to the signature buffer\n\t\tfor (const statement of signatureValues) {\n\t\t\tsignatureBufferStatements.push(Buffer.from(statement, \"hex\"));\n\t\t}\n\t}\n\n\tlet messageBuffer: Buffer | string;\n\tif (aipObj.hashing_algorithm) {\n\t\t// this is actually Hashed-AIP (HAIP) and works a bit differently\n\t\tif (!aipObj.index_unit_size) {\n\t\t\t// remove OP_RETURN - will be added by Script.buildDataOut\n\t\t\tsignatureBufferStatements.shift();\n\t\t}\n\t\tconst dataScript = Script.fromSafeDataArray(signatureBufferStatements);\n\t\tlet dataBuffer = Buffer.from(dataScript.toHex(), \"hex\");\n\t\tif (aipObj.index_unit_size) {\n\t\t\t// the indexed buffer should not contain the OP_RETURN opcode, but this\n\t\t\t// is added by the buildDataOut function automatically. Remove it.\n\t\t\tdataBuffer = dataBuffer.slice(1);\n\t\t}\n\t\tmessageBuffer = await sha256(Buffer.from(dataBuffer.toString(\"hex\")));\n\t} else {\n\t\t// regular AIP\n\t\tmessageBuffer = Buffer.concat([...signatureBufferStatements]);\n\t}\n\n\t// AIOP uses address, HAIP uses signing_address field names\n\tconst adressString =\n\t\t(aipObj as AIPType).address || (aipObj as HAIPType).signing_address;\n\t// verify aip signature\n\ttry {\n\t\taipObj.verified = Bsm.verify(\n\t\t\tmessageBuffer,\n\t\t\taipObj.signature || \"\",\n\t\t\tAddress.fromString(adressString),\n\t\t);\n\t} catch (e) {\n\t\taipObj.verified = false;\n\t}\n\n\t// Try if this is a Twetch compatible AIP signature\n\tif (!aipObj.verified) {\n\t\t// Twetch signs a UTF-8 buffer of the hex string of a sha256 hash of the message\n\t\t// Without 0x06 (OP_RETURN) and without 0x7c at the end, the trailing pipe (\"|\")\n\n\t\tmessageBuffer = Buffer.concat([\n\t\t\t...signatureBufferStatements.slice(\n\t\t\t\t1,\n\t\t\t\tsignatureBufferStatements.length - 1,\n\t\t\t),\n\t\t]);\n\t\tconst buff = await sha256(messageBuffer);\n\t\tmessageBuffer = Buffer.from(buff.toString(\"hex\"));\n\t\ttry {\n\t\t\taipObj.verified = Bsm.verify(\n\t\t\t\tmessageBuffer,\n\t\t\t\taipObj.signature || \"\",\n\t\t\t\tAddress.fromString(adressString),\n\t\t\t);\n\t\t} catch (e) {\n\t\t\taipObj.verified = false;\n\t\t}\n\t}\n\n\treturn aipObj.verified || false;\n};\n\nexport enum SIGPROTO {\n\tHAIP = \"HAIP\",\n\tAIP = \"AIP\",\n\tBITCOM_HASHED = \"BITCOM_HASHED\",\n\tPSP = \"PSP\",\n}\n\nexport const AIPhandler = async (\n\tuseOpReturnSchema: Object[],\n\tprotocol: SIGPROTO,\n\tdataObj: Object,\n\tcell: Cell[],\n\ttape: Tape[],\n\ttx: BobTx,\n) => {\n\t// loop over the schema\n\tconst aipObj: { [key: string]: number | number[] | string } = {};\n\n\t// Does not have the required number of fields\n\tif (cell.length < 4) {\n\t\tthrow new Error(\n\t\t\t`AIP requires at least 4 fields including the prefix ${tx}`,\n\t\t);\n\t}\n\n\tfor (const [idx, schemaField] of Object.entries(useOpReturnSchema)) {\n\t\tconst x = Number.parseInt(idx, 10);\n\n\t\tlet schemaEncoding;\n\t\tlet aipField: keyof AIPType;\n\t\tif (Array.isArray(schemaField)) {\n\t\t\t// signature indexes are specified\n\t\t\tschemaEncoding = schemaField[0].index;\n\t\t\t[aipField] = Object.keys(schemaField[0]) as (keyof AIPType)[];\n\t\t\t// run through the rest of the fields in this cell, should be de indexes\n\t\t\tconst fieldData: number[] = [];\n\t\t\tfor (let i = x + 1; i < cell.length; i++) {\n\t\t\t\tif (cell[i].h && Array.isArray(fieldData)) {\n\t\t\t\t\tfieldData.push(Number.parseInt(cell[i].h || \"\", 16));\n\t\t\t\t}\n\t\t\t}\n\t\t\taipObj[aipField] = fieldData;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t[aipField] = Object.keys(schemaField) as (keyof AIPType)[];\n\t\t\t[schemaEncoding] = Object.values(schemaField);\n\t\t}\n\n\t\taipObj[aipField] = cellValue(cell[x + 1], schemaEncoding) || \"\";\n\t}\n\n\t// There is an issue where some services add the signature as binary to the transaction\n\t// whereas others add the signature as base64. This will confuse bob and the parser and\n\t// the signature will not be verified. When the signature is added in binary cell[3].s is\n\t// binary, otherwise cell[3].s contains the base64 signature and should be used.\n\tif (cell[0].s === address && cell[3].s && isBase64(cell[3].s)) {\n\t\taipObj.signature = cell[3].s;\n\t}\n\n\tif (!aipObj.signature) {\n\t\tthrow new Error(`AIP requires a signature ${tx}`);\n\t}\n\n\tif (!(await validateSignature(aipObj as Partial<AIPType>, cell, tape))) {\n\t\t// throw new Error('AIP requires a valid signature', tx);\n\t}\n\n\tsaveProtocolData(dataObj, protocol, aipObj);\n};\n\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n\tif (!tape) {\n\t\tthrow new Error(\"Invalid AIP transaction. tape is required\");\n\t}\n\tif (!tx) {\n\t\tthrow new Error(\"Invalid AIP transaction. tx is required\");\n\t}\n\treturn await AIPhandler(\n\t\topReturnSchema,\n\t\tSIGPROTO.AIP,\n\t\tdataObj,\n\t\tcell,\n\t\ttape,\n\t\ttx,\n\t);\n};\n\nexport const AIP: Protocol = {\n\tname: \"AIP\",\n\taddress,\n\topReturnSchema,\n\thandler,\n};\n","import type { HandlerProps, Protocol } from \"../../types/common\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\nconst address = \"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\";\n\nconst opReturnSchema = [\n\t{ content: [\"string\", \"binary\", \"file\"] },\n\t{ \"content-type\": \"string\" },\n\t{ encoding: \"string\" }, // we use this field to determine content character encoding. If encoding is not a valid character encoding (gzip), we assume it is binary\n\t{ filename: \"string\" },\n];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps): void => {\n\tconst encodingMap = new Map<string, string>();\n\tencodingMap.set(\"utf8\", \"string\");\n\tencodingMap.set(\"text\", \"string\"); // invalid but people use it :(\n\tencodingMap.set(\"gzip\", \"binary\"); // invalid but people use it :(\n\tencodingMap.set(\"text/plain\", \"string\");\n\tencodingMap.set(\"image/png\", \"binary\");\n\tencodingMap.set(\"image/jpeg\", \"binary\");\n\n\tif (!cell[1] || !cell[2]) {\n\t\tthrow new Error(`Invalid B tx: ${tx}`);\n\t}\n\n\t// Check pushdata length + 1 for protocol prefix\n\tif (cell.length > opReturnSchema.length + 1) {\n\t\tthrow new Error(\"Invalid B tx. Too many fields.\");\n\t}\n\n\t// Make sure there are not more fields than possible\n\n\tconst bObj: { [key: string]: string | number | undefined } = {};\n\t// loop over the schema\n\tfor (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n\t\tconst x = Number.parseInt(idx, 10);\n\t\tconst bField = Object.keys(schemaField)[0];\n\t\tlet schemaEncoding = Object.values(schemaField)[0];\n\t\tif (bField === \"content\") {\n\t\t\t// If the encoding is ommitted, try to infer from content-type instead of breaking\n\t\t\tif (cell[1].f) {\n\t\t\t\t// this is file reference to B files\n\t\t\t\tschemaEncoding = \"file\";\n\t\t\t} else if ((!cell[3] || !cell[3].s) && cell[2].s) {\n\t\t\t\tschemaEncoding = encodingMap.get(cell[2].s);\n\t\t\t\tif (!schemaEncoding) {\n\t\t\t\t\tconsole.warn(\"Problem inferring encoding. Malformed B data.\", cell);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// add the missing encoding field\n\t\t\t\tif (!cell[3]) {\n\t\t\t\t\tcell[3] = { h: \"\", b: \"\", s: \"\", i: 0, ii: 0 };\n\t\t\t\t}\n\t\t\t\tcell[3].s = schemaEncoding === \"string\" ? \"utf-8\" : \"binary\";\n\t\t\t} else {\n\t\t\t\tschemaEncoding = cell[3]?.s\n\t\t\t\t\t? encodingMap.get(cell[3].s.replace(\"-\", \"\").toLowerCase())\n\t\t\t\t\t: null;\n\t\t\t}\n\t\t}\n\n\t\t// encoding is not required\n\t\tif (bField === \"encoding\" && !cell[x + 1]) {\n\t\t\t// encoding omitted\n\t\t\tcontinue;\n\t\t}\n\n\t\t// filename is not required\n\t\tif (bField === \"filename\" && !cell[x + 1]) {\n\t\t\t// filename omitted\n\t\t\tcontinue;\n\t\t}\n\n\t\t// check for malformed syntax\n\t\tif (!cell || !cell[x + 1]) {\n\t\t\tthrow new Error(`malformed B syntax ${cell}`);\n\t\t}\n\n\t\t// set field value from either s, b, ls, or lb depending on encoding and availability\n\t\tconst data = cell[x + 1];\n\t\tbObj[bField] = cellValue(data, schemaEncoding);\n\t}\n\n\tsaveProtocolData(dataObj, \"B\", bObj);\n};\n\nexport const B: Protocol = {\n\tname: \"B\",\n\taddress,\n\topReturnSchema,\n\thandler,\n};\n","import type { HandlerProps, Protocol } from \"../../types/common\";\nimport { bmapOpReturnSchemaHandler } from \"../utils\";\n\nconst address = \"1BAPSuaPnfGnSBM3GLV9yhxUdYe4vGbdMT\";\n\nconst opReturnSchema = [\n\t{ type: \"string\" },\n\t{ hash: \"string\" },\n\t{ sequence: \"string\" },\n];\n\nexport const handler = ({ dataObj, cell, tx }: HandlerProps) => {\n\tif (!tx) {\n\t\tthrow new Error(\"Invalid BAP tx, tx required\");\n\t}\n\tbmapOpReturnSchemaHandler(\"BAP\", opReturnSchema, dataObj, cell, tx);\n};\n\nexport const BAP: Protocol = {\n\tname: \"BAP\",\n\taddress,\n\topReturnSchema,\n\thandler,\n};\n","import type { HandlerProps, Protocol } from \"../../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst protocolAddress = \"$\";\n\nconst opReturnSchema = [\n\t{\n\t\tsu: [\n\t\t\t{ pubkey: \"string\" },\n\t\t\t{ sign_position: \"string\" },\n\t\t\t{ signature: \"string\" },\n\t\t],\n\t\techo: [{ data: \"string\" }, { to: \"string\" }, { filename: \"string\" }],\n\t\troute: [\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\tadd: [\n\t\t\t\t\t\t{ bitcom_address: \"string\" },\n\t\t\t\t\t\t{ route_matcher: \"string\" },\n\t\t\t\t\t\t{ endpoint_template: \"string\" },\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tenable: [{ path: \"string\" }],\n\t\t\t\t},\n\t\t\t],\n\t\t],\n\t\tuseradd: [{ address: \"string\" }],\n\t},\n];\n\n// const handler = function (dataObj, protocolName, cell, tape, tx) {\nconst handler = ({ dataObj, cell }: HandlerProps) => {\n\tif (!cell.length || !cell.every((c) => c.s)) {\n\t\tthrow new Error(\"Invalid Bitcom tx\");\n\t}\n\n\t// gather up the string values\n\tconst bitcomObj = cell.map((c) => (c?.s ? c.s : \"\"));\n\n\tsaveProtocolData(dataObj, \"BITCOM\", bitcomObj);\n};\n\nexport const BITCOM: Protocol = {\n\tname: \"BITCOM\",\n\taddress: protocolAddress,\n\topReturnSchema,\n\thandler,\n};\n","import type { HandlerProps, Protocol } from \"../../types/common\";\nimport { SIGPROTO } from \"./aip\";\nimport { signatureHandler } from \"../utils/signatureVerification\";\n\nconst address = \"15igChEkUWgx4dsEcSuPitcLNZmNDfUvgA\";\n\n// see https://bsvalias.org/05-verify-public-key-owner.html\nconst opReturnSchema = [\n\t{ hash: \"string\" }, // sha256\n\t{ signature: \"string\" },\n\t{ pubkey: \"binary\" },\n\t{ paymail: \"string\" },\n];\n\nconst handler = async ({ dataObj, cell, tape }: HandlerProps) => {\n\tif (!tape) {\n\t\tthrow new Error(\"Invalid BITCOM_HASHED tx. Bad tape\");\n\t}\n\n\tif (!cell.length || cell[0].s !== address || !cell[1] || !cell[2] || !cell[3] || !cell[4]) {\n\t\tthrow new Error(\"Invalid BITCOM_HASHED record\");\n\t}\n\n\treturn await signatureHandler(\n\t\topReturnSchema,\n\t\tSIGPROTO.BITCOM_HASHED,\n\t\tdataObj,\n\t\tcell,\n\t\ttape,\n\t);\n};\n\nexport const BITCOM_HASHED: Protocol = {\n\tname: \"BITCOM_HASHED\",\n\taddress,\n\topReturnSchema,\n\thandler,\n};\n","import { Address, Bsm, PubKey, Script } from \"@ts-bitcoin/core\";\nimport { Cell, Tape } from \"bpu-ts\";\nimport { Buffer } from \"buffer\";\nimport type { BmapTx } from \"../../types/common\";\nimport { cellValue, checkOpReturn, saveProtocolData } from \"../utils\";\n\nconst validateSignature = (signedObj: any, cell: Cell[], tape: Tape[]) => {\n\tif (!Array.isArray(tape) || tape.length < 3) {\n\t\tthrow new Error(\"Signature validation requires at least 3 cells including the prefix\");\n\t}\n\n\tlet cellIndex = -1;\n\ttape.forEach((cc, index) => {\n\t\tif (cc.cell === cell) {\n\t\t\tcellIndex = index;\n\t\t}\n\t});\n\tif (cellIndex === -1) {\n\t\tthrow new Error(\"Could not find cell in tape\");\n\t}\n\n\tconst signatureBufferStatements = [];\n\tfor (let i = 0; i < cellIndex; i++) {\n\t\tconst cellContainer = tape[i];\n\t\tif (!checkOpReturn(cellContainer)) {\n\t\t\tfor (const statement of cellContainer.cell) {\n\t\t\t\t// add the value as hex\n\t\t\t\tlet value = statement.h;\n\t\t\t\tif (!value) {\n\t\t\t\t\tvalue = Buffer.from(statement.b as string, \"base64\").toString(\"hex\");\n\t\t\t\t}\n\t\t\t\tif (!value) {\n\t\t\t\t\tvalue = Buffer.from(statement.s as string).toString(\"hex\");\n\t\t\t\t}\n\t\t\t\tsignatureBufferStatements.push(Buffer.from(value, \"hex\"));\n\t\t\t}\n\t\t\tsignatureBufferStatements.push(Buffer.from(\"7c\", \"hex\")); // pipe separator\n\t\t}\n\t}\n\tconst dataScript = Script.fromSafeDataArray(signatureBufferStatements);\n\tconst messageBuffer = Buffer.from(dataScript.toHex(), \"hex\");\n\n\t// verify signature\n\tconst publicKey = PubKey.fromString(signedObj.pubkey);\n\tconst signingAddress = Address.fromPubKey(publicKey);\n\ttry {\n\t\tsignedObj.verified = Bsm.verify(\n\t\t\tmessageBuffer,\n\t\t\tsignedObj.signature,\n\t\t\tsigningAddress,\n\t\t);\n\t} catch (e) {\n\t\tsignedObj.verified = false;\n\t}\n\n\treturn signedObj.verified;\n};\n\nexport const signatureHandler = async (\n\topReturnSchema: any[],\n\tprotocolName: string,\n\tdataObj: BmapTx,\n\tcell: Cell[],\n\ttape: Tape[],\n) => {\n\tconst obj: { [key: string]: any } = {\n\t\tverified: false,\n\t};\n\n\t// Does not have the required number of fields\n\tif (cell.length < opReturnSchema.length + 1) {\n\t\tthrow new Error(\n\t\t\t`Requires at least ${opReturnSchema.length + 1} fields including the prefix`,\n\t\t);\n\t}\n\n\t// loop over schema\n\tfor (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n\t\tconst x = Number.parseInt(idx, 10);\n\t\tconst key = Object.keys(schemaField)[0];\n\t\tconst type = schemaField[key];\n\n\t\t// get the cell value\n\t\tconst val = cellValue(cell[x + 1], type);\n\t\tif (val) {\n\t\t\tobj[key] = val;\n\t\t}\n\t}\n\n\tif (!obj.signature) {\n\t\tthrow new Error(`Requires a signature`);\n\t}\n\n\t// verify signature if we have all required fields\n\tif (obj.signature && obj.pubkey && tape) {\n\t\tvalidateSignature(obj, cell, tape);\n\t}\n\n\tsaveProtocolData(dataObj, protocolName, obj);\n}; ","import { Address, Bsm, PubKey } from \"@ts-bitcoin/core\";\nimport { Buffer } from \"buffer\";\nimport type { HandlerProps, Protocol } from \"../../types/common\";\nimport { cellValue, saveProtocolData, sha256 } from \"../utils\";\n\nconst address = \"13SrNDkVzY5bHBRKNu5iXTQ7K7VqTh5tJC\";\n\nconst opReturnSchema = [\n\t{ bitkey_signature: \"string\" },\n\t{ user_signature: \"string\" },\n\t{ paymail: \"string\" },\n\t{ pubkey: \"string\" },\n];\n\n// const handler = function (dataObj, cell, tape, tx) {\n// https://bitkey.network/how\nconst handler = async ({ dataObj, cell }: HandlerProps) => {\n\tif (!cell.length) {\n\t\tthrow new Error(\"Invalid Bitkey tx\");\n\t}\n\n\tconst bitkeyObj: { [key: string]: string | boolean } = {};\n\n\t// loop over the schema\n\tfor (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n\t\tconst x = Number.parseInt(idx, 10);\n\t\tconst bitkeyField = Object.keys(schemaField)[0];\n\t\tconst schemaEncoding = Object.values(schemaField)[0];\n\t\tbitkeyObj[bitkeyField] = cellValue(cell[x + 1], schemaEncoding) as string;\n\t}\n\n\tconst userAddress = Address.fromPubKey(\n\t\tPubKey.fromString(bitkeyObj.pubkey as string),\n\t).toString();\n\n\t// sha256( hex(paymail(USER)) | hex(pubkey(USER)) )\n\tconst paymailHex = Buffer.from(bitkeyObj.paymail as string).toString(\"hex\");\n\tconst pubkeyHex = Buffer.from(bitkeyObj.pubkey as string).toString(\"hex\");\n\tconst concatenated = paymailHex + pubkeyHex;\n\tconst bitkeySignatureBuffer = await sha256(Buffer.from(concatenated, \"hex\"));\n\n\tconst bitkeySignatureVerified = Bsm.verify(\n\t\tbitkeySignatureBuffer,\n\t\tbitkeyObj.bitkey_signature as string,\n\t\tAddress.fromString(\"13SrNDkVzY5bHBRKNu5iXTQ7K7VqTh5tJC\"),\n\t);\n\tconst userSignatureVerified = Bsm.verify(\n\t\tBuffer.from(bitkeyObj.pubkey as string),\n\t\tbitkeyObj.user_signature as string,\n\t\tAddress.fromString(userAddress),\n\t);\n\tbitkeyObj.verified = bitkeySignatureVerified && userSignatureVerified;\n\n\tsaveProtocolData(dataObj, \"BITKEY\", bitkeyObj);\n};\n\nexport const BITKEY: Protocol = {\n\tname: \"BITKEY\",\n\taddress,\n\topReturnSchema,\n\thandler,\n};\n","import { Address, Bsm, PubKey } from \"@ts-bitcoin/core\";\nimport { Buffer } from \"buffer\";\nimport type { HandlerProps, Protocol } from \"../../types/common\";\nimport type { BITPIC as BITPICType } from \"../../types/protocols/bitpic\";\nimport { saveProtocolData, sha256 } from \"../utils\";\n\nconst protocolAddress = \"18pAqbYqhzErT6Zk3a5dwxHtB9icv8jH2p\";\n\nconst opReturnSchema = [\n\t{ paymail: \"string\" },\n\t{ pubkey: \"binary\" },\n\t{ signature: \"string\" },\n];\n\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n\t// Validation\n\tif (\n\t\tcell[0].s !== protocolAddress ||\n\t\t!cell[1] ||\n\t\t!cell[2] ||\n\t\t!cell[3] ||\n\t\t!cell[1].s ||\n\t\t!cell[2].b ||\n\t\t!cell[3].s ||\n\t\t!tape\n\t) {\n\t\tthrow new Error(`Invalid BITPIC record: ${tx}`);\n\t}\n\n\tconst bitpicObj: BITPICType = {\n\t\tpaymail: cell[1].s,\n\t\tpubkey: Buffer.from(cell[2].b, \"base64\").toString(\"hex\"),\n\t\tsignature: cell[3].s || \"\",\n\t\tverified: false,\n\t};\n\n\tconst b = tape[1].cell;\n\tif (b[0].s === \"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\") {\n\t\t// verify bitpic signature\n\n\t\t// TODO: Verification\n\t\t// const pubkey = Buffer.from(cell[2].b, 'base64').toString('hex')\n\t\t// const address = Address.fromPubKey(PubKey.fromString(pubkey)).toString()\n\t\t// const hex = Buffer.from(hash, 'hex')\n\t\t// const verified = Message.verify(hex, address, expected)\n\t\t// return verified\n\n\t\t// const expected = res.cell[3].s\n\t\t// const paymail = res.cell[1].s\n\t\t// const pubkey = Buffer.from(res.cell[2].b, \"base64\").toString(\"hex\")\n\t\t// const address = new bsv.PublicKey(pubkey).toAddress().toString()\n\t\t// const hex = Buffer.from(res.hash, \"hex\")\n\t\t// const verified = Message.verify(hex, address, expected)\n\t\t// return verified\n\n\t\ttry {\n\t\t\t// TODO: bob transactions are missing this binary part, cannot verify signature\n\t\t\tconst bin = (cell[1].lb || cell[1].b) as string;\n\t\t\tconst buf = Buffer.from(bin, \"base64\");\n\t\t\tconst hashBuff = await sha256(buf);\n\t\t\tconst address = Address.fromPubKey(\n\t\t\t\tPubKey.fromString(bitpicObj.pubkey as string),\n\t\t\t);\n\n\t\t\tbitpicObj.verified = Bsm.verify(hashBuff, bitpicObj.signature, address);\n\t\t} catch (e) {\n\t\t\t// failed verification\n\t\t\tbitpicObj.verified = false;\n\t\t}\n\t}\n\n\tsaveProtocolData(dataObj, \"BITPIC\", bitpicObj);\n};\n\nexport const BITPIC: Protocol = {\n\tname: \"BITPIC\",\n\taddress: protocolAddress,\n\topReturnSchema,\n\thandler,\n};\n","import type { HandlerProps, Protocol } from \"../../types/common\";\nimport { AIPhandler, SIGPROTO } from \"./aip\";\n\nconst address = \"1HA1P2exomAwCUycZHr8WeyFoy5vuQASE3\";\n\nconst opReturnSchema = [\n\t{ hashing_algorithm: \"string\" },\n\t{ signing_algorithm: \"string\" },\n\t{ signing_address: \"string\" },\n\t{ signature: \"string\" },\n\t{ index_unit_size: \"number\" },\n\t[{ index: \"binary\" }],\n];\n\n// https://github.com/torusJKL/BitcoinBIPs/blob/master/HAIP.md\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n\tif (!tape) {\n\t\tthrow new Error(\"Invalid HAIP tx. Bad tape\");\n\t}\n\tif (!tx) {\n\t\tthrow new Error(\"Invalid HAIP tx.\");\n\t}\n\treturn await AIPhandler(\n\t\topReturnSchema,\n\t\tSIGPROTO.HAIP,\n\t\tdataObj,\n\t\tcell,\n\t\ttape,\n\t\ttx,\n\t);\n};\n\nexport const HAIP: Protocol = {\n\tname: \"HAIP\",\n\taddress,\n\topReturnSchema,\n\thandler,\n};\n","import { decode } from \"@msgpack/msgpack\";\nimport type { Cell } from \"bpu-ts\";\nimport { Buffer } from \"buffer\";\nimport type { HandlerProps, Protocol } from \"../../types/common\";\nimport type { MAP as MAPType } from \"../../types/protocols/map\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5\";\n\nconst opReturnSchema = [\n\t{\n\t\tcmd: {\n\t\t\tSET: [{ key: \"string\" }, { val: \"string\" }],\n\t\t\tSELECT: [{ tx: \"string\" }],\n\t\t\tADD: [{ key: \"string\" }, [{ val: \"string\" }]],\n\t\t\tDELETE: [{ key: \"string\" }, [{ val: \"string\" }]],\n\t\t\tJSON: \"string\",\n\t\t\tREMOVE: [[{ key: \"string\" }]],\n\t\t\tCLEAR: [[{ txid: \"string\" }]],\n\t\t},\n\t},\n];\n\nconst processADD = (cell: Cell[], mapObj: MAPType) => {\n\tlet last = null;\n\tfor (const pushdataContainer of cell) {\n\t\t// ignore MAP command\n\t\tif (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst pushdata = pushdataContainer.s as string;\n\t\tif (pushdataContainer.i === 2) {\n\t\t\t// Key name\n\t\t\tmapObj[pushdata] = [];\n\t\t\tlast = pushdata;\n\t\t} else {\n\t\t\tif (last && Array.isArray(mapObj[last])) {\n\t\t\t\t(mapObj[last] as string[]).push(pushdata);\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst proccessDELETE = (cell: Cell[], mapObj: MAPType) => {\n\tlet last = null;\n\tfor (const pushdataContainer of cell) {\n\t\t// ignore MAP command\n\t\tif (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst pushdata = pushdataContainer.s as string;\n\t\tif (pushdataContainer.i === 2) {\n\t\t\t// Key name\n\t\t\tmapObj[pushdata] = [];\n\t\t\tlast = pushdata;\n\t\t} else {\n\t\t\tif (last) {\n\t\t\t\t(mapObj[last] as string[]).push(pushdata);\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst processSELECT = (cell: Cell[], mapObj: MAPType) => {\n\t// TODO\n\t// console.log('MAP SELECT');\n\tfor (const pushdataContainer of cell) {\n\t\t// ignore MAP command\n\t\tif (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n\t\t\tmapObj.SELECT = \"TODO\";\n\t\t\tcontinue;\n\t\t}\n\t}\n};\n\nconst processMSGPACK = (cell: Cell[], mapObj: MAPType) => {\n\tfor (const pushdataContainer of cell) {\n\t\t// ignore MAP command\n\t\tif (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (pushdataContainer.i === 2) {\n\t\t\ttry {\n\t\t\t\tif (!decode) {\n\t\t\t\t\tthrow new Error(\"Msgpack is required but not loaded\");\n\t\t\t\t}\n\t\t\t\tconst buff = Buffer.from(pushdataContainer.b as string, \"base64\");\n\t\t\t\tmapObj = decode(buff) as MAPType;\n\t\t\t} catch (e) {\n\t\t\t\tmapObj = {} as MAPType;\n\t\t\t}\n\t\t}\n\t}\n\treturn mapObj;\n};\n\nconst processJSON = (cell: Cell[], mapObj: MAPType) => {\n\tfor (const pushdataContainer of cell) {\n\t\t// ignore MAP command\n\t\tif (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (pushdataContainer.i === 2) {\n\t\t\ttry {\n\t\t\t\tmapObj = JSON.parse(pushdataContainer.s as string);\n\t\t\t} catch (e) {\n\t\t\t\tmapObj = {} as MAPType;\n\t\t\t}\n\t\t}\n\t}\n\treturn mapObj;\n};\n\nconst processSET = (cell: Cell[], mapObj: MAPType) => {\n\tlet last = null;\n\tfor (const pushdataContainer of cell) {\n\t\t// ignore MAP command\n\t\tif (\n\t\t\t!pushdataContainer.s ||\n\t\t\tpushdataContainer.i === 0 ||\n\t\t\tpushdataContainer.i === 1\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst pushdata = pushdataContainer.s;\n\t\tif (pushdataContainer.i % 2 === 0) {\n\t\t\t// key\n\t\t\tmapObj[pushdata] = \"\";\n\t\t\tlast = pushdata;\n\t\t} else {\n\t\t\t// value\n\t\t\tif (!last) {\n\t\t\t\tthrow new Error(`malformed MAP syntax. Cannot parse.${last}`);\n\t\t\t}\n\t\t\tmapObj[last] = pushdata;\n\t\t}\n\t}\n};\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n\t// Validate\n\tif (\n\t\tcell[0].s !== address ||\n\t\t!cell[1] ||\n\t\t!cell[1].s ||\n\t\t!cell[2] ||\n\t\t!cell[2].s\n\t) {\n\t\tthrow new Error(`Invalid MAP record: ${tx}`);\n\t}\n\n\tlet mapObj = {} as MAPType;\n\n\t// parse the protocol separator\n\tconst commands: any[] = [];\n\tlet commandSeparator = 0;\n\tfor (let i = 1; i < cell.length; i++) {\n\t\tif (cell[i].s === \":::\") {\n\t\t\tcommandSeparator++;\n\t\t} else {\n\t\t\tif (!commands[commandSeparator]) commands[commandSeparator] = [];\n\t\t\tcell[i].i = commands[commandSeparator].length + 1;\n\t\t\tcommands[commandSeparator].push(cell[i]);\n\t\t}\n\t}\n\n\t// Get the MAP command key name from the query schema\n\tconst mapCmdKey = Object.keys(opReturnSchema[0])[0];\n\n\t// Add the firt MAP command in the response object\n\tmapObj[mapCmdKey] = commands[0][0].s;\n\n\tfor (const cc of commands) {\n\t\t// re-add the MAP address\n\t\tcc.unshift({\n\t\t\ts: address,\n\t\t\ti: 0,\n\t\t});\n\n\t\tconst command = cc[1].s;\n\t\t// Individual parsing rules for each MAP command\n\t\tswitch (command) {\n\t\t\t// Also check for SELECT commands and strip off the <SELECT> <TXID> part and run it through\n\t\t\tcase \"ADD\": {\n\t\t\t\tprocessADD(cc, mapObj);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"REMOVE\": {\n\t\t\t\tmapObj.key = cc[2].s;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"DELETE\": {\n\t\t\t\tproccessDELETE(cc, mapObj);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"CLEAR\": {\n\t\t\t\t// TODO\n\t\t\t\t// console.log('MAP CLEAR');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"SELECT\": {\n\t\t\t\tprocessSELECT(cc, mapObj);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"MSGPACK\": {\n\t\t\t\tmapObj = processMSGPACK(cc, mapObj);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"JSON\": {\n\t\t\t\tmapObj = processJSON(cc, mapObj);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"SET\": {\n\t\t\t\tprocessSET(cc, mapObj);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\t// don't know what to do ...\n\t\t\t}\n\t\t}\n\t}\n\n\tsaveProtocolData(dataObj, \"MAP\", mapObj);\n};\n\nexport const MAP: Protocol = {\n\tname: \"MAP\",\n\taddress,\n\topReturnSchema,\n\thandler,\n};\n","import { Buffer } from \"buffer\";\nimport type {\n\tHandlerProps,\n\tMetaNet,\n\tMetanetNode,\n\tProtocol,\n} from \"../../types/common\";\nimport { sha256 } from \"../utils\";\n\nconst address = \"meta\";\n\nconst opReturnSchema = [\n\t{ address: \"string\" },\n\t{ parent: \"string\" },\n\t{ name: \"string\" },\n];\n\nexport const getEnvSafeMetanetID = async (a: string, tx: string) => {\n\t// Calculate the node ID\n\tconst buf = Buffer.from(a + tx);\n\tconst hashBuf = await sha256(buf);\n\treturn hashBuf.toString(\"hex\");\n};\n\nconst handler = async ({ dataObj, cell, tx }: HandlerProps) => {\n\tif (\n\t\t!cell.length ||\n\t\tcell[0].s !== \"meta\" ||\n\t\t!cell[1] ||\n\t\t!cell[1].s ||\n\t\t!cell[2] ||\n\t\t!cell[2].s ||\n\t\t!tx\n\t) {\n\t\tthrow new Error(`Invalid Metanet tx ${tx}`);\n\t}\n\t// For now, we just copy from MOM keys later if available, or keep BOB format\n\n\tconst nodeId = await getEnvSafeMetanetID(cell[1].s, tx.tx.h);\n\t// Described this node\n\tconst node = {\n\t\ta: cell[1].s,\n\t\ttx: tx.tx.h,\n\t\tid: nodeId,\n\t};\n\tlet parent = {} as MetanetNode;\n\tif (tx.in) {\n\t\tconst parentId = await getEnvSafeMetanetID(tx.in[0].e.a, cell[2].s);\n\t\t// Parent node\n\t\tparent = {\n\t\t\ta: tx.in[0].e.a,\n\t\t\ttx: cell[2].s,\n\t\t\tid: parentId,\n\t\t};\n\t}\n\n\tif (!dataObj.METANET) {\n\t\tdataObj.METANET = [];\n\t}\n\tdataObj.METANET.push({\n\t\tnode,\n\t\tparent,\n\t} as MetaNet);\n};\n\nexport const METANET: Protocol = {\n\tname: \"METANET\",\n\taddress,\n\topReturnSchema,\n\thandler,\n};\n","import type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../../types/common\";\nimport type { ORD as OrdType } from \"../../types/protocols/ord\";\nimport { saveProtocolData } from \"../utils\";\n\n// const OrdScript =\n//     'OP_FALSE OP_IF 6F7264 OP_1 <CONTENT_TYPE_PLACEHOLDER> OP_0 <DATA_PLACEHOLDER> OP_ENDIF'.split(\n//         ' '\n//     )\n\nconst scriptChecker = (cell: Cell[]) => {\n\tif (cell.length < 13) {\n\t\t// wrong length\n\t\treturn false;\n\t}\n\n\t// Find OP_IF wrapper\n\tconst startIdx = findIndex(cell, (c: Cell) => c.ops === \"OP_IF\");\n\tconst endIdx = findIndex(\n\t\tcell,\n\t\t(c: Cell, i: number) => i > startIdx && c.ops === \"OP_ENDIF\",\n\t);\n\tconst ordScript = cell.slice(startIdx, endIdx);\n\tconst prevCell = cell[startIdx - 1];\n\treturn (\n\t\tprevCell?.op === 0 &&\n\t\t!!ordScript[0] &&\n\t\t!!ordScript[1] &&\n\t\tordScript[1].s == \"ord\"\n\t);\n};\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n\tif (!cell[0] || !out) {\n\t\tthrow new Error(\"Invalid Ord tx. dataObj, cell, out and tx are required.\");\n\t}\n\n\t// assemble asm\n\t// make sure first piece matches a txid\n\t// 2nd piece matches any difficulty. set some resonable limit in bytes if there isnt one documented somewhere\n\t// next\n\n\t// Find OP_IF wrapper\n\tconst startIdx = findIndex(cell, (c: Cell) => c.ops === \"OP_IF\");\n\tconst endIdx =\n\t\tfindIndex(\n\t\t\tcell,\n\t\t\t(c: Cell, i: number) => i > startIdx && c.ops === \"OP_ENDIF\",\n\t\t) + 1;\n\tconst ordScript = cell.slice(startIdx, endIdx);\n\n\tif (!ordScript[0] || !ordScript[1] || ordScript[1].s !== \"ord\") {\n\t\tthrow new Error(\"Invalid Ord tx. Prefix not found.\");\n\t}\n\n\tlet data: string | undefined;\n\tlet contentType: string | undefined;\n\tordScript.forEach((push, idx, all) => {\n\t\t// content-type\n\t\tif (push.ops === \"OP_1\") {\n\t\t\tcontentType = all[idx + 1].s;\n\t\t}\n\t\t// data\n\t\tif (push.ops === \"OP_0\") {\n\t\t\tdata = all[idx + 1].b;\n\t\t}\n\t});\n\n\tif (!data) {\n\t\tthrow new Error(\"Invalid Ord data.\");\n\t}\n\tif (!contentType) {\n\t\tthrow new Error(\"Invalid Ord content type.\");\n\t}\n\n\tconst OrdObj: OrdType = {\n\t\tdata,\n\t\tcontentType,\n\t};\n\n\tsaveProtocolData(dataObj, \"ORD\", OrdObj);\n};\n\nexport const ORD: Protocol = {\n\tname: \"ORD\",\n\thandler,\n\tscriptChecker,\n};\n\nfunction findIndex(array: any[], predicate: Function) {\n\treturn findLastIndex(array, predicate);\n}\nfunction findLastIndex(array: any[], predicate: Function, fromIndex?: number) {\n\tconst length = array == null ? 0 : array.length;\n\tif (!length) {\n\t\treturn -1;\n\t}\n\tlet index = length - 1;\n\tif (fromIndex !== undefined) {\n\t\tindex = fromIndex;\n\t\tindex =\n\t\t\tfromIndex < 0 ? Math.max(length + index, 0) : Math.min(index, length - 1);\n\t}\n\treturn baseFindIndex(array, predicate, index, true);\n}\n\nfunction baseFindIndex(\n\tarray: any[],\n\tpredicate: Function,\n\tfromIndex: number,\n\tfromRight: boolean,\n) {\n\tconst { length } = array;\n\tlet index = fromIndex + (fromRight ? 1 : -1);\n\n\twhile (fromRight ? index-- : ++index < length) {\n\t\tif (predicate(array[index], index, array)) {\n\t\t\treturn index;\n\t\t}\n\t}\n\treturn -1;\n}\n","import type { HandlerProps, Protocol } from \"../../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1GvFYzwtFix3qSAZhESQVTz9DeudHZNoh1\";\n\nconst opReturnSchema = [\n\t{ pair: \"json\" },\n\t{ address: \"string\" },\n\t{ timestamp: \"string\" },\n];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n\tif (\n\t\tcell[0].s !== address ||\n\t\t!cell[1] ||\n\t\t!cell[2] ||\n\t\t!cell[3] ||\n\t\t!cell[1].s ||\n\t\t!cell[2].s ||\n\t\t!cell[3].s\n\t) {\n\t\tthrow new Error(`Invalid RON record ${tx?.tx.h}`);\n\t}\n\n\tconst pair = JSON.parse(cell[1].s);\n\tconst timestamp = Number(cell[3].s);\n\n\tsaveProtocolData(dataObj, \"RON\", {\n\t\tpair,\n\t\taddress: cell[2].s,\n\t\ttimestamp,\n\t});\n};\n\nexport const RON: Protocol = {\n\tname: \"RON\",\n\taddress,\n\topReturnSchema,\n\thandler,\n};\n","import type { HandlerProps } from \"../../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1SymRe7erxM46GByucUWnB9fEEMgo7spd\";\n\nconst opReturnSchema = [{ url: \"string\" }];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n\tif (cell[0].s !== address || !cell[1] || !cell[1].s) {\n\t\tthrow new Error(`Invalid SymRe tx: ${tx}`);\n\t}\n\n\tsaveProtocolData(dataObj, \"SYMRE\", { url: cell[1].s });\n};\n\nexport const SYMRE = {\n\tname: \"SYMRE\",\n\taddress,\n\topReturnSchema,\n\thandler,\n};\n"],"names":[],"version":3,"file":"bmap.js.map","sourceRoot":"../"}