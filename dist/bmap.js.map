{"mappings":"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","sources":["src/bmap.ts","src/protocols/_21e8.ts","src/utils.ts","src/protocols/aip.ts","src/protocols/b.ts","src/protocols/bap.ts","src/protocols/bitcom.ts","src/protocols/bitkey.ts","src/protocols/bitpic.ts","src/protocols/haip.ts","src/protocols/map.ts","src/protocols/metanet.ts","src/protocols/ord.ts","src/protocols/ron.ts","src/protocols/symre.ts"],"sourcesContent":["import { type In, type Out, type Tape, parse } from \"bpu-ts\";\nimport type {\n\tBmapTx,\n\tBobTx,\n\tHandler,\n\tHandlerProps,\n\tMetaNet,\n\tMomTx,\n\tProtocol,\n\tScriptChecker,\n} from \"../types/common\";\nimport { _21E8 } from \"./protocols/_21e8\";\nimport { AIP } from \"./protocols/aip\";\nimport { B } from \"./protocols/b\";\nimport { BAP } from \"./protocols/bap\";\nimport { BITCOM } from \"./protocols/bitcom\";\nimport { BITKEY } from \"./protocols/bitkey\";\nimport { BITPIC } from \"./protocols/bitpic\";\nimport { HAIP } from \"./protocols/haip\";\nimport { MAP } from \"./protocols/map\";\nimport { METANET } from \"./protocols/metanet\";\nimport { ORD } from \"./protocols/ord\";\nimport { RON } from \"./protocols/ron\";\nimport { SYMRE } from \"./protocols/symre\";\nimport {\n\tcheckOpFalseOpReturn,\n\tcheckOpReturn,\n\tisObjectArray,\n\tisStringArray,\n\tsaveProtocolData,\n} from \"./utils\";\n\n// Names of enabled protocols\nconst enabledProtocols = new Map<string, string>([]);\n// Protocol Handlers\nconst protocolHandlers = new Map<string, Handler>([]);\n// Script checkers are intentionally minimalistic detection functions for identifying matching scripts for a given protocol. Only if a checker returns true is a handler called for processing.\nconst protocolScriptCheckers = new Map<string, ScriptChecker>([]);\nconst protocolOpReturnSchemas = new Map<string, Object[]>();\n\nexport const allProtocols = [\n\tAIP,\n\tB,\n\tBAP,\n\tMAP,\n\tMETANET,\n\t_21E8,\n\tBITCOM,\n\tBITKEY,\n\tBITPIC,\n\tHAIP,\n\tRON,\n\tSYMRE,\n\tORD,\n];\n\nexport const supportedProtocols = allProtocols.map((p) => p.name);\nexport const defaultProtocols = [AIP, B, BAP, MAP, METANET, ORD];\n\n// prepare protocol map, handlers and schemas\nfor (const protocol of defaultProtocols) {\n\tif (protocol.address) {\n\t\tenabledProtocols.set(protocol.address, protocol.name);\n\t}\n\tprotocolHandlers.set(protocol.name, protocol.handler);\n\tif (protocol.opReturnSchema) {\n\t\tprotocolOpReturnSchemas.set(protocol.name, protocol.opReturnSchema);\n\t}\n\tif (protocol.scriptChecker) {\n\t\tprotocolScriptCheckers.set(protocol.name, protocol.scriptChecker);\n\t}\n}\n\n// Takes a BOB formatted op_return transaction\nexport class BMAP {\n\tenabledProtocols: Map<string, string>;\n\n\tprotocolHandlers: Map<string, Handler>;\n\n\tprotocolScriptCheckers: Map<string, ScriptChecker>;\n\n\tprotocolOpReturnSchemas: Map<string, Object[]>;\n\n\tconstructor() {\n\t\t// initial default protocol handlers in this instantiation\n\t\tthis.enabledProtocols = enabledProtocols;\n\t\tthis.protocolHandlers = protocolHandlers;\n\t\tthis.protocolScriptCheckers = protocolScriptCheckers;\n\t\tthis.protocolOpReturnSchemas = protocolOpReturnSchemas;\n\t}\n\n\taddProtocolHandler({\n\t\tname,\n\t\taddress,\n\t\topReturnSchema,\n\t\thandler,\n\t\tscriptChecker,\n\t}: Protocol) {\n\t\tif (address) {\n\t\t\tthis.enabledProtocols.set(address, name);\n\t\t}\n\t\tthis.protocolHandlers.set(name, handler);\n\t\tif (opReturnSchema) {\n\t\t\tthis.protocolOpReturnSchemas.set(name, opReturnSchema);\n\t\t}\n\t\tif (scriptChecker) {\n\t\t\tthis.protocolScriptCheckers.set(name, scriptChecker);\n\t\t}\n\t}\n\n\ttransformTx = async (tx: BobTx | MomTx): Promise<BmapTx> => {\n\t\tif (!tx || !tx.in || !tx.out) {\n\t\t\tthrow new Error(\"Cannot process tx\");\n\t\t}\n\n\t\t// This will become our nicely formatted response object\n\t\tlet dataObj: Partial<BobTx> = {};\n\n\t\tfor (const [key, val] of Object.entries(tx)) {\n\t\t\tif (key === \"out\") {\n\t\t\t\t// loop over the outputs\n\t\t\t\tfor (const out of tx.out) {\n\t\t\t\t\tconst { tape } = out;\n\n\t\t\t\t\t// Process opReturn data\n\t\t\t\t\tif (tape?.some((cc) => checkOpReturn(cc))) {\n\t\t\t\t\t\tdataObj = await this.processDataProtocols(tape, out, tx, dataObj);\n\t\t\t\t\t}\n\n\t\t\t\t\t// No OP_FALSE OP_RETURN in this tape\n\t\t\t\t\tconst _21e8Checker = this.protocolScriptCheckers.get(_21E8.name);\n\t\t\t\t\tconst ordChecker = this.protocolScriptCheckers.get(ORD.name);\n\n\t\t\t\t\t// Check for 21e8 and ords\n\t\t\t\t\tif (\n\t\t\t\t\t\ttape?.some((cc) => {\n\t\t\t\t\t\t\tconst { cell } = cc;\n\t\t\t\t\t\t\tif (_21e8Checker?.(cell)) {\n\t\t\t\t\t\t\t\t// 'found 21e8'\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ordChecker?.(cell)) {\n\t\t\t\t\t\t\t\t// 'found 1sat ordinal'\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t) {\n\t\t\t\t\t\t// find the cell array\n\t\t\t\t\t\t// loop over tape\n\t\t\t\t\t\tfor (const cellContainer of tape) {\n\t\t\t\t\t\t\tconst { cell } = cellContainer;\n\t\t\t\t\t\t\t// Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n\t\t\t\t\t\t\tif (!cell) {\n\t\t\t\t\t\t\t\tthrow new Error(\"empty cell while parsing\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet protocolName = \"\";\n\t\t\t\t\t\t\tif (_21e8Checker?.(cell)) {\n\t\t\t\t\t\t\t\tprotocolName = _21E8.name;\n\t\t\t\t\t\t\t} else if (ordChecker?.(cell)) {\n\t\t\t\t\t\t\t\tprotocolName = ORD.name;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// nothing found\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.process(protocolName, {\n\t\t\t\t\t\t\t\ttx,\n\t\t\t\t\t\t\t\tcell,\n\t\t\t\t\t\t\t\tdataObj: dataObj as BmapTx,\n\t\t\t\t\t\t\t\ttape,\n\t\t\t\t\t\t\t\tout,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (key === \"in\") {\n\t\t\t\tdataObj[key] = val.map((v: In) => {\n\t\t\t\t\tconst r = { ...v } as any;\n\t\t\t\t\tdelete r.tape;\n\t\t\t\t\treturn r as In;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// known key, just write it retaining original type\n\t\t\t\tdataObj[key] = val;\n\t\t\t}\n\t\t}\n\n\t\t// If this is a MOM planaria it will have metanet keys available\n\t\tif (dataObj.METANET && (tx as MomTx).parent) {\n\t\t\tconst meta = {\n\t\t\t\tancestor: (tx as MomTx).ancestor,\n\t\t\t\tparent: (tx as MomTx).parent,\n\t\t\t\tchild: (tx as MomTx).child,\n\t\t\t\thead: (tx as MomTx).head,\n\t\t\t} as MetaNet;\n\t\t\t(dataObj.METANET as MetaNet[]).push(meta);\n\t\t\t// remove parent and node from root level for (MOM data)\n\t\t\tdelete dataObj.ancestor;\n\t\t\tdelete dataObj.child;\n\t\t\tdelete dataObj.parent;\n\t\t\tdelete dataObj.head;\n\t\t\tdelete dataObj.node;\n\t\t}\n\n\t\treturn dataObj as BmapTx;\n\t};\n\n\tprocessUnknown = (key: string, dataObj: Partial<BmapTx>, out: Out) => {\n\t\t// no known non-OP_RETURN scripts\n\t\tif (key && !dataObj[key]) {\n\t\t\tdataObj[key] = [];\n\t\t}\n\t\t(dataObj[key] as Out[]).push({\n\t\t\ti: out.i,\n\t\t\te: out.e,\n\t\t\ttape: [],\n\t\t});\n\t};\n\n\tprocess = async (\n\t\tprotocolName: string,\n\t\t{ cell, dataObj, tape, out, tx }: HandlerProps,\n\t) => {\n\t\tif (\n\t\t\tthis.protocolHandlers.has(protocolName) &&\n\t\t\ttypeof this.protocolHandlers.get(protocolName) === \"function\"\n\t\t) {\n\t\t\tconst handler = this.protocolHandlers.get(protocolName);\n\t\t\tif (handler) {\n\t\t\t\t/* eslint-disable no-await-in-loop */\n\t\t\t\tawait handler({\n\t\t\t\t\tdataObj: dataObj,\n\t\t\t\t\tcell,\n\t\t\t\t\ttape,\n\t\t\t\t\tout,\n\t\t\t\t\ttx,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tsaveProtocolData(dataObj, protocolName, cell);\n\t\t}\n\t};\n\n\tprocessDataProtocols = async (\n\t\ttape: Tape[],\n\t\tout: Out,\n\t\ttx: BobTx,\n\t\tdataObj: Partial<BobTx>,\n\t): Promise<Partial<BobTx>> => {\n\t\t// loop over tape\n\t\tfor (const cellContainer of tape) {\n\t\t\tconst { cell } = cellContainer;\n\t\t\tif (!cell) {\n\t\t\t\tthrow new Error(\"empty cell while parsing\");\n\t\t\t}\n\n\t\t\t// Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n\t\t\tif (checkOpFalseOpReturn(cellContainer)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst prefix = cell[0].s;\n\n\t\t\tif (prefix) {\n\t\t\t\tconst bitcomProtocol =\n\t\t\t\t\tthis.enabledProtocols.get(prefix) ||\n\t\t\t\t\tdefaultProtocols.filter((p) => p.name === prefix)[0]?.name;\n\t\t\t\tif (bitcomProtocol) {\n\t\t\t\t\tawait this.process(bitcomProtocol, {\n\t\t\t\t\t\tcell,\n\t\t\t\t\t\tdataObj: dataObj as BmapTx,\n\t\t\t\t\t\ttape,\n\t\t\t\t\t\tout,\n\t\t\t\t\t\ttx,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthis.processUnknown(prefix, dataObj, out);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dataObj;\n\t};\n}\n\nexport const fetchRawTx = async (txid: string): Promise<string> => {\n\tconst url = `https://api.whatsonchain.com/v1/bsv/main/tx/${txid}/hex`;\n\n\tconsole.log(\"hitting\", url);\n\n\tconst res = await fetch(url);\n\treturn await res.text();\n};\n\nexport const bobFromRawTx = async (rawTx: string): Promise<BobTx> => {\n\tconst bpuTx = await parse({\n\t\ttx: { r: rawTx },\n\t\tsplit: [\n\t\t\t{\n\t\t\t\ttoken: { op: 106 },\n\t\t\t\tinclude: \"l\",\n\t\t\t},\n\t\t\t{\n\t\t\t\ttoken: { s: \"|\" },\n\t\t\t},\n\t\t],\n\t});\n\treturn bpuTx as BobTx;\n};\n\n// TransformTx\n// tx - a raw hex string or a Bob/Bmap/Mom transaction object\n// protocols - the handlers you want to load and use to process the tx\n// reducing the number of supported protocols may improve transform speed\n// at the expense of detecting more data protocols\nexport const TransformTx = async (\n\ttx: BobTx | string | MomTx | BmapTx,\n\tprotocols?: string[] | Protocol[],\n) => {\n\tif (typeof tx === \"string\") {\n\t\tlet rawTx: string | undefined;\n\t\t// if it a txid or  complete transaction hex?\n\t\tif (tx.length === 64) {\n\t\t\t// txid - fetch raw tx\n\t\t\trawTx = await fetchRawTx(tx);\n\t\t}\n\n\t\tif (Buffer.from(tx).byteLength <= 146) {\n\t\t\tthrow new Error(\"Invalid rawTx\");\n\t\t}\n\n\t\tif (!rawTx) {\n\t\t\trawTx = tx;\n\t\t}\n\n\t\t// TODO: Double check 146 is intended to be minimum possible byte length for a tx\n\t\tconst bobTx = await bobFromRawTx(rawTx);\n\n\t\tif (bobTx) {\n\t\t\ttx = bobTx;\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid txid\");\n\t\t}\n\t}\n\n\tconst b = new BMAP();\n\n\t// if protocols are specified\n\tif (protocols) {\n\t\t// wipe out defaults\n\t\tb.enabledProtocols.clear();\n\t\tif (isStringArray(protocols)) {\n\t\t\t// set enabled protocols\n\t\t\tfor (const protocol of allProtocols) {\n\t\t\t\tif ((protocols as string[])?.includes(protocol.name)) {\n\t\t\t\t\tb.addProtocolHandler(protocol);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObjectArray(protocols)) {\n\t\t\tfor (const p of protocols) {\n\t\t\t\tconst protocol = p as Protocol;\n\t\t\t\tif (protocol) {\n\t\t\t\t\tb.addProtocolHandler(protocol);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t\"Invalid protocol array. Must be either an array of protocol names (string[]), or Protocol objects (Protocol[]).\",\n\t\t\t);\n\t\t}\n\t}\n\n\treturn b.transformTx(tx);\n};\n","import type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../../types/common\";\nimport type { _21E8 as _21E8Type } from \"../../types/protocols/_21e8\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\n// 21e8 does not use the first pushdata for id\n// in fact there is no id since the 21e8 is designed for difficulty and can be changed\n// instead we use the static part of the script to indentfy the transaction\n// TODO - the OP_X_PLACEHOLDER is the number of bytes to push onto the stack and must match difficulty size\nconst _21e8Script =\n\t\"OP_SIZE <OP_X_PLACEHOLDER> OP_PICK OP_SHA256 OP_SWAP OP_SPLIT OP_DROP OP_EQUALVERIFY OP_DROP OP_CHECKSIG\".split(\n\t\t\" \",\n\t);\n\nconst scriptChecker = (cell: Cell[]) => {\n\tif (cell.length !== 12) {\n\t\t// wrong length\n\t\treturn false;\n\t}\n\n\t// match exact script\n\tconst ops = [...cell].map((c) => c.ops).splice(2, cell.length);\n\n\t// calculate target byte length\n\tconst target = cellValue(cell[1], \"hex\") as string;\n\tconst targetOpSize = Buffer.from(target).byteLength;\n\n\t// replace the placeholder opcode with actual\n\tops[1] = `OP_${targetOpSize}`;\n\t_21e8Script[1] = `OP_${targetOpSize}`;\n\n\t// protocol identifier always in first pushdata\n\treturn ops.join() === _21e8Script.join();\n};\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n\tif (!cell[0] || !out) {\n\t\tthrow new Error(\"Invalid 21e8 tx. dataObj, cell, out and tx are required.\");\n\t}\n\n\t// assemble asm\n\t// make sure first piece matches a txid\n\t// 2nd piece matches any difficulty. set some resonable limit in bytes if there isnt one documented somewhere\n\t// next\n\n\tconst txid = cellValue(cell[0], \"hex\") as string;\n\tconst target = cellValue(cell[1], \"hex\") as string;\n\tif (!target) {\n\t\tthrow new Error(`Invalid 21e8 target. ${JSON.stringify(cell[0], null, 2)}`);\n\t}\n\tconst difficulty = Buffer.from(target, \"hex\").byteLength;\n\n\tconst _21e8Obj: _21E8Type = {\n\t\ttarget,\n\t\tdifficulty,\n\t\tvalue: out.e.v,\n\t\ttxid,\n\t};\n\n\tsaveProtocolData(dataObj, \"21E8\", _21e8Obj);\n};\n\nexport const _21E8: Protocol = {\n\tname: \"21E8\",\n\thandler,\n\tscriptChecker,\n};\n","import { Hash, Utils } from '@bsv/sdk'\nimport { Cell, Tape } from 'bpu-ts'\nimport { Buffer } from 'buffer'\nimport { BobTx } from '../types/common'\nconst { toArray } = Utils;\n\nexport const isStringArray = (arr: Array<any>): boolean => {\n  return (\n    arr.length > 0 &&\n    arr.every((value) => {\n      return typeof value === 'string'\n    })\n  )\n}\nexport const isObjectArray = (arr: Array<any>): boolean => {\n  return (\n    arr.length > 0 &&\n    arr.every((value) => {\n      return value === 'object'\n    })\n  )\n}\n/**\n * returns the BOB cell value for a given encoding\n *\n * @param pushData\n * @param schemaEncoding\n * @returns {string|number}\n */\nexport const cellValue = (\n  pushData: Cell,\n  schemaEncoding?: string\n): string | number => {\n  if (!pushData) {\n    throw new Error(`cannot get cell value of: ${pushData}`)\n  } else if (schemaEncoding === 'string') {\n    return pushData['s'] ? pushData.s : pushData.ls || ''\n  } else if (schemaEncoding === 'hex') {\n    return pushData['h']\n      ? pushData.h\n      : pushData.lh ||\n      (pushData['b']\n        ? Buffer.from(pushData.b, 'base64').toString('hex')\n        : pushData.lb &&\n        Buffer.from(pushData.lb, 'base64').toString('hex')) ||\n      ''\n  } else if (schemaEncoding === 'number') {\n    return parseInt(pushData['h'] ? pushData.h : pushData.lh || '0', 16)\n  } else if (schemaEncoding === 'file') {\n    return `bitfs://${pushData['f'] ? pushData.f : pushData.lf}`\n  }\n\n  return (pushData['b'] ? pushData.b : pushData.lb) || ''\n}\n\n/**\n * Check if cells end with OP_RETURN\n */\nexport const checkOpReturn = (cc: Tape): boolean => {\n  return cc.cell.some((c: Cell) => c.op === 106)\n}\n\n/**\n * Check if cells end with OP_FALSE + OP_RETURN\n */\nexport const checkOpFalseOpReturn = (cc: Tape): boolean => {\n  if (cc.cell.length !== 2) {\n    return false\n  }\n  const opReturnIdx = cc.cell.findIndex((c) => c.op === 106)\n  if (opReturnIdx !== -1) {\n    return cc.cell[opReturnIdx - 1]?.op === 0\n  }\n  return false\n}\n\n/**\n * Helper function to store protocol data\n *\n * @param dataObj\n * @param protocolName\n * @param data\n */\nexport const saveProtocolData = (\n  dataObj: { [key: string]: any },\n  protocolName: string,\n  data: any\n) => {\n  if (!dataObj[protocolName]) {\n    dataObj[protocolName] = [data]\n  } else {\n    dataObj[protocolName].push(data)\n  }\n}\n\n/**\n * BMAP default handler to work with query schema's\n *\n * @param opReturnSchema\n * @param protocolName\n * @param dataObj\n * @param cell\n * @param tape\n * @param tx\n */\nexport const bmapOpReturnSchemaHandler = function (\n  protocolName: string,\n  opReturnSchema: Object[],\n  dataObj: Object,\n  cell: Cell[],\n  tx: BobTx\n) {\n  // loop over the schema\n  const obj: { [key: string]: any } = {}\n\n  // Does not have the required number of fields\n  const length = opReturnSchema.length + 1\n  if (cell.length < length) {\n    throw new Error(\n      `${protocolName} requires at least ${length} fields including the prefix: ${tx.tx.h}`\n    )\n  }\n\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = parseInt(idx, 10)\n\n    const [field] = Object.keys(schemaField)\n    const [schemaEncoding] = Object.values(schemaField)\n    obj[field] = cellValue(cell[x + 1], schemaEncoding)\n  }\n\n  saveProtocolData(dataObj, protocolName, obj)\n}\n\n/**\n * Check whether the given data is base64\n *\n * @param data\n * @returns {boolean}\n */\nexport const isBase64 = function (data: string) {\n  const regex =\n    '(?:[A-Za-z0-9+\\\\/]{4})*(?:[A-Za-z0-9+\\\\/]{2}==|[A-Za-z0-9+/]{3}=)?'\n  return new RegExp(`^${regex}$`, 'gi').test(data)\n}\n\n// hashes a message buffer, returns the hash as a buffer\nexport const sha256 = (msgBuffer: number[]) => {\n  return Hash.sha256(toArray(msgBuffer))\n}\n","import { BSM, BigNumber, Hash, type PublicKey, Script, Signature, Utils } from \"@bsv/sdk\";\nimport type { Cell, Tape } from \"bpu-ts\";\nimport { Buffer } from \"buffer\";\nimport fetch from \"node-fetch\";\nimport type { HandlerProps, Protocol } from \"../../types/common\";\nimport type { AIP as AIPType } from \"../../types/protocols/aip\";\nimport type { HAIP as HAIPType } from \"../../types/protocols/haip\";\nimport { cellValue, checkOpFalseOpReturn, isBase64, saveProtocolData } from \"../utils\";\n\nconst { toArray, toHex, fromBase58Check, toBase58Check } = Utils;\n\nconst address = \"15PciHG22SNLQJXMoSUaWVi7WSqc7hCfva\";\nconst opReturnSchema = [\n  { algorithm: \"string\" },\n  { address: \"string\" },\n  { signature: \"binary\" },\n  [{ index: \"binary\" }],\n];\n\nconst getFileBuffer = async (bitfsRef: string) => {\n  try {\n    const result = await fetch(`https://x.bitfs.network/${bitfsRef}`);\n    return await result.buffer();\n  } catch {\n    return Buffer.from(\"\");\n  }\n};\n\nfunction toBigNumberFromBuffer(buffer: number[]): BigNumber {\n  const hex = toHex(buffer);\n  return new BigNumber(hex, 16);\n}\n\nfunction recoverPublicKeyFromBSM(message: number[], signature: Signature, expectedAddress: string): PublicKey {\n  const msgHash = BSM.magicHash(message);\n  const bigMsg = toBigNumberFromBuffer(msgHash);\n\n  for (let recovery = 0; recovery < 4; recovery++) {\n    try {\n      const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n      const pubKeyHash = publicKey.toHash() as number[];\n      const { prefix } = fromBase58Check(expectedAddress);\n      const recoveredAddress = toBase58Check(pubKeyHash, prefix as number[]);\n      if (recoveredAddress === expectedAddress) {\n        console.log(\"[recoverPublicKeyFromBSM] Successfully recovered matching public key\");\n        return publicKey;\n      } else {\n        console.log(\"[recoverPublicKeyFromBSM] Trying recovery=\", recovery, \"Recovered address=\", recoveredAddress, \"expected=\", expectedAddress);\n      }\n    } catch (e) {\n      console.log(\"[recoverPublicKeyFromBSM] Recovery error:\", e);\n    }\n  }\n\n  console.log(\"[recoverPublicKeyFromBSM] Failed to recover any matching address\");\n  throw new Error(\"Failed to recover public key matching the expected address\");\n}\n\nfunction fromSafeDataArray(dataBufs: Buffer[]): Script {\n  const script = new Script();\n  script.chunks.push({ op: 0 }); // OP_FALSE\n  script.chunks.push({ op: 106 }); // OP_RETURN\n  for (const buf of dataBufs) {\n    const length = buf.length;\n    if (length <= 75) {\n      script.chunks.push({ op: length, data: Array.from(buf) });\n    } else if (length <= 0xff) {\n      script.chunks.push({ op: 0x4c, data: Array.from(buf) });\n    } else if (length <= 0xffff) {\n      script.chunks.push({ op: 0x4d, data: Array.from(buf) });\n    } else {\n      script.chunks.push({ op: 0x4e, data: Array.from(buf) });\n    }\n  }\n  return script;\n}\n\nasync function validateSignature(\n  aipObj: Partial<AIPType | HAIPType>,\n  cell: Cell[],\n  tape: Tape[]\n): Promise<boolean> {\n  if (!Array.isArray(tape) || tape.length < 3) {\n    throw new Error(\"AIP requires at least 3 cells including the prefix\");\n  }\n\n  let cellIndex = -1;\n  tape.forEach((cc, index) => {\n    if (cc.cell === cell) {\n      cellIndex = index;\n    }\n  });\n  if (cellIndex === -1) {\n    throw new Error(\"AIP could not find cell in tape\");\n  }\n\n  let usingIndexes: number[] = (aipObj.index as number[]) || [];\n  const signatureValues: string[] = [\"6a\"]; // index 0: OP_RETURN\n\n  // Gather data from all previous cells\n  for (let i = 0; i < cellIndex; i++) {\n    const cellContainer = tape[i];\n    if (!checkOpFalseOpReturn(cellContainer)) {\n      const cellData: string[] = [];\n      for (const statement of cellContainer.cell) {\n        let value: string | undefined;\n        if (statement.h) {\n          value = statement.h;\n        } else if (statement.f) {\n          const fileBuffer = await getFileBuffer(statement.f);\n          value = fileBuffer.length > 0 ? fileBuffer.toString(\"hex\") : undefined;\n        } else if (statement.b) {\n          const buf = Buffer.from(statement.b, \"base64\");\n          if (buf.length > 0) {\n            value = buf.toString(\"hex\");\n          }\n        } else if (statement.s) {\n          if (statement.s.length > 0) {\n            value = Buffer.from(statement.s).toString(\"hex\");\n          }\n        }\n\n        if (value && value.length > 0) {\n          cellData.push(value);\n        }\n      }\n      if (cellData.length > 0) {\n        // add all cellData\n        signatureValues.push(...cellData);\n        // add pipe after this cell\n        signatureValues.push(\"7c\");\n      }\n    }\n  }\n\n  // Now HAIP indexing logic\n  if (aipObj.hashing_algorithm && aipObj.index_unit_size) {\n    const indexLength = aipObj.index_unit_size * 2;\n    usingIndexes = [];\n    const indexesHex = cell[6]?.h || \"\";\n    for (let i = 0; i < indexesHex.length; i += indexLength) {\n      usingIndexes.push(Number.parseInt(indexesHex.substr(i, indexLength), 16));\n    }\n    aipObj.index = usingIndexes;\n  }\n\n  console.log(\"usingIndexes\", usingIndexes);\n  console.log(\"signatureValues\", signatureValues);\n\n  const signatureBufferStatements: Buffer[] = [];\n  if (usingIndexes.length > 0) {\n    for (const idx of usingIndexes) {\n      if (typeof signatureValues[idx] !== 'string') {\n        console.log(\"signatureValues[idx]\", signatureValues[idx], \"idx\", idx);\n      }\n      if (!signatureValues[idx]) {\n        console.log(\"signatureValues is missing an index\", idx, \"This means indexing is off\");\n        return false;\n      }\n      signatureBufferStatements.push(Buffer.from(signatureValues[idx], \"hex\"));\n    }\n  } else {\n    for (const val of signatureValues) {\n      signatureBufferStatements.push(Buffer.from(val, \"hex\"));\n    }\n  }\n\n  console.log(\"signatureBufferStatements\", signatureBufferStatements.map((b) => b.toString(\"hex\")));\n\n  let messageBuffer: Buffer;\n  if (aipObj.hashing_algorithm) {\n    // HAIP logic\n    if (!aipObj.index_unit_size) {\n      // remove OP_RETURN chunk\n      signatureBufferStatements.shift();\n    }\n    const dataScript = fromSafeDataArray(signatureBufferStatements);\n    let dataBuffer = Buffer.from(dataScript.toHex(), \"hex\");\n    if (aipObj.index_unit_size) {\n      dataBuffer = dataBuffer.slice(1);\n    }\n    const hashed = Hash.sha256(toArray(dataBuffer));\n    messageBuffer = Buffer.from(hashed);\n  } else {\n    // regular AIP\n    messageBuffer = Buffer.concat(signatureBufferStatements);\n  }\n\n  const addressString = (aipObj as AIPType).address || (aipObj as HAIPType).signing_address;\n  const signatureStr = aipObj.signature as string;\n  const signature = Signature.fromCompact(signatureStr, 'base64');\n\n  const tryNormalLogic = (): boolean => {\n    console.log(\"[validateSignature:tryNormalLogic] start\");\n    try {\n      const msgArr = toArray(messageBuffer);\n      const recoveredPubkey = recoverPublicKeyFromBSM(msgArr, signature, addressString);\n      console.log(\"[tryNormalLogic] recoveredPubkey ok, verifying with BSM.verify now\");\n      const res = BSM.verify(msgArr, signature, recoveredPubkey);\n      console.log(\"[tryNormalLogic] BSM.verify result:\", res);\n      return res;\n    } catch (err) {\n      console.log(\"[tryNormalLogic] error:\", err);\n      return false;\n    }\n  };\n\n  const tryTwetchLogic = (): boolean => {\n    console.log(\"[validateSignature:tryTwetchLogic] start\");\n    // For twetch: remove first and last item and sha256 the remainder, interpret hex as utf8\n    if (signatureBufferStatements.length <= 2) {\n      return false;\n    }\n    const trimmed = signatureBufferStatements.slice(1, -1);\n    console.log(\"[tryTwetchLogic] trimmedStatements count:\", trimmed.length);\n    const buff = Hash.sha256(toArray(Buffer.concat(trimmed)));\n    const hexStr = toHex(buff);\n    const twetchMsg = Buffer.from(hexStr, \"utf8\");\n    try {\n      const recoveredPubkey = recoverPublicKeyFromBSM(toArray(twetchMsg), signature, addressString);\n      console.log(\"[tryTwetchLogic] recoveredPubkey ok, verifying with BSM.verify now\");\n      const res = BSM.verify(toArray(twetchMsg), signature, recoveredPubkey);\n      console.log(\"[tryTwetchLogic] BSM.verify result:\", res);\n      return res;\n    } catch (err) {\n      console.log(\"[tryTwetchLogic] error:\", err);\n      return false;\n    }\n  };\n\n  let verified = tryNormalLogic();\n  if (!verified) {\n    verified = tryTwetchLogic();\n  }\n\n  console.log(\"[validateSignature] final verified=\", verified);\n  (aipObj as AIPType).verified = verified;\n  return verified;\n}\n\nexport enum SIGPROTO {\n  HAIP = \"HAIP\",\n  AIP = \"AIP\",\n}\n\nexport const AIPhandler = async (\n  useOpReturnSchema: any[],\n  protocol: SIGPROTO,\n  dataObj: any,\n  cell: Cell[],\n  tape: Tape[],\n  tx?: any\n) => {\n  const aipObj: { [key: string]: any } = { verified: false };\n\n  // minimal fields check\n  if (cell.length < 4) {\n    throw new Error(\"AIP requires at least 4 fields including the prefix\");\n  }\n\n  for (const [idx, schemaField] of Object.entries(useOpReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n    if (Array.isArray(schemaField)) {\n      const [aipField] = Object.keys(schemaField[0]) as (keyof AIPType)[];\n      const fieldData: number[] = [];\n      for (let i = x + 1; i < cell.length; i++) {\n        if (cell[i].h) {\n          fieldData.push(Number.parseInt(cell[i].h!, 16));\n        }\n      }\n      aipObj[aipField] = fieldData;\n    } else {\n      const [aipField] = Object.keys(schemaField) as (keyof AIPType)[];\n      const [schemaEncoding] = Object.values(schemaField);\n      aipObj[aipField] = cellValue(cell[x + 1], schemaEncoding as string) || \"\";\n    }\n  }\n\n  if (cell[0].s === address && cell[3].s && isBase64(cell[3].s)) {\n    aipObj.signature = cell[3].s;\n  }\n\n  console.log(\"[AIPhandler] AIP object before validate:\", aipObj);\n\n  if (!aipObj.signature) {\n    throw new Error(\"AIP requires a signature\");\n  }\n\n  await validateSignature(aipObj as Partial<AIPType>, cell, tape);\n  console.log(\"[AIPhandler] After validate, verified:\", aipObj.verified);\n\n  saveProtocolData(dataObj, protocol, aipObj);\n};\n\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n  if (!tape) {\n    throw new Error(\"Invalid AIP transaction\");\n  }\n  return await AIPhandler(\n    opReturnSchema,\n    SIGPROTO.AIP,\n    dataObj,\n    cell,\n    tape,\n    tx\n  );\n};\n\nexport const AIP: Protocol = {\n  name: \"AIP\",\n  address,\n  opReturnSchema,\n  handler,\n};","import type { HandlerProps, Protocol } from \"../../types/common\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\nconst address = \"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\";\n\nconst opReturnSchema = [\n\t{ content: [\"string\", \"binary\", \"file\"] },\n\t{ \"content-type\": \"string\" },\n\t{ encoding: \"string\" }, // we use this field to determine content character encoding. If encoding is not a valid character encoding (gzip), we assume it is binary\n\t{ filename: \"string\" },\n];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps): void => {\n\tconst encodingMap = new Map<string, string>();\n\tencodingMap.set(\"utf8\", \"string\");\n\tencodingMap.set(\"text\", \"string\"); // invalid but people use it :(\n\tencodingMap.set(\"gzip\", \"binary\"); // invalid but people use it :(\n\tencodingMap.set(\"text/plain\", \"string\");\n\tencodingMap.set(\"image/png\", \"binary\");\n\tencodingMap.set(\"image/jpeg\", \"binary\");\n\n\tif (!cell[1] || !cell[2]) {\n\t\tthrow new Error(`Invalid B tx: ${tx}`);\n\t}\n\n\t// Check pushdata length + 1 for protocol prefix\n\tif (cell.length > opReturnSchema.length + 1) {\n\t\tthrow new Error(\"Invalid B tx. Too many fields.\");\n\t}\n\n\t// Make sure there are not more fields than possible\n\n\tconst bObj: { [key: string]: string | number | undefined } = {};\n\t// loop over the schema\n\tfor (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n\t\tconst x = Number.parseInt(idx, 10);\n\t\tconst bField = Object.keys(schemaField)[0];\n\t\tlet schemaEncoding = Object.values(schemaField)[0];\n\t\tif (bField === \"content\") {\n\t\t\t// If the encoding is ommitted, try to infer from content-type instead of breaking\n\t\t\tif (cell[1].f) {\n\t\t\t\t// this is file reference to B files\n\t\t\t\tschemaEncoding = \"file\";\n\t\t\t} else if ((!cell[3] || !cell[3].s) && cell[2].s) {\n\t\t\t\tschemaEncoding = encodingMap.get(cell[2].s);\n\t\t\t\tif (!schemaEncoding) {\n\t\t\t\t\tconsole.warn(\"Problem inferring encoding. Malformed B data.\", cell);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// add the missing encoding field\n\t\t\t\tif (!cell[3]) {\n\t\t\t\t\tcell[3] = { h: \"\", b: \"\", s: \"\", i: 0, ii: 0 };\n\t\t\t\t}\n\t\t\t\tcell[3].s = schemaEncoding === \"string\" ? \"utf-8\" : \"binary\";\n\t\t\t} else {\n\t\t\t\tschemaEncoding = cell[3]?.s\n\t\t\t\t\t? encodingMap.get(cell[3].s.replace(\"-\", \"\").toLowerCase())\n\t\t\t\t\t: null;\n\t\t\t}\n\t\t}\n\n\t\t// encoding is not required\n\t\tif (bField === \"encoding\" && !cell[x + 1]) {\n\t\t\t// encoding omitted\n\t\t\tcontinue;\n\t\t}\n\n\t\t// filename is not required\n\t\tif (bField === \"filename\" && !cell[x + 1]) {\n\t\t\t// filename omitted\n\t\t\tcontinue;\n\t\t}\n\n\t\t// check for malformed syntax\n\t\tif (!cell || !cell[x + 1]) {\n\t\t\tthrow new Error(`malformed B syntax ${cell}`);\n\t\t}\n\n\t\t// set field value from either s, b, ls, or lb depending on encoding and availability\n\t\tconst data = cell[x + 1];\n\t\tbObj[bField] = cellValue(data, schemaEncoding);\n\t}\n\n\tsaveProtocolData(dataObj, \"B\", bObj);\n};\n\nexport const B: Protocol = {\n\tname: \"B\",\n\taddress,\n\topReturnSchema,\n\thandler,\n};\n","import type { HandlerProps, Protocol } from \"../../types/common\";\nimport { bmapOpReturnSchemaHandler } from \"../utils\";\n\nconst address = \"1BAPSuaPnfGnSBM3GLV9yhxUdYe4vGbdMT\";\n\nconst opReturnSchema = [\n\t{ type: \"string\" },\n\t{ hash: \"string\" },\n\t{ sequence: \"string\" },\n];\n\nexport const handler = ({ dataObj, cell, tx }: HandlerProps) => {\n\tif (!tx) {\n\t\tthrow new Error(\"Invalid BAP tx, tx required\");\n\t}\n\tbmapOpReturnSchemaHandler(\"BAP\", opReturnSchema, dataObj, cell, tx);\n};\n\nexport const BAP: Protocol = {\n\tname: \"BAP\",\n\taddress,\n\topReturnSchema,\n\thandler,\n};\n","import type { HandlerProps, Protocol } from \"../../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst protocolAddress = \"$\";\n\nconst opReturnSchema = [\n\t{\n\t\tsu: [\n\t\t\t{ pubkey: \"string\" },\n\t\t\t{ sign_position: \"string\" },\n\t\t\t{ signature: \"string\" },\n\t\t],\n\t\techo: [{ data: \"string\" }, { to: \"string\" }, { filename: \"string\" }],\n\t\troute: [\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\tadd: [\n\t\t\t\t\t\t{ bitcom_address: \"string\" },\n\t\t\t\t\t\t{ route_matcher: \"string\" },\n\t\t\t\t\t\t{ endpoint_template: \"string\" },\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tenable: [{ path: \"string\" }],\n\t\t\t\t},\n\t\t\t],\n\t\t],\n\t\tuseradd: [{ address: \"string\" }],\n\t},\n];\n\n// const handler = function (dataObj, protocolName, cell, tape, tx) {\nconst handler = ({ dataObj, cell }: HandlerProps) => {\n\tif (!cell.length || !cell.every((c) => c.s)) {\n\t\tthrow new Error(\"Invalid Bitcom tx\");\n\t}\n\n\t// gather up the string values\n\tconst bitcomObj = cell.map((c) => (c?.s ? c.s : \"\"));\n\n\tsaveProtocolData(dataObj, \"BITCOM\", bitcomObj);\n};\n\nexport const BITCOM: Protocol = {\n\tname: \"BITCOM\",\n\taddress: protocolAddress,\n\topReturnSchema,\n\thandler,\n};\n","import { BSM, BigNumber, Hash, PublicKey, Signature, Utils } from \"@bsv/sdk\";\nimport { Buffer } from \"buffer\";\nimport type { HandlerProps, Protocol } from \"../../types/common\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\nconst { toArray, toBase58Check, toHex } = Utils;\nconst { magicHash } = BSM;\n\nconst address = \"13SrNDkVzY5bHBRKNu5iXTQ7K7VqTh5tJC\";\n\nconst opReturnSchema = [\n  { bitkey_signature: \"string\" },\n  { user_signature: \"string\" },\n  { paymail: \"string\" },\n  { pubkey: \"string\" },\n];\n\n// Helper to convert array to BigNumber\nfunction toBigNumber(buffer: number[]): BigNumber {\n  const hex = toHex(buffer);\n  return new BigNumber(hex, 16);\n}\n\n// Recovers a public key from a BSM signature by brute forcing recovery factors\n// Steps:\n// 1. Apply magicHash to the raw message.\n// 2. Try all recovery factors 0–3 with Signature.RecoverPublicKey()\n// 3. If BSM.verify() returns true with the recovered pubkey, return it.\nfunction recoverPublicKeyFromBSM(message: number[], signature: Signature): PublicKey {\n  // First, BSM signatures are verified by applying magicHash internally,\n  // so we must apply magicHash to the raw message ourselves for recovery:\n  const msgHash = magicHash(message);\n\n  const bigMsg = toBigNumber(msgHash);\n  for (let recovery = 0; recovery < 4; recovery++) {\n    try {\n      const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n      // Verify using BSM.verify() with the original raw message (no magicHash)\n      if (BSM.verify(message, signature, publicKey)) {\n        return publicKey;\n      }\n    } catch {\n      // Try next recovery factor\n    }\n  }\n  throw new Error(\"Failed to recover public key from BSM signature\");\n}\n\nconst handler = async ({ dataObj, cell }: HandlerProps) => {\n  if (cell.length < 5) {\n    throw new Error(\"Invalid Bitkey tx\");\n  }\n\n  const bitkeyObj: { [key: string]: string | boolean } = {};\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n    const bitkeyField = Object.keys(schemaField)[0];\n    const schemaEncoding = Object.values(schemaField)[0];\n    bitkeyObj[bitkeyField] = cellValue(cell[x + 1], schemaEncoding) as string;\n  }\n\n  // Derive userAddress from pubkey\n  const pubkeyHex = bitkeyObj.pubkey as string;\n  const userPubkey = PublicKey.fromString(pubkeyHex);\n  const userPubKeyHash = userPubkey.toHash() as number[];\n  const userAddress = toBase58Check(userPubKeyHash);\n\n  // Prepare raw message for bitkey signature verification: sha256(paymail_hex + pubkey_hex)\n  const paymailHex = Buffer.from(bitkeyObj.paymail as string).toString(\"hex\");\n  const concatenated = paymailHex + pubkeyHex;\n  const concatenatedBuffer = Buffer.from(concatenated, \"hex\");\n  const bitkeyMessage = Hash.sha256(toArray(concatenatedBuffer));\n  // This is the raw message. BSM.verify() will do magicHash internally.\n\n  const bitkeySignature = Signature.fromCompact(bitkeyObj.bitkey_signature as string, 'base64');\n\n  // Recover Bitkey pubkey\n  const recoveredBitkeyPubkey = recoverPublicKeyFromBSM(bitkeyMessage, bitkeySignature);\n  const recoveredBitkeyPubKeyHash = recoveredBitkeyPubkey.toHash() as number[];\n  const recoveredBitkeyAddress = toBase58Check(recoveredBitkeyPubKeyHash);\n  const bitkeySignatureVerified = BSM.verify(bitkeyMessage, bitkeySignature, recoveredBitkeyPubkey) && (recoveredBitkeyAddress === address);\n\n  // Verify user signature by using the pubkey as the message\n  const userMessage = toArray(Buffer.from(pubkeyHex, \"utf8\"));\n  const userSignature = Signature.fromCompact(bitkeyObj.user_signature as string, 'base64');\n  const recoveredUserPubkey = recoverPublicKeyFromBSM(userMessage, userSignature);\n  const recoveredUserPubKeyHash = recoveredUserPubkey.toHash() as number[];\n  const recoveredUserAddress = toBase58Check(recoveredUserPubKeyHash);\n  const userSignatureVerified = BSM.verify(userMessage, userSignature, recoveredUserPubkey) && (recoveredUserAddress === userAddress);\n\n  bitkeyObj.verified = bitkeySignatureVerified && userSignatureVerified;\n  saveProtocolData(dataObj, \"BITKEY\", bitkeyObj);\n};\n\nexport const BITKEY: Protocol = {\n  name: \"BITKEY\",\n  address,\n  opReturnSchema,\n  handler,\n};","import { BSM, Hash, PublicKey, Signature, Utils } from \"@bsv/sdk\";\nimport { Buffer } from \"buffer\";\nimport type { HandlerProps, Protocol } from \"../../types/common\";\nimport type { BITPIC as BITPICType } from \"../../types/protocols/bitpic\";\nimport { saveProtocolData } from \"../utils\";\nconst { magicHash } = BSM;\nconst { toArray } = Utils;\n\nconst protocolAddress = \"18pAqbYqhzErT6Zk3a5dwxHtB9icv8jH2p\";\n\nconst opReturnSchema = [\n  { paymail: \"string\" },\n  { pubkey: \"binary\" },\n  { signature: \"string\" },\n];\n\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n  // Validation\n  if (\n    cell[0].s !== protocolAddress ||\n    !cell[1] ||\n    !cell[2] ||\n    !cell[3] ||\n    !cell[1].s ||\n    !cell[2].b ||\n    !cell[3].s ||\n    !tape\n  ) {\n    throw new Error(`Invalid BITPIC record: ${tx}`);\n  }\n\n  const bitpicObj: BITPICType = {\n    paymail: cell[1].s,\n    pubkey: Buffer.from(cell[2].b, \"base64\").toString(\"hex\"),\n    signature: cell[3].s || \"\",\n    verified: false,\n  };\n\n  const b = tape[1].cell;\n  if (b[0].s === \"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\") {\n    // verify bitpic signature\n\n    try {\n      // TODO: bob transactions are missing this binary part, cannot verify signature\n      const bin = (cell[1].lb || cell[1].b) as string;\n      const hashBuff = Hash.sha256(toArray(bin, \"base64\"));\n      const sig = Signature.fromCompact(bitpicObj.signature as string, \"base64\");\n      const pubkey = PublicKey.fromString(bitpicObj.pubkey as string);\n      const msgHash = magicHash(hashBuff);\n      bitpicObj.verified = BSM.verify(msgHash, sig, pubkey);\n    } catch (e) {\n      // failed verification\n      bitpicObj.verified = false;\n    }\n  }\n\n  saveProtocolData(dataObj, \"BITPIC\", bitpicObj);\n};\n\nexport const BITPIC: Protocol = {\n  name: \"BITPIC\",\n  address: protocolAddress,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol } from \"../../types/common\";\nimport { AIPhandler, SIGPROTO } from \"./aip\";\n\nconst address = \"1HA1P2exomAwCUycZHr8WeyFoy5vuQASE3\";\n\nconst opReturnSchema = [\n  { hashing_algorithm: \"string\" },\n  { signing_algorithm: \"string\" },\n  { signing_address: \"string\" },\n  { signature: \"string\" },\n  { index_unit_size: \"number\" },\n  [{ index: \"binary\" }],\n];\n\n// https://github.com/torusJKL/BitcoinBIPs/blob/master/HAIP.md\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n  if (!tape) {\n    throw new Error(\"Invalid HAIP tx. Bad tape\");\n  }\n  if (!tx) {\n    throw new Error(\"Invalid HAIP tx.\");\n  }\n  return await AIPhandler(\n    opReturnSchema,\n    SIGPROTO.HAIP,\n    dataObj,\n    cell,\n    tape,\n    // tx,\n  );\n};\n\nexport const HAIP: Protocol = {\n  name: \"HAIP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { decode } from \"@msgpack/msgpack\";\nimport type { Cell } from \"bpu-ts\";\nimport { Buffer } from \"buffer\";\nimport type { HandlerProps, Protocol } from \"../../types/common\";\nimport type { MAP as MAPType } from \"../../types/protocols/map\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5\";\n\nconst opReturnSchema = [\n\t{\n\t\tcmd: {\n\t\t\tSET: [{ key: \"string\" }, { val: \"string\" }],\n\t\t\tSELECT: [{ tx: \"string\" }],\n\t\t\tADD: [{ key: \"string\" }, [{ val: \"string\" }]],\n\t\t\tDELETE: [{ key: \"string\" }, [{ val: \"string\" }]],\n\t\t\tJSON: \"string\",\n\t\t\tREMOVE: [[{ key: \"string\" }]],\n\t\t\tCLEAR: [[{ txid: \"string\" }]],\n\t\t},\n\t},\n];\n\nconst processADD = (cell: Cell[], mapObj: MAPType) => {\n\tlet last = null;\n\tfor (const pushdataContainer of cell) {\n\t\t// ignore MAP command\n\t\tif (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst pushdata = pushdataContainer.s as string;\n\t\tif (pushdataContainer.i === 2) {\n\t\t\t// Key name\n\t\t\tmapObj[pushdata] = [];\n\t\t\tlast = pushdata;\n\t\t} else {\n\t\t\tif (last && Array.isArray(mapObj[last])) {\n\t\t\t\t(mapObj[last] as string[]).push(pushdata);\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst proccessDELETE = (cell: Cell[], mapObj: MAPType) => {\n\tlet last = null;\n\tfor (const pushdataContainer of cell) {\n\t\t// ignore MAP command\n\t\tif (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst pushdata = pushdataContainer.s as string;\n\t\tif (pushdataContainer.i === 2) {\n\t\t\t// Key name\n\t\t\tmapObj[pushdata] = [];\n\t\t\tlast = pushdata;\n\t\t} else {\n\t\t\tif (last) {\n\t\t\t\t(mapObj[last] as string[]).push(pushdata);\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst processSELECT = (cell: Cell[], mapObj: MAPType) => {\n\t// TODO\n\t// console.log('MAP SELECT');\n\tfor (const pushdataContainer of cell) {\n\t\t// ignore MAP command\n\t\tif (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n\t\t\tmapObj.SELECT = \"TODO\";\n\t\t\tcontinue;\n\t\t}\n\t}\n};\n\nconst processMSGPACK = (cell: Cell[], mapObj: MAPType) => {\n\tfor (const pushdataContainer of cell) {\n\t\t// ignore MAP command\n\t\tif (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (pushdataContainer.i === 2) {\n\t\t\ttry {\n\t\t\t\tif (!decode) {\n\t\t\t\t\tthrow new Error(\"Msgpack is required but not loaded\");\n\t\t\t\t}\n\t\t\t\tconst buff = Buffer.from(pushdataContainer.b as string, \"base64\");\n\t\t\t\tmapObj = decode(buff) as MAPType;\n\t\t\t} catch (e) {\n\t\t\t\tmapObj = {} as MAPType;\n\t\t\t}\n\t\t}\n\t}\n\treturn mapObj;\n};\n\nconst processJSON = (cell: Cell[], mapObj: MAPType) => {\n\tfor (const pushdataContainer of cell) {\n\t\t// ignore MAP command\n\t\tif (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (pushdataContainer.i === 2) {\n\t\t\ttry {\n\t\t\t\tmapObj = JSON.parse(pushdataContainer.s as string);\n\t\t\t} catch (e) {\n\t\t\t\tmapObj = {} as MAPType;\n\t\t\t}\n\t\t}\n\t}\n\treturn mapObj;\n};\n\nconst processSET = (cell: Cell[], mapObj: MAPType) => {\n\tlet last = null;\n\tfor (const pushdataContainer of cell) {\n\t\t// ignore MAP command\n\t\tif (\n\t\t\t!pushdataContainer.s ||\n\t\t\tpushdataContainer.i === 0 ||\n\t\t\tpushdataContainer.i === 1\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst pushdata = pushdataContainer.s;\n\t\tif (pushdataContainer.i % 2 === 0) {\n\t\t\t// key\n\t\t\tmapObj[pushdata] = \"\";\n\t\t\tlast = pushdata;\n\t\t} else {\n\t\t\t// value\n\t\t\tif (!last) {\n\t\t\t\tthrow new Error(`malformed MAP syntax. Cannot parse.${last}`);\n\t\t\t}\n\t\t\tmapObj[last] = pushdata;\n\t\t}\n\t}\n};\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n\t// Validate\n\tif (\n\t\tcell[0].s !== address ||\n\t\t!cell[1] ||\n\t\t!cell[1].s ||\n\t\t!cell[2] ||\n\t\t!cell[2].s\n\t) {\n\t\tthrow new Error(`Invalid MAP record: ${tx}`);\n\t}\n\n\tlet mapObj = {} as MAPType;\n\n\t// parse the protocol separator\n\tconst commands: any[] = [];\n\tlet commandSeparator = 0;\n\tfor (let i = 1; i < cell.length; i++) {\n\t\tif (cell[i].s === \":::\") {\n\t\t\tcommandSeparator++;\n\t\t} else {\n\t\t\tif (!commands[commandSeparator]) commands[commandSeparator] = [];\n\t\t\tcell[i].i = commands[commandSeparator].length + 1;\n\t\t\tcommands[commandSeparator].push(cell[i]);\n\t\t}\n\t}\n\n\t// Get the MAP command key name from the query schema\n\tconst mapCmdKey = Object.keys(opReturnSchema[0])[0];\n\n\t// Add the firt MAP command in the response object\n\tmapObj[mapCmdKey] = commands[0][0].s;\n\n\tfor (const cc of commands) {\n\t\t// re-add the MAP address\n\t\tcc.unshift({\n\t\t\ts: address,\n\t\t\ti: 0,\n\t\t});\n\n\t\tconst command = cc[1].s;\n\t\t// Individual parsing rules for each MAP command\n\t\tswitch (command) {\n\t\t\t// Also check for SELECT commands and strip off the <SELECT> <TXID> part and run it through\n\t\t\tcase \"ADD\": {\n\t\t\t\tprocessADD(cc, mapObj);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"REMOVE\": {\n\t\t\t\tmapObj.key = cc[2].s;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"DELETE\": {\n\t\t\t\tproccessDELETE(cc, mapObj);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"CLEAR\": {\n\t\t\t\t// TODO\n\t\t\t\t// console.log('MAP CLEAR');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"SELECT\": {\n\t\t\t\tprocessSELECT(cc, mapObj);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"MSGPACK\": {\n\t\t\t\tmapObj = processMSGPACK(cc, mapObj);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"JSON\": {\n\t\t\t\tmapObj = processJSON(cc, mapObj);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"SET\": {\n\t\t\t\tprocessSET(cc, mapObj);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\t// don't know what to do ...\n\t\t\t}\n\t\t}\n\t}\n\n\tsaveProtocolData(dataObj, \"MAP\", mapObj);\n};\n\nexport const MAP: Protocol = {\n\tname: \"MAP\",\n\taddress,\n\topReturnSchema,\n\thandler,\n};\n","import { Hash, Utils } from \"@bsv/sdk\";\nimport { Buffer } from \"buffer\";\nimport type {\n  HandlerProps,\n  MetaNet,\n  MetanetNode,\n  Protocol,\n} from \"../../types/common\";\n\nconst { toArray, toHex } = Utils;\n\nconst address = \"meta\";\n\nconst opReturnSchema = [\n  { address: \"string\" },\n  { parent: \"string\" },\n  { name: \"string\" },\n];\n\nexport const getEnvSafeMetanetID = async (a: string, tx: string) => {\n  // Calculate the node ID\n  const buf = Buffer.from(a + tx);\n  const hashBuf = Hash.sha256(toArray(buf));\n  return toHex(hashBuf);\n};\n\nconst handler = async ({ dataObj, cell, tx }: HandlerProps) => {\n  if (\n    !cell.length ||\n    cell[0].s !== \"meta\" ||\n    !cell[1] ||\n    !cell[1].s ||\n    !cell[2] ||\n    !cell[2].s ||\n    !tx\n  ) {\n    throw new Error(`Invalid Metanet tx ${tx}`);\n  }\n  // For now, we just copy from MOM keys later if available, or keep BOB format\n\n  const nodeId = await getEnvSafeMetanetID(cell[1].s, tx.tx.h);\n  // Described this node\n  const node = {\n    a: cell[1].s,\n    tx: tx.tx.h,\n    id: nodeId,\n  };\n  let parent = {} as MetanetNode;\n  if (tx.in) {\n    const parentId = await getEnvSafeMetanetID(tx.in[0].e.a, cell[2].s);\n    // Parent node\n    parent = {\n      a: tx.in[0].e.a,\n      tx: cell[2].s,\n      id: parentId,\n    };\n  }\n\n  if (!dataObj.METANET) {\n    dataObj.METANET = [];\n  }\n  dataObj.METANET.push({\n    node,\n    parent,\n  } as MetaNet);\n};\n\nexport const METANET: Protocol = {\n  name: \"METANET\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../../types/common\";\nimport type { ORD as OrdType } from \"../../types/protocols/ord\";\nimport { saveProtocolData } from \"../utils\";\n\n// const OrdScript =\n//     'OP_FALSE OP_IF 6F7264 OP_1 <CONTENT_TYPE_PLACEHOLDER> OP_0 <DATA_PLACEHOLDER> OP_ENDIF'.split(\n//         ' '\n//     )\n\nconst scriptChecker = (cell: Cell[]) => {\n\tif (cell.length < 13) {\n\t\t// wrong length\n\t\treturn false;\n\t}\n\n\t// Find OP_IF wrapper\n\tconst startIdx = findIndex(cell, (c: Cell) => c.ops === \"OP_IF\");\n\tconst endIdx = findIndex(\n\t\tcell,\n\t\t(c: Cell, i: number) => i > startIdx && c.ops === \"OP_ENDIF\",\n\t);\n\tconst ordScript = cell.slice(startIdx, endIdx);\n\tconst prevCell = cell[startIdx - 1];\n\treturn (\n\t\tprevCell?.op === 0 &&\n\t\t!!ordScript[0] &&\n\t\t!!ordScript[1] &&\n\t\tordScript[1].s == \"ord\"\n\t);\n};\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n\tif (!cell[0] || !out) {\n\t\tthrow new Error(\"Invalid Ord tx. dataObj, cell, out and tx are required.\");\n\t}\n\n\t// assemble asm\n\t// make sure first piece matches a txid\n\t// 2nd piece matches any difficulty. set some resonable limit in bytes if there isnt one documented somewhere\n\t// next\n\n\t// Find OP_IF wrapper\n\tconst startIdx = findIndex(cell, (c: Cell) => c.ops === \"OP_IF\");\n\tconst endIdx =\n\t\tfindIndex(\n\t\t\tcell,\n\t\t\t(c: Cell, i: number) => i > startIdx && c.ops === \"OP_ENDIF\",\n\t\t) + 1;\n\tconst ordScript = cell.slice(startIdx, endIdx);\n\n\tif (!ordScript[0] || !ordScript[1] || ordScript[1].s !== \"ord\") {\n\t\tthrow new Error(\"Invalid Ord tx. Prefix not found.\");\n\t}\n\n\tlet data: string | undefined;\n\tlet contentType: string | undefined;\n\tordScript.forEach((push, idx, all) => {\n\t\t// content-type\n\t\tif (push.ops === \"OP_1\") {\n\t\t\tcontentType = all[idx + 1].s;\n\t\t}\n\t\t// data\n\t\tif (push.ops === \"OP_0\") {\n\t\t\tdata = all[idx + 1].b;\n\t\t}\n\t});\n\n\tif (!data) {\n\t\tthrow new Error(\"Invalid Ord data.\");\n\t}\n\tif (!contentType) {\n\t\tthrow new Error(\"Invalid Ord content type.\");\n\t}\n\n\tconst OrdObj: OrdType = {\n\t\tdata,\n\t\tcontentType,\n\t};\n\n\tsaveProtocolData(dataObj, \"ORD\", OrdObj);\n};\n\nexport const ORD: Protocol = {\n\tname: \"ORD\",\n\thandler,\n\tscriptChecker,\n};\n\nfunction findIndex(array: any[], predicate: Function) {\n\treturn findLastIndex(array, predicate);\n}\nfunction findLastIndex(array: any[], predicate: Function, fromIndex?: number) {\n\tconst length = array == null ? 0 : array.length;\n\tif (!length) {\n\t\treturn -1;\n\t}\n\tlet index = length - 1;\n\tif (fromIndex !== undefined) {\n\t\tindex = fromIndex;\n\t\tindex =\n\t\t\tfromIndex < 0 ? Math.max(length + index, 0) : Math.min(index, length - 1);\n\t}\n\treturn baseFindIndex(array, predicate, index, true);\n}\n\nfunction baseFindIndex(\n\tarray: any[],\n\tpredicate: Function,\n\tfromIndex: number,\n\tfromRight: boolean,\n) {\n\tconst { length } = array;\n\tlet index = fromIndex + (fromRight ? 1 : -1);\n\n\twhile (fromRight ? index-- : ++index < length) {\n\t\tif (predicate(array[index], index, array)) {\n\t\t\treturn index;\n\t\t}\n\t}\n\treturn -1;\n}\n","import type { HandlerProps, Protocol } from \"../../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1GvFYzwtFix3qSAZhESQVTz9DeudHZNoh1\";\n\nconst opReturnSchema = [\n\t{ pair: \"json\" },\n\t{ address: \"string\" },\n\t{ timestamp: \"string\" },\n];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n\tif (\n\t\tcell[0].s !== address ||\n\t\t!cell[1] ||\n\t\t!cell[2] ||\n\t\t!cell[3] ||\n\t\t!cell[1].s ||\n\t\t!cell[2].s ||\n\t\t!cell[3].s\n\t) {\n\t\tthrow new Error(`Invalid RON record ${tx?.tx.h}`);\n\t}\n\n\tconst pair = JSON.parse(cell[1].s);\n\tconst timestamp = Number(cell[3].s);\n\n\tsaveProtocolData(dataObj, \"RON\", {\n\t\tpair,\n\t\taddress: cell[2].s,\n\t\ttimestamp,\n\t});\n};\n\nexport const RON: Protocol = {\n\tname: \"RON\",\n\taddress,\n\topReturnSchema,\n\thandler,\n};\n","import type { HandlerProps } from \"../../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1SymRe7erxM46GByucUWnB9fEEMgo7spd\";\n\nconst opReturnSchema = [{ url: \"string\" }];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n\tif (cell[0].s !== address || !cell[1] || !cell[1].s) {\n\t\tthrow new Error(`Invalid SymRe tx: ${tx}`);\n\t}\n\n\tsaveProtocolData(dataObj, \"SYMRE\", { url: cell[1].s });\n};\n\nexport const SYMRE = {\n\tname: \"SYMRE\",\n\taddress,\n\topReturnSchema,\n\thandler,\n};\n"],"names":[],"version":3,"file":"bmap.js.map","sourceRoot":"../"}