{"version":3,"file":"bmap.es.js","sources":["../src/utils.ts","../src/protocols/_21e8.ts","../src/protocols/aip.ts","../src/protocols/b.ts","../src/protocols/bap.ts","../src/protocols/bitcom.ts","../src/protocols/bitkey.ts","../src/protocols/bitpic.ts","../src/protocols/haip.ts","../src/protocols/map.ts","../src/protocols/metanet.ts","../src/protocols/ord.ts","../src/protocols/ron.ts","../src/protocols/symre.ts","../src/bmap.ts"],"sourcesContent":["import { Hash, Utils } from \"@bsv/sdk\";\nimport type { Cell, Tape } from \"bpu-ts\";\nimport type { BmapTx, BobTx, SchemaField } from \"./types/common\";\nconst { toArray } = Utils;\n\nexport const isStringArray = (arr: Array<any>): boolean => {\n  return (\n    arr.length > 0 &&\n    arr.every((value) => {\n      return typeof value === \"string\";\n    })\n  );\n};\nexport const isObjectArray = (arr: Array<any>): boolean => {\n  return (\n    arr.length > 0 &&\n    arr.every((value) => {\n      return value === \"object\";\n    })\n  );\n};\n/**\n * returns the BOB cell value for a given encoding\n *\n * @param pushData\n * @param schemaEncoding\n * @returns {string|number}\n */\nexport const cellValue = (pushData: Cell, schemaEncoding?: string): string | number => {\n  if (!pushData) {\n    throw new Error(`cannot get cell value of: ${pushData}`);\n  }\n  if (schemaEncoding === \"string\") {\n    return pushData.s ? pushData.s : pushData.ls || \"\";\n  }\n  if (schemaEncoding === \"hex\") {\n    return pushData.h\n      ? pushData.h\n      : pushData.lh ||\n          (pushData.b\n            ? Buffer.from(pushData.b, \"base64\").toString(\"hex\")\n            : pushData.lb && Buffer.from(pushData.lb, \"base64\").toString(\"hex\")) ||\n          \"\";\n  }\n  if (schemaEncoding === \"number\") {\n    return Number.parseInt(pushData.h ? pushData.h : pushData.lh || \"0\", 16);\n  }\n  if (schemaEncoding === \"file\") {\n    return `bitfs://${pushData.f ? pushData.f : pushData.lf}`;\n  }\n\n  return (pushData.b ? pushData.b : pushData.lb) || \"\";\n};\n\n/**\n * Check if cells end with OP_RETURN\n */\nexport const checkOpReturn = (cc: Tape): boolean => {\n  return cc.cell.some((c: Cell) => c.op === 106);\n};\n\n/**\n * Check if cells end with OP_FALSE + OP_RETURN\n */\nexport const checkOpFalseOpReturn = (cc: Tape): boolean => {\n  if (cc.cell.length !== 2) {\n    return false;\n  }\n  const opReturnIdx = cc.cell.findIndex((c) => c.op === 106);\n  if (opReturnIdx !== -1) {\n    return cc.cell[opReturnIdx - 1]?.op === 0;\n  }\n  return false;\n};\n\n/**\n * Helper function to store protocol data\n *\n * @param dataObj\n * @param protocolName\n * @param data\n */\nexport const saveProtocolData = (\n  dataObj: { [key: string]: any },\n  protocolName: string,\n  data: any\n) => {\n  if (!dataObj[protocolName]) {\n    dataObj[protocolName] = [data];\n  } else {\n    dataObj[protocolName].push(data);\n  }\n};\n\n/**\n * BMAP default handler to work with query schema's\n *\n * @param opReturnSchema\n * @param protocolName\n * @param dataObj\n * @param cell\n * @param tape\n * @param tx\n */\nexport const bmapOpReturnSchemaHandler = (\n  protocolName: string,\n  opReturnSchema: SchemaField[],\n  dataObj: BmapTx,\n  cell: Cell[],\n  tx: BobTx\n) => {\n  // loop over the schema\n  const obj: { [key: string]: any } = {};\n\n  // Does not have the required number of fields\n  const length = opReturnSchema.length + 1;\n  if (cell.length < length) {\n    throw new Error(\n      `${protocolName} requires at least ${length} fields including the prefix: ${tx.tx.h}`\n    );\n  }\n\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n\n    const [field] = Object.keys(schemaField);\n    const [schemaEncoding] = Object.values(schemaField);\n    obj[field] = cellValue(cell[x + 1], schemaEncoding as string);\n  }\n\n  saveProtocolData(dataObj, protocolName, obj);\n};\n\n/**\n * Check whether the given data is base64\n *\n * @param data\n * @returns {boolean}\n */\nexport const isBase64 = (data: string) => {\n  const regex = \"(?:[A-Za-z0-9+\\\\/]{4})*(?:[A-Za-z0-9+\\\\/]{2}==|[A-Za-z0-9+/]{3}=)?\";\n  return new RegExp(`^${regex}$`, \"gi\").test(data);\n};\n\n// hashes a message buffer, returns the hash as a buffer\nexport const sha256 = (msgBuffer: number[]) => {\n  return Hash.sha256(toArray(msgBuffer));\n};\n","import type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { _21E8 as _21E8Type } from \"../types/protocols/_21e8\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\n// 21e8 does not use the first pushdata for id\n// in fact there is no id since the 21e8 is designed for difficulty and can be changed\n// instead we use the static part of the script to indentfy the transaction\n// TODO - the OP_X_PLACEHOLDER is the number of bytes to push onto the stack and must match difficulty size\nconst _21e8Script =\n  \"OP_SIZE <OP_X_PLACEHOLDER> OP_PICK OP_SHA256 OP_SWAP OP_SPLIT OP_DROP OP_EQUALVERIFY OP_DROP OP_CHECKSIG\".split(\n    \" \"\n  );\n\nconst scriptChecker = (cell: Cell[]) => {\n  if (cell.length !== 12) {\n    // wrong length\n    return false;\n  }\n\n  // match exact script\n  const ops = [...cell].map((c) => c.ops).splice(2, cell.length);\n\n  // calculate target byte length\n  const target = cellValue(cell[1], \"hex\") as string;\n  const targetOpSize = Buffer.from(target).byteLength;\n\n  // replace the placeholder opcode with actual\n  ops[1] = `OP_${targetOpSize}`;\n  _21e8Script[1] = `OP_${targetOpSize}`;\n\n  // protocol identifier always in first pushdata\n  return ops.join() === _21e8Script.join();\n};\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n  if (!cell[0] || !out) {\n    throw new Error(\"Invalid 21e8 tx. dataObj, cell, out and tx are required.\");\n  }\n\n  // assemble asm\n  // make sure first piece matches a txid\n  // 2nd piece matches any difficulty. set some resonable limit in bytes if there isnt one documented somewhere\n  // next\n\n  const txid = cellValue(cell[0], \"hex\") as string;\n  const target = cellValue(cell[1], \"hex\") as string;\n  if (!target) {\n    throw new Error(`Invalid 21e8 target. ${JSON.stringify(cell[0], null, 2)}`);\n  }\n  const difficulty = Buffer.from(target, \"hex\").byteLength;\n\n  const _21e8Obj: _21E8Type = {\n    target,\n    difficulty,\n    value: out.e.v,\n    txid,\n  };\n\n  saveProtocolData(dataObj, \"21E8\", _21e8Obj);\n};\n\nexport const _21E8: Protocol = {\n  name: \"21E8\",\n  handler,\n  scriptChecker,\n};\n","import { BSM, BigNumber, Hash, Script, Signature, Utils } from \"@bsv/sdk\";\nimport type { Cell, Tape } from \"bpu-ts\";\nimport type { BmapTx, BobTx, HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport type { AIP as AIPType } from \"../types/protocols/aip\";\nimport type { HAIP as HAIPType } from \"../types/protocols/haip\";\nimport { cellValue, checkOpFalseOpReturn, isBase64, saveProtocolData } from \"../utils\";\n\nconst { toArray, toHex, fromBase58Check, toBase58Check } = Utils;\n\nconst address = \"15PciHG22SNLQJXMoSUaWVi7WSqc7hCfva\";\n\nconst opReturnSchema: SchemaField[] = [\n  { algorithm: \"string\" },\n  { address: \"string\" },\n  { signature: \"binary\" },\n  [{ index: \"binary\" }],\n];\n\nfunction validateSignature(\n  aipObj: Partial<AIPType | HAIPType>,\n  cell: Cell[],\n  tape: Tape[]\n): boolean {\n  if (!Array.isArray(tape) || tape.length < 3) {\n    throw new Error(\"AIP requires at least 3 cells including the prefix\");\n  }\n\n  let cellIndex = -1;\n  for (let i = 0; i < tape.length; i++) {\n    if (tape[i].cell === cell) {\n      cellIndex = i;\n      break;\n    }\n  }\n  if (cellIndex === -1) {\n    throw new Error(\"AIP could not find cell in tape\");\n  }\n\n  let usingIndexes: number[] = aipObj.index || [];\n  const signatureValues = [\"6a\"]; // OP_RETURN - is included in AIP\n  for (let i = 0; i < cellIndex; i++) {\n    const cellContainer = tape[i];\n    if (!checkOpFalseOpReturn(cellContainer)) {\n      for (const statement of cellContainer.cell) {\n        // add the value as hex\n        if (statement.h) {\n          signatureValues.push(statement.h);\n        } else if (statement.b) {\n          // no hex? try base64\n          signatureValues.push(toHex(toArray(statement.b, \"base64\")));\n        } else if (statement.s) {\n          signatureValues.push(toHex(toArray(statement.s)));\n        }\n      }\n      signatureValues.push(\"7c\"); // | hex\n    }\n  }\n\n  if (aipObj.hashing_algorithm) {\n    // when using HAIP, we need to parse the indexes in a non standard way\n    // indexLength is byte size of the indexes being described\n    if (aipObj.index_unit_size) {\n      const indexLength = aipObj.index_unit_size * 2;\n      usingIndexes = [];\n      const indexes = cell[6].h as string;\n      for (let i = 0; i < indexes.length; i += indexLength) {\n        usingIndexes.push(Number.parseInt(indexes.substr(i, indexLength), 16));\n      }\n      aipObj.index = usingIndexes;\n    }\n  }\n\n  const signatureBufferStatements: number[][] = [];\n  // check whether we need to only sign some indexes\n  if (usingIndexes.length > 0) {\n    for (const index of usingIndexes) {\n      if (index >= signatureValues.length) {\n        console.log(\"[validateSignature] Index out of bounds:\", index);\n        return false;\n      }\n      signatureBufferStatements.push(toArray(signatureValues[index], \"hex\"));\n    }\n  } else {\n    // add all the values to the signature buffer\n    for (const statement of signatureValues) {\n      signatureBufferStatements.push(toArray(statement, \"hex\"));\n    }\n  }\n\n  let messageBuffer: number[];\n  if (aipObj.hashing_algorithm) {\n    // this is actually Hashed-AIP (HAIP) and works a bit differently\n    if (!aipObj.index_unit_size) {\n      // remove OP_RETURN - will be added by Script.buildDataOut\n      signatureBufferStatements.shift();\n    }\n    const dataScript = Script.fromHex(toHex(signatureBufferStatements.flat()));\n    let dataArray = toArray(dataScript.toHex(), \"hex\");\n    if (aipObj.index_unit_size) {\n      // the indexed buffer should not contain the OP_RETURN opcode, but this\n      // is added by the buildDataOut function automatically. Remove it.\n      dataArray = dataArray.slice(1);\n    }\n    messageBuffer = Hash.sha256(dataArray);\n  } else {\n    // regular AIP\n    messageBuffer = signatureBufferStatements.flat();\n  }\n\n  // AIOP uses address, HAIP uses signing_address field names\n  const addressString = (aipObj as AIPType).address || (aipObj as HAIPType).signing_address;\n  if (!addressString || !aipObj.signature) {\n    return false;\n  }\n\n  let signature: Signature;\n  try {\n    signature = Signature.fromCompact(aipObj.signature, \"base64\");\n  } catch (e) {\n    console.log(\"[validateSignature] Failed to parse signature:\", e);\n    return false;\n  }\n\n  const tryNormalLogic = (): boolean => {\n    try {\n      const msgHash = BSM.magicHash(messageBuffer);\n      const bigMsg = toBigNumberFromBuffer(msgHash);\n\n      for (let recovery = 0; recovery < 4; recovery++) {\n        try {\n          const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n          const pubKeyHash = publicKey.toHash() as number[];\n          const { prefix } = fromBase58Check(addressString);\n          const recoveredAddress = toBase58Check(pubKeyHash, prefix as number[]);\n          if (recoveredAddress === addressString) {\n            return BSM.verify(messageBuffer, signature, publicKey);\n          }\n        } catch (e) {\n          console.log(\"[tryNormalLogic] Recovery error:\", e);\n        }\n      }\n    } catch (e) {\n      console.log(\"[tryNormalLogic] error:\", e);\n    }\n    return false;\n  };\n\n  const tryTwetchLogic = (): boolean => {\n    // Twetch signs a UTF-8 buffer of the hex string of a sha256 hash of the message\n    // Without 0x06 (OP_RETURN) and without 0x7c at the end, the trailing pipe (\"|\")\n    if (signatureBufferStatements.length <= 2) {\n      return false;\n    }\n\n    try {\n      const trimmed = signatureBufferStatements.slice(1, -1);\n      const buff = Hash.sha256(trimmed.flat());\n      const hexStr = toHex(buff);\n      const twetchMsg = toArray(hexStr, \"utf8\");\n\n      const msgHash = BSM.magicHash(twetchMsg);\n      const bigMsg = toBigNumberFromBuffer(msgHash);\n\n      for (let recovery = 0; recovery < 4; recovery++) {\n        try {\n          const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n          const pubKeyHash = publicKey.toHash() as number[];\n          const { prefix } = fromBase58Check(addressString);\n          const recoveredAddress = toBase58Check(pubKeyHash, prefix as number[]);\n          if (recoveredAddress === addressString) {\n            return BSM.verify(twetchMsg, signature, publicKey);\n          }\n        } catch (e) {\n          console.log(\"[tryTwetchLogic] Recovery error:\", e);\n        }\n      }\n    } catch (e) {\n      console.log(\"[tryTwetchLogic] error:\", e);\n    }\n    return false;\n  };\n\n  let verified = tryNormalLogic();\n  if (!verified) {\n    verified = tryTwetchLogic();\n  }\n\n  aipObj.verified = verified;\n  return verified;\n}\n\nfunction toBigNumberFromBuffer(buffer: number[]): BigNumber {\n  const hex = toHex(buffer);\n  return new BigNumber(hex, 16);\n}\n\nexport enum SIGPROTO {\n  HAIP = \"HAIP\",\n  AIP = \"AIP\",\n}\n\nexport const AIPhandler = async (\n  useOpReturnSchema: SchemaField[],\n  protocol: SIGPROTO,\n  dataObj: Partial<BobTx>,\n  cell: Cell[],\n  tape: Tape[]\n): Promise<HandlerProps> => {\n  // loop over the schema\n  const aipObj: { [key: string]: number | number[] | string | boolean } = {};\n\n  // Does not have the required number of fields\n  if (cell.length < 4) {\n    throw new Error(\"AIP requires at least 4 fields including the prefix\");\n  }\n\n  for (const [idx, schemaField] of Object.entries(useOpReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n\n    if (Array.isArray(schemaField)) {\n      // signature indexes are specified\n      const [aipField] = Object.keys(schemaField[0]) as (keyof AIPType)[];\n      // run through the rest of the fields in this cell, should be de indexes\n      const fieldData: number[] = [];\n      for (let i = x + 1; i < cell.length; i++) {\n        if (cell[i].h && Array.isArray(fieldData)) {\n          fieldData.push(Number.parseInt(cell[i].h || \"\", 16));\n        }\n      }\n      aipObj[aipField] = fieldData;\n    } else {\n      const [aipField] = Object.keys(schemaField) as (keyof AIPType)[];\n      const [schemaEncoding] = Object.values(schemaField);\n      aipObj[aipField] = cellValue(cell[x + 1], schemaEncoding as string) || \"\";\n    }\n  }\n\n  // There is an issue where some services add the signature as binary to the transaction\n  // whereas others add the signature as base64. This will confuse bob and the parser and\n  // the signature will not be verified. When the signature is added in binary cell[3].s is\n  // binary, otherwise cell[3].s contains the base64 signature and should be used.\n  if (cell[0].s === address && cell[3].s && isBase64(cell[3].s)) {\n    aipObj.signature = cell[3].s;\n  }\n\n  if (!aipObj.signature) {\n    throw new Error(\"AIP requires a signature\");\n  }\n\n  validateSignature(aipObj as Partial<AIPType>, cell, tape);\n\n  saveProtocolData(dataObj, protocol, aipObj);\n  return { dataObj: dataObj as BmapTx, cell, tape };\n};\n\nconst handler = async ({ dataObj, cell, tape }: HandlerProps): Promise<HandlerProps> => {\n  if (!tape) {\n    throw new Error(\"Invalid AIP transaction. tape is required\");\n  }\n  return AIPhandler(opReturnSchema, SIGPROTO.AIP, dataObj, cell, tape);\n};\n\nexport const AIP: Protocol = {\n  name: \"AIP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\nconst address = \"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\";\n\nconst opReturnSchema: SchemaField[] = [\n  { content: [\"string\", \"binary\", \"file\"] },\n  { \"content-type\": \"string\" },\n  { encoding: \"string\" }, // we use this field to determine content character encoding. If encoding is not a valid character encoding (gzip), we assume it is binary\n  { filename: \"string\" },\n];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps): void => {\n  const encodingMap = new Map<string, string>();\n  encodingMap.set(\"utf8\", \"string\");\n  encodingMap.set(\"text\", \"string\"); // invalid but people use it :(\n  encodingMap.set(\"gzip\", \"binary\"); // invalid but people use it :(\n  encodingMap.set(\"text/plain\", \"string\");\n  encodingMap.set(\"image/png\", \"binary\");\n  encodingMap.set(\"image/jpeg\", \"binary\");\n\n  if (!cell[1] || !cell[2]) {\n    throw new Error(`Invalid B tx: ${tx}`);\n  }\n\n  // Check pushdata length + 1 for protocol prefix\n  if (cell.length > opReturnSchema.length + 1) {\n    throw new Error(\"Invalid B tx. Too many fields.\");\n  }\n\n  // Make sure there are not more fields than possible\n\n  const bObj: { [key: string]: string | number | undefined } = {};\n  // loop over the schema\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n    const bField = Object.keys(schemaField)[0];\n    let schemaEncoding = Object.values(schemaField)[0];\n    if (bField === \"content\") {\n      // If the encoding is ommitted, try to infer from content-type instead of breaking\n      if (cell[1].f) {\n        // this is file reference to B files\n        schemaEncoding = \"file\";\n      } else if ((!cell[3] || !cell[3].s) && cell[2].s) {\n        schemaEncoding = encodingMap.get(cell[2].s) as string;\n        if (!schemaEncoding) {\n          console.warn(\"Problem inferring encoding. Malformed B data.\", cell);\n          return;\n        }\n\n        // add the missing encoding field\n        if (!cell[3]) {\n          cell[3] = { h: \"\", b: \"\", s: \"\", i: 0, ii: 0 };\n        }\n        cell[3].s = schemaEncoding === \"string\" ? \"utf-8\" : \"binary\";\n      } else {\n        const encoding = (\n          cell[3]?.s ? encodingMap.get(cell[3].s.replace(\"-\", \"\").toLowerCase()) : null\n        ) as string | null;\n        if (!encoding) {\n          console.warn(\"Problem inferring encoding. Malformed B data.\", cell);\n          return;\n        }\n        schemaEncoding = encoding;\n      }\n    }\n\n    // encoding is not required\n    if (bField === \"encoding\" && !cell[x + 1]) {\n      // encoding omitted\n      continue;\n    }\n\n    // filename is not required\n    if (bField === \"filename\" && !cell[x + 1]) {\n      // filename omitted\n      continue;\n    }\n\n    // check for malformed syntax\n    if (!cell || !cell[x + 1]) {\n      throw new Error(`malformed B syntax ${cell}`);\n    }\n\n    // set field value from either s, b, ls, or lb depending on encoding and availability\n    const data = cell[x + 1];\n    bObj[bField] = cellValue(data, schemaEncoding as string);\n  }\n\n  saveProtocolData(dataObj, \"B\", bObj);\n};\n\nexport const B: Protocol = {\n  name: \"B\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { bmapOpReturnSchemaHandler } from \"../utils\";\n\nconst address = \"1BAPSuaPnfGnSBM3GLV9yhxUdYe4vGbdMT\";\n\nconst opReturnSchema: SchemaField[] = [\n  { type: \"string\" },\n  { hash: \"string\" },\n  { sequence: \"string\" },\n];\n\nexport const handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (!tx) {\n    throw new Error(\"Invalid BAP tx, tx required\");\n  }\n  bmapOpReturnSchemaHandler(\"BAP\", opReturnSchema, dataObj, cell, tx);\n};\n\nexport const BAP: Protocol = {\n  name: \"BAP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst protocolAddress = \"$\";\n\nconst opReturnSchema: SchemaField[] = [\n  {\n    su: [{ pubkey: \"string\" }, { sign_position: \"string\" }, { signature: \"string\" }],\n    echo: [{ data: \"string\" }, { to: \"string\" }, { filename: \"string\" }],\n    route: [\n      [\n        {\n          add: [\n            { bitcom_address: \"string\" },\n            { route_matcher: \"string\" },\n            { endpoint_template: \"string\" },\n          ],\n        },\n        {\n          enable: [{ path: \"string\" }],\n        },\n      ],\n    ],\n    useradd: [{ address: \"string\" }],\n  },\n];\n\n// const handler = function (dataObj, protocolName, cell, tape, tx) {\nconst handler = ({ dataObj, cell }: HandlerProps) => {\n  if (!cell.length || !cell.every((c) => c.s)) {\n    throw new Error(\"Invalid Bitcom tx\");\n  }\n\n  // gather up the string values\n  const bitcomObj = cell.map((c) => (c?.s ? c.s : \"\"));\n\n  saveProtocolData(dataObj, \"BITCOM\", bitcomObj);\n};\n\nexport const BITCOM: Protocol = {\n  name: \"BITCOM\",\n  address: protocolAddress,\n  opReturnSchema,\n  handler,\n};\n","import { BSM, BigNumber, Hash, PublicKey, Signature, Utils } from \"@bsv/sdk\";\nimport type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\nconst { toArray, toBase58Check, toHex } = Utils;\nconst { magicHash } = BSM;\n\nconst address = \"13SrNDkVzY5bHBRKNu5iXTQ7K7VqTh5tJC\";\n\nconst opReturnSchema: SchemaField[] = [\n  { bitkey_signature: \"string\" },\n  { user_signature: \"string\" },\n  { paymail: \"string\" },\n  { pubkey: \"string\" },\n];\n\n// Helper to convert array to BigNumber\nfunction toBigNumber(buffer: number[]): BigNumber {\n  const hex = toHex(buffer);\n  return new BigNumber(hex, 16);\n}\n\n// Recovers a public key from a BSM signature by brute forcing recovery factors\n// Steps:\n// 1. Apply magicHash to the raw message.\n// 2. Try all recovery factors 0â€“3 with Signature.RecoverPublicKey()\n// 3. If BSM.verify() returns true with the recovered pubkey, return it.\nfunction recoverPublicKeyFromBSM(message: number[], signature: Signature): PublicKey {\n  // First, BSM signatures are verified by applying magicHash internally,\n  // so we must apply magicHash to the raw message ourselves for recovery:\n  const msgHash = magicHash(message);\n\n  const bigMsg = toBigNumber(msgHash);\n  for (let recovery = 0; recovery < 4; recovery++) {\n    try {\n      const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n      // Verify using BSM.verify() with the original raw message (no magicHash)\n      if (BSM.verify(message, signature, publicKey)) {\n        return publicKey;\n      }\n    } catch {\n      // Try next recovery factor\n    }\n  }\n  throw new Error(\"Failed to recover public key from BSM signature\");\n}\n\nconst handler = async ({ dataObj, cell }: HandlerProps) => {\n  if (cell.length < 5) {\n    throw new Error(\"Invalid Bitkey tx\");\n  }\n\n  const bitkeyObj: { [key: string]: string | boolean } = {};\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n    const bitkeyField = Object.keys(schemaField)[0];\n    const schemaEncoding = Object.values(schemaField)[0];\n    bitkeyObj[bitkeyField] = cellValue(cell[x + 1], schemaEncoding as string) as string;\n  }\n\n  // Derive userAddress from pubkey\n  const pubkeyHex = bitkeyObj.pubkey as string;\n  const userPubkey = PublicKey.fromString(pubkeyHex);\n  const userPubKeyHash = userPubkey.toHash() as number[];\n  const userAddress = toBase58Check(userPubKeyHash);\n\n  // Prepare raw message for bitkey signature verification: sha256(paymail_hex + pubkey_hex)\n  const paymailHex = Buffer.from(bitkeyObj.paymail as string).toString(\"hex\");\n  const concatenated = paymailHex + pubkeyHex;\n  const concatenatedBuffer = Buffer.from(concatenated, \"hex\");\n  const bitkeyMessage = Hash.sha256(toArray(concatenatedBuffer));\n  // This is the raw message. BSM.verify() will do magicHash internally.\n\n  const bitkeySignature = Signature.fromCompact(bitkeyObj.bitkey_signature as string, \"base64\");\n\n  // Recover Bitkey pubkey\n  const recoveredBitkeyPubkey = recoverPublicKeyFromBSM(bitkeyMessage, bitkeySignature);\n  const recoveredBitkeyPubKeyHash = recoveredBitkeyPubkey.toHash() as number[];\n  const recoveredBitkeyAddress = toBase58Check(recoveredBitkeyPubKeyHash);\n  const bitkeySignatureVerified =\n    BSM.verify(bitkeyMessage, bitkeySignature, recoveredBitkeyPubkey) &&\n    recoveredBitkeyAddress === address;\n\n  // Verify user signature by using the pubkey as the message\n  const userMessage = toArray(Buffer.from(pubkeyHex, \"utf8\"));\n  const userSignature = Signature.fromCompact(bitkeyObj.user_signature as string, \"base64\");\n  const recoveredUserPubkey = recoverPublicKeyFromBSM(userMessage, userSignature);\n  const recoveredUserPubKeyHash = recoveredUserPubkey.toHash() as number[];\n  const recoveredUserAddress = toBase58Check(recoveredUserPubKeyHash);\n  const userSignatureVerified =\n    BSM.verify(userMessage, userSignature, recoveredUserPubkey) &&\n    recoveredUserAddress === userAddress;\n\n  bitkeyObj.verified = bitkeySignatureVerified && userSignatureVerified;\n  saveProtocolData(dataObj, \"BITKEY\", bitkeyObj);\n};\n\nexport const BITKEY: Protocol = {\n  name: \"BITKEY\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { BSM, Hash, PublicKey, Signature, Utils } from \"@bsv/sdk\";\nimport type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport type { BITPIC as BITPICType } from \"../types/protocols/bitpic\";\nimport { saveProtocolData } from \"../utils\";\nconst { magicHash } = BSM;\nconst { toArray } = Utils;\n\nconst protocolAddress = \"18pAqbYqhzErT6Zk3a5dwxHtB9icv8jH2p\";\n\nconst opReturnSchema: SchemaField[] = [\n  { paymail: \"string\" },\n  { pubkey: \"binary\" },\n  { signature: \"string\" },\n];\n\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n  // Validation\n  if (\n    cell[0].s !== protocolAddress ||\n    !cell[1] ||\n    !cell[2] ||\n    !cell[3] ||\n    !cell[1].s ||\n    !cell[2].b ||\n    !cell[3].s ||\n    !tape\n  ) {\n    throw new Error(`Invalid BITPIC record: ${tx}`);\n  }\n\n  const bitpicObj: BITPICType = {\n    paymail: cell[1].s,\n    pubkey: Buffer.from(cell[2].b, \"base64\").toString(\"hex\"),\n    signature: cell[3].s || \"\",\n    verified: false,\n  };\n\n  const b = tape[1].cell;\n  if (b[0].s === \"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\") {\n    // verify bitpic signature\n\n    try {\n      // TODO: bob transactions are missing this binary part, cannot verify signature\n      const bin = (cell[1].lb || cell[1].b) as string;\n      const hashBuff = Hash.sha256(toArray(bin, \"base64\"));\n      const sig = Signature.fromCompact(bitpicObj.signature as string, \"base64\");\n      const pubkey = PublicKey.fromString(bitpicObj.pubkey as string);\n      const msgHash = magicHash(hashBuff);\n      bitpicObj.verified = BSM.verify(msgHash, sig, pubkey);\n    } catch (e) {\n      // failed verification\n      bitpicObj.verified = false;\n    }\n  }\n\n  saveProtocolData(dataObj, \"BITPIC\", bitpicObj);\n};\n\nexport const BITPIC: Protocol = {\n  name: \"BITPIC\",\n  address: protocolAddress,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { AIPhandler, SIGPROTO } from \"./aip\";\n\nconst address = \"1HA1P2exomAwCUycZHr8WeyFoy5vuQASE3\";\n\nconst opReturnSchema: SchemaField[] = [\n  { algorithm: \"string\" },\n  { algorithm: \"string\" },\n  { address: \"string\" },\n  { signature: \"string\" },\n  { algorithm: \"string\" },\n  [{ index: \"binary\" }],\n];\n\n// https://github.com/torusJKL/BitcoinBIPs/blob/master/HAIP.md\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n  if (!tape) {\n    throw new Error(\"Invalid HAIP tx. Bad tape\");\n  }\n  if (!tx) {\n    throw new Error(\"Invalid HAIP tx.\");\n  }\n  return await AIPhandler(\n    opReturnSchema,\n    SIGPROTO.HAIP,\n    dataObj,\n    cell,\n    tape\n    // tx,\n  );\n};\n\nexport const HAIP: Protocol = {\n  name: \"HAIP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { decode } from \"@msgpack/msgpack\";\nimport type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport type { MAP as MAPType } from \"../types/protocols/map\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5\";\n\nconst opReturnSchema: SchemaField[] = [\n  {\n    cmd: {\n      SET: [{ key: \"string\" }, { val: \"string\" }],\n      SELECT: [{ tx: \"string\" }],\n      ADD: [{ key: \"string\" }, [{ val: \"string\" }]],\n      DELETE: [{ key: \"string\" }, [{ val: \"string\" }]],\n      JSON: \"string\",\n      REMOVE: [[{ key: \"string\" }]],\n      CLEAR: [[{ txid: \"string\" }]],\n    },\n  },\n];\n\nconst processADD = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    const pushdata = pushdataContainer.s as string;\n    if (pushdataContainer.i === 2) {\n      // Key name\n      mapObj[pushdata] = [];\n      last = pushdata;\n    } else {\n      if (last && Array.isArray(mapObj[last])) {\n        (mapObj[last] as string[]).push(pushdata);\n      }\n    }\n  }\n};\n\nconst proccessDELETE = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    const pushdata = pushdataContainer.s as string;\n    if (pushdataContainer.i === 2) {\n      // Key name\n      mapObj[pushdata] = [];\n      last = pushdata;\n    } else {\n      if (last) {\n        (mapObj[last] as string[]).push(pushdata);\n      }\n    }\n  }\n};\n\nconst processSELECT = (cell: Cell[], mapObj: MAPType) => {\n  // TODO\n  // console.log('MAP SELECT');\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      mapObj.SELECT = \"TODO\";\n    }\n  }\n};\n\nconst processMSGPACK = (cell: Cell[], mapObj: MAPType) => {\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    if (pushdataContainer.i === 2) {\n      try {\n        if (!decode) {\n          throw new Error(\"Msgpack is required but not loaded\");\n        }\n        const buff = Buffer.from(pushdataContainer.b as string, \"base64\");\n        mapObj = decode(buff) as MAPType;\n      } catch (e) {\n        mapObj = {} as MAPType;\n      }\n    }\n  }\n  return mapObj;\n};\n\nconst processJSON = (cell: Cell[], mapObj: MAPType) => {\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    if (pushdataContainer.i === 2) {\n      try {\n        mapObj = JSON.parse(pushdataContainer.s as string);\n      } catch (e) {\n        mapObj = {} as MAPType;\n      }\n    }\n  }\n  return mapObj;\n};\n\nconst processSET = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (!pushdataContainer.s || pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n\n    const pushdata = pushdataContainer.s;\n    if (pushdataContainer.i % 2 === 0) {\n      // key\n      mapObj[pushdata] = \"\";\n      last = pushdata;\n    } else {\n      // value\n      if (!last) {\n        throw new Error(`malformed MAP syntax. Cannot parse.${last}`);\n      }\n      mapObj[last] = pushdata;\n    }\n  }\n};\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  // Validate\n  if (cell[0].s !== address || !cell[1] || !cell[1].s || !cell[2] || !cell[2].s) {\n    throw new Error(`Invalid MAP record: ${tx}`);\n  }\n\n  let mapObj = {} as MAPType;\n\n  // parse the protocol separator\n  const commands: any[] = [];\n  let commandSeparator = 0;\n  for (let i = 1; i < cell.length; i++) {\n    if (cell[i].s === \":::\") {\n      commandSeparator++;\n    } else {\n      if (!commands[commandSeparator]) commands[commandSeparator] = [];\n      cell[i].i = commands[commandSeparator].length + 1;\n      commands[commandSeparator].push(cell[i]);\n    }\n  }\n\n  // Get the MAP command key name from the query schema\n  const mapCmdKey = Object.keys(opReturnSchema[0])[0];\n\n  // Add the firt MAP command in the response object\n  mapObj[mapCmdKey] = commands[0][0].s;\n\n  for (const cc of commands) {\n    // re-add the MAP address\n    cc.unshift({\n      s: address,\n      i: 0,\n    });\n\n    const command = cc[1].s;\n    // Individual parsing rules for each MAP command\n    switch (command) {\n      // Also check for SELECT commands and strip off the <SELECT> <TXID> part and run it through\n      case \"ADD\": {\n        processADD(cc, mapObj);\n        break;\n      }\n      case \"REMOVE\": {\n        mapObj.key = cc[2].s;\n        break;\n      }\n      case \"DELETE\": {\n        proccessDELETE(cc, mapObj);\n        break;\n      }\n      case \"CLEAR\": {\n        // TODO\n        // console.log('MAP CLEAR');\n        break;\n      }\n      case \"SELECT\": {\n        processSELECT(cc, mapObj);\n        break;\n      }\n      case \"MSGPACK\": {\n        mapObj = processMSGPACK(cc, mapObj);\n        break;\n      }\n      case \"JSON\": {\n        mapObj = processJSON(cc, mapObj);\n        break;\n      }\n      case \"SET\": {\n        processSET(cc, mapObj);\n        break;\n      }\n      default: {\n        // don't know what to do ...\n      }\n    }\n  }\n\n  saveProtocolData(dataObj, \"MAP\", mapObj);\n};\n\nexport const MAP: Protocol = {\n  name: \"MAP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { Hash, Utils } from \"@bsv/sdk\";\nimport type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\n\nconst { toArray, toHex } = Utils;\n\nconst address = \"meta\";\n\nconst opReturnSchema: SchemaField[] = [\n  { address: \"string\" },\n  { parent: \"string\" },\n  { name: \"string\" },\n];\n\nexport const getEnvSafeMetanetID = async (a: string, tx: string) => {\n  // Calculate the node ID\n  const buf = Buffer.from(a + tx);\n  const hashBuf = Hash.sha256(toArray(buf));\n  return toHex(hashBuf);\n};\n\nconst handler = async ({ dataObj, cell, tx }: HandlerProps) => {\n  if (\n    !cell.length ||\n    cell[0].s !== \"meta\" ||\n    !cell[1] ||\n    !cell[1].s ||\n    !cell[2] ||\n    !cell[2].s ||\n    !tx\n  ) {\n    throw new Error(`Invalid Metanet tx ${tx}`);\n  }\n  // For now, we just copy from MOM keys later if available, or keep BOB format\n\n  const nodeId = await getEnvSafeMetanetID(cell[1].s, tx.tx.h);\n  // Described this node\n  const node = {\n    a: cell[1].s,\n    tx: tx.tx.h,\n    id: nodeId,\n  };\n  let parent = {\n    a: \"\",\n    tx: \"\",\n    id: \"\",\n  };\n  if (tx.in) {\n    const parentId = await getEnvSafeMetanetID(tx.in[0].e.a, cell[2].s);\n    // Parent node\n    parent = {\n      a: tx.in[0].e.a,\n      tx: cell[2].s,\n      id: parentId,\n    };\n  }\n\n  if (!dataObj.METANET) {\n    dataObj.METANET = [];\n  }\n  dataObj.METANET.push({\n    node,\n    parent,\n  });\n};\n\nexport const METANET: Protocol = {\n  name: \"METANET\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { ORD as OrdType } from \"../types/protocols/ord\";\n\nconst scriptChecker = (cell: Cell[]) => {\n  if (cell.length < 13) {\n    // wrong length\n    return false;\n  }\n\n  // Find OP_IF wrapper\n  const startIdx = findIndex(cell, (c: Cell) => c.ops === \"OP_IF\");\n  const endIdx = findIndex(cell, (c: Cell, i: number) => i > startIdx && c.ops === \"OP_ENDIF\");\n  const ordScript = cell.slice(startIdx, endIdx);\n  const prevCell = cell[startIdx - 1];\n  return prevCell?.op === 0 && !!ordScript[0] && !!ordScript[1] && ordScript[1].s === \"ord\";\n};\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n  if (!cell[0] || !out) {\n    throw new Error(\"Invalid Ord tx. dataObj, cell, out and tx are required.\");\n  }\n\n  // Find OP_IF wrapper\n  const startIdx = findIndex(cell, (c: Cell) => c.ops === \"OP_IF\");\n  const endIdx = findIndex(cell, (c: Cell, i: number) => i > startIdx && c.ops === \"OP_ENDIF\") + 1;\n  const ordScript = cell.slice(startIdx, endIdx);\n\n  if (!ordScript[0] || !ordScript[1] || ordScript[1].s !== \"ord\") {\n    throw new Error(\"Invalid Ord tx. Prefix not found.\");\n  }\n\n  let data: string | undefined;\n  let contentType: string | undefined;\n  ordScript.forEach((push, idx, all) => {\n    // content-type\n    if (push.ops === \"OP_1\") {\n      contentType = all[idx + 1].s;\n    }\n    // data\n    if (push.ops === \"OP_0\") {\n      data = all[idx + 1].b;\n    }\n  });\n\n  if (!data) {\n    throw new Error(\"Invalid Ord data.\");\n  }\n  if (!contentType) {\n    throw new Error(\"Invalid Ord content type.\");\n  }\n\n  const OrdObj: OrdType = {\n    data,\n    contentType,\n  };\n\n  if (!dataObj.ORD) {\n    dataObj.ORD = [];\n  }\n  dataObj.ORD.push(OrdObj);\n};\n\nexport const ORD: Protocol = {\n  name: \"ORD\",\n  handler,\n  scriptChecker,\n};\n\nfunction findIndex<T>(\n  array: T[],\n  predicate: (value: T, index: number, array: T[]) => boolean\n): number {\n  return findLastIndex(array, predicate);\n}\n\nfunction findLastIndex<T>(\n  array: T[],\n  predicate: (value: T, index: number, array: T[]) => boolean,\n  fromIndex?: number\n): number {\n  const length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  let index = length - 1;\n  if (fromIndex !== undefined) {\n    index = fromIndex;\n    index = fromIndex < 0 ? Math.max(length + index, 0) : Math.min(index, length - 1);\n  }\n  return baseFindIndex(array, predicate, index, true);\n}\n\nfunction baseFindIndex<T>(\n  array: T[],\n  predicate: (value: T, index: number, array: T[]) => boolean,\n  fromIndex: number,\n  fromRight: boolean\n): number {\n  const { length } = array;\n  let index = fromIndex + (fromRight ? 1 : -1);\n\n  while (fromRight ? index-- : ++index < length) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1GvFYzwtFix3qSAZhESQVTz9DeudHZNoh1\";\n\nconst opReturnSchema: SchemaField[] = [\n  { pair: \"json\" },\n  { address: \"string\" },\n  { timestamp: \"string\" },\n];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (\n    cell[0].s !== address ||\n    !cell[1] ||\n    !cell[2] ||\n    !cell[3] ||\n    !cell[1].s ||\n    !cell[2].s ||\n    !cell[3].s\n  ) {\n    throw new Error(`Invalid RON record ${tx?.tx.h}`);\n  }\n\n  const pair = JSON.parse(cell[1].s);\n  const timestamp = Number(cell[3].s);\n\n  saveProtocolData(dataObj, \"RON\", {\n    pair,\n    address: cell[2].s,\n    timestamp,\n  });\n};\n\nexport const RON: Protocol = {\n  name: \"RON\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1SymRe7erxM46GByucUWnB9fEEMgo7spd\";\n\nconst opReturnSchema = [{ url: \"string\" }];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (cell[0].s !== address || !cell[1] || !cell[1].s) {\n    throw new Error(`Invalid SymRe tx: ${tx}`);\n  }\n\n  saveProtocolData(dataObj, \"SYMRE\", { url: cell[1].s });\n};\n\nexport const SYMRE = {\n  name: \"SYMRE\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { type In, type Out, type Tape, parse } from \"bpu-ts\";\nimport { _21E8 } from \"./protocols/_21e8\";\nimport { AIP } from \"./protocols/aip\";\nimport { B } from \"./protocols/b\";\nimport { BAP } from \"./protocols/bap\";\nimport { BITCOM } from \"./protocols/bitcom\";\nimport { BITKEY } from \"./protocols/bitkey\";\nimport { BITPIC } from \"./protocols/bitpic\";\nimport { HAIP } from \"./protocols/haip\";\nimport { MAP } from \"./protocols/map\";\nimport { METANET } from \"./protocols/metanet\";\nimport { ORD } from \"./protocols/ord\";\nimport { RON } from \"./protocols/ron\";\nimport { SYMRE } from \"./protocols/symre\";\nimport type {\n  BmapTx,\n  BobTx,\n  Handler,\n  HandlerProps,\n  MetaNet,\n  MomTx,\n  Protocol,\n  SchemaField,\n  ScriptChecker,\n} from \"./types/common\";\nimport {\n  checkOpFalseOpReturn,\n  checkOpReturn,\n  isObjectArray,\n  isStringArray,\n  saveProtocolData,\n} from \"./utils\";\n\n// Names of enabled protocols\nconst enabledProtocols = new Map<string, string>([]);\n// Protocol Handlers\nconst protocolHandlers = new Map<string, Handler>([]);\n// Script checkers are intentionally minimalistic detection functions for identifying matching scripts for a given protocol. Only if a checker returns true is a handler called for processing.\nconst protocolScriptCheckers = new Map<string, ScriptChecker>([]);\nconst protocolOpReturnSchemas = new Map<string, SchemaField[]>();\n\nexport const allProtocols = [\n  AIP,\n  B,\n  BAP,\n  MAP,\n  METANET,\n  _21E8,\n  BITCOM,\n  BITKEY,\n  BITPIC,\n  HAIP,\n  RON,\n  SYMRE,\n  ORD,\n];\n\nexport const supportedProtocols = allProtocols.map((p) => p.name);\nexport const defaultProtocols = [AIP, B, BAP, MAP, METANET, ORD];\n\n// prepare protocol map, handlers and schemas\nfor (const protocol of defaultProtocols) {\n  if (protocol.address) {\n    enabledProtocols.set(protocol.address, protocol.name);\n  }\n  protocolHandlers.set(protocol.name, protocol.handler);\n  if (protocol.opReturnSchema) {\n    protocolOpReturnSchemas.set(protocol.name, protocol.opReturnSchema);\n  }\n  if (protocol.scriptChecker) {\n    protocolScriptCheckers.set(protocol.name, protocol.scriptChecker);\n  }\n}\n\n// Takes a BOB formatted op_return transaction\nexport class BMAP {\n  enabledProtocols: Map<string, string>;\n  protocolHandlers: Map<string, Handler>;\n  protocolScriptCheckers: Map<string, ScriptChecker>;\n  protocolOpReturnSchemas: Map<string, SchemaField[]>;\n\n  constructor() {\n    // initial default protocol handlers in this instantiation\n    this.enabledProtocols = enabledProtocols;\n    this.protocolHandlers = protocolHandlers;\n    this.protocolScriptCheckers = protocolScriptCheckers;\n    this.protocolOpReturnSchemas = protocolOpReturnSchemas;\n  }\n\n  addProtocolHandler({ name, address, opReturnSchema, handler, scriptChecker }: Protocol) {\n    if (address) {\n      this.enabledProtocols.set(address, name);\n    }\n    this.protocolHandlers.set(name, handler);\n    if (opReturnSchema) {\n      this.protocolOpReturnSchemas.set(name, opReturnSchema);\n    }\n    if (scriptChecker) {\n      this.protocolScriptCheckers.set(name, scriptChecker);\n    }\n  }\n\n  transformTx = async (tx: BobTx | MomTx): Promise<BmapTx> => {\n    if (!tx || !tx.in || !tx.out) {\n      throw new Error(\"Cannot process tx\");\n    }\n\n    // This will become our nicely formatted response object\n    let dataObj: Partial<BobTx> = {};\n\n    for (const [key, val] of Object.entries(tx)) {\n      if (key === \"out\") {\n        // loop over the outputs\n        for (const out of tx.out) {\n          const { tape } = out;\n\n          // Process opReturn data\n          if (tape?.some((cc) => checkOpReturn(cc))) {\n            dataObj = await this.processDataProtocols(tape, out, tx, dataObj);\n          }\n\n          // No OP_FALSE OP_RETURN in this tape\n          const _21e8Checker = this.protocolScriptCheckers.get(_21E8.name);\n          const ordChecker = this.protocolScriptCheckers.get(ORD.name);\n\n          // Check for 21e8 and ords\n          if (\n            tape?.some((cc) => {\n              const { cell } = cc;\n              if (_21e8Checker?.(cell)) {\n                // 'found 21e8'\n                return true;\n              }\n              if (ordChecker?.(cell)) {\n                // 'found 1sat ordinal'\n                return true;\n              }\n            })\n          ) {\n            // find the cell array\n            // loop over tape\n            for (const cellContainer of tape) {\n              const { cell } = cellContainer;\n              // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n              if (!cell) {\n                throw new Error(\"empty cell while parsing\");\n              }\n              let protocolName = \"\";\n              if (_21e8Checker?.(cell)) {\n                protocolName = _21E8.name;\n              } else if (ordChecker?.(cell)) {\n                protocolName = ORD.name;\n              } else {\n                // nothing found\n                continue;\n              }\n\n              this.process(protocolName, {\n                tx,\n                cell,\n                dataObj: dataObj as BmapTx,\n                tape,\n                out,\n              });\n            }\n          }\n        }\n      } else if (key === \"in\") {\n        dataObj[key] = val.map((v: In) => {\n          const r = { ...v } as any;\n          r.tape = undefined;\n          return r as In;\n        });\n      } else {\n        // known key, just write it retaining original type\n        dataObj[key] = val;\n      }\n    }\n\n    // If this is a MOM planaria it will have metanet keys available\n    if (dataObj.METANET && (tx as MomTx).parent) {\n      const meta = {\n        ancestor: (tx as MomTx).ancestor,\n        parent: (tx as MomTx).parent,\n        child: (tx as MomTx).child,\n        head: (tx as MomTx).head,\n      } as MetaNet;\n      (dataObj.METANET as MetaNet[]).push(meta);\n      // remove parent and node from root level for (MOM data)\n      dataObj.ancestor = undefined;\n      dataObj.child = undefined;\n      dataObj.parent = undefined;\n      dataObj.head = undefined;\n      dataObj.node = undefined;\n    }\n\n    return dataObj as BmapTx;\n  };\n\n  processUnknown = (key: string, dataObj: Partial<BmapTx>, out: Out) => {\n    // no known non-OP_RETURN scripts\n    if (key && !dataObj[key]) {\n      dataObj[key] = [];\n    }\n    (dataObj[key] as Out[]).push({\n      i: out.i,\n      e: out.e,\n      tape: [],\n    });\n  };\n\n  process = async (protocolName: string, { cell, dataObj, tape, out, tx }: HandlerProps) => {\n    if (\n      this.protocolHandlers.has(protocolName) &&\n      typeof this.protocolHandlers.get(protocolName) === \"function\"\n    ) {\n      const handler = this.protocolHandlers.get(protocolName);\n      if (handler) {\n        /* eslint-disable no-await-in-loop */\n        await handler({\n          dataObj,\n          cell,\n          tape,\n          out,\n          tx,\n        });\n      }\n    } else {\n      saveProtocolData(dataObj, protocolName, cell);\n    }\n  };\n\n  processDataProtocols = async (\n    tape: Tape[],\n    out: Out,\n    tx: BobTx,\n    dataObj: Partial<BobTx>\n  ): Promise<Partial<BobTx>> => {\n    // loop over tape\n    for (const cellContainer of tape) {\n      const { cell } = cellContainer;\n      if (!cell) {\n        throw new Error(\"empty cell while parsing\");\n      }\n\n      // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n      if (checkOpFalseOpReturn(cellContainer)) {\n        continue;\n      }\n\n      const prefix = cell[0].s;\n\n      if (prefix) {\n        const bitcomProtocol =\n          this.enabledProtocols.get(prefix) ||\n          defaultProtocols.filter((p) => p.name === prefix)[0]?.name;\n        if (bitcomProtocol) {\n          await this.process(bitcomProtocol, {\n            cell,\n            dataObj: dataObj as BmapTx,\n            tape,\n            out,\n            tx,\n          });\n        } else {\n          this.processUnknown(prefix, dataObj, out);\n        }\n      }\n    }\n    return dataObj;\n  };\n}\n\nexport const fetchRawTx = async (txid: string): Promise<string> => {\n  const url = `https://api.whatsonchain.com/v1/bsv/main/tx/${txid}/hex`;\n  console.log(\"hitting\", url);\n  const res = await fetch(url);\n  return await res.text();\n};\n\nexport const bobFromRawTx = async (rawTx: string): Promise<BobTx> => {\n  const bpuTx = await parse({\n    tx: { r: rawTx },\n    split: [\n      {\n        token: { op: 106 },\n        include: \"l\",\n      },\n      {\n        token: { s: \"|\" },\n      },\n    ],\n  });\n  return bpuTx as BobTx;\n};\n\n// TransformTx\n// tx - a raw hex string or a Bob/Bmap/Mom transaction object\n// protocols - the handlers you want to load and use to process the tx\n// reducing the number of supported protocols may improve transform speed\n// at the expense of detecting more data protocols\nexport const TransformTx = async (\n  tx: BobTx | string | MomTx | BmapTx,\n  protocols?: string[] | Protocol[]\n) => {\n  if (typeof tx === \"string\") {\n    let rawTx: string | undefined;\n    // if it a txid or  complete transaction hex?\n    if (tx.length === 64) {\n      // txid - fetch raw tx\n      rawTx = await fetchRawTx(tx);\n    }\n\n    if (Buffer.from(tx).byteLength <= 146) {\n      throw new Error(\"Invalid rawTx\");\n    }\n\n    if (!rawTx) {\n      rawTx = tx;\n    }\n\n    // TODO: Double check 146 is intended to be minimum possible byte length for a tx\n    const bobTx = await bobFromRawTx(rawTx);\n\n    if (bobTx) {\n      tx = bobTx;\n    } else {\n      throw new Error(\"Invalid txid\");\n    }\n  }\n\n  const b = new BMAP();\n\n  // if protocols are specified\n  if (protocols) {\n    // wipe out defaults\n    b.enabledProtocols.clear();\n    if (isStringArray(protocols)) {\n      // set enabled protocols\n      for (const protocol of allProtocols) {\n        if ((protocols as string[])?.includes(protocol.name)) {\n          b.addProtocolHandler(protocol);\n        }\n      }\n    } else if (isObjectArray(protocols)) {\n      for (const p of protocols) {\n        const protocol = p as Protocol;\n        if (protocol) {\n          b.addProtocolHandler(protocol);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Invalid protocol array. Must be either an array of protocol names (string[]), or Protocol objects (Protocol[]).\"\n      );\n    }\n  }\n\n  return b.transformTx(tx);\n};\n\n// Export types\nexport type {\n  BmapTx,\n  BobTx,\n  Handler,\n  HandlerProps,\n  MomTx,\n  Protocol,\n  ScriptChecker,\n} from \"./types/common\";\n\n// Export all protocol types\nexport type { _21E8 } from \"./types/protocols/_21e8\";\nexport type { AIP } from \"./types/protocols/aip\";\nexport type { B } from \"./types/protocols/b\";\nexport type { BAP } from \"./types/protocols/bap\";\nexport type { BITCOM } from \"./types/protocols/bitcom\";\nexport type { BITKEY } from \"./types/protocols/bitkey\";\nexport type { BITPIC } from \"./types/protocols/bitpic\";\nexport type { HAIP } from \"./types/protocols/haip\";\nexport type { MAP } from \"./types/protocols/map\";\nexport type { ORD } from \"./types/protocols/ord\";\nexport type { RON } from \"./types/protocols/ron\";\nexport type { SYMRE } from \"./types/protocols/symre\";\n"],"names":["isStringArray","arr","value","isObjectArray","cellValue","pushData","schemaEncoding","checkOpReturn","cc","c","checkOpFalseOpReturn","opReturnIdx","_a","saveProtocolData","dataObj","protocolName","data","bmapOpReturnSchemaHandler","opReturnSchema","cell","tx","obj","length","idx","schemaField","x","field","isBase64","regex","_21e8Script","scriptChecker","ops","target","targetOpSize","handler","out","txid","difficulty","_21e8Obj","_21E8","toArray","toHex","fromBase58Check","toBase58Check","Utils","address","validateSignature","aipObj","tape","cellIndex","i","usingIndexes","signatureValues","cellContainer","statement","indexLength","indexes","signatureBufferStatements","index","messageBuffer","dataScript","Script","dataArray","Hash","addressString","signature","Signature","e","tryNormalLogic","msgHash","BSM","bigMsg","toBigNumberFromBuffer","recovery","publicKey","pubKeyHash","prefix","tryTwetchLogic","trimmed","buff","hexStr","twetchMsg","verified","buffer","hex","BigNumber","SIGPROTO","AIPhandler","useOpReturnSchema","protocol","aipField","fieldData","AIP","encodingMap","bObj","bField","encoding","B","BAP","protocolAddress","bitcomObj","BITCOM","magicHash","toBigNumber","recoverPublicKeyFromBSM","message","bitkeyObj","bitkeyField","pubkeyHex","userPubKeyHash","PublicKey","userAddress","concatenated","concatenatedBuffer","bitkeyMessage","bitkeySignature","recoveredBitkeyPubkey","recoveredBitkeyPubKeyHash","recoveredBitkeyAddress","bitkeySignatureVerified","userMessage","userSignature","recoveredUserPubkey","recoveredUserPubKeyHash","recoveredUserAddress","userSignatureVerified","BITKEY","bitpicObj","bin","hashBuff","sig","pubkey","BITPIC","HAIP","processADD","mapObj","last","pushdataContainer","pushdata","proccessDELETE","processSELECT","processMSGPACK","decode","processJSON","processSET","commands","commandSeparator","mapCmdKey","MAP","getEnvSafeMetanetID","a","buf","hashBuf","nodeId","node","parent","parentId","METANET","startIdx","findIndex","endIdx","ordScript","prevCell","contentType","push","all","OrdObj","ORD","array","predicate","findLastIndex","fromIndex","baseFindIndex","fromRight","pair","timestamp","RON","SYMRE","enabledProtocols","protocolHandlers","protocolScriptCheckers","protocolOpReturnSchemas","allProtocols","supportedProtocols","p","defaultProtocols","BMAP","name","key","val","_21e8Checker","ordChecker","v","r","meta","bitcomProtocol","fetchRawTx","url","bobFromRawTx","rawTx","parse","TransformTx","protocols","bobTx","b"],"mappings":"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"}