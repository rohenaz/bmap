{"version":3,"file":"bmap.es.js","sources":["../src/utils.ts","../src/protocols/_21e8.ts","../src/protocols/aip.ts","../src/protocols/b.ts","../src/protocols/bap.ts","../src/protocols/bitcom.ts","../src/protocols/bitkey.ts","../src/protocols/bitpic.ts","../src/protocols/haip.ts","../src/protocols/map.ts","../src/protocols/metanet.ts","../src/protocols/ord.ts","../src/protocols/ron.ts","../src/protocols/symre.ts","../src/bmap.ts"],"sourcesContent":["import { Hash, Utils } from \"@bsv/sdk\";\nimport type { Cell, Tape } from \"bpu-ts\";\nimport type { BmapTx, BobTx, SchemaField } from \"./types/common\";\nconst { toArray } = Utils;\n\nexport const isStringArray = (arr: Array<any>): boolean => {\n  return (\n    arr.length > 0 &&\n    arr.every((value) => {\n      return typeof value === \"string\";\n    })\n  );\n};\nexport const isObjectArray = (arr: Array<any>): boolean => {\n  return (\n    arr.length > 0 &&\n    arr.every((value) => {\n      return value === \"object\";\n    })\n  );\n};\n/**\n * returns the BOB cell value for a given encoding\n *\n * @param pushData\n * @param schemaEncoding\n * @returns {string|number}\n */\nexport const cellValue = (pushData: Cell, schemaEncoding?: string): string | number => {\n  if (!pushData) {\n    throw new Error(`cannot get cell value of: ${pushData}`);\n  }\n  if (schemaEncoding === \"string\") {\n    return pushData.s ? pushData.s : pushData.ls || \"\";\n  }\n  if (schemaEncoding === \"hex\") {\n    return pushData.h\n      ? pushData.h\n      : pushData.lh ||\n      (pushData.b\n        ? Buffer.from(pushData.b, \"base64\").toString(\"hex\")\n        : pushData.lb && Buffer.from(pushData.lb, \"base64\").toString(\"hex\")) ||\n      \"\";\n  }\n  if (schemaEncoding === \"number\") {\n    return Number.parseInt(pushData.h ? pushData.h : pushData.lh || \"0\", 16);\n  }\n  if (schemaEncoding === \"file\") {\n    return `bitfs://${pushData.f ? pushData.f : pushData.lf}`;\n  }\n  if (schemaEncoding === \"binary\") {\n    return pushData.b || pushData.lb || \"\";\n  }\n\n  return (pushData.b ? pushData.b : pushData.lb) || \"\";\n};\n\n/**\n * Check if cells end with OP_RETURN\n */\nexport const checkOpReturn = (cc: Tape): boolean => {\n  return cc.cell.some((c: Cell) => c.op === 106);\n};\n\n/**\n * Check if cells end with OP_FALSE + OP_RETURN\n */\nexport const checkOpFalseOpReturn = (cc: Tape): boolean => {\n  if (cc.cell.length !== 2) {\n    return false;\n  }\n  const opReturnIdx = cc.cell.findIndex((c) => c.op === 106);\n  if (opReturnIdx !== -1) {\n    return cc.cell[opReturnIdx - 1]?.op === 0;\n  }\n  return false;\n};\n\n/**\n * Helper function to store protocol data\n *\n * @param dataObj\n * @param protocolName\n * @param data\n */\nexport const saveProtocolData = (\n  dataObj: { [key: string]: any },\n  protocolName: string,\n  data: any\n) => {\n  if (!dataObj[protocolName]) {\n    dataObj[protocolName] = [data];\n  } else {\n    if (!Array.isArray(dataObj[protocolName])) {\n      const prevData = dataObj[protocolName];\n      dataObj[protocolName] = [];\n      dataObj[protocolName][0] = prevData;\n    }\n    dataObj[protocolName].push(data);\n  }\n};\n\n/**\n * BMAP default handler to work with query schema's\n *\n * @param opReturnSchema\n * @param protocolName\n * @param dataObj\n * @param cell\n * @param tape\n * @param tx\n */\nexport const bmapOpReturnSchemaHandler = (\n  protocolName: string,\n  opReturnSchema: SchemaField[],\n  dataObj: BmapTx,\n  cell: Cell[],\n  tx: BobTx\n) => {\n  // loop over the schema\n  const obj: { [key: string]: any } = {};\n\n  // Does not have the required number of fields\n  const length = opReturnSchema.length + 1;\n  if (cell.length < length) {\n    throw new Error(\n      `${protocolName} requires at least ${length} fields including the prefix: ${tx.tx.h}`\n    );\n  }\n\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n\n    const [field] = Object.keys(schemaField);\n    const [schemaEncoding] = Object.values(schemaField);\n    obj[field] = cellValue(cell[x + 1], schemaEncoding as string);\n  }\n\n  saveProtocolData(dataObj, protocolName, obj);\n};\n\n/**\n * Check whether the given data is base64\n *\n * @param data\n * @returns {boolean}\n */\nexport const isBase64 = (data: string) => {\n  const regex = \"(?:[A-Za-z0-9+\\\\/]{4})*(?:[A-Za-z0-9+\\\\/]{2}==|[A-Za-z0-9+/]{3}=)?\";\n  return new RegExp(`^${regex}$`, \"gi\").test(data);\n};\n\n// hashes a message buffer, returns the hash as a buffer\nexport const sha256 = (msgBuffer: number[]) => {\n  return Hash.sha256(toArray(msgBuffer));\n};\n\n\nexport const shallowEqualArrays = <T>(arr1: T[], arr2: T[]): boolean => {\n  return (\n    arr1.length === arr2.length &&\n    arr1.every((value, index) => value === arr2[index])\n  );\n}\n","import type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { _21E8 as _21E8Type } from \"../types/protocols/_21e8\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\n// 21e8 does not use the first pushdata for id\n// in fact there is no id since the 21e8 is designed for difficulty and can be changed\n// instead we use the static part of the script to indentfy the transaction\n// TODO - the OP_X_PLACEHOLDER is the number of bytes to push onto the stack and must match difficulty size\nconst _21e8Script =\n  \"OP_SIZE <OP_X_PLACEHOLDER> OP_PICK OP_SHA256 OP_SWAP OP_SPLIT OP_DROP OP_EQUALVERIFY OP_DROP OP_CHECKSIG\".split(\n    \" \"\n  );\n\nconst scriptChecker = (cell: Cell[]) => {\n  if (cell.length !== 12) {\n    // wrong length\n    return false;\n  }\n\n  // match exact script\n  const ops = [...cell].map((c) => c.ops).splice(2, cell.length);\n\n  // calculate target byte length\n  const target = cellValue(cell[1], \"hex\") as string;\n  const targetOpSize = Buffer.from(target).byteLength;\n\n  // replace the placeholder opcode with actual\n  ops[1] = `OP_${targetOpSize}`;\n  _21e8Script[1] = `OP_${targetOpSize}`;\n\n  // protocol identifier always in first pushdata\n  return ops.join() === _21e8Script.join();\n};\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n  if (!cell[0] || !out) {\n    throw new Error(\"Invalid 21e8 tx. dataObj, cell, out and tx are required.\");\n  }\n\n  // assemble asm\n  // make sure first piece matches a txid\n  // 2nd piece matches any difficulty. set some resonable limit in bytes if there isnt one documented somewhere\n  // next\n\n  const txid = cellValue(cell[0], \"hex\") as string;\n  const target = cellValue(cell[1], \"hex\") as string;\n  if (!target) {\n    throw new Error(`Invalid 21e8 target. ${JSON.stringify(cell[0], null, 2)}`);\n  }\n  const difficulty = Buffer.from(target, \"hex\").byteLength;\n\n  const _21e8Obj: _21E8Type = {\n    target,\n    difficulty,\n    value: out.e.v,\n    txid,\n  };\n\n  saveProtocolData(dataObj, \"21E8\", _21e8Obj);\n};\n\nexport const _21E8: Protocol = {\n  name: \"21E8\",\n  handler,\n  scriptChecker,\n};\n","import { BSM, BigNumber, Hash, Script, Signature, Utils } from \"@bsv/sdk\";\nimport type { Cell, Tape } from \"bpu-ts\";\nimport type { BmapTx, BobTx, HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport type { AIP as AIPType } from \"../types/protocols/aip\";\nimport type { HAIP as HAIPType } from \"../types/protocols/haip\";\nimport { cellValue, checkOpFalseOpReturn, isBase64, saveProtocolData, shallowEqualArrays } from \"../utils\";\n\nconst { toArray, toHex, fromBase58Check, toBase58Check } = Utils;\n\nconst address = \"15PciHG22SNLQJXMoSUaWVi7WSqc7hCfva\";\n\nconst opReturnSchema: SchemaField[] = [\n  { algorithm: \"string\" },\n  { address: \"string\" },\n  { signature: \"binary\" },\n  [{ index: \"number[]\" }],\n];\n\nfunction validateSignature(\n  aipObj: Partial<AIPType | HAIPType>,\n  cell: Cell[],\n  tape: Tape[]\n): boolean {\n  if (!Array.isArray(tape) || tape.length < 3) {\n    throw new Error(\"AIP requires at least 3 cells including the prefix\");\n  }\n\n  let cellIndex = -1;\n  for (let i = 0; i < tape.length; i++) {\n    if (shallowEqualArrays(tape[i].cell, cell)) {\n      console.log(\"[validateSignature] found cell in tape\");\n      cellIndex = i;\n      break;\n    }\n  }\n  if (cellIndex === -1) {\n    throw new Error(\"AIP could not find cell in tape\");\n  }\n\n  console.log(\"[validateSignature] tape:\", tape.map(t => t.cell.map(c => `c.ii: ${c.ii}, c.h: ${c.h?.slice(0, 10)}, c.b: ${c.b?.slice(0, 10)}, c.s: ${c.s?.slice(0, 10)}`)));\n\n  let usingIndexes: number[] = aipObj.index || [];\n  const signatureValues: number[][] = [];\n\n  // Always start with OP_RETURN\n  const allCells = tape.flatMap(t => t.cell)\n    .filter(c => c.ii !== undefined)\n    .sort((a, b) => (a.ii || 0) - (b.ii || 0));\n\n  const firstCell = allCells[0];\n  if (firstCell?.op === 106) {\n    signatureValues.push(toArray(\"6a\", \"hex\")); // Use OP_RETURN from opcode\n  } else {\n    // If no opcode, just use the standard OP_RETURN\n    signatureValues.push(toArray(\"6a\", \"hex\"));\n  }\n\n  // Create a map of all cells by their ii value\n  const cellsByIndex = new Map<number, Cell>();\n  for (const cell of allCells) {\n    if (cell.ii !== undefined) {\n      cellsByIndex.set(cell.ii, cell);\n    }\n  }\n\n  // Print out all cells in order with their hex values\n  console.log(\"[validateSignature] All cells in order:\");\n  for (const c of allCells) {\n    console.log(`ii: ${c.ii}, hex: ${c.h}, s: ${c.s}`);\n  }\n\n  if (usingIndexes.length > 0) {\n    console.log(\"[validateSignature] Using indexes:\", usingIndexes);\n\n    // Filter to only the values at the specified indices\n    for (let i = 0; i < usingIndexes.length; i++) {\n      const index = usingIndexes[i];\n\n      // Skip index 0 since we already handled OP_RETURN\n      if (index === 0) continue;\n\n      // Find the cell with exact ii match\n      const targetCell = allCells.find(c => (c.ii || 0) === index);\n\n      // If we don't find a cell at this index, it's a protocol separator\n      if (!targetCell) {\n        signatureValues.push(toArray(\"7c\", \"hex\")); // |\n        continue;\n      }\n\n      if (targetCell.h) {\n        signatureValues.push(toArray(targetCell.h, \"hex\"));\n      } else if (targetCell.b) {\n        signatureValues.push(toArray(targetCell.b, \"base64\"));\n      } else if (targetCell.s) {\n        signatureValues.push(toArray(targetCell.s));\n      } else {\n        console.log(`[validateSignature] No usable value found in cell with ii: ${targetCell.ii}`);\n        return false;\n      }\n    }\n  } else {\n    // Process each tape up to the AIP tape\n    for (let i = 1; i < cellIndex; i++) {\n      const tapeCells = tape[i].cell;\n      if (!checkOpFalseOpReturn({ cell: tapeCells } as Tape)) {\n        // Add each cell's value\n        for (const cell of tapeCells) {\n          if (cell.h) {\n            signatureValues.push(toArray(cell.h, \"hex\"));\n          } else if (cell.b) {\n            signatureValues.push(toArray(cell.b, \"base64\"));\n          } else if (cell.s) {\n            signatureValues.push(toArray(cell.s));\n          }\n        }\n\n        // Add protocol separator after each tape\n        signatureValues.push(toArray(\"7c\", \"hex\")); // |\n      }\n    }\n  }\n\n  // Handle HAIP specific logic\n  if (aipObj.hashing_algorithm) {\n    // when using HAIP, we need to parse the indexes in a non standard way\n    // indexLength is byte size of the indexes being described\n    if (aipObj.index_unit_size) {\n      const indexLength = aipObj.index_unit_size * 2;\n      usingIndexes = [];\n      const indexes = cell[6].h as string;\n      for (let i = 0; i < indexes.length; i += indexLength) {\n        usingIndexes.push(Number.parseInt(indexes.substr(i, indexLength), 16));\n      }\n      aipObj.index = usingIndexes;\n    }\n  }\n\n  console.log(\"[validateSignature] Final signature values:\", signatureValues.map(v => toHex(v)));\n\n  let messageBuffer: number[];\n  if (aipObj.hashing_algorithm) {\n    // this is actually Hashed-AIP (HAIP) and works a bit differently\n    if (!aipObj.index_unit_size) {\n      // remove OP_RETURN - will be added by Script.buildDataOut\n      signatureValues.shift();\n    }\n    const dataScript = Script.fromHex(toHex(signatureValues.flat()));\n    let dataArray = toArray(dataScript.toHex(), \"hex\");\n    if (aipObj.index_unit_size) {\n      // the indexed buffer should not contain the OP_RETURN opcode, but this\n      // is added by the buildDataOut function automatically. Remove it.\n      dataArray = dataArray.slice(1);\n    }\n    messageBuffer = Hash.sha256(dataArray);\n  } else {\n    // regular AIP\n    messageBuffer = signatureValues.flat();\n  }\n\n  // AIOP uses address, HAIP uses signing_address field names\n  const addressString = (aipObj as AIPType).address || (aipObj as HAIPType).signing_address;\n  if (!addressString || !aipObj.signature) {\n    return false;\n  }\n\n  let signature: Signature;\n  try {\n    // the signature is always base64 encoded\n    signature = Signature.fromCompact(aipObj.signature, \"base64\");\n  } catch (e) {\n    console.log(\"[validateSignature] Failed to parse signature:\", e);\n    return false;\n  }\n\n  const tryNormalLogic = (): boolean => {\n    try {\n      const msgHash = BSM.magicHash(messageBuffer);\n      const bigMsg = toBigNumberFromBuffer(msgHash);\n\n      for (let recovery = 0; recovery < 4; recovery++) {\n        try {\n          const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n          const pubKeyHash = publicKey.toHash() as number[];\n          const { prefix } = fromBase58Check(addressString);\n          const recoveredAddress = toBase58Check(pubKeyHash, prefix as number[]);\n          if (recoveredAddress === addressString) {\n            return BSM.verify(messageBuffer, signature, publicKey);\n          }\n        } catch (e) {\n          console.log(\"[tryNormalLogic] Recovery error:\", e);\n        }\n      }\n    } catch (e) {\n      console.log(\"[tryNormalLogic] error:\", e);\n    }\n    return false;\n  };\n\n  const tryTwetchLogic = (): boolean => {\n    // Twetch signs a UTF-8 buffer of the hex string of a sha256 hash of the message\n    // Without 0x06 (OP_RETURN) and without 0x7c at the end, the trailing pipe (\"|\")\n    if (signatureValues.length <= 2) {\n      return false;\n    }\n\n    try {\n      const trimmed = signatureValues.slice(1, -1);\n      const buff = Hash.sha256(trimmed.flat());\n      const hexStr = toHex(buff);\n      const twetchMsg = toArray(hexStr, \"utf8\");\n\n      const msgHash = BSM.magicHash(twetchMsg);\n      const bigMsg = toBigNumberFromBuffer(msgHash);\n\n      for (let recovery = 0; recovery < 4; recovery++) {\n        try {\n          const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n          const pubKeyHash = publicKey.toHash() as number[];\n          const { prefix } = fromBase58Check(addressString);\n          const recoveredAddress = toBase58Check(pubKeyHash, prefix as number[]);\n          if (recoveredAddress === addressString) {\n            return BSM.verify(twetchMsg, signature, publicKey);\n          }\n        } catch (e) {\n          console.log(\"[tryTwetchLogic] Recovery error:\", e);\n        }\n      }\n    } catch (e) {\n      console.log(\"[tryTwetchLogic] error:\", e);\n    }\n    return false;\n  };\n\n  let verified = tryNormalLogic();\n  if (!verified) {\n    verified = tryTwetchLogic();\n  }\n\n  aipObj.verified = verified;\n  return verified;\n}\n\nfunction toBigNumberFromBuffer(buffer: number[]): BigNumber {\n  const hex = toHex(buffer);\n  return new BigNumber(hex, 16);\n}\n\nexport enum SIGPROTO {\n  HAIP = \"HAIP\",\n  AIP = \"AIP\",\n}\n\nexport const AIPhandler = async (\n  useOpReturnSchema: SchemaField[],\n  protocol: SIGPROTO,\n  dataObj: Partial<BobTx>,\n  cell: Cell[],\n  tape: Tape[]\n): Promise<HandlerProps> => {\n  // loop over the schema\n  const aipObj: { [key: string]: number | number[] | string | boolean } = {};\n\n  // Does not have the required number of fields\n  if (cell.length < 4) {\n    throw new Error(\"AIP requires at least 4 fields including the prefix\");\n  }\n\n  for (const [idx, schemaField] of Object.entries(useOpReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n\n    if (Array.isArray(schemaField)) {\n      // signature indexes are specified\n      const [aipField] = Object.keys(schemaField[0]) as (keyof AIPType)[];\n      // field \"index\"\n      console.log(\"[AIPhandler] aipField:\", aipField);\n      // run through the rest of the fields in this cell, should be de indexes\n      const fieldData: number[] = [];\n      for (let i = x + 1; i < cell.length; i++) {\n        if (cell[i].h && Array.isArray(fieldData)) {\n          fieldData.push(Number.parseInt(cell[i].h || \"\", 16));\n        }\n      }\n      console.log(\"[AIPhandler] fieldData:\", fieldData);\n      aipObj[aipField] = fieldData;\n    } else {\n      const [aipField] = Object.keys(schemaField) as (keyof AIPType)[];\n      const [schemaEncoding] = Object.values(schemaField);\n      aipObj[aipField] = cellValue(cell[x + 1], schemaEncoding as string) || \"\";\n    }\n  }\n\n  // There is an issue where some services add the signature as binary to the transaction\n  // whereas others add the signature as base64. This will confuse bob and the parser and\n  // the signature will not be verified. When the signature is added in binary cell[3].s is\n  // binary, otherwise cell[3].s contains the base64 signature and should be used.\n  if (cell[0].s === address && cell[3].s && isBase64(cell[3].s)) {\n    aipObj.signature = cell[3].s;\n  }\n\n  if (!aipObj.signature) {\n    throw new Error(\"AIP requires a signature\");\n  }\n\n  validateSignature(aipObj as Partial<AIPType>, cell, tape);\n\n  saveProtocolData(dataObj, protocol, aipObj);\n  return { dataObj: dataObj as BmapTx, cell, tape };\n};\n\nconst handler = async ({ dataObj, cell, tape }: HandlerProps): Promise<HandlerProps> => {\n  if (!tape) {\n    throw new Error(\"Invalid AIP transaction. tape is required\");\n  }\n  return AIPhandler(opReturnSchema, SIGPROTO.AIP, dataObj, cell, tape);\n};\n\nexport const AIP: Protocol = {\n  name: \"AIP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\nconst address = \"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\";\n\nconst opReturnSchema: SchemaField[] = [\n  { content: [\"string\", \"binary\", \"file\"] },\n  { \"content-type\": \"string\" },\n  { encoding: \"string\" }, // we use this field to determine content character encoding. If encoding is not a valid character encoding (gzip), we assume it is binary\n  { filename: \"string\" },\n];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps): void => {\n  const encodingMap = new Map<string, string>();\n  encodingMap.set(\"utf8\", \"string\");\n  encodingMap.set(\"text\", \"string\"); // invalid but people use it :(\n  encodingMap.set(\"gzip\", \"binary\"); // invalid but people use it :(\n  encodingMap.set(\"text/plain\", \"string\");\n  encodingMap.set(\"image/png\", \"binary\");\n  encodingMap.set(\"image/jpeg\", \"binary\");\n  encodingMap.set(\"application/octet-stream\", \"binary\"); // for encrypted data\n\n  if (!cell[1] || !cell[2]) {\n    throw new Error(`Invalid B tx: ${tx}`);\n  }\n\n  // Check pushdata length + 1 for protocol prefix\n  if (cell.length > opReturnSchema.length + 1) {\n    throw new Error(\"Invalid B tx. Too many fields.\");\n  }\n\n  const bObj: { [key: string]: string | number | undefined } = {};\n  // loop over the schema\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n    const bField = Object.keys(schemaField)[0];\n    let schemaEncoding = Object.values(schemaField)[0];\n    if (bField === \"content\") {\n      // If the encoding is ommitted, try to infer from content-type instead of breaking\n      if (cell[1].f) {\n        // this is file reference to B files\n        schemaEncoding = \"file\";\n      } else if ((!cell[3] || !cell[3].s) && cell[2].s) {\n        schemaEncoding = encodingMap.get(cell[2].s) as string;\n        if (!schemaEncoding) {\n          // If we can't infer from content-type, assume binary for encrypted data\n          schemaEncoding = \"binary\";\n        }\n\n        // add the missing encoding field\n        if (!cell[3]) {\n          cell[3] = { h: \"\", b: \"\", s: \"\", i: 0, ii: 0 };\n        }\n        cell[3].s = schemaEncoding === \"string\" ? \"utf-8\" : \"binary\";\n      } else {\n        const encoding = (\n          cell[3]?.s ? encodingMap.get(cell[3].s.replace(\"-\", \"\").toLowerCase()) : null\n        ) as string | null;\n        if (!encoding) {\n          // If we can't determine encoding, assume binary for encrypted data\n          schemaEncoding = \"binary\";\n        } else {\n          schemaEncoding = encoding;\n        }\n      }\n    }\n\n    // encoding is not required\n    if (bField === \"encoding\" && !cell[x + 1]) {\n      // encoding omitted\n      continue;\n    }\n\n    // filename is not required\n    if (bField === \"filename\" && !cell[x + 1]) {\n      // filename omitted\n      continue;\n    }\n\n    // check for malformed syntax\n    if (!cell || !cell[x + 1]) {\n      throw new Error(`malformed B syntax ${cell}`);\n    }\n\n    // set field value from either s, b, ls, or lb depending on encoding and availability\n    const data = cell[x + 1];\n    bObj[bField] = cellValue(data, schemaEncoding as string);\n  }\n\n  saveProtocolData(dataObj, \"B\", bObj);\n};\n\nexport const B: Protocol = {\n  name: \"B\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { bmapOpReturnSchemaHandler } from \"../utils\";\n\nconst address = \"1BAPSuaPnfGnSBM3GLV9yhxUdYe4vGbdMT\";\n\nconst opReturnSchema: SchemaField[] = [\n  { type: \"string\" },\n  { hash: \"string\" },\n  { sequence: \"string\" },\n];\n\nexport const handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (!tx) {\n    throw new Error(\"Invalid BAP tx, tx required\");\n  }\n  bmapOpReturnSchemaHandler(\"BAP\", opReturnSchema, dataObj, cell, tx);\n};\n\nexport const BAP: Protocol = {\n  name: \"BAP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst protocolAddress = \"$\";\n\nconst opReturnSchema: SchemaField[] = [\n  {\n    su: [{ pubkey: \"string\" }, { sign_position: \"string\" }, { signature: \"string\" }],\n    echo: [{ data: \"string\" }, { to: \"string\" }, { filename: \"string\" }],\n    route: [\n      [\n        {\n          add: [\n            { bitcom_address: \"string\" },\n            { route_matcher: \"string\" },\n            { endpoint_template: \"string\" },\n          ],\n        },\n        {\n          enable: [{ path: \"string\" }],\n        },\n      ],\n    ],\n    useradd: [{ address: \"string\" }],\n  },\n];\n\n// const handler = function (dataObj, protocolName, cell, tape, tx) {\nconst handler = ({ dataObj, cell }: HandlerProps) => {\n  if (!cell.length || !cell.every((c) => c.s)) {\n    throw new Error(\"Invalid Bitcom tx\");\n  }\n\n  // gather up the string values\n  const bitcomObj = cell.map((c) => (c?.s ? c.s : \"\"));\n\n  saveProtocolData(dataObj, \"BITCOM\", bitcomObj);\n};\n\nexport const BITCOM: Protocol = {\n  name: \"BITCOM\",\n  address: protocolAddress,\n  opReturnSchema,\n  handler,\n};\n","import { BSM, BigNumber, Hash, PublicKey, Signature, Utils } from \"@bsv/sdk\";\nimport type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\nconst { toArray, toBase58Check, toHex } = Utils;\nconst { magicHash } = BSM;\n\nconst address = \"13SrNDkVzY5bHBRKNu5iXTQ7K7VqTh5tJC\";\n\nconst opReturnSchema: SchemaField[] = [\n  { bitkey_signature: \"string\" },\n  { user_signature: \"string\" },\n  { paymail: \"string\" },\n  { pubkey: \"string\" },\n];\n\n// Helper to convert array to BigNumber\nfunction toBigNumber(buffer: number[]): BigNumber {\n  const hex = toHex(buffer);\n  return new BigNumber(hex, 16);\n}\n\n// Recovers a public key from a BSM signature by brute forcing recovery factors\n// Steps:\n// 1. Apply magicHash to the raw message.\n// 2. Try all recovery factors 0â€“3 with Signature.RecoverPublicKey()\n// 3. If BSM.verify() returns true with the recovered pubkey, return it.\nfunction recoverPublicKeyFromBSM(message: number[], signature: Signature): PublicKey {\n  // First, BSM signatures are verified by applying magicHash internally,\n  // so we must apply magicHash to the raw message ourselves for recovery:\n  const msgHash = magicHash(message);\n\n  const bigMsg = toBigNumber(msgHash);\n  for (let recovery = 0; recovery < 4; recovery++) {\n    try {\n      const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n      // Verify using BSM.verify() with the original raw message (no magicHash)\n      if (BSM.verify(message, signature, publicKey)) {\n        return publicKey;\n      }\n    } catch {\n      // Try next recovery factor\n    }\n  }\n  throw new Error(\"Failed to recover public key from BSM signature\");\n}\n\nconst handler = async ({ dataObj, cell }: HandlerProps) => {\n  if (cell.length < 5) {\n    throw new Error(\"Invalid Bitkey tx\");\n  }\n\n  const bitkeyObj: { [key: string]: string | boolean } = {};\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n    const bitkeyField = Object.keys(schemaField)[0];\n    const schemaEncoding = Object.values(schemaField)[0];\n    bitkeyObj[bitkeyField] = cellValue(cell[x + 1], schemaEncoding as string) as string;\n  }\n\n  // Derive userAddress from pubkey\n  const pubkeyHex = bitkeyObj.pubkey as string;\n  const userPubkey = PublicKey.fromString(pubkeyHex);\n  const userPubKeyHash = userPubkey.toHash() as number[];\n  const userAddress = toBase58Check(userPubKeyHash);\n\n  // Prepare raw message for bitkey signature verification: sha256(paymail_hex + pubkey_hex)\n  const paymailHex = Buffer.from(bitkeyObj.paymail as string).toString(\"hex\");\n  const concatenated = paymailHex + pubkeyHex;\n  const concatenatedBuffer = Buffer.from(concatenated, \"hex\");\n  const bitkeyMessage = Hash.sha256(toArray(concatenatedBuffer));\n  // This is the raw message. BSM.verify() will do magicHash internally.\n\n  const bitkeySignature = Signature.fromCompact(bitkeyObj.bitkey_signature as string, \"base64\");\n\n  // Recover Bitkey pubkey\n  const recoveredBitkeyPubkey = recoverPublicKeyFromBSM(bitkeyMessage, bitkeySignature);\n  const recoveredBitkeyPubKeyHash = recoveredBitkeyPubkey.toHash() as number[];\n  const recoveredBitkeyAddress = toBase58Check(recoveredBitkeyPubKeyHash);\n  const bitkeySignatureVerified =\n    BSM.verify(bitkeyMessage, bitkeySignature, recoveredBitkeyPubkey) &&\n    recoveredBitkeyAddress === address;\n\n  // Verify user signature by using the pubkey as the message\n  const userMessage = toArray(Buffer.from(pubkeyHex, \"utf8\"));\n  const userSignature = Signature.fromCompact(bitkeyObj.user_signature as string, \"base64\");\n  const recoveredUserPubkey = recoverPublicKeyFromBSM(userMessage, userSignature);\n  const recoveredUserPubKeyHash = recoveredUserPubkey.toHash() as number[];\n  const recoveredUserAddress = toBase58Check(recoveredUserPubKeyHash);\n  const userSignatureVerified =\n    BSM.verify(userMessage, userSignature, recoveredUserPubkey) &&\n    recoveredUserAddress === userAddress;\n\n  bitkeyObj.verified = bitkeySignatureVerified && userSignatureVerified;\n  saveProtocolData(dataObj, \"BITKEY\", bitkeyObj);\n};\n\nexport const BITKEY: Protocol = {\n  name: \"BITKEY\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { BSM, Hash, PublicKey, Signature, Utils } from \"@bsv/sdk\";\nimport type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport type { BITPIC as BITPICType } from \"../types/protocols/bitpic\";\nimport { saveProtocolData } from \"../utils\";\nconst { magicHash } = BSM;\nconst { toArray } = Utils;\n\nconst protocolAddress = \"18pAqbYqhzErT6Zk3a5dwxHtB9icv8jH2p\";\n\nconst opReturnSchema: SchemaField[] = [\n  { paymail: \"string\" },\n  { pubkey: \"binary\" },\n  { signature: \"string\" },\n];\n\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n  // Validation\n  if (\n    cell[0].s !== protocolAddress ||\n    !cell[1] ||\n    !cell[2] ||\n    !cell[3] ||\n    !cell[1].s ||\n    !cell[2].b ||\n    !cell[3].s ||\n    !tape\n  ) {\n    throw new Error(`Invalid BITPIC record: ${tx}`);\n  }\n\n  const bitpicObj: BITPICType = {\n    paymail: cell[1].s,\n    pubkey: Buffer.from(cell[2].b, \"base64\").toString(\"hex\"),\n    signature: cell[3].s || \"\",\n    verified: false,\n  };\n\n  const b = tape[1].cell;\n  if (b[0].s === \"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\") {\n    // verify bitpic signature\n\n    try {\n      // TODO: bob transactions are missing this binary part, cannot verify signature\n      const bin = (cell[1].lb || cell[1].b) as string;\n      const hashBuff = Hash.sha256(toArray(bin, \"base64\"));\n      const sig = Signature.fromCompact(bitpicObj.signature as string, \"base64\");\n      const pubkey = PublicKey.fromString(bitpicObj.pubkey as string);\n      const msgHash = magicHash(hashBuff);\n      bitpicObj.verified = BSM.verify(msgHash, sig, pubkey);\n    } catch (e) {\n      // failed verification\n      bitpicObj.verified = false;\n    }\n  }\n\n  saveProtocolData(dataObj, \"BITPIC\", bitpicObj);\n};\n\nexport const BITPIC: Protocol = {\n  name: \"BITPIC\",\n  address: protocolAddress,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { AIPhandler, SIGPROTO } from \"./aip\";\n\nconst address = \"1HA1P2exomAwCUycZHr8WeyFoy5vuQASE3\";\n\nconst opReturnSchema: SchemaField[] = [\n  { algorithm: \"string\" },\n  { algorithm: \"string\" },\n  { address: \"string\" },\n  { signature: \"string\" },\n  { algorithm: \"string\" },\n  [{ index: \"binary\" }],\n];\n\n// https://github.com/torusJKL/BitcoinBIPs/blob/master/HAIP.md\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n  if (!tape) {\n    throw new Error(\"Invalid HAIP tx. Bad tape\");\n  }\n  if (!tx) {\n    throw new Error(\"Invalid HAIP tx.\");\n  }\n  return await AIPhandler(\n    opReturnSchema,\n    SIGPROTO.HAIP,\n    dataObj,\n    cell,\n    tape\n    // tx,\n  );\n};\n\nexport const HAIP: Protocol = {\n  name: \"HAIP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { decode } from \"@msgpack/msgpack\";\nimport type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport type { MAP as MAPType } from \"../types/protocols/map\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5\";\n\nconst opReturnSchema: SchemaField[] = [\n  {\n    cmd: {\n      SET: [{ key: \"string\" }, { val: \"string\" }],\n      SELECT: [{ tx: \"string\" }],\n      ADD: [{ key: \"string\" }, [{ val: \"string\" }]],\n      DELETE: [{ key: \"string\" }, [{ val: \"string\" }]],\n      JSON: \"string\",\n      REMOVE: [[{ key: \"string\" }]],\n      CLEAR: [[{ txid: \"string\" }]],\n    },\n  },\n];\n\nconst processADD = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    const pushdata = pushdataContainer.s as string;\n    if (pushdataContainer.i === 2) {\n      // Key name\n      mapObj[pushdata] = [];\n      last = pushdata;\n    } else {\n      if (last && Array.isArray(mapObj[last])) {\n        (mapObj[last] as string[]).push(pushdata);\n      }\n    }\n  }\n};\n\nconst proccessDELETE = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    const pushdata = pushdataContainer.s as string;\n    if (pushdataContainer.i === 2) {\n      // Key name\n      mapObj[pushdata] = [];\n      last = pushdata;\n    } else {\n      if (last) {\n        (mapObj[last] as string[]).push(pushdata);\n      }\n    }\n  }\n};\n\nconst processSELECT = (cell: Cell[], mapObj: MAPType) => {\n  // TODO\n  // console.log('MAP SELECT');\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      mapObj.SELECT = \"TODO\";\n    }\n  }\n};\n\nconst processMSGPACK = (cell: Cell[], mapObj: MAPType) => {\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    if (pushdataContainer.i === 2) {\n      try {\n        if (!decode) {\n          throw new Error(\"Msgpack is required but not loaded\");\n        }\n        const buff = Buffer.from(pushdataContainer.b as string, \"base64\");\n        mapObj = decode(buff) as MAPType;\n      } catch (e) {\n        mapObj = {} as MAPType;\n      }\n    }\n  }\n  return mapObj;\n};\n\nconst processJSON = (cell: Cell[], mapObj: MAPType) => {\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    if (pushdataContainer.i === 2) {\n      try {\n        mapObj = JSON.parse(pushdataContainer.s as string);\n      } catch (e) {\n        mapObj = {} as MAPType;\n      }\n    }\n  }\n  return mapObj;\n};\n\nconst processSET = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (!pushdataContainer.s || pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n\n    const pushdata = pushdataContainer.s;\n    if (pushdataContainer.i % 2 === 0) {\n      // key\n      mapObj[pushdata] = \"\";\n      last = pushdata;\n    } else {\n      // value\n      if (!last) {\n        throw new Error(`malformed MAP syntax. Cannot parse.${last}`);\n      }\n      mapObj[last] = pushdata;\n    }\n  }\n};\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  // Validate\n  if (cell[0].s !== address || !cell[1] || !cell[1].s || !cell[2] || !cell[2].s) {\n    // limit each error message to 100 characters\n    throw new Error(`Invalid MAP record: ${JSON.stringify(tx, null, 2).substring(0, 100)}`);\n  }\n\n  let mapObj = {} as MAPType;\n\n  // parse the protocol separator\n  const commands: any[] = [];\n  let commandSeparator = 0;\n  for (let i = 1; i < cell.length; i++) {\n    if (cell[i].s === \":::\") {\n      commandSeparator++;\n    } else {\n      if (!commands[commandSeparator]) commands[commandSeparator] = [];\n      cell[i].i = commands[commandSeparator].length + 1;\n      commands[commandSeparator].push(cell[i]);\n    }\n  }\n\n  // Get the MAP command key name from the query schema\n  const mapCmdKey = Object.keys(opReturnSchema[0])[0];\n\n  // Add the firt MAP command in the response object\n  mapObj[mapCmdKey] = commands[0][0].s;\n\n  for (const cc of commands) {\n    // re-add the MAP address\n    cc.unshift({\n      s: address,\n      i: 0,\n    });\n\n    const command = cc[1].s;\n    // Individual parsing rules for each MAP command\n    switch (command) {\n      // Also check for SELECT commands and strip off the <SELECT> <TXID> part and run it through\n      case \"ADD\": {\n        processADD(cc, mapObj);\n        break;\n      }\n      case \"REMOVE\": {\n        mapObj.key = cc[2].s;\n        break;\n      }\n      case \"DELETE\": {\n        proccessDELETE(cc, mapObj);\n        break;\n      }\n      case \"CLEAR\": {\n        // TODO\n        // console.log('MAP CLEAR');\n        break;\n      }\n      case \"SELECT\": {\n        processSELECT(cc, mapObj);\n        break;\n      }\n      case \"MSGPACK\": {\n        mapObj = processMSGPACK(cc, mapObj);\n        break;\n      }\n      case \"JSON\": {\n        mapObj = processJSON(cc, mapObj);\n        break;\n      }\n      case \"SET\": {\n        processSET(cc, mapObj);\n        break;\n      }\n      default: {\n        // don't know what to do ...\n      }\n    }\n  }\n\n  saveProtocolData(dataObj, \"MAP\", mapObj);\n};\n\nexport const MAP: Protocol = {\n  name: \"MAP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { Hash, Utils } from \"@bsv/sdk\";\nimport type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\n\nconst { toArray, toHex } = Utils;\n\nconst address = \"meta\";\n\nconst opReturnSchema: SchemaField[] = [\n  { address: \"string\" },\n  { parent: \"string\" },\n  { name: \"string\" },\n];\n\nexport const getEnvSafeMetanetID = async (a: string, tx: string) => {\n  // Calculate the node ID\n  const buf = Buffer.from(a + tx);\n  const hashBuf = Hash.sha256(toArray(buf));\n  return toHex(hashBuf);\n};\n\nconst handler = async ({ dataObj, cell, tx }: HandlerProps) => {\n  if (\n    !cell.length ||\n    cell[0].s !== \"meta\" ||\n    !cell[1] ||\n    !cell[1].s ||\n    !cell[2] ||\n    !cell[2].s ||\n    !tx\n  ) {\n    throw new Error(`Invalid Metanet tx ${tx}`);\n  }\n  // For now, we just copy from MOM keys later if available, or keep BOB format\n\n  const nodeId = await getEnvSafeMetanetID(cell[1].s, tx.tx.h);\n  // Described this node\n  const node = {\n    a: cell[1].s,\n    tx: tx.tx.h,\n    id: nodeId,\n  };\n  let parent = {\n    a: \"\",\n    tx: \"\",\n    id: \"\",\n  };\n  if (tx.in) {\n    const parentId = await getEnvSafeMetanetID(tx.in[0].e.a, cell[2].s);\n    // Parent node\n    parent = {\n      a: tx.in[0].e.a,\n      tx: cell[2].s,\n      id: parentId,\n    };\n  }\n\n  if (!dataObj.METANET) {\n    dataObj.METANET = [];\n  }\n  dataObj.METANET.push({\n    node,\n    parent,\n  });\n};\n\nexport const METANET: Protocol = {\n  name: \"METANET\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { ORD as OrdType } from \"../types/protocols/ord\";\n\nconst scriptChecker = (cell: Cell[]) => {\n  if (cell.length < 13) {\n    // wrong length\n    return false;\n  }\n\n  // Find OP_IF wrapper\n  const startIdx = findIndex(cell, (c: Cell) => c.ops === \"OP_IF\");\n  const endIdx = findIndex(cell, (c: Cell, i: number) => i > startIdx && c.ops === \"OP_ENDIF\");\n  const ordScript = cell.slice(startIdx, endIdx);\n  const prevCell = cell[startIdx - 1];\n  return prevCell?.op === 0 && !!ordScript[0] && !!ordScript[1] && ordScript[1].s === \"ord\";\n};\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n  if (!cell[0] || !out) {\n    throw new Error(\"Invalid Ord tx. dataObj, cell, out and tx are required.\");\n  }\n\n  // Find OP_IF wrapper\n  const startIdx = findIndex(cell, (c: Cell) => c.ops === \"OP_IF\");\n  const endIdx = findIndex(cell, (c: Cell, i: number) => i > startIdx && c.ops === \"OP_ENDIF\") + 1;\n  const ordScript = cell.slice(startIdx, endIdx);\n\n  if (!ordScript[0] || !ordScript[1] || ordScript[1].s !== \"ord\") {\n    throw new Error(\"Invalid Ord tx. Prefix not found.\");\n  }\n\n  let data: string | undefined;\n  let contentType: string | undefined;\n  ordScript.forEach((push, idx, all) => {\n    // content-type\n    if (push.ops === \"OP_1\") {\n      contentType = all[idx + 1].s;\n    }\n    // data\n    if (push.ops === \"OP_0\") {\n      data = all[idx + 1].b;\n    }\n  });\n\n  if (!data) {\n    throw new Error(\"Invalid Ord data.\");\n  }\n  if (!contentType) {\n    throw new Error(\"Invalid Ord content type.\");\n  }\n\n  const OrdObj: OrdType = {\n    data,\n    contentType,\n  };\n\n  if (!dataObj.ORD) {\n    dataObj.ORD = [];\n  }\n  dataObj.ORD.push(OrdObj);\n};\n\nexport const ORD: Protocol = {\n  name: \"ORD\",\n  handler,\n  scriptChecker,\n};\n\nfunction findIndex<T>(\n  array: T[],\n  predicate: (value: T, index: number, array: T[]) => boolean\n): number {\n  return findLastIndex(array, predicate);\n}\n\nfunction findLastIndex<T>(\n  array: T[],\n  predicate: (value: T, index: number, array: T[]) => boolean,\n  fromIndex?: number\n): number {\n  const length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  let index = length - 1;\n  if (fromIndex !== undefined) {\n    index = fromIndex;\n    index = fromIndex < 0 ? Math.max(length + index, 0) : Math.min(index, length - 1);\n  }\n  return baseFindIndex(array, predicate, index, true);\n}\n\nfunction baseFindIndex<T>(\n  array: T[],\n  predicate: (value: T, index: number, array: T[]) => boolean,\n  fromIndex: number,\n  fromRight: boolean\n): number {\n  const { length } = array;\n  let index = fromIndex + (fromRight ? 1 : -1);\n\n  while (fromRight ? index-- : ++index < length) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n","import type { HandlerProps, Protocol, SchemaField } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1GvFYzwtFix3qSAZhESQVTz9DeudHZNoh1\";\n\nconst opReturnSchema: SchemaField[] = [\n  { pair: \"json\" },\n  { address: \"string\" },\n  { timestamp: \"string\" },\n];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (\n    cell[0].s !== address ||\n    !cell[1] ||\n    !cell[2] ||\n    !cell[3] ||\n    !cell[1].s ||\n    !cell[2].s ||\n    !cell[3].s\n  ) {\n    throw new Error(`Invalid RON record ${tx?.tx.h}`);\n  }\n\n  const pair = JSON.parse(cell[1].s);\n  const timestamp = Number(cell[3].s);\n\n  saveProtocolData(dataObj, \"RON\", {\n    pair,\n    address: cell[2].s,\n    timestamp,\n  });\n};\n\nexport const RON: Protocol = {\n  name: \"RON\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1SymRe7erxM46GByucUWnB9fEEMgo7spd\";\n\nconst opReturnSchema = [{ url: \"string\" }];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (cell[0].s !== address || !cell[1] || !cell[1].s) {\n    throw new Error(`Invalid SymRe tx: ${tx}`);\n  }\n\n  saveProtocolData(dataObj, \"SYMRE\", { url: cell[1].s });\n};\n\nexport const SYMRE = {\n  name: \"SYMRE\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { type In, type Out, type Tape, parse } from \"bpu-ts\";\nimport { _21E8 } from \"./protocols/_21e8\";\nimport { AIP } from \"./protocols/aip\";\nimport { B } from \"./protocols/b\";\nimport { BAP } from \"./protocols/bap\";\nimport { BITCOM } from \"./protocols/bitcom\";\nimport { BITKEY } from \"./protocols/bitkey\";\nimport { BITPIC } from \"./protocols/bitpic\";\nimport { HAIP } from \"./protocols/haip\";\nimport { MAP } from \"./protocols/map\";\nimport { METANET } from \"./protocols/metanet\";\nimport { ORD } from \"./protocols/ord\";\nimport { RON } from \"./protocols/ron\";\nimport { SYMRE } from \"./protocols/symre\";\nimport type {\n  BmapTx,\n  BobTx,\n  Handler,\n  HandlerProps,\n  MetaNet,\n  MomTx,\n  Protocol,\n  SchemaField,\n  ScriptChecker,\n} from \"./types/common\";\nimport {\n  checkOpFalseOpReturn,\n  checkOpReturn,\n  isObjectArray,\n  isStringArray,\n  saveProtocolData,\n} from \"./utils\";\n\n// Names of enabled protocols\nconst enabledProtocols = new Map<string, string>([]);\n// Protocol Handlers\nconst protocolHandlers = new Map<string, Handler>([]);\n// Script checkers are intentionally minimalistic detection functions for identifying matching scripts for a given protocol. Only if a checker returns true is a handler called for processing.\nconst protocolScriptCheckers = new Map<string, ScriptChecker>([]);\nconst protocolOpReturnSchemas = new Map<string, SchemaField[]>();\n\nexport const allProtocols: Protocol[] = [\n  AIP,\n  B,\n  BAP,\n  MAP,\n  METANET,\n  _21E8,\n  BITCOM,\n  BITKEY,\n  BITPIC,\n  HAIP,\n  RON,\n  SYMRE,\n  ORD,\n];\n\nexport const supportedProtocols = allProtocols.map((p) => p.name);\nexport const defaultProtocols = [AIP, B, BAP, MAP, METANET, ORD];\n\n// prepare protocol map, handlers and schemas\nfor (const protocol of defaultProtocols) {\n  if (protocol.address) {\n    enabledProtocols.set(protocol.address, protocol.name);\n  }\n  protocolHandlers.set(protocol.name, protocol.handler);\n  if (protocol.opReturnSchema) {\n    protocolOpReturnSchemas.set(protocol.name, protocol.opReturnSchema);\n  }\n  if (protocol.scriptChecker) {\n    protocolScriptCheckers.set(protocol.name, protocol.scriptChecker);\n  }\n}\n\n// Takes a BOB formatted op_return transaction\nexport class BMAP {\n  enabledProtocols: Map<string, string>;\n  protocolHandlers: Map<string, Handler>;\n  protocolScriptCheckers: Map<string, ScriptChecker>;\n  protocolOpReturnSchemas: Map<string, SchemaField[]>;\n\n  constructor() {\n    // initial default protocol handlers in this instantiation\n    this.enabledProtocols = enabledProtocols;\n    this.protocolHandlers = protocolHandlers;\n    this.protocolScriptCheckers = protocolScriptCheckers;\n    this.protocolOpReturnSchemas = protocolOpReturnSchemas;\n  }\n\n  addProtocolHandler({ name, address, opReturnSchema, handler, scriptChecker }: Protocol) {\n    if (address) {\n      this.enabledProtocols.set(address, name);\n    }\n    this.protocolHandlers.set(name, handler);\n    if (opReturnSchema) {\n      this.protocolOpReturnSchemas.set(name, opReturnSchema);\n    }\n    if (scriptChecker) {\n      this.protocolScriptCheckers.set(name, scriptChecker);\n    }\n  }\n\n  transformTx = async (tx: BobTx | MomTx): Promise<BmapTx> => {\n    if (!tx || !tx.in || !tx.out) {\n      throw new Error(\"Cannot process tx\");\n    }\n\n    // This will become our nicely formatted response object\n    let dataObj: Partial<BobTx> = {\n      // Initialize blk with default values\n      blk: {\n        i: tx.blk?.i ?? 0,\n        t: tx.blk?.t ?? 0,\n        h: tx.blk?.h ?? \"\"\n      }\n    };\n\n    for (const [key, val] of Object.entries(tx)) {\n      if (key === \"out\") {\n        // loop over the outputs\n        for (const out of tx.out) {\n          const { tape } = out;\n\n          // Process opReturn data\n          if (tape?.some((cc) => checkOpReturn(cc))) {\n            dataObj = await this.processDataProtocols(tape, out, tx, dataObj);\n          }\n\n          // No OP_FALSE OP_RETURN in this tape\n          const _21e8Checker = this.protocolScriptCheckers.get(_21E8.name);\n          const ordChecker = this.protocolScriptCheckers.get(ORD.name);\n\n          // Check for 21e8 and ords\n          if (\n            tape?.some((cc) => {\n              const { cell } = cc;\n              if (_21e8Checker?.(cell)) {\n                // 'found 21e8'\n                return true;\n              }\n              if (ordChecker?.(cell)) {\n                // 'found 1sat ordinal'\n                return true;\n              }\n            })\n          ) {\n            // find the cell array\n            // loop over tape\n            for (const cellContainer of tape) {\n              const { cell } = cellContainer;\n              // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n              if (!cell) {\n                throw new Error(\"empty cell while parsing\");\n              }\n              let protocolName = \"\";\n              if (_21e8Checker?.(cell)) {\n                protocolName = _21E8.name;\n              } else if (ordChecker?.(cell)) {\n                protocolName = ORD.name;\n              } else {\n                // nothing found\n                continue;\n              }\n\n              this.process(protocolName, {\n                tx,\n                cell,\n                dataObj: dataObj as BmapTx,\n                tape,\n                out,\n              });\n            }\n          }\n        }\n      } else if (key === \"in\") {\n        dataObj[key] = val.map((v: In) => {\n          const r = { ...v } as any;\n          r.tape = undefined;\n          return r as In;\n        });\n      } else {\n        // known key, just write it retaining original type\n        dataObj[key] = val;\n      }\n    }\n\n    // If this is a MOM planaria it will have metanet keys available\n    if (dataObj.METANET && (tx as MomTx).parent) {\n      const meta = {\n        ancestor: (tx as MomTx).ancestor,\n        parent: (tx as MomTx).parent,\n        child: (tx as MomTx).child,\n        head: (tx as MomTx).head,\n      } as MetaNet;\n      (dataObj.METANET as MetaNet[]).push(meta);\n      // remove parent and node from root level for (MOM data)\n      dataObj.ancestor = undefined;\n      dataObj.child = undefined;\n      dataObj.parent = undefined;\n      dataObj.head = undefined;\n      dataObj.node = undefined;\n    }\n\n    return dataObj as BmapTx;\n  };\n\n  processUnknown = (key: string, dataObj: Partial<BmapTx>, out: Out) => {\n    // no known non-OP_RETURN scripts\n    if (key && !dataObj[`_${key}`]) {\n      dataObj[`_${key}`] = [];\n    }\n    (dataObj[`_${key}`] as Out[]).push({\n      i: out.i,\n      e: out.e,\n      tape: [],\n    });\n  };\n\n  process = async (protocolName: string, { cell, dataObj, tape, out, tx }: HandlerProps) => {\n    if (\n      this.protocolHandlers.has(protocolName) &&\n      typeof this.protocolHandlers.get(protocolName) === \"function\"\n    ) {\n      const handler = this.protocolHandlers.get(protocolName);\n      if (handler) {\n        await handler({\n          dataObj,\n          cell,\n          tape,\n          out,\n          tx,\n        });\n      }\n    } else {\n      saveProtocolData(dataObj, protocolName, cell);\n    }\n  };\n\n  processDataProtocols = async (\n    tape: Tape[],\n    out: Out,\n    tx: BobTx,\n    dataObj: Partial<BobTx>\n  ): Promise<Partial<BobTx>> => {\n    // loop over tape\n    for (const cellContainer of tape) {\n      const { cell } = cellContainer;\n      if (!cell) {\n        throw new Error(\"empty cell while parsing\");\n      }\n\n      // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n      if (checkOpFalseOpReturn(cellContainer)) {\n        continue;\n      }\n\n      const prefix = cell[0].s;\n\n      if (prefix) {\n        const protocolName = this.enabledProtocols.get(prefix);\n        if (protocolName) {\n          await this.process(protocolName, {\n            cell,\n            dataObj: dataObj as BmapTx,\n            tape,\n            out,\n            tx,\n          });\n        } else {\n          this.processUnknown(prefix, dataObj, out);\n        }\n      }\n    }\n    return dataObj;\n  };\n}\n\nexport const fetchRawTx = async (txid: string): Promise<string> => {\n  const url = `https://api.whatsonchain.com/v1/bsv/main/tx/${txid}/hex`;\n  console.log(\"hitting\", url);\n  const res = await fetch(url);\n  return await res.text();\n};\n\nexport const bobFromRawTx = async (rawTx: string): Promise<BobTx> => {\n  const bpuTx = await parse({\n    tx: { r: rawTx },\n    split: [\n      {\n        token: { op: 106 },\n        include: \"l\",\n      },\n      {\n        token: { s: \"|\" },\n      },\n    ],\n  });\n  return bpuTx as BobTx;\n};\n\n// TransformTx\n// tx - a raw hex string or a Bob/Bmap/Mom transaction object\n// protocols - the handlers you want to load and use to process the tx\n// reducing the number of supported protocols may improve transform speed\n// at the expense of detecting more data protocols\nexport const TransformTx = async (\n  tx: BobTx | string | MomTx | BmapTx,\n  protocols?: string[] | Protocol[]\n) => {\n  if (typeof tx === \"string\") {\n    let rawTx: string | undefined;\n    // if it a txid or  complete transaction hex?\n    if (tx.length === 64) {\n      // txid - fetch raw tx\n      rawTx = await fetchRawTx(tx);\n    }\n\n    if (Buffer.from(tx).byteLength <= 146) {\n      throw new Error(\"Invalid rawTx\");\n    }\n\n    if (!rawTx) {\n      rawTx = tx;\n    }\n\n    // TODO: Double check 146 is intended to be minimum possible byte length for a tx\n    const bobTx = await bobFromRawTx(rawTx);\n\n    if (bobTx) {\n      tx = bobTx;\n    } else {\n      throw new Error(\"Invalid txid\");\n    }\n  }\n\n  const b = new BMAP();\n\n  // if protocols are specified\n  if (protocols) {\n    // wipe out defaults\n    b.enabledProtocols.clear();\n    if (isStringArray(protocols)) {\n      // set enabled protocols\n      for (const protocol of allProtocols) {\n        if ((protocols as string[])?.includes(protocol.name)) {\n          b.addProtocolHandler(protocol);\n        }\n      }\n    } else if (isObjectArray(protocols)) {\n      for (const p of protocols) {\n        const protocol = p as Protocol;\n        if (protocol) {\n          b.addProtocolHandler(protocol);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Invalid protocol array. Must be either an array of protocol names (string[]), or Protocol objects (Protocol[]).\"\n      );\n    }\n  }\n\n  return b.transformTx(tx);\n};\n\n// Export types\nexport type {\n  BmapTx,\n  BobTx,\n  Handler,\n  HandlerProps,\n  MomTx,\n  Protocol,\n  ScriptChecker,\n} from \"./types/common\";\n\n// Export all protocol types\nexport type { _21E8 } from \"./types/protocols/_21e8\";\nexport type { AIP } from \"./types/protocols/aip\";\nexport type { B } from \"./types/protocols/b\";\nexport type { BAP } from \"./types/protocols/bap\";\nexport type { BITCOM } from \"./types/protocols/bitcom\";\nexport type { BITKEY } from \"./types/protocols/bitkey\";\nexport type { BITPIC } from \"./types/protocols/bitpic\";\nexport type { HAIP } from \"./types/protocols/haip\";\nexport type { MAP } from \"./types/protocols/map\";\nexport type { ORD } from \"./types/protocols/ord\";\nexport type { RON } from \"./types/protocols/ron\";\nexport type { SYMRE } from \"./types/protocols/symre\";\n"],"names":["toArray","Utils","isStringArray","arr","value","isObjectArray","cellValue","pushData","schemaEncoding","checkOpReturn","cc","c","checkOpFalseOpReturn","opReturnIdx","_a","saveProtocolData","dataObj","protocolName","data","prevData","bmapOpReturnSchemaHandler","opReturnSchema","cell","tx","obj","length","idx","schemaField","x","field","isBase64","regex","shallowEqualArrays","arr1","arr2","index","_21e8Script","scriptChecker","ops","target","targetOpSize","handler","out","txid","difficulty","_21e8Obj","_21E8","toHex","fromBase58Check","toBase58Check","address","validateSignature","aipObj","tape","cellIndex","t","_b","_c","usingIndexes","signatureValues","allCells","a","b","firstCell","cellsByIndex","targetCell","tapeCells","indexLength","indexes","i","v","messageBuffer","dataScript","Script","dataArray","Hash","addressString","signature","Signature","e","tryNormalLogic","msgHash","BSM","bigMsg","toBigNumberFromBuffer","recovery","publicKey","pubKeyHash","prefix","tryTwetchLogic","trimmed","buff","hexStr","twetchMsg","verified","buffer","hex","BigNumber","SIGPROTO","AIPhandler","useOpReturnSchema","protocol","aipField","fieldData","AIP","encodingMap","bObj","bField","encoding","B","BAP","protocolAddress","bitcomObj","BITCOM","magicHash","toBigNumber","recoverPublicKeyFromBSM","message","bitkeyObj","bitkeyField","pubkeyHex","userPubKeyHash","PublicKey","userAddress","concatenated","concatenatedBuffer","bitkeyMessage","bitkeySignature","recoveredBitkeyPubkey","recoveredBitkeyPubKeyHash","recoveredBitkeyAddress","bitkeySignatureVerified","userMessage","userSignature","recoveredUserPubkey","recoveredUserPubKeyHash","recoveredUserAddress","userSignatureVerified","BITKEY","bitpicObj","bin","hashBuff","sig","pubkey","BITPIC","HAIP","processADD","mapObj","last","pushdataContainer","pushdata","proccessDELETE","processSELECT","processMSGPACK","decode","processJSON","processSET","commands","commandSeparator","mapCmdKey","MAP","getEnvSafeMetanetID","buf","hashBuf","nodeId","node","parent","parentId","METANET","startIdx","findIndex","endIdx","ordScript","prevCell","contentType","push","all","OrdObj","ORD","array","predicate","findLastIndex","fromIndex","baseFindIndex","fromRight","pair","timestamp","RON","SYMRE","enabledProtocols","protocolHandlers","protocolScriptCheckers","protocolOpReturnSchemas","allProtocols","supportedProtocols","p","defaultProtocols","BMAP","name","key","val","_21e8Checker","ordChecker","cellContainer","r","meta","fetchRawTx","url","bobFromRawTx","rawTx","parse","TransformTx","protocols","bobTx"],"mappings":"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"}