{"version":3,"file":"bmap.es.js","sources":["../src/utils.ts","../src/protocols/_21e8.ts","../src/protocols/aip.ts","../src/protocols/b.ts","../src/protocols/bap.ts","../src/protocols/bitcom.ts","../src/protocols/bitkey.ts","../src/protocols/bitpic.ts","../src/protocols/haip.ts","../src/protocols/map.ts","../src/protocols/metanet.ts","../src/protocols/ord.ts","../src/protocols/ron.ts","../src/protocols/symre.ts","../src/bmap.ts"],"sourcesContent":["\nimport { Hash, Utils } from '@bsv/sdk';\nimport type { Cell, Tape } from 'bpu-ts';\nimport type { BobTx } from './types/common';\nconst { toArray } = Utils;\n\nexport const isStringArray = (arr: Array<any>): boolean => {\n  return (\n    arr.length > 0 &&\n    arr.every((value) => {\n      return typeof value === 'string'\n    })\n  )\n}\nexport const isObjectArray = (arr: Array<any>): boolean => {\n  return (\n    arr.length > 0 &&\n    arr.every((value) => {\n      return value === 'object'\n    })\n  )\n}\n/**\n * returns the BOB cell value for a given encoding\n *\n * @param pushData\n * @param schemaEncoding\n * @returns {string|number}\n */\nexport const cellValue = (\n  pushData: Cell,\n  schemaEncoding?: string\n): string | number => {\n  if (!pushData) {\n    throw new Error(`cannot get cell value of: ${pushData}`)\n  } else if (schemaEncoding === 'string') {\n    return pushData['s'] ? pushData.s : pushData.ls || ''\n  } else if (schemaEncoding === 'hex') {\n    return pushData['h']\n      ? pushData.h\n      : pushData.lh ||\n      (pushData['b']\n        ? Buffer.from(pushData.b, 'base64').toString('hex')\n        : pushData.lb &&\n        Buffer.from(pushData.lb, 'base64').toString('hex')) ||\n      ''\n  } else if (schemaEncoding === 'number') {\n    return parseInt(pushData['h'] ? pushData.h : pushData.lh || '0', 16)\n  } else if (schemaEncoding === 'file') {\n    return `bitfs://${pushData['f'] ? pushData.f : pushData.lf}`\n  }\n\n  return (pushData['b'] ? pushData.b : pushData.lb) || ''\n}\n\n/**\n * Check if cells end with OP_RETURN\n */\nexport const checkOpReturn = (cc: Tape): boolean => {\n  return cc.cell.some((c: Cell) => c.op === 106)\n}\n\n/**\n * Check if cells end with OP_FALSE + OP_RETURN\n */\nexport const checkOpFalseOpReturn = (cc: Tape): boolean => {\n  if (cc.cell.length !== 2) {\n    return false\n  }\n  const opReturnIdx = cc.cell.findIndex((c) => c.op === 106)\n  if (opReturnIdx !== -1) {\n    return cc.cell[opReturnIdx - 1]?.op === 0\n  }\n  return false\n}\n\n/**\n * Helper function to store protocol data\n *\n * @param dataObj\n * @param protocolName\n * @param data\n */\nexport const saveProtocolData = (\n  dataObj: { [key: string]: any },\n  protocolName: string,\n  data: any\n) => {\n  if (!dataObj[protocolName]) {\n    dataObj[protocolName] = [data]\n  } else {\n    dataObj[protocolName].push(data)\n  }\n}\n\n/**\n * BMAP default handler to work with query schema's\n *\n * @param opReturnSchema\n * @param protocolName\n * @param dataObj\n * @param cell\n * @param tape\n * @param tx\n */\nexport const bmapOpReturnSchemaHandler = (\n  protocolName: string,\n  opReturnSchema: Object[],\n  dataObj: Object,\n  cell: Cell[],\n  tx: BobTx\n) => {\n  // loop over the schema\n  const obj: { [key: string]: any } = {}\n\n  // Does not have the required number of fields\n  const length = opReturnSchema.length + 1\n  if (cell.length < length) {\n    throw new Error(\n      `${protocolName} requires at least ${length} fields including the prefix: ${tx.tx.h}`\n    )\n  }\n\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10)\n\n    const [field] = Object.keys(schemaField)\n    const [schemaEncoding] = Object.values(schemaField)\n    obj[field] = cellValue(cell[x + 1], schemaEncoding)\n  }\n\n  saveProtocolData(dataObj, protocolName, obj)\n}\n\n/**\n * Check whether the given data is base64\n *\n * @param data\n * @returns {boolean}\n */\nexport const isBase64 = (data: string) => {\n  const regex =\n    '(?:[A-Za-z0-9+\\\\/]{4})*(?:[A-Za-z0-9+\\\\/]{2}==|[A-Za-z0-9+/]{3}=)?'\n  return new RegExp(`^${regex}$`, 'gi').test(data)\n}\n\n// hashes a message buffer, returns the hash as a buffer\nexport const sha256 = (msgBuffer: number[]) => {\n  return Hash.sha256(toArray(msgBuffer))\n}\n","import type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { _21E8 as _21E8Type } from \"../types/protocols/_21e8\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\n// 21e8 does not use the first pushdata for id\n// in fact there is no id since the 21e8 is designed for difficulty and can be changed\n// instead we use the static part of the script to indentfy the transaction\n// TODO - the OP_X_PLACEHOLDER is the number of bytes to push onto the stack and must match difficulty size\nconst _21e8Script =\n  \"OP_SIZE <OP_X_PLACEHOLDER> OP_PICK OP_SHA256 OP_SWAP OP_SPLIT OP_DROP OP_EQUALVERIFY OP_DROP OP_CHECKSIG\".split(\n    \" \",\n  );\n\nconst scriptChecker = (cell: Cell[]) => {\n  if (cell.length !== 12) {\n    // wrong length\n    return false;\n  }\n\n  // match exact script\n  const ops = [...cell].map((c) => c.ops).splice(2, cell.length);\n\n  // calculate target byte length\n  const target = cellValue(cell[1], \"hex\") as string;\n  const targetOpSize = Buffer.from(target).byteLength;\n\n  // replace the placeholder opcode with actual\n  ops[1] = `OP_${targetOpSize}`;\n  _21e8Script[1] = `OP_${targetOpSize}`;\n\n  // protocol identifier always in first pushdata\n  return ops.join() === _21e8Script.join();\n};\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n  if (!cell[0] || !out) {\n    throw new Error(\"Invalid 21e8 tx. dataObj, cell, out and tx are required.\");\n  }\n\n  // assemble asm\n  // make sure first piece matches a txid\n  // 2nd piece matches any difficulty. set some resonable limit in bytes if there isnt one documented somewhere\n  // next\n\n  const txid = cellValue(cell[0], \"hex\") as string;\n  const target = cellValue(cell[1], \"hex\") as string;\n  if (!target) {\n    throw new Error(`Invalid 21e8 target. ${JSON.stringify(cell[0], null, 2)}`);\n  }\n  const difficulty = Buffer.from(target, \"hex\").byteLength;\n\n  const _21e8Obj: _21E8Type = {\n    target,\n    difficulty,\n    value: out.e.v,\n    txid,\n  };\n\n  saveProtocolData(dataObj, \"21E8\", _21e8Obj);\n};\n\nexport const _21E8: Protocol = {\n  name: \"21E8\",\n  handler,\n  scriptChecker,\n};\n","\nimport { BSM, BigNumber, Hash, type PublicKey, Script, Signature, Utils } from \"@bsv/sdk\";\nimport type { Cell, Tape } from \"bpu-ts\";\nimport fetch from \"node-fetch\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { AIP as AIPType } from \"../types/protocols/aip\";\nimport type { HAIP as HAIPType } from \"../types/protocols/haip\";\nimport { cellValue, checkOpFalseOpReturn, isBase64, saveProtocolData } from \"../utils\";\n\nconst { toArray, toHex, fromBase58Check, toBase58Check } = Utils;\n\nconst address = \"15PciHG22SNLQJXMoSUaWVi7WSqc7hCfva\";\nconst opReturnSchema = [\n  { algorithm: \"string\" },\n  { address: \"string\" },\n  { signature: \"binary\" },\n  [{ index: \"binary\" }],\n];\n\nconst getFileBuffer = async (bitfsRef: string) => {\n  try {\n    const result = await fetch(`https://x.bitfs.network/${bitfsRef}`);\n    return await result.buffer();\n  } catch {\n    return Buffer.from(\"\");\n  }\n};\n\nfunction toBigNumberFromBuffer(buffer: number[]): BigNumber {\n  const hex = toHex(buffer);\n  return new BigNumber(hex, 16);\n}\n\nfunction recoverPublicKeyFromBSM(message: number[], signature: Signature, expectedAddress: string): PublicKey {\n  const msgHash = BSM.magicHash(message);\n  const bigMsg = toBigNumberFromBuffer(msgHash);\n\n  for (let recovery = 0; recovery < 4; recovery++) {\n    try {\n      const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n      const pubKeyHash = publicKey.toHash() as number[];\n      const { prefix } = fromBase58Check(expectedAddress);\n      const recoveredAddress = toBase58Check(pubKeyHash, prefix as number[]);\n      if (recoveredAddress === expectedAddress) {\n        console.log(\"[recoverPublicKeyFromBSM] Successfully recovered matching public key\");\n        return publicKey;\n      } else {\n        console.log(\"[recoverPublicKeyFromBSM] Trying recovery=\", recovery, \"Recovered address=\", recoveredAddress, \"expected=\", expectedAddress);\n      }\n    } catch (e) {\n      console.log(\"[recoverPublicKeyFromBSM] Recovery error:\", e);\n    }\n  }\n\n  console.log(\"[recoverPublicKeyFromBSM] Failed to recover any matching address\");\n  throw new Error(\"Failed to recover public key matching the expected address\");\n}\n\nfunction fromSafeDataArray(dataBufs: Buffer[]): Script {\n  const script = new Script();\n  script.chunks.push({ op: 0 }); // OP_FALSE\n  script.chunks.push({ op: 106 }); // OP_RETURN\n  for (const buf of dataBufs) {\n    const length = buf.length;\n    if (length <= 75) {\n      script.chunks.push({ op: length, data: Array.from(buf) });\n    } else if (length <= 0xff) {\n      script.chunks.push({ op: 0x4c, data: Array.from(buf) });\n    } else if (length <= 0xffff) {\n      script.chunks.push({ op: 0x4d, data: Array.from(buf) });\n    } else {\n      script.chunks.push({ op: 0x4e, data: Array.from(buf) });\n    }\n  }\n  return script;\n}\n\nasync function validateSignature(\n  aipObj: Partial<AIPType | HAIPType>,\n  cell: Cell[],\n  tape: Tape[]\n): Promise<boolean> {\n  if (!Array.isArray(tape) || tape.length < 3) {\n    throw new Error(\"AIP requires at least 3 cells including the prefix\");\n  }\n\n  let cellIndex = -1;\n  tape.forEach((cc, index) => {\n    if (cc.cell === cell) {\n      cellIndex = index;\n    }\n  });\n  if (cellIndex === -1) {\n    throw new Error(\"AIP could not find cell in tape\");\n  }\n\n  let usingIndexes: number[] = (aipObj.index as number[]) || [];\n  const signatureValues: string[] = [\"6a\"]; // index 0: OP_RETURN\n\n  // Gather data from all previous cells\n  for (let i = 0; i < cellIndex; i++) {\n    const cellContainer = tape[i];\n    if (!checkOpFalseOpReturn(cellContainer)) {\n      const cellData: string[] = [];\n      for (const statement of cellContainer.cell) {\n        let value: string | undefined;\n        if (statement.h) {\n          value = statement.h;\n        } else if (statement.f) {\n          const fileBuffer = await getFileBuffer(statement.f);\n          value = fileBuffer.length > 0 ? fileBuffer.toString(\"hex\") : undefined;\n        } else if (statement.b) {\n          const buf = Buffer.from(statement.b, \"base64\");\n          if (buf.length > 0) {\n            value = buf.toString(\"hex\");\n          }\n        } else if (statement.s) {\n          if (statement.s.length > 0) {\n            value = Buffer.from(statement.s).toString(\"hex\");\n          }\n        }\n\n        if (value && value.length > 0) {\n          cellData.push(value);\n        }\n      }\n      if (cellData.length > 0) {\n        // add all cellData\n        signatureValues.push(...cellData);\n        // add pipe after this cell\n        signatureValues.push(\"7c\");\n      }\n    }\n  }\n\n  // Now HAIP indexing logic\n  if (aipObj.hashing_algorithm && aipObj.index_unit_size) {\n    const indexLength = aipObj.index_unit_size * 2;\n    usingIndexes = [];\n    const indexesHex = cell[6]?.h || \"\";\n    for (let i = 0; i < indexesHex.length; i += indexLength) {\n      usingIndexes.push(Number.parseInt(indexesHex.substr(i, indexLength), 16));\n    }\n    aipObj.index = usingIndexes;\n  }\n\n  console.log(\"usingIndexes\", usingIndexes);\n  console.log(\"signatureValues\", signatureValues);\n\n  const signatureBufferStatements: Buffer[] = [];\n  if (usingIndexes.length > 0) {\n    for (const idx of usingIndexes) {\n      if (typeof signatureValues[idx] !== 'string') {\n        console.log(\"signatureValues[idx]\", signatureValues[idx], \"idx\", idx);\n      }\n      if (!signatureValues[idx]) {\n        console.log(\"signatureValues is missing an index\", idx, \"This means indexing is off\");\n        return false;\n      }\n      signatureBufferStatements.push(Buffer.from(signatureValues[idx], \"hex\"));\n    }\n  } else {\n    for (const val of signatureValues) {\n      signatureBufferStatements.push(Buffer.from(val, \"hex\"));\n    }\n  }\n\n  console.log(\"signatureBufferStatements\", signatureBufferStatements.map((b) => b.toString(\"hex\")));\n\n  let messageBuffer: Buffer;\n  if (aipObj.hashing_algorithm) {\n    // HAIP logic\n    if (!aipObj.index_unit_size) {\n      // remove OP_RETURN chunk\n      signatureBufferStatements.shift();\n    }\n    const dataScript = fromSafeDataArray(signatureBufferStatements);\n    let dataBuffer = Buffer.from(dataScript.toHex(), \"hex\");\n    if (aipObj.index_unit_size) {\n      dataBuffer = dataBuffer.slice(1);\n    }\n    const hashed = Hash.sha256(toArray(dataBuffer));\n    messageBuffer = Buffer.from(hashed);\n  } else {\n    // regular AIP\n    messageBuffer = Buffer.concat(signatureBufferStatements);\n  }\n\n  const addressString = (aipObj as AIPType).address || (aipObj as HAIPType).signing_address;\n  const signatureStr = aipObj.signature as string;\n  const signature = Signature.fromCompact(signatureStr, 'base64');\n\n  const tryNormalLogic = (): boolean => {\n    console.log(\"[validateSignature:tryNormalLogic] start\");\n    try {\n      const msgArr = toArray(messageBuffer);\n      const recoveredPubkey = recoverPublicKeyFromBSM(msgArr, signature, addressString);\n      console.log(\"[tryNormalLogic] recoveredPubkey ok, verifying with BSM.verify now\");\n      const res = BSM.verify(msgArr, signature, recoveredPubkey);\n      console.log(\"[tryNormalLogic] BSM.verify result:\", res);\n      return res;\n    } catch (err) {\n      console.log(\"[tryNormalLogic] error:\", err);\n      return false;\n    }\n  };\n\n  const tryTwetchLogic = (): boolean => {\n    console.log(\"[validateSignature:tryTwetchLogic] start\");\n    // For twetch: remove first and last item and sha256 the remainder, interpret hex as utf8\n    if (signatureBufferStatements.length <= 2) {\n      return false;\n    }\n    const trimmed = signatureBufferStatements.slice(1, -1);\n    console.log(\"[tryTwetchLogic] trimmedStatements count:\", trimmed.length);\n    const buff = Hash.sha256(toArray(Buffer.concat(trimmed)));\n    const hexStr = toHex(buff);\n    const twetchMsg = Buffer.from(hexStr, \"utf8\");\n    try {\n      const recoveredPubkey = recoverPublicKeyFromBSM(toArray(twetchMsg), signature, addressString);\n      console.log(\"[tryTwetchLogic] recoveredPubkey ok, verifying with BSM.verify now\");\n      const res = BSM.verify(toArray(twetchMsg), signature, recoveredPubkey);\n      console.log(\"[tryTwetchLogic] BSM.verify result:\", res);\n      return res;\n    } catch (err) {\n      console.log(\"[tryTwetchLogic] error:\", err);\n      return false;\n    }\n  };\n\n  let verified = tryNormalLogic();\n  if (!verified) {\n    verified = tryTwetchLogic();\n  }\n\n  console.log(\"[validateSignature] final verified=\", verified);\n  (aipObj as AIPType).verified = verified;\n  return verified;\n}\n\nexport enum SIGPROTO {\n  HAIP = \"HAIP\",\n  AIP = \"AIP\",\n}\n\nexport const AIPhandler = async (\n  useOpReturnSchema: any[],\n  protocol: SIGPROTO,\n  dataObj: any,\n  cell: Cell[],\n  tape: Tape[],\n  tx?: any\n) => {\n  const aipObj: { [key: string]: any } = { verified: false };\n\n  // minimal fields check\n  if (cell.length < 4) {\n    throw new Error(\"AIP requires at least 4 fields including the prefix\");\n  }\n\n  for (const [idx, schemaField] of Object.entries(useOpReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n    if (Array.isArray(schemaField)) {\n      const [aipField] = Object.keys(schemaField[0]) as (keyof AIPType)[];\n      const fieldData: number[] = [];\n      for (let i = x + 1; i < cell.length; i++) {\n        if (cell[i].h) {\n          fieldData.push(Number.parseInt(cell[i].h!, 16));\n        }\n      }\n      aipObj[aipField] = fieldData;\n    } else {\n      const [aipField] = Object.keys(schemaField) as (keyof AIPType)[];\n      const [schemaEncoding] = Object.values(schemaField);\n      aipObj[aipField] = cellValue(cell[x + 1], schemaEncoding as string) || \"\";\n    }\n  }\n\n  if (cell[0].s === address && cell[3].s && isBase64(cell[3].s)) {\n    aipObj.signature = cell[3].s;\n  }\n\n  console.log(\"[AIPhandler] AIP object before validate:\", aipObj);\n\n  if (!aipObj.signature) {\n    throw new Error(\"AIP requires a signature\");\n  }\n\n  await validateSignature(aipObj as Partial<AIPType>, cell, tape);\n  console.log(\"[AIPhandler] After validate, verified:\", aipObj.verified);\n\n  saveProtocolData(dataObj, protocol, aipObj);\n};\n\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n  if (!tape) {\n    throw new Error(\"Invalid AIP transaction\");\n  }\n  return await AIPhandler(\n    opReturnSchema,\n    SIGPROTO.AIP,\n    dataObj,\n    cell,\n    tape,\n    tx\n  );\n};\n\nexport const AIP: Protocol = {\n  name: \"AIP\",\n  address,\n  opReturnSchema,\n  handler,\n};","import type { HandlerProps, Protocol } from \"../types/common\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\nconst address = \"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\";\n\nconst opReturnSchema = [\n  { content: [\"string\", \"binary\", \"file\"] },\n  { \"content-type\": \"string\" },\n  { encoding: \"string\" }, // we use this field to determine content character encoding. If encoding is not a valid character encoding (gzip), we assume it is binary\n  { filename: \"string\" },\n];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps): void => {\n  const encodingMap = new Map<string, string>();\n  encodingMap.set(\"utf8\", \"string\");\n  encodingMap.set(\"text\", \"string\"); // invalid but people use it :(\n  encodingMap.set(\"gzip\", \"binary\"); // invalid but people use it :(\n  encodingMap.set(\"text/plain\", \"string\");\n  encodingMap.set(\"image/png\", \"binary\");\n  encodingMap.set(\"image/jpeg\", \"binary\");\n\n  if (!cell[1] || !cell[2]) {\n    throw new Error(`Invalid B tx: ${tx}`);\n  }\n\n  // Check pushdata length + 1 for protocol prefix\n  if (cell.length > opReturnSchema.length + 1) {\n    throw new Error(\"Invalid B tx. Too many fields.\");\n  }\n\n  // Make sure there are not more fields than possible\n\n  const bObj: { [key: string]: string | number | undefined } = {};\n  // loop over the schema\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n    const bField = Object.keys(schemaField)[0];\n    let schemaEncoding = Object.values(schemaField)[0];\n    if (bField === \"content\") {\n      // If the encoding is ommitted, try to infer from content-type instead of breaking\n      if (cell[1].f) {\n        // this is file reference to B files\n        schemaEncoding = \"file\";\n      } else if ((!cell[3] || !cell[3].s) && cell[2].s) {\n        schemaEncoding = encodingMap.get(cell[2].s);\n        if (!schemaEncoding) {\n          console.warn(\"Problem inferring encoding. Malformed B data.\", cell);\n          return;\n        }\n\n        // add the missing encoding field\n        if (!cell[3]) {\n          cell[3] = { h: \"\", b: \"\", s: \"\", i: 0, ii: 0 };\n        }\n        cell[3].s = schemaEncoding === \"string\" ? \"utf-8\" : \"binary\";\n      } else {\n        schemaEncoding = cell[3]?.s\n          ? encodingMap.get(cell[3].s.replace(\"-\", \"\").toLowerCase())\n          : null;\n      }\n    }\n\n    // encoding is not required\n    if (bField === \"encoding\" && !cell[x + 1]) {\n      // encoding omitted\n      continue;\n    }\n\n    // filename is not required\n    if (bField === \"filename\" && !cell[x + 1]) {\n      // filename omitted\n      continue;\n    }\n\n    // check for malformed syntax\n    if (!cell || !cell[x + 1]) {\n      throw new Error(`malformed B syntax ${cell}`);\n    }\n\n    // set field value from either s, b, ls, or lb depending on encoding and availability\n    const data = cell[x + 1];\n    bObj[bField] = cellValue(data, schemaEncoding);\n  }\n\n  saveProtocolData(dataObj, \"B\", bObj);\n};\n\nexport const B: Protocol = {\n  name: \"B\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol } from \"../types/common\";\nimport { bmapOpReturnSchemaHandler } from \"../utils\";\n\nconst address = \"1BAPSuaPnfGnSBM3GLV9yhxUdYe4vGbdMT\";\n\nconst opReturnSchema = [\n  { type: \"string\" },\n  { hash: \"string\" },\n  { sequence: \"string\" },\n];\n\nexport const handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (!tx) {\n    throw new Error(\"Invalid BAP tx, tx required\");\n  }\n  bmapOpReturnSchemaHandler(\"BAP\", opReturnSchema, dataObj, cell, tx);\n};\n\nexport const BAP: Protocol = {\n  name: \"BAP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst protocolAddress = \"$\";\n\nconst opReturnSchema = [\n  {\n    su: [\n      { pubkey: \"string\" },\n      { sign_position: \"string\" },\n      { signature: \"string\" },\n    ],\n    echo: [{ data: \"string\" }, { to: \"string\" }, { filename: \"string\" }],\n    route: [\n      [\n        {\n          add: [\n            { bitcom_address: \"string\" },\n            { route_matcher: \"string\" },\n            { endpoint_template: \"string\" },\n          ],\n        },\n        {\n          enable: [{ path: \"string\" }],\n        },\n      ],\n    ],\n    useradd: [{ address: \"string\" }],\n  },\n];\n\n// const handler = function (dataObj, protocolName, cell, tape, tx) {\nconst handler = ({ dataObj, cell }: HandlerProps) => {\n  if (!cell.length || !cell.every((c) => c.s)) {\n    throw new Error(\"Invalid Bitcom tx\");\n  }\n\n  // gather up the string values\n  const bitcomObj = cell.map((c) => (c?.s ? c.s : \"\"));\n\n  saveProtocolData(dataObj, \"BITCOM\", bitcomObj);\n};\n\nexport const BITCOM: Protocol = {\n  name: \"BITCOM\",\n  address: protocolAddress,\n  opReturnSchema,\n  handler,\n};\n","import { BSM, BigNumber, Hash, PublicKey, Signature, Utils } from \"@bsv/sdk\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport { cellValue, saveProtocolData } from \"../utils\";\n\nconst { toArray, toBase58Check, toHex } = Utils;\nconst { magicHash } = BSM;\n\nconst address = \"13SrNDkVzY5bHBRKNu5iXTQ7K7VqTh5tJC\";\n\nconst opReturnSchema = [\n  { bitkey_signature: \"string\" },\n  { user_signature: \"string\" },\n  { paymail: \"string\" },\n  { pubkey: \"string\" },\n];\n\n// Helper to convert array to BigNumber\nfunction toBigNumber(buffer: number[]): BigNumber {\n  const hex = toHex(buffer);\n  return new BigNumber(hex, 16);\n}\n\n// Recovers a public key from a BSM signature by brute forcing recovery factors\n// Steps:\n// 1. Apply magicHash to the raw message.\n// 2. Try all recovery factors 0â€“3 with Signature.RecoverPublicKey()\n// 3. If BSM.verify() returns true with the recovered pubkey, return it.\nfunction recoverPublicKeyFromBSM(message: number[], signature: Signature): PublicKey {\n  // First, BSM signatures are verified by applying magicHash internally,\n  // so we must apply magicHash to the raw message ourselves for recovery:\n  const msgHash = magicHash(message);\n\n  const bigMsg = toBigNumber(msgHash);\n  for (let recovery = 0; recovery < 4; recovery++) {\n    try {\n      const publicKey = signature.RecoverPublicKey(recovery, bigMsg);\n      // Verify using BSM.verify() with the original raw message (no magicHash)\n      if (BSM.verify(message, signature, publicKey)) {\n        return publicKey;\n      }\n    } catch {\n      // Try next recovery factor\n    }\n  }\n  throw new Error(\"Failed to recover public key from BSM signature\");\n}\n\nconst handler = async ({ dataObj, cell }: HandlerProps) => {\n  if (cell.length < 5) {\n    throw new Error(\"Invalid Bitkey tx\");\n  }\n\n  const bitkeyObj: { [key: string]: string | boolean } = {};\n  for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n    const x = Number.parseInt(idx, 10);\n    const bitkeyField = Object.keys(schemaField)[0];\n    const schemaEncoding = Object.values(schemaField)[0];\n    bitkeyObj[bitkeyField] = cellValue(cell[x + 1], schemaEncoding) as string;\n  }\n\n  // Derive userAddress from pubkey\n  const pubkeyHex = bitkeyObj.pubkey as string;\n  const userPubkey = PublicKey.fromString(pubkeyHex);\n  const userPubKeyHash = userPubkey.toHash() as number[];\n  const userAddress = toBase58Check(userPubKeyHash);\n\n  // Prepare raw message for bitkey signature verification: sha256(paymail_hex + pubkey_hex)\n  const paymailHex = Buffer.from(bitkeyObj.paymail as string).toString(\"hex\");\n  const concatenated = paymailHex + pubkeyHex;\n  const concatenatedBuffer = Buffer.from(concatenated, \"hex\");\n  const bitkeyMessage = Hash.sha256(toArray(concatenatedBuffer));\n  // This is the raw message. BSM.verify() will do magicHash internally.\n\n  const bitkeySignature = Signature.fromCompact(bitkeyObj.bitkey_signature as string, 'base64');\n\n  // Recover Bitkey pubkey\n  const recoveredBitkeyPubkey = recoverPublicKeyFromBSM(bitkeyMessage, bitkeySignature);\n  const recoveredBitkeyPubKeyHash = recoveredBitkeyPubkey.toHash() as number[];\n  const recoveredBitkeyAddress = toBase58Check(recoveredBitkeyPubKeyHash);\n  const bitkeySignatureVerified = BSM.verify(bitkeyMessage, bitkeySignature, recoveredBitkeyPubkey) && (recoveredBitkeyAddress === address);\n\n  // Verify user signature by using the pubkey as the message\n  const userMessage = toArray(Buffer.from(pubkeyHex, \"utf8\"));\n  const userSignature = Signature.fromCompact(bitkeyObj.user_signature as string, 'base64');\n  const recoveredUserPubkey = recoverPublicKeyFromBSM(userMessage, userSignature);\n  const recoveredUserPubKeyHash = recoveredUserPubkey.toHash() as number[];\n  const recoveredUserAddress = toBase58Check(recoveredUserPubKeyHash);\n  const userSignatureVerified = BSM.verify(userMessage, userSignature, recoveredUserPubkey) && (recoveredUserAddress === userAddress);\n\n  bitkeyObj.verified = bitkeySignatureVerified && userSignatureVerified;\n  saveProtocolData(dataObj, \"BITKEY\", bitkeyObj);\n};\n\nexport const BITKEY: Protocol = {\n  name: \"BITKEY\",\n  address,\n  opReturnSchema,\n  handler,\n};","import { BSM, Hash, PublicKey, Signature, Utils } from \"@bsv/sdk\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { BITPIC as BITPICType } from \"../types/protocols/bitpic\";\nimport { saveProtocolData } from \"../utils\";\nconst { magicHash } = BSM;\nconst { toArray } = Utils;\n\n\nconst protocolAddress = \"18pAqbYqhzErT6Zk3a5dwxHtB9icv8jH2p\";\n\nconst opReturnSchema = [\n  { paymail: \"string\" },\n  { pubkey: \"binary\" },\n  { signature: \"string\" },\n];\n\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n  // Validation\n  if (\n    cell[0].s !== protocolAddress ||\n    !cell[1] ||\n    !cell[2] ||\n    !cell[3] ||\n    !cell[1].s ||\n    !cell[2].b ||\n    !cell[3].s ||\n    !tape\n  ) {\n    throw new Error(`Invalid BITPIC record: ${tx}`);\n  }\n\n  const bitpicObj: BITPICType = {\n    paymail: cell[1].s,\n    pubkey: Buffer.from(cell[2].b, \"base64\").toString(\"hex\"),\n    signature: cell[3].s || \"\",\n    verified: false,\n  };\n\n  const b = tape[1].cell;\n  if (b[0].s === \"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\") {\n    // verify bitpic signature\n\n    try {\n      // TODO: bob transactions are missing this binary part, cannot verify signature\n      const bin = (cell[1].lb || cell[1].b) as string;\n      const hashBuff = Hash.sha256(toArray(bin, \"base64\"));\n      const sig = Signature.fromCompact(bitpicObj.signature as string, \"base64\");\n      const pubkey = PublicKey.fromString(bitpicObj.pubkey as string);\n      const msgHash = magicHash(hashBuff);\n      bitpicObj.verified = BSM.verify(msgHash, sig, pubkey);\n    } catch (e) {\n      // failed verification\n      bitpicObj.verified = false;\n    }\n  }\n\n  saveProtocolData(dataObj, \"BITPIC\", bitpicObj);\n};\n\nexport const BITPIC: Protocol = {\n  name: \"BITPIC\",\n  address: protocolAddress,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps, Protocol } from \"../types/common\";\nimport { AIPhandler, SIGPROTO } from \"./aip\";\n\nconst address = \"1HA1P2exomAwCUycZHr8WeyFoy5vuQASE3\";\n\nconst opReturnSchema = [\n  { hashing_algorithm: \"string\" },\n  { signing_algorithm: \"string\" },\n  { signing_address: \"string\" },\n  { signature: \"string\" },\n  { index_unit_size: \"number\" },\n  [{ index: \"binary\" }],\n];\n\n// https://github.com/torusJKL/BitcoinBIPs/blob/master/HAIP.md\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n  if (!tape) {\n    throw new Error(\"Invalid HAIP tx. Bad tape\");\n  }\n  if (!tx) {\n    throw new Error(\"Invalid HAIP tx.\");\n  }\n  return await AIPhandler(\n    opReturnSchema,\n    SIGPROTO.HAIP,\n    dataObj,\n    cell,\n    tape,\n    // tx,\n  );\n};\n\nexport const HAIP: Protocol = {\n  name: \"HAIP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","\nimport { decode } from \"@msgpack/msgpack\";\nimport type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { MAP as MAPType } from \"../types/protocols/map\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5\";\n\nconst opReturnSchema = [\n  {\n    cmd: {\n      SET: [{ key: \"string\" }, { val: \"string\" }],\n      SELECT: [{ tx: \"string\" }],\n      ADD: [{ key: \"string\" }, [{ val: \"string\" }]],\n      DELETE: [{ key: \"string\" }, [{ val: \"string\" }]],\n      JSON: \"string\",\n      REMOVE: [[{ key: \"string\" }]],\n      CLEAR: [[{ txid: \"string\" }]],\n    },\n  },\n];\n\nconst processADD = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    const pushdata = pushdataContainer.s as string;\n    if (pushdataContainer.i === 2) {\n      // Key name\n      mapObj[pushdata] = [];\n      last = pushdata;\n    } else {\n      if (last && Array.isArray(mapObj[last])) {\n        (mapObj[last] as string[]).push(pushdata);\n      }\n    }\n  }\n};\n\nconst proccessDELETE = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    const pushdata = pushdataContainer.s as string;\n    if (pushdataContainer.i === 2) {\n      // Key name\n      mapObj[pushdata] = [];\n      last = pushdata;\n    } else {\n      if (last) {\n        (mapObj[last] as string[]).push(pushdata);\n      }\n    }\n  }\n};\n\nconst processSELECT = (cell: Cell[], mapObj: MAPType) => {\n  // TODO\n  // console.log('MAP SELECT');\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      mapObj.SELECT = \"TODO\";\n      continue;\n    }\n  }\n};\n\nconst processMSGPACK = (cell: Cell[], mapObj: MAPType) => {\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    if (pushdataContainer.i === 2) {\n      try {\n        if (!decode) {\n          throw new Error(\"Msgpack is required but not loaded\");\n        }\n        const buff = Buffer.from(pushdataContainer.b as string, \"base64\");\n        mapObj = decode(buff) as MAPType;\n      } catch (e) {\n        mapObj = {} as MAPType;\n      }\n    }\n  }\n  return mapObj;\n};\n\nconst processJSON = (cell: Cell[], mapObj: MAPType) => {\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n      continue;\n    }\n    if (pushdataContainer.i === 2) {\n      try {\n        mapObj = JSON.parse(pushdataContainer.s as string);\n      } catch (e) {\n        mapObj = {} as MAPType;\n      }\n    }\n  }\n  return mapObj;\n};\n\nconst processSET = (cell: Cell[], mapObj: MAPType) => {\n  let last = null;\n  for (const pushdataContainer of cell) {\n    // ignore MAP command\n    if (\n      !pushdataContainer.s ||\n      pushdataContainer.i === 0 ||\n      pushdataContainer.i === 1\n    ) {\n      continue;\n    }\n\n    const pushdata = pushdataContainer.s;\n    if (pushdataContainer.i % 2 === 0) {\n      // key\n      mapObj[pushdata] = \"\";\n      last = pushdata;\n    } else {\n      // value\n      if (!last) {\n        throw new Error(`malformed MAP syntax. Cannot parse.${last}`);\n      }\n      mapObj[last] = pushdata;\n    }\n  }\n};\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  // Validate\n  if (\n    cell[0].s !== address ||\n    !cell[1] ||\n    !cell[1].s ||\n    !cell[2] ||\n    !cell[2].s\n  ) {\n    throw new Error(`Invalid MAP record: ${tx}`);\n  }\n\n  let mapObj = {} as MAPType;\n\n  // parse the protocol separator\n  const commands: any[] = [];\n  let commandSeparator = 0;\n  for (let i = 1; i < cell.length; i++) {\n    if (cell[i].s === \":::\") {\n      commandSeparator++;\n    } else {\n      if (!commands[commandSeparator]) commands[commandSeparator] = [];\n      cell[i].i = commands[commandSeparator].length + 1;\n      commands[commandSeparator].push(cell[i]);\n    }\n  }\n\n  // Get the MAP command key name from the query schema\n  const mapCmdKey = Object.keys(opReturnSchema[0])[0];\n\n  // Add the firt MAP command in the response object\n  mapObj[mapCmdKey] = commands[0][0].s;\n\n  for (const cc of commands) {\n    // re-add the MAP address\n    cc.unshift({\n      s: address,\n      i: 0,\n    });\n\n    const command = cc[1].s;\n    // Individual parsing rules for each MAP command\n    switch (command) {\n      // Also check for SELECT commands and strip off the <SELECT> <TXID> part and run it through\n      case \"ADD\": {\n        processADD(cc, mapObj);\n        break;\n      }\n      case \"REMOVE\": {\n        mapObj.key = cc[2].s;\n        break;\n      }\n      case \"DELETE\": {\n        proccessDELETE(cc, mapObj);\n        break;\n      }\n      case \"CLEAR\": {\n        // TODO\n        // console.log('MAP CLEAR');\n        break;\n      }\n      case \"SELECT\": {\n        processSELECT(cc, mapObj);\n        break;\n      }\n      case \"MSGPACK\": {\n        mapObj = processMSGPACK(cc, mapObj);\n        break;\n      }\n      case \"JSON\": {\n        mapObj = processJSON(cc, mapObj);\n        break;\n      }\n      case \"SET\": {\n        processSET(cc, mapObj);\n        break;\n      }\n      default: {\n        // don't know what to do ...\n      }\n    }\n  }\n\n  saveProtocolData(dataObj, \"MAP\", mapObj);\n};\n\nexport const MAP: Protocol = {\n  name: \"MAP\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","\nimport { Hash, Utils } from \"@bsv/sdk\";\nimport type {\n  HandlerProps,\n  MetaNet,\n  MetanetNode,\n  Protocol,\n} from \"../types/common\";\n\nconst { toArray, toHex } = Utils;\n\nconst address = \"meta\";\n\nconst opReturnSchema = [\n  { address: \"string\" },\n  { parent: \"string\" },\n  { name: \"string\" },\n];\n\nexport const getEnvSafeMetanetID = async (a: string, tx: string) => {\n  // Calculate the node ID\n  const buf = Buffer.from(a + tx);\n  const hashBuf = Hash.sha256(toArray(buf));\n  return toHex(hashBuf);\n};\n\nconst handler = async ({ dataObj, cell, tx }: HandlerProps) => {\n  if (\n    !cell.length ||\n    cell[0].s !== \"meta\" ||\n    !cell[1] ||\n    !cell[1].s ||\n    !cell[2] ||\n    !cell[2].s ||\n    !tx\n  ) {\n    throw new Error(`Invalid Metanet tx ${tx}`);\n  }\n  // For now, we just copy from MOM keys later if available, or keep BOB format\n\n  const nodeId = await getEnvSafeMetanetID(cell[1].s, tx.tx.h);\n  // Described this node\n  const node = {\n    a: cell[1].s,\n    tx: tx.tx.h,\n    id: nodeId,\n  };\n  let parent = {} as MetanetNode;\n  if (tx.in) {\n    const parentId = await getEnvSafeMetanetID(tx.in[0].e.a, cell[2].s);\n    // Parent node\n    parent = {\n      a: tx.in[0].e.a,\n      tx: cell[2].s,\n      id: parentId,\n    };\n  }\n\n  if (!dataObj.METANET) {\n    dataObj.METANET = [];\n  }\n  dataObj.METANET.push({\n    node,\n    parent,\n  } as MetaNet);\n};\n\nexport const METANET: Protocol = {\n  name: \"METANET\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { Cell } from \"bpu-ts\";\nimport type { HandlerProps, Protocol } from \"../types/common\";\nimport type { ORD as OrdType } from \"../types/protocols/ord\";\nimport { saveProtocolData } from \"../utils\";\n\n// const OrdScript =\n//     'OP_FALSE OP_IF 6F7264 OP_1 <CONTENT_TYPE_PLACEHOLDER> OP_0 <DATA_PLACEHOLDER> OP_ENDIF'.split(\n//         ' '\n//     )\n\nconst scriptChecker = (cell: Cell[]) => {\n  if (cell.length < 13) {\n    // wrong length\n    return false;\n  }\n\n  // Find OP_IF wrapper\n  const startIdx = findIndex(cell, (c: Cell) => c.ops === \"OP_IF\");\n  const endIdx = findIndex(\n    cell,\n    (c: Cell, i: number) => i > startIdx && c.ops === \"OP_ENDIF\",\n  );\n  const ordScript = cell.slice(startIdx, endIdx);\n  const prevCell = cell[startIdx - 1];\n  return (\n    prevCell?.op === 0 &&\n    !!ordScript[0] &&\n    !!ordScript[1] &&\n    ordScript[1].s == \"ord\"\n  );\n};\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n  if (!cell[0] || !out) {\n    throw new Error(\"Invalid Ord tx. dataObj, cell, out and tx are required.\");\n  }\n\n  // assemble asm\n  // make sure first piece matches a txid\n  // 2nd piece matches any difficulty. set some resonable limit in bytes if there isnt one documented somewhere\n  // next\n\n  // Find OP_IF wrapper\n  const startIdx = findIndex(cell, (c: Cell) => c.ops === \"OP_IF\");\n  const endIdx =\n    findIndex(\n      cell,\n      (c: Cell, i: number) => i > startIdx && c.ops === \"OP_ENDIF\",\n    ) + 1;\n  const ordScript = cell.slice(startIdx, endIdx);\n\n  if (!ordScript[0] || !ordScript[1] || ordScript[1].s !== \"ord\") {\n    throw new Error(\"Invalid Ord tx. Prefix not found.\");\n  }\n\n  let data: string | undefined;\n  let contentType: string | undefined;\n  ordScript.forEach((push, idx, all) => {\n    // content-type\n    if (push.ops === \"OP_1\") {\n      contentType = all[idx + 1].s;\n    }\n    // data\n    if (push.ops === \"OP_0\") {\n      data = all[idx + 1].b;\n    }\n  });\n\n  if (!data) {\n    throw new Error(\"Invalid Ord data.\");\n  }\n  if (!contentType) {\n    throw new Error(\"Invalid Ord content type.\");\n  }\n\n  const OrdObj: OrdType = {\n    data,\n    contentType,\n  };\n\n  saveProtocolData(dataObj, \"ORD\", OrdObj);\n};\n\nexport const ORD: Protocol = {\n  name: \"ORD\",\n  handler,\n  scriptChecker,\n};\n\nfunction findIndex(array: any[], predicate: Function) {\n  return findLastIndex(array, predicate);\n}\nfunction findLastIndex(array: any[], predicate: Function, fromIndex?: number) {\n  const length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  let index = length - 1;\n  if (fromIndex !== undefined) {\n    index = fromIndex;\n    index =\n      fromIndex < 0 ? Math.max(length + index, 0) : Math.min(index, length - 1);\n  }\n  return baseFindIndex(array, predicate, index, true);\n}\n\nfunction baseFindIndex(\n  array: any[],\n  predicate: Function,\n  fromIndex: number,\n  fromRight: boolean,\n) {\n  const { length } = array;\n  let index = fromIndex + (fromRight ? 1 : -1);\n\n  while (fromRight ? index-- : ++index < length) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n","import type { HandlerProps, Protocol } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1GvFYzwtFix3qSAZhESQVTz9DeudHZNoh1\";\n\nconst opReturnSchema = [\n  { pair: \"json\" },\n  { address: \"string\" },\n  { timestamp: \"string\" },\n];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (\n    cell[0].s !== address ||\n    !cell[1] ||\n    !cell[2] ||\n    !cell[3] ||\n    !cell[1].s ||\n    !cell[2].s ||\n    !cell[3].s\n  ) {\n    throw new Error(`Invalid RON record ${tx?.tx.h}`);\n  }\n\n  const pair = JSON.parse(cell[1].s);\n  const timestamp = Number(cell[3].s);\n\n  saveProtocolData(dataObj, \"RON\", {\n    pair,\n    address: cell[2].s,\n    timestamp,\n  });\n};\n\nexport const RON: Protocol = {\n  name: \"RON\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import type { HandlerProps } from \"../types/common\";\nimport { saveProtocolData } from \"../utils\";\n\nconst address = \"1SymRe7erxM46GByucUWnB9fEEMgo7spd\";\n\nconst opReturnSchema = [{ url: \"string\" }];\n\nconst handler = ({ dataObj, cell, tx }: HandlerProps) => {\n  if (cell[0].s !== address || !cell[1] || !cell[1].s) {\n    throw new Error(`Invalid SymRe tx: ${tx}`);\n  }\n\n  saveProtocolData(dataObj, \"SYMRE\", { url: cell[1].s });\n};\n\nexport const SYMRE = {\n  name: \"SYMRE\",\n  address,\n  opReturnSchema,\n  handler,\n};\n","import { type In, type Out, type Tape, parse } from \"bpu-ts\";\nimport { _21E8 } from \"./protocols/_21e8\";\nimport { AIP } from \"./protocols/aip\";\nimport { B } from \"./protocols/b\";\nimport { BAP } from \"./protocols/bap\";\nimport { BITCOM } from \"./protocols/bitcom\";\nimport { BITKEY } from \"./protocols/bitkey\";\nimport { BITPIC } from \"./protocols/bitpic\";\nimport { HAIP } from \"./protocols/haip\";\nimport { MAP } from \"./protocols/map\";\nimport { METANET } from \"./protocols/metanet\";\nimport { ORD } from \"./protocols/ord\";\nimport { RON } from \"./protocols/ron\";\nimport { SYMRE } from \"./protocols/symre\";\nimport type {\n  BmapTx,\n  BobTx,\n  Handler,\n  HandlerProps,\n  MetaNet,\n  MomTx,\n  Protocol,\n  ScriptChecker,\n} from \"./types/common\";\nimport {\n  checkOpFalseOpReturn,\n  checkOpReturn,\n  isObjectArray,\n  isStringArray,\n  saveProtocolData,\n} from \"./utils\";\n\n// Names of enabled protocols\nconst enabledProtocols = new Map<string, string>([]);\n// Protocol Handlers\nconst protocolHandlers = new Map<string, Handler>([]);\n// Script checkers are intentionally minimalistic detection functions for identifying matching scripts for a given protocol. Only if a checker returns true is a handler called for processing.\nconst protocolScriptCheckers = new Map<string, ScriptChecker>([]);\nconst protocolOpReturnSchemas = new Map<string, Object[]>();\n\nexport const allProtocols = [\n  AIP,\n  B,\n  BAP,\n  MAP,\n  METANET,\n  _21E8,\n  BITCOM,\n  BITKEY,\n  BITPIC,\n  HAIP,\n  RON,\n  SYMRE,\n  ORD,\n];\n\nexport const supportedProtocols = allProtocols.map((p) => p.name);\nexport const defaultProtocols = [AIP, B, BAP, MAP, METANET, ORD];\n\n// prepare protocol map, handlers and schemas\nfor (const protocol of defaultProtocols) {\n  if (protocol.address) {\n    enabledProtocols.set(protocol.address, protocol.name);\n  }\n  protocolHandlers.set(protocol.name, protocol.handler);\n  if (protocol.opReturnSchema) {\n    protocolOpReturnSchemas.set(protocol.name, protocol.opReturnSchema);\n  }\n  if (protocol.scriptChecker) {\n    protocolScriptCheckers.set(protocol.name, protocol.scriptChecker);\n  }\n}\n\n// Takes a BOB formatted op_return transaction\nexport class BMAP {\n  enabledProtocols: Map<string, string>;\n\n  protocolHandlers: Map<string, Handler>;\n\n  protocolScriptCheckers: Map<string, ScriptChecker>;\n\n  protocolOpReturnSchemas: Map<string, Object[]>;\n\n  constructor() {\n    // initial default protocol handlers in this instantiation\n    this.enabledProtocols = enabledProtocols;\n    this.protocolHandlers = protocolHandlers;\n    this.protocolScriptCheckers = protocolScriptCheckers;\n    this.protocolOpReturnSchemas = protocolOpReturnSchemas;\n  }\n\n  addProtocolHandler({\n    name,\n    address,\n    opReturnSchema,\n    handler,\n    scriptChecker,\n  }: Protocol) {\n    if (address) {\n      this.enabledProtocols.set(address, name);\n    }\n    this.protocolHandlers.set(name, handler);\n    if (opReturnSchema) {\n      this.protocolOpReturnSchemas.set(name, opReturnSchema);\n    }\n    if (scriptChecker) {\n      this.protocolScriptCheckers.set(name, scriptChecker);\n    }\n  }\n\n  transformTx = async (tx: BobTx | MomTx): Promise<BmapTx> => {\n    if (!tx || !tx.in || !tx.out) {\n      throw new Error(\"Cannot process tx\");\n    }\n\n    // This will become our nicely formatted response object\n    let dataObj: Partial<BobTx> = {};\n\n    for (const [key, val] of Object.entries(tx)) {\n      if (key === \"out\") {\n        // loop over the outputs\n        for (const out of tx.out) {\n          const { tape } = out;\n\n          // Process opReturn data\n          if (tape?.some((cc) => checkOpReturn(cc))) {\n            dataObj = await this.processDataProtocols(tape, out, tx, dataObj);\n          }\n\n          // No OP_FALSE OP_RETURN in this tape\n          const _21e8Checker = this.protocolScriptCheckers.get(_21E8.name);\n          const ordChecker = this.protocolScriptCheckers.get(ORD.name);\n\n          // Check for 21e8 and ords\n          if (\n            tape?.some((cc) => {\n              const { cell } = cc;\n              if (_21e8Checker?.(cell)) {\n                // 'found 21e8'\n                return true;\n              }\n              if (ordChecker?.(cell)) {\n                // 'found 1sat ordinal'\n                return true;\n              }\n            })\n          ) {\n            // find the cell array\n            // loop over tape\n            for (const cellContainer of tape) {\n              const { cell } = cellContainer;\n              // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n              if (!cell) {\n                throw new Error(\"empty cell while parsing\");\n              }\n              let protocolName = \"\";\n              if (_21e8Checker?.(cell)) {\n                protocolName = _21E8.name;\n              } else if (ordChecker?.(cell)) {\n                protocolName = ORD.name;\n              } else {\n                // nothing found\n                continue;\n              }\n\n              this.process(protocolName, {\n                tx,\n                cell,\n                dataObj: dataObj as BmapTx,\n                tape,\n                out,\n              });\n            }\n          }\n        }\n      } else if (key === \"in\") {\n        dataObj[key] = val.map((v: In) => {\n          const r = { ...v } as any;\n          delete r.tape;\n          return r as In;\n        });\n      } else {\n        // known key, just write it retaining original type\n        dataObj[key] = val;\n      }\n    }\n\n    // If this is a MOM planaria it will have metanet keys available\n    if (dataObj.METANET && (tx as MomTx).parent) {\n      const meta = {\n        ancestor: (tx as MomTx).ancestor,\n        parent: (tx as MomTx).parent,\n        child: (tx as MomTx).child,\n        head: (tx as MomTx).head,\n      } as MetaNet;\n      (dataObj.METANET as MetaNet[]).push(meta);\n      // remove parent and node from root level for (MOM data)\n      delete dataObj.ancestor;\n      delete dataObj.child;\n      delete dataObj.parent;\n      delete dataObj.head;\n      delete dataObj.node;\n    }\n\n    return dataObj as BmapTx;\n  };\n\n  processUnknown = (key: string, dataObj: Partial<BmapTx>, out: Out) => {\n    // no known non-OP_RETURN scripts\n    if (key && !dataObj[key]) {\n      dataObj[key] = [];\n    }\n    (dataObj[key] as Out[]).push({\n      i: out.i,\n      e: out.e,\n      tape: [],\n    });\n  };\n\n  process = async (\n    protocolName: string,\n    { cell, dataObj, tape, out, tx }: HandlerProps,\n  ) => {\n    if (\n      this.protocolHandlers.has(protocolName) &&\n      typeof this.protocolHandlers.get(protocolName) === \"function\"\n    ) {\n      const handler = this.protocolHandlers.get(protocolName);\n      if (handler) {\n        /* eslint-disable no-await-in-loop */\n        await handler({\n          dataObj: dataObj,\n          cell,\n          tape,\n          out,\n          tx,\n        });\n      }\n    } else {\n      saveProtocolData(dataObj, protocolName, cell);\n    }\n  };\n\n  processDataProtocols = async (\n    tape: Tape[],\n    out: Out,\n    tx: BobTx,\n    dataObj: Partial<BobTx>,\n  ): Promise<Partial<BobTx>> => {\n    // loop over tape\n    for (const cellContainer of tape) {\n      const { cell } = cellContainer;\n      if (!cell) {\n        throw new Error(\"empty cell while parsing\");\n      }\n\n      // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n      if (checkOpFalseOpReturn(cellContainer)) {\n        continue;\n      }\n\n      const prefix = cell[0].s;\n\n      if (prefix) {\n        const bitcomProtocol =\n          this.enabledProtocols.get(prefix) ||\n          defaultProtocols.filter((p) => p.name === prefix)[0]?.name;\n        if (bitcomProtocol) {\n          await this.process(bitcomProtocol, {\n            cell,\n            dataObj: dataObj as BmapTx,\n            tape,\n            out,\n            tx,\n          });\n        } else {\n          this.processUnknown(prefix, dataObj, out);\n        }\n      }\n    }\n    return dataObj;\n  };\n}\n\nexport const fetchRawTx = async (txid: string): Promise<string> => {\n  const url = `https://api.whatsonchain.com/v1/bsv/main/tx/${txid}/hex`;\n\n  console.log(\"hitting\", url);\n\n  const res = await fetch(url);\n  return await res.text();\n};\n\nexport const bobFromRawTx = async (rawTx: string): Promise<BobTx> => {\n  const bpuTx = await parse({\n    tx: { r: rawTx },\n    split: [\n      {\n        token: { op: 106 },\n        include: \"l\",\n      },\n      {\n        token: { s: \"|\" },\n      },\n    ],\n  });\n  return bpuTx as BobTx;\n};\n\n// TransformTx\n// tx - a raw hex string or a Bob/Bmap/Mom transaction object\n// protocols - the handlers you want to load and use to process the tx\n// reducing the number of supported protocols may improve transform speed\n// at the expense of detecting more data protocols\nexport const TransformTx = async (\n  tx: BobTx | string | MomTx | BmapTx,\n  protocols?: string[] | Protocol[],\n) => {\n  if (typeof tx === \"string\") {\n    let rawTx: string | undefined;\n    // if it a txid or  complete transaction hex?\n    if (tx.length === 64) {\n      // txid - fetch raw tx\n      rawTx = await fetchRawTx(tx);\n    }\n\n    if (Buffer.from(tx).byteLength <= 146) {\n      throw new Error(\"Invalid rawTx\");\n    }\n\n    if (!rawTx) {\n      rawTx = tx;\n    }\n\n    // TODO: Double check 146 is intended to be minimum possible byte length for a tx\n    const bobTx = await bobFromRawTx(rawTx);\n\n    if (bobTx) {\n      tx = bobTx;\n    } else {\n      throw new Error(\"Invalid txid\");\n    }\n  }\n\n  const b = new BMAP();\n\n  // if protocols are specified\n  if (protocols) {\n    // wipe out defaults\n    b.enabledProtocols.clear();\n    if (isStringArray(protocols)) {\n      // set enabled protocols\n      for (const protocol of allProtocols) {\n        if ((protocols as string[])?.includes(protocol.name)) {\n          b.addProtocolHandler(protocol);\n        }\n      }\n    } else if (isObjectArray(protocols)) {\n      for (const p of protocols) {\n        const protocol = p as Protocol;\n        if (protocol) {\n          b.addProtocolHandler(protocol);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Invalid protocol array. Must be either an array of protocol names (string[]), or Protocol objects (Protocol[]).\",\n      );\n    }\n  }\n\n  return b.transformTx(tx);\n};\n\n// Export types\nexport type { BmapTx, BobTx, Handler, HandlerProps, MetaNet, MomTx, Protocol, ScriptChecker } from './types/common';\nexport type { _21E8 } from './types/protocols/_21e8';\nexport type { AIP } from './types/protocols/aip';\nexport type { B } from './types/protocols/b';\nexport type { BAP } from './types/protocols/bap';\nexport type { BITCOM } from './types/protocols/bitcom';\nexport type { BITKEY } from './types/protocols/bitkey';\nexport type { BITPIC } from './types/protocols/bitpic';\nexport type { HAIP } from './types/protocols/haip';\nexport type { MAP } from './types/protocols/map';\nexport type { ORD } from './types/protocols/ord';\nexport type { RON } from './types/protocols/ron';\nexport type { SYMRE } from './types/protocols/symre';\n\n"],"names":["isStringArray","arr","value","isObjectArray","cellValue","pushData","schemaEncoding","checkOpReturn","cc","c","checkOpFalseOpReturn","opReturnIdx","_a","saveProtocolData","dataObj","protocolName","data","bmapOpReturnSchemaHandler","opReturnSchema","cell","tx","obj","length","idx","schemaField","x","field","isBase64","regex","_21e8Script","scriptChecker","ops","target","targetOpSize","handler","out","txid","difficulty","_21e8Obj","_21E8","toArray","toHex","fromBase58Check","toBase58Check","Utils","address","getFileBuffer","bitfsRef","fetch","toBigNumberFromBuffer","buffer","hex","BigNumber","recoverPublicKeyFromBSM","message","signature","expectedAddress","msgHash","BSM","bigMsg","recovery","publicKey","pubKeyHash","prefix","recoveredAddress","e","fromSafeDataArray","dataBufs","script","Script","buf","validateSignature","aipObj","tape","cellIndex","index","usingIndexes","signatureValues","i","cellContainer","cellData","statement","fileBuffer","indexLength","indexesHex","signatureBufferStatements","val","b","messageBuffer","dataScript","dataBuffer","hashed","Hash","addressString","signatureStr","Signature","tryNormalLogic","msgArr","recoveredPubkey","res","err","tryTwetchLogic","trimmed","buff","hexStr","twetchMsg","verified","SIGPROTO","AIPhandler","useOpReturnSchema","protocol","aipField","fieldData","AIP","encodingMap","bObj","bField","B","BAP","protocolAddress","bitcomObj","BITCOM","magicHash","toBigNumber","bitkeyObj","bitkeyField","pubkeyHex","userPubKeyHash","PublicKey","userAddress","concatenated","concatenatedBuffer","bitkeyMessage","bitkeySignature","recoveredBitkeyPubkey","recoveredBitkeyPubKeyHash","recoveredBitkeyAddress","bitkeySignatureVerified","userMessage","userSignature","recoveredUserPubkey","recoveredUserPubKeyHash","recoveredUserAddress","userSignatureVerified","BITKEY","bitpicObj","bin","hashBuff","sig","pubkey","BITPIC","HAIP","processADD","mapObj","last","pushdataContainer","pushdata","proccessDELETE","processSELECT","processMSGPACK","decode","processJSON","processSET","commands","commandSeparator","mapCmdKey","MAP","getEnvSafeMetanetID","a","hashBuf","nodeId","node","parent","parentId","METANET","startIdx","findIndex","endIdx","ordScript","prevCell","contentType","push","all","ORD","array","predicate","findLastIndex","fromIndex","baseFindIndex","fromRight","pair","timestamp","RON","SYMRE","enabledProtocols","protocolHandlers","protocolScriptCheckers","protocolOpReturnSchemas","allProtocols","supportedProtocols","p","defaultProtocols","BMAP","name","key","_21e8Checker","ordChecker","v","r","meta","bitcomProtocol","fetchRawTx","url","bobFromRawTx","rawTx","parse","TransformTx","protocols","bobTx"],"mappings":";;;;AAMa,MAAAA,KAAgB,CAACC,MAE1BA,EAAI,SAAS,KACbA,EAAI,MAAM,CAACC,MACF,OAAOA,KAAU,QACzB,GAGQC,KAAgB,CAACF,MAE1BA,EAAI,SAAS,KACbA,EAAI,MAAM,CAACC,MACFA,MAAU,QAClB,GAUQE,IAAY,CACvBC,GACAC,MACoB;AACpB,MAAKD,GAEL;AAAA,QAAWC,MAAmB;AAC5B,aAAOD,EAAS,IAAOA,EAAS,IAAIA,EAAS,MAAM;AACrD,QAAWC,MAAmB;AAC5B,aAAOD,EAAS,IACZA,EAAS,IACTA,EAAS,OACVA,EAAS,IACN,OAAO,KAAKA,EAAS,GAAG,QAAQ,EAAE,SAAS,KAAK,IAChDA,EAAS,MACX,OAAO,KAAKA,EAAS,IAAI,QAAQ,EAAE,SAAS,KAAK,MACnD;AACJ,QAAWC,MAAmB;AACrB,aAAA,SAASD,EAAS,IAAOA,EAAS,IAAIA,EAAS,MAAM,KAAK,EAAE;AACrE,QAAWC,MAAmB;AAC5B,aAAO,WAAWD,EAAS,IAAOA,EAAS,IAAIA,EAAS,EAAE;AAAA,QAf1D,OAAM,IAAI,MAAM,6BAA6BA,CAAQ,EAAE;AAkBzD,UAAQA,EAAS,IAAOA,EAAS,IAAIA,EAAS,OAAO;AACvD,GAKaE,KAAgB,CAACC,MACrBA,EAAG,KAAK,KAAK,CAACC,MAAYA,EAAE,OAAO,GAAG,GAMlCC,IAAuB,CAACF,MAAsB;;AACrD,MAAAA,EAAG,KAAK,WAAW;AACd,WAAA;AAEH,QAAAG,IAAcH,EAAG,KAAK,UAAU,CAACC,MAAMA,EAAE,OAAO,GAAG;AACzD,SAAIE,MAAgB,OACXC,IAAAJ,EAAG,KAAKG,IAAc,CAAC,MAAvB,gBAAAC,EAA0B,QAAO,IAEnC;AACT,GASaC,IAAmB,CAC9BC,GACAC,GACAC,MACG;AACC,EAACF,EAAQC,CAAY,IAGfD,EAAAC,CAAY,EAAE,KAAKC,CAAI,IAFvBF,EAAAC,CAAY,IAAI,CAACC,CAAI;AAIjC,GAYaC,KAA4B,CACvCF,GACAG,GACAJ,GACAK,GACAC,MACG;AAEH,QAAMC,IAA8B,CAAC,GAG/BC,IAASJ,EAAe,SAAS;AACnC,MAAAC,EAAK,SAASG;AAChB,UAAM,IAAI;AAAA,MACR,GAAGP,CAAY,sBAAsBO,CAAM,iCAAiCF,EAAG,GAAG,CAAC;AAAA,IACrF;AAGF,aAAW,CAACG,GAAKC,CAAW,KAAK,OAAO,QAAQN,CAAc,GAAG;AAC/D,UAAMO,IAAI,OAAO,SAASF,GAAK,EAAE,GAE3B,CAACG,CAAK,IAAI,OAAO,KAAKF,CAAW,GACjC,CAAClB,CAAc,IAAI,OAAO,OAAOkB,CAAW;AAClD,IAAAH,EAAIK,CAAK,IAAItB,EAAUe,EAAKM,IAAI,CAAC,GAAGnB,CAAc;AAAA,EAAA;AAGnC,EAAAO,EAAAC,GAASC,GAAcM,CAAG;AAC7C,GAQaM,KAAW,CAACX,MAAiB;AACxC,QAAMY,IACJ;AACK,SAAA,IAAI,OAAO,IAAIA,CAAK,KAAK,IAAI,EAAE,KAAKZ,CAAI;AACjD,GCvIMa,IACJ,2GAA2G;AAAA,EACzG;AACF,GAEIC,KAAgB,CAACX,MAAiB;AAClC,MAAAA,EAAK,WAAW;AAEX,WAAA;AAIT,QAAMY,IAAM,CAAC,GAAGZ,CAAI,EAAE,IAAI,CAACV,MAAMA,EAAE,GAAG,EAAE,OAAO,GAAGU,EAAK,MAAM,GAGvDa,IAAS5B,EAAUe,EAAK,CAAC,GAAG,KAAK,GACjCc,IAAe,OAAO,KAAKD,CAAM,EAAE;AAGrC,SAAAD,EAAA,CAAC,IAAI,MAAME,CAAY,IACfJ,EAAA,CAAC,IAAI,MAAMI,CAAY,IAG5BF,EAAI,WAAWF,EAAY,KAAK;AACzC,GAEMK,KAAU,CAAC,EAAE,SAAApB,GAAS,MAAAK,GAAM,KAAAgB,QAA8B;AAC9D,MAAI,CAAChB,EAAK,CAAC,KAAK,CAACgB;AACT,UAAA,IAAI,MAAM,0DAA0D;AAQ5E,QAAMC,IAAOhC,EAAUe,EAAK,CAAC,GAAG,KAAK,GAC/Ba,IAAS5B,EAAUe,EAAK,CAAC,GAAG,KAAK;AACvC,MAAI,CAACa;AACG,UAAA,IAAI,MAAM,wBAAwB,KAAK,UAAUb,EAAK,CAAC,GAAG,MAAM,CAAC,CAAC,EAAE;AAE5E,QAAMkB,IAAa,OAAO,KAAKL,GAAQ,KAAK,EAAE,YAExCM,IAAsB;AAAA,IAC1B,QAAAN;AAAA,IACA,YAAAK;AAAA,IACA,OAAOF,EAAI,EAAE;AAAA,IACb,MAAAC;AAAA,EACF;AAEiB,EAAAvB,EAAAC,GAAS,QAAQwB,CAAQ;AAC5C,GAEaC,IAAkB;AAAA,EAC7B,MAAM;AAAA,EAAA,SACNL;AAAAA,EACAJ,eAAAA;AACF,GCzDM,EAAA,SAAEU,GAAA,OAASC,GAAO,iBAAAC,IAAiBC,eAAAA,GAAkB,IAAAC,GAErDC,IAAU,sCACV3B,IAAiB;AAAA,EACrB,EAAE,WAAW,SAAS;AAAA,EACtB,EAAE,SAAS,SAAS;AAAA,EACpB,EAAE,WAAW,SAAS;AAAA,EACtB,CAAC,EAAE,OAAO,SAAU,CAAA;AACtB,GAEM4B,KAAgB,OAAOC,MAAqB;AAC5C,MAAA;AAEK,WAAA,OADQ,MAAMC,GAAM,2BAA2BD,CAAQ,EAAE,GAC5C,OAAO;AAAA,EAAA,QACrB;AACC,WAAA,OAAO,KAAK,EAAE;AAAA,EAAA;AAEzB;AAEA,SAASE,GAAsBC,GAA6B;AACpD,QAAAC,IAAMV,EAAMS,CAAM;AACjB,SAAA,IAAIE,EAAUD,GAAK,EAAE;AAC9B;AAEA,SAASE,EAAwBC,GAAmBC,GAAsBC,GAAoC;AACtG,QAAAC,IAAUC,EAAI,UAAUJ,CAAO,GAC/BK,IAASV,GAAsBQ,CAAO;AAE5C,WAASG,IAAW,GAAGA,IAAW,GAAGA;AAC/B,QAAA;AACF,YAAMC,IAAYN,EAAU,iBAAiBK,GAAUD,CAAM,GACvDG,IAAaD,EAAU,OAAO,GAC9B,EAAE,QAAAE,EAAA,IAAWrB,GAAgBc,CAAe,GAC5CQ,IAAmBrB,GAAcmB,GAAYC,CAAkB;AACrE,UAAIC,MAAqBR;AACvB,uBAAQ,IAAI,sEAAsE,GAC3EK;AAEP,cAAQ,IAAI,8CAA8CD,GAAU,sBAAsBI,GAAkB,aAAaR,CAAe;AAAA,aAEnIS,GAAG;AACF,cAAA,IAAI,6CAA6CA,CAAC;AAAA,IAAA;AAI9D,gBAAQ,IAAI,kEAAkE,GACxE,IAAI,MAAM,4DAA4D;AAC9E;AAEA,SAASC,GAAkBC,GAA4B;AAC/C,QAAAC,IAAS,IAAIC,GAAO;AAC1B,EAAAD,EAAO,OAAO,KAAK,EAAE,IAAI,GAAG,GAC5BA,EAAO,OAAO,KAAK,EAAE,IAAI,KAAK;AAC9B,aAAWE,KAAOH,GAAU;AAC1B,UAAM7C,IAASgD,EAAI;AACnB,IAAIhD,KAAU,KACL8C,EAAA,OAAO,KAAK,EAAE,IAAI9C,GAAQ,MAAM,MAAM,KAAKgD,CAAG,GAAG,IAC/ChD,KAAU,MACZ8C,EAAA,OAAO,KAAK,EAAE,IAAI,IAAM,MAAM,MAAM,KAAKE,CAAG,GAAG,IAC7ChD,KAAU,QACZ8C,EAAA,OAAO,KAAK,EAAE,IAAI,IAAM,MAAM,MAAM,KAAKE,CAAG,GAAG,IAE/CF,EAAA,OAAO,KAAK,EAAE,IAAI,IAAM,MAAM,MAAM,KAAKE,CAAG,GAAG;AAAA,EACxD;AAEK,SAAAF;AACT;AAEA,eAAeG,GACbC,GACArD,GACAsD,GACkB;;AAClB,MAAI,CAAC,MAAM,QAAQA,CAAI,KAAKA,EAAK,SAAS;AAClC,UAAA,IAAI,MAAM,oDAAoD;AAGtE,MAAIC,IAAY;AAMhB,MALKD,EAAA,QAAQ,CAACjE,GAAImE,MAAU;AACtB,IAAAnE,EAAG,SAASW,MACFuD,IAAAC;AAAA,EACd,CACD,GACGD,MAAc;AACV,UAAA,IAAI,MAAM,iCAAiC;AAG/C,MAAAE,IAA0BJ,EAAO,SAAsB,CAAC;AACtD,QAAAK,IAA4B,CAAC,IAAI;AAGvC,WAASC,IAAI,GAAGA,IAAIJ,GAAWI,KAAK;AAC5B,UAAAC,IAAgBN,EAAKK,CAAC;AACxB,QAAA,CAACpE,EAAqBqE,CAAa,GAAG;AACxC,YAAMC,IAAqB,CAAC;AACjB,iBAAAC,KAAaF,EAAc,MAAM;AACtC,YAAA7E;AACJ,YAAI+E,EAAU;AACZ,UAAA/E,IAAQ+E,EAAU;AAAA,iBACTA,EAAU,GAAG;AACtB,gBAAMC,IAAa,MAAMpC,GAAcmC,EAAU,CAAC;AAClD,UAAA/E,IAAQgF,EAAW,SAAS,IAAIA,EAAW,SAAS,KAAK,IAAI;AAAA,QAAA,WACpDD,EAAU,GAAG;AACtB,gBAAMX,IAAM,OAAO,KAAKW,EAAU,GAAG,QAAQ;AACzC,UAAAX,EAAI,SAAS,MACPpE,IAAAoE,EAAI,SAAS,KAAK;AAAA,QAC5B,MACF,CAAWW,EAAU,KACfA,EAAU,EAAE,SAAS,MACvB/E,IAAQ,OAAO,KAAK+E,EAAU,CAAC,EAAE,SAAS,KAAK;AAI/C,QAAA/E,KAASA,EAAM,SAAS,KAC1B8E,EAAS,KAAK9E,CAAK;AAAA,MACrB;AAEE,MAAA8E,EAAS,SAAS,MAEJH,EAAA,KAAK,GAAGG,CAAQ,GAEhCH,EAAgB,KAAK,IAAI;AAAA,IAC3B;AAAA,EACF;AAIE,MAAAL,EAAO,qBAAqBA,EAAO,iBAAiB;AAChD,UAAAW,IAAcX,EAAO,kBAAkB;AAC7C,IAAAI,IAAe,CAAC;AAChB,UAAMQ,MAAaxE,IAAAO,EAAK,CAAC,MAAN,gBAAAP,EAAS,MAAK;AACjC,aAASkE,IAAI,GAAGA,IAAIM,EAAW,QAAQN,KAAKK;AAC7B,MAAAP,EAAA,KAAK,OAAO,SAASQ,EAAW,OAAON,GAAGK,CAAW,GAAG,EAAE,CAAC;AAE1E,IAAAX,EAAO,QAAQI;AAAA,EAAA;AAGT,UAAA,IAAI,gBAAgBA,CAAY,GAChC,QAAA,IAAI,mBAAmBC,CAAe;AAE9C,QAAMQ,IAAsC,CAAC;AACzC,MAAAT,EAAa,SAAS;AACxB,eAAWrD,KAAOqD,GAAc;AAI1B,UAHA,OAAOC,EAAgBtD,CAAG,KAAM,YAClC,QAAQ,IAAI,wBAAwBsD,EAAgBtD,CAAG,GAAG,OAAOA,CAAG,GAElE,CAACsD,EAAgBtD,CAAG;AACd,uBAAA,IAAI,uCAAuCA,GAAK,4BAA4B,GAC7E;AAET,MAAA8D,EAA0B,KAAK,OAAO,KAAKR,EAAgBtD,CAAG,GAAG,KAAK,CAAC;AAAA,IAAA;AAAA;AAGzE,eAAW+D,KAAOT;AAChB,MAAAQ,EAA0B,KAAK,OAAO,KAAKC,GAAK,KAAK,CAAC;AAIlD,UAAA,IAAI,6BAA6BD,EAA0B,IAAI,CAACE,MAAMA,EAAE,SAAS,KAAK,CAAC,CAAC;AAE5F,MAAAC;AACJ,MAAIhB,EAAO,mBAAmB;AAExB,IAACA,EAAO,mBAEVa,EAA0B,MAAM;AAE5B,UAAAI,IAAavB,GAAkBmB,CAAyB;AAC9D,QAAIK,IAAa,OAAO,KAAKD,EAAW,SAAS,KAAK;AACtD,IAAIjB,EAAO,oBACIkB,IAAAA,EAAW,MAAM,CAAC;AAEjC,UAAMC,IAASC,EAAK,OAAOpD,EAAQkD,CAAU,CAAC;AAC9B,IAAAF,IAAA,OAAO,KAAKG,CAAM;AAAA,EAAA;AAGlB,IAAAH,IAAA,OAAO,OAAOH,CAAyB;AAGnD,QAAAQ,IAAiBrB,EAAmB,WAAYA,EAAoB,iBACpEsB,IAAetB,EAAO,WACtBjB,IAAYwC,EAAU,YAAYD,GAAc,QAAQ,GAExDE,IAAiB,MAAe;AACpC,YAAQ,IAAI,0CAA0C;AAClD,QAAA;AACI,YAAAC,IAASzD,EAAQgD,CAAa,GAC9BU,IAAkB7C,EAAwB4C,GAAQ1C,GAAWsC,CAAa;AAChF,cAAQ,IAAI,oEAAoE;AAChF,YAAMM,IAAMzC,EAAI,OAAOuC,GAAQ1C,GAAW2C,CAAe;AACjD,qBAAA,IAAI,uCAAuCC,CAAG,GAC/CA;AAAA,aACAC,GAAK;AACJ,qBAAA,IAAI,2BAA2BA,CAAG,GACnC;AAAA,IAAA;AAAA,EAEX,GAEMC,IAAiB,MAAe;AAGhC,QAFJ,QAAQ,IAAI,0CAA0C,GAElDhB,EAA0B,UAAU;AAC/B,aAAA;AAET,UAAMiB,IAAUjB,EAA0B,MAAM,GAAG,EAAE;AAC7C,YAAA,IAAI,6CAA6CiB,EAAQ,MAAM;AACjE,UAAAC,IAAOX,EAAK,OAAOpD,EAAQ,OAAO,OAAO8D,CAAO,CAAC,CAAC,GAClDE,IAAS/D,EAAM8D,CAAI,GACnBE,IAAY,OAAO,KAAKD,GAAQ,MAAM;AACxC,QAAA;AACF,YAAMN,IAAkB7C,EAAwBb,EAAQiE,CAAS,GAAGlD,GAAWsC,CAAa;AAC5F,cAAQ,IAAI,oEAAoE;AAChF,YAAMM,IAAMzC,EAAI,OAAOlB,EAAQiE,CAAS,GAAGlD,GAAW2C,CAAe;AAC7D,qBAAA,IAAI,uCAAuCC,CAAG,GAC/CA;AAAA,aACAC,GAAK;AACJ,qBAAA,IAAI,2BAA2BA,CAAG,GACnC;AAAA,IAAA;AAAA,EAEX;AAEA,MAAIM,IAAWV,EAAe;AAC9B,SAAKU,MACHA,IAAWL,EAAe,IAGpB,QAAA,IAAI,uCAAuCK,CAAQ,GAC1DlC,EAAmB,WAAWkC,GACxBA;AACT;AAEY,IAAAC,sBAAAA,OACVA,EAAA,OAAO,QACPA,EAAA,MAAM,OAFIA,IAAAA,KAAA,CAAA,CAAA;AAKL,MAAMC,IAAa,OACxBC,GACAC,GACAhG,GACAK,GACAsD,GACArD,MACG;AACG,QAAAoD,IAAiC,EAAE,UAAU,GAAM;AAGrD,MAAArD,EAAK,SAAS;AACV,UAAA,IAAI,MAAM,qDAAqD;AAGvE,aAAW,CAACI,GAAKC,CAAW,KAAK,OAAO,QAAQqF,CAAiB,GAAG;AAClE,UAAMpF,IAAI,OAAO,SAASF,GAAK,EAAE;AAC7B,QAAA,MAAM,QAAQC,CAAW,GAAG;AAC9B,YAAM,CAACuF,CAAQ,IAAI,OAAO,KAAKvF,EAAY,CAAC,CAAC,GACvCwF,IAAsB,CAAC;AAC7B,eAASlC,IAAIrD,IAAI,GAAGqD,IAAI3D,EAAK,QAAQ2D;AAC/B,QAAA3D,EAAK2D,CAAC,EAAE,KACAkC,EAAA,KAAK,OAAO,SAAS7F,EAAK2D,CAAC,EAAE,GAAI,EAAE,CAAC;AAGlD,MAAAN,EAAOuC,CAAQ,IAAIC;AAAA,IAAA,OACd;AACL,YAAM,CAACD,CAAQ,IAAI,OAAO,KAAKvF,CAAW,GACpC,CAAClB,CAAc,IAAI,OAAO,OAAOkB,CAAW;AAC3C,MAAAgD,EAAAuC,CAAQ,IAAI3G,EAAUe,EAAKM,IAAI,CAAC,GAAGnB,CAAwB,KAAK;AAAA,IAAA;AAAA,EACzE;AASE,MANAa,EAAK,CAAC,EAAE,MAAM0B,KAAW1B,EAAK,CAAC,EAAE,KAAKQ,GAASR,EAAK,CAAC,EAAE,CAAC,MACnDqD,EAAA,YAAYrD,EAAK,CAAC,EAAE,IAGrB,QAAA,IAAI,4CAA4CqD,CAAM,GAE1D,CAACA,EAAO;AACJ,UAAA,IAAI,MAAM,0BAA0B;AAGtC,QAAAD,GAAkBC,GAA4BrD,GAAMsD,CAAI,GACtD,QAAA,IAAI,0CAA0CD,EAAO,QAAQ,GAEpD3D,EAAAC,GAASgG,GAAUtC,CAAM;AAC5C,GAEMtC,KAAU,OAAO,EAAE,SAAApB,GAAS,MAAAK,GAAM,MAAAsD,GAAM,IAAArD,QAAuB;AACnE,MAAI,CAACqD;AACG,UAAA,IAAI,MAAM,yBAAyB;AAE3C,SAAO,MAAMmC;AAAA,IACX1F;AAAAA,IACA;AAAA,IACAJ;AAAA,IACAK;AAAA,IACAsD;AAAA,EAEF;AACF,GAEawC,IAAgB;AAAA,EAC3B,MAAM;AAAA,EAAA,SACNpE;AAAAA,EAAA,gBACA3B;AAAAA,EACAgB,SAAAA;AACF,GCtTMW,KAAU,sCAEV3B,IAAiB;AAAA,EACrB,EAAE,SAAS,CAAC,UAAU,UAAU,MAAM,EAAE;AAAA,EACxC,EAAE,gBAAgB,SAAS;AAAA,EAC3B,EAAE,UAAU,SAAS;AAAA;AAAA,EACrB,EAAE,UAAU,SAAS;AACvB,GAEMgB,KAAU,CAAC,EAAE,SAAApB,GAAS,MAAAK,GAAM,IAAAC,QAA6B;;AACvD,QAAA8F,wBAAkB,IAAoB;AAQ5C,MAPYA,EAAA,IAAI,QAAQ,QAAQ,GACpBA,EAAA,IAAI,QAAQ,QAAQ,GACpBA,EAAA,IAAI,QAAQ,QAAQ,GACpBA,EAAA,IAAI,cAAc,QAAQ,GAC1BA,EAAA,IAAI,aAAa,QAAQ,GACzBA,EAAA,IAAI,cAAc,QAAQ,GAElC,CAAC/F,EAAK,CAAC,KAAK,CAACA,EAAK,CAAC;AACrB,UAAM,IAAI,MAAM,iBAAiBC,CAAE,EAAE;AAIvC,MAAID,EAAK,SAASD,EAAe,SAAS;AAClC,UAAA,IAAI,MAAM,gCAAgC;AAKlD,QAAMiG,IAAuD,CAAC;AAE9D,aAAW,CAAC5F,GAAKC,CAAW,KAAK,OAAO,QAAQN,CAAc,GAAG;AAC/D,UAAMO,IAAI,OAAO,SAASF,GAAK,EAAE,GAC3B6F,IAAS,OAAO,KAAK5F,CAAW,EAAE,CAAC;AACzC,QAAIlB,IAAiB,OAAO,OAAOkB,CAAW,EAAE,CAAC;AACjD,QAAI4F,MAAW;AAET,UAAAjG,EAAK,CAAC,EAAE;AAEO,QAAAb,IAAA;AAAA,gBACP,CAACa,EAAK,CAAC,KAAK,CAACA,EAAK,CAAC,EAAE,MAAMA,EAAK,CAAC,EAAE,GAAG;AAEhD,YADAb,IAAiB4G,EAAY,IAAI/F,EAAK,CAAC,EAAE,CAAC,GACtC,CAACb,GAAgB;AACX,kBAAA,KAAK,iDAAiDa,CAAI;AAClE;AAAA,QAAA;AAIE,QAACA,EAAK,CAAC,MACTA,EAAK,CAAC,IAAI,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,EAAE,IAE/CA,EAAK,CAAC,EAAE,IAAIb,MAAmB,WAAW,UAAU;AAAA,MAAA;AAEpD,QAAAA,KAAiBM,IAAAO,EAAK,CAAC,MAAN,QAAAP,EAAS,IACtBsG,EAAY,IAAI/F,EAAK,CAAC,EAAE,EAAE,QAAQ,KAAK,EAAE,EAAE,YAAa,CAAA,IACxD;AAWR,QANIiG,MAAW,cAAc,CAACjG,EAAKM,IAAI,CAAC,KAMpC2F,MAAW,cAAc,CAACjG,EAAKM,IAAI,CAAC;AAEtC;AAIF,QAAI,CAACN,KAAQ,CAACA,EAAKM,IAAI,CAAC;AACtB,YAAM,IAAI,MAAM,sBAAsBN,CAAI,EAAE;AAIxC,UAAAH,IAAOG,EAAKM,IAAI,CAAC;AACvB,IAAA0F,EAAKC,CAAM,IAAIhH,EAAUY,GAAMV,CAAc;AAAA,EAAA;AAG9B,EAAAO,EAAAC,GAAS,KAAKqG,CAAI;AACrC,GAEaE,IAAc;AAAA,EACzB,MAAM;AAAA,EAAA,SACNxE;AAAAA,EAAA,gBACA3B;AAAAA,EACAgB,SAAAA;AACF,GCzFMW,KAAU,sCAEV3B,IAAiB;AAAA,EACrB,EAAE,MAAM,SAAS;AAAA,EACjB,EAAE,MAAM,SAAS;AAAA,EACjB,EAAE,UAAU,SAAS;AACvB,GAEagB,KAAU,CAAC,EAAE,SAAApB,GAAS,MAAAK,GAAM,IAAAC,QAAuB;AAC9D,MAAI,CAACA;AACG,UAAA,IAAI,MAAM,6BAA6B;AAE/C,EAAAH,GAA0B,OAAOC,GAAgBJ,GAASK,GAAMC,CAAE;AACpE,GAEakG,IAAgB;AAAA,EAC3B,MAAM;AAAA,EAAA,SACNzE;AAAAA,EAAA,gBACA3B;AAAAA,EACAgB,SAAAA;AACF,GCpBMqF,KAAkB,KAElBrG,KAAiB;AAAA,EACrB;AAAA,IACE,IAAI;AAAA,MACF,EAAE,QAAQ,SAAS;AAAA,MACnB,EAAE,eAAe,SAAS;AAAA,MAC1B,EAAE,WAAW,SAAS;AAAA,IACxB;AAAA,IACA,MAAM,CAAC,EAAE,MAAM,YAAY,EAAE,IAAI,YAAY,EAAE,UAAU,UAAU;AAAA,IACnE,OAAO;AAAA,MACL;AAAA,QACE;AAAA,UACE,KAAK;AAAA,YACH,EAAE,gBAAgB,SAAS;AAAA,YAC3B,EAAE,eAAe,SAAS;AAAA,YAC1B,EAAE,mBAAmB,SAAS;AAAA,UAAA;AAAA,QAElC;AAAA,QACA;AAAA,UACE,QAAQ,CAAC,EAAE,MAAM,SAAU,CAAA;AAAA,QAAA;AAAA,MAC7B;AAAA,IAEJ;AAAA,IACA,SAAS,CAAC,EAAE,SAAS,SAAU,CAAA;AAAA,EAAA;AAEnC,GAGMgB,KAAU,CAAC,EAAE,SAAApB,GAAS,MAAAK,QAAyB;AAC/C,MAAA,CAACA,EAAK,UAAU,CAACA,EAAK,MAAM,CAACV,MAAMA,EAAE,CAAC;AAClC,UAAA,IAAI,MAAM,mBAAmB;AAI/B,QAAA+G,IAAYrG,EAAK,IAAI,CAACV,MAAOA,KAAA,QAAAA,EAAG,IAAIA,EAAE,IAAI,EAAG;AAElC,EAAAI,EAAAC,GAAS,UAAU0G,CAAS;AAC/C,GAEaC,KAAmB;AAAA,EAC9B,MAAM;AAAA,EACN,SAASF;AAAAA,EAAA,gBACTrG;AAAAA,EACAgB,SAAAA;AACF,GC5CM,EAAA,SAAEM,GAAS,eAAAG,UAAeF,GAAA,IAAUG,GACpC,EAAE8E,WAAAA,GAAc,IAAAhE,GAEhBb,IAAU,sCAEV3B,KAAiB;AAAA,EACrB,EAAE,kBAAkB,SAAS;AAAA,EAC7B,EAAE,gBAAgB,SAAS;AAAA,EAC3B,EAAE,SAAS,SAAS;AAAA,EACpB,EAAE,QAAQ,SAAS;AACrB;AAGA,SAASyG,GAAYzE,GAA6B;AAC1C,QAAAC,IAAMV,GAAMS,CAAM;AACjB,SAAA,IAAIE,EAAUD,GAAK,EAAE;AAC9B;AAOA,SAASE,EAAwBC,GAAmBC,GAAiC;AAG7E,QAAAE,IAAUiE,GAAUpE,CAAO,GAE3BK,IAASgE,GAAYlE,CAAO;AAClC,WAASG,IAAW,GAAGA,IAAW,GAAGA;AAC/B,QAAA;AACF,YAAMC,IAAYN,EAAU,iBAAiBK,GAAUD,CAAM;AAE7D,UAAID,EAAI,OAAOJ,GAASC,GAAWM,CAAS;AACnC,eAAAA;AAAA,IACT,QACM;AAAA,IAAA;AAIJ,QAAA,IAAI,MAAM,iDAAiD;AACnE;AAEA,MAAM3B,KAAU,OAAO,EAAE,SAAApB,GAAS,MAAAK,QAAyB;AACrD,MAAAA,EAAK,SAAS;AACV,UAAA,IAAI,MAAM,mBAAmB;AAGrC,QAAMyG,IAAiD,CAAC;AACxD,aAAW,CAACrG,IAAKC,CAAW,KAAK,OAAO,QAAQN,EAAc,GAAG;AAC/D,UAAMO,KAAI,OAAO,SAASF,IAAK,EAAE,GAC3BsG,KAAc,OAAO,KAAKrG,CAAW,EAAE,CAAC,GACxClB,KAAiB,OAAO,OAAOkB,CAAW,EAAE,CAAC;AACnD,IAAAoG,EAAUC,EAAW,IAAIzH,EAAUe,EAAKM,KAAI,CAAC,GAAGnB,EAAc;AAAA,EAAA;AAIhE,QAAMwH,IAAYF,EAAU,QAEtBG,IADaC,EAAU,WAAWF,CAAS,EACf,OAAO,GACnCG,IAActF,EAAcoF,CAAc,GAI1CG,IADa,OAAO,KAAKN,EAAU,OAAiB,EAAE,SAAS,KAAK,IACxCE,GAC5BK,IAAqB,OAAO,KAAKD,GAAc,KAAK,GACpDE,IAAgBxC,EAAK,OAAOpD,EAAQ2F,CAAkB,CAAC,GAGvDE,IAAkBtC,EAAU,YAAY6B,EAAU,kBAA4B,QAAQ,GAGtFU,IAAwBjF,EAAwB+E,GAAeC,CAAe,GAC9EE,IAA4BD,EAAsB,OAAO,GACzDE,IAAyB7F,EAAc4F,CAAyB,GAChEE,IAA0B/E,EAAI,OAAO0E,GAAeC,GAAiBC,CAAqB,KAAME,MAA2B3F,GAG3H6F,IAAclG,EAAQ,OAAO,KAAKsF,GAAW,MAAM,CAAC,GACpDa,IAAgB5C,EAAU,YAAY6B,EAAU,gBAA0B,QAAQ,GAClFgB,IAAsBvF,EAAwBqF,GAAaC,CAAa,GACxEE,IAA0BD,EAAoB,OAAO,GACrDE,IAAuBnG,EAAckG,CAAuB,GAC5DE,KAAwBrF,EAAI,OAAOgF,GAAaC,GAAeC,CAAmB,KAAME,MAAyBb;AAEvH,EAAAL,EAAU,WAAWa,KAA2BM,IAC/BlI,EAAAC,GAAS,UAAU8G,CAAS;AAC/C,GAEaoB,KAAmB;AAAA,EAC9B,MAAM;AAAA,EAAA,SACNnG;AAAAA,EAAA,gBACA3B;AAAAA,EACAgB,SAAAA;AACF,GC9FM,EAAE,WAAAwF,GAAc,IAAAhE,GAChB,EAAElB,SAAAA,GAAY,IAAAI,GAGd2E,KAAkB,sCAElBrG,KAAiB;AAAA,EACrB,EAAE,SAAS,SAAS;AAAA,EACpB,EAAE,QAAQ,SAAS;AAAA,EACnB,EAAE,WAAW,SAAS;AACxB,GAEMgB,KAAU,OAAO,EAAE,SAAApB,GAAS,MAAAK,GAAM,MAAAsD,GAAM,IAAArD,QAAuB;AAEnE,MACED,EAAK,CAAC,EAAE,MAAMoG,MACd,CAACpG,EAAK,CAAC,KACP,CAACA,EAAK,CAAC,KACP,CAACA,EAAK,CAAC,KACP,CAACA,EAAK,CAAC,EAAE,KACT,CAACA,EAAK,CAAC,EAAE,KACT,CAACA,EAAK,CAAC,EAAE,KACT,CAACsD;AAED,UAAM,IAAI,MAAM,0BAA0BrD,CAAE,EAAE;AAGhD,QAAM6H,IAAwB;AAAA,IAC5B,SAAS9H,EAAK,CAAC,EAAE;AAAA,IACjB,QAAQ,OAAO,KAAKA,EAAK,CAAC,EAAE,GAAG,QAAQ,EAAE,SAAS,KAAK;AAAA,IACvD,WAAWA,EAAK,CAAC,EAAE,KAAK;AAAA,IACxB,UAAU;AAAA,EACZ;AAGA,MADUsD,EAAK,CAAC,EAAE,KACZ,CAAC,EAAE,MAAM;AAGT,QAAA;AAEF,YAAMyE,IAAO/H,EAAK,CAAC,EAAE,MAAMA,EAAK,CAAC,EAAE,GAC7BgI,IAAWvD,EAAK,OAAOpD,GAAQ0G,GAAK,QAAQ,CAAC,GAC7CE,IAAMrD,EAAU,YAAYkD,EAAU,WAAqB,QAAQ,GACnEI,IAASrB,EAAU,WAAWiB,EAAU,MAAgB,GACxDxF,IAAUiE,GAAUyB,CAAQ;AAClC,MAAAF,EAAU,WAAWvF,EAAI,OAAOD,GAAS2F,GAAKC,CAAM;AAAA,YAC1C;AAEV,MAAAJ,EAAU,WAAW;AAAA,IAAA;AAIR,EAAApI,EAAAC,GAAS,UAAUmI,CAAS;AAC/C,GAEaK,KAAmB;AAAA,EAC9B,MAAM;AAAA,EACN,SAAS/B;AAAA,EAAA,gBACTrG;AAAAA,EACAgB,SAAAA;AACF,GC7DMW,KAAU,sCAEV3B,KAAiB;AAAA,EACrB,EAAE,mBAAmB,SAAS;AAAA,EAC9B,EAAE,mBAAmB,SAAS;AAAA,EAC9B,EAAE,iBAAiB,SAAS;AAAA,EAC5B,EAAE,WAAW,SAAS;AAAA,EACtB,EAAE,iBAAiB,SAAS;AAAA,EAC5B,CAAC,EAAE,OAAO,SAAU,CAAA;AACtB,GAGMgB,KAAU,OAAO,EAAE,SAAApB,GAAS,MAAAK,GAAM,MAAAsD,GAAM,IAAArD,QAAuB;AACnE,MAAI,CAACqD;AACG,UAAA,IAAI,MAAM,2BAA2B;AAE7C,MAAI,CAACrD;AACG,UAAA,IAAI,MAAM,kBAAkB;AAEpC,SAAO,MAAMwF;AAAA,IACX1F;AAAAA,IACAyF,EAAS;AAAA,IACT7F;AAAA,IACAK;AAAA,IACAsD;AAAA;AAAA,EAEF;AACF,GAEa8E,KAAiB;AAAA,EAC5B,MAAM;AAAA,EAAA,SACN1G;AAAAA,EAAA,gBACA3B;AAAAA,EACAgB,SAAAA;AACF,GC9BMW,IAAU,sCAEV3B,KAAiB;AAAA,EACrB;AAAA,IACE,KAAK;AAAA,MACH,KAAK,CAAC,EAAE,KAAK,SAAY,GAAA,EAAE,KAAK,UAAU;AAAA,MAC1C,QAAQ,CAAC,EAAE,IAAI,UAAU;AAAA,MACzB,KAAK,CAAC,EAAE,KAAK,SAAA,GAAY,CAAC,EAAE,KAAK,SAAS,CAAC,CAAC;AAAA,MAC5C,QAAQ,CAAC,EAAE,KAAK,SAAA,GAAY,CAAC,EAAE,KAAK,SAAS,CAAC,CAAC;AAAA,MAC/C,MAAM;AAAA,MACN,QAAQ,CAAC,CAAC,EAAE,KAAK,SAAU,CAAA,CAAC;AAAA,MAC5B,OAAO,CAAC,CAAC,EAAE,MAAM,SAAA,CAAU,CAAC;AAAA,IAAA;AAAA,EAC9B;AAEJ,GAEMsI,KAAa,CAACrI,GAAcsI,MAAoB;AACpD,MAAIC,IAAO;AACX,aAAWC,KAAqBxI,GAAM;AAEpC,QAAIwI,EAAkB,MAAM,KAAKA,EAAkB,MAAM;AACvD;AAEF,UAAMC,IAAWD,EAAkB;AAC/B,IAAAA,EAAkB,MAAM,KAEnBF,EAAAG,CAAQ,IAAI,CAAC,GACbF,IAAAE,KAEHF,KAAQ,MAAM,QAAQD,EAAOC,CAAI,CAAC,KACnCD,EAAOC,CAAI,EAAe,KAAKE,CAAQ;AAAA,EAE5C;AAEJ,GAEMC,KAAiB,CAAC1I,GAAcsI,MAAoB;AACxD,MAAIC,IAAO;AACX,aAAWC,KAAqBxI,GAAM;AAEpC,QAAIwI,EAAkB,MAAM,KAAKA,EAAkB,MAAM;AACvD;AAEF,UAAMC,IAAWD,EAAkB;AAC/B,IAAAA,EAAkB,MAAM,KAEnBF,EAAAG,CAAQ,IAAI,CAAC,GACbF,IAAAE,KAEHF,KACDD,EAAOC,CAAI,EAAe,KAAKE,CAAQ;AAAA,EAE5C;AAEJ,GAEME,KAAgB,CAAC3I,GAAcsI,MAAoB;AAGvD,aAAWE,KAAqBxI;AAE9B,QAAIwI,EAAkB,MAAM,KAAKA,EAAkB,MAAM,GAAG;AAC1D,MAAAF,EAAO,SAAS;AAChB;AAAA,IAAA;AAGN,GAEMM,KAAiB,CAAC5I,GAAcsI,MAAoB;AACxD,aAAWE,KAAqBxI;AAE9B,QAAI,EAAAwI,EAAkB,MAAM,KAAKA,EAAkB,MAAM,MAGrDA,EAAkB,MAAM;AACtB,UAAA;AACF,YAAI,CAACK;AACG,gBAAA,IAAI,MAAM,oCAAoC;AAEtD,cAAMzD,IAAO,OAAO,KAAKoD,EAAkB,GAAa,QAAQ;AAChE,QAAAF,IAASO,EAAOzD,CAAI;AAAA,cACV;AACV,QAAAkD,IAAS,CAAC;AAAA,MAAA;AAIT,SAAAA;AACT,GAEMQ,KAAc,CAAC9I,GAAcsI,MAAoB;AACrD,aAAWE,KAAqBxI;AAE9B,QAAI,EAAAwI,EAAkB,MAAM,KAAKA,EAAkB,MAAM,MAGrDA,EAAkB,MAAM;AACtB,UAAA;AACO,QAAAF,IAAA,KAAK,MAAME,EAAkB,CAAW;AAAA,cACvC;AACV,QAAAF,IAAS,CAAC;AAAA,MAAA;AAIT,SAAAA;AACT,GAEMS,KAAa,CAAC/I,GAAcsI,MAAoB;AACpD,MAAIC,IAAO;AACX,aAAWC,KAAqBxI,GAAM;AAGlC,QAAA,CAACwI,EAAkB,KACnBA,EAAkB,MAAM,KACxBA,EAAkB,MAAM;AAExB;AAGF,UAAMC,IAAWD,EAAkB;AAC/B,QAAAA,EAAkB,IAAI,MAAM;AAE9B,MAAAF,EAAOG,CAAQ,IAAI,IACZF,IAAAE;AAAA,SACF;AAEL,UAAI,CAACF;AACH,cAAM,IAAI,MAAM,sCAAsCA,CAAI,EAAE;AAE9D,MAAAD,EAAOC,CAAI,IAAIE;AAAA,IAAA;AAAA,EACjB;AAEJ,GAEM1H,KAAU,CAAC,EAAE,SAAApB,GAAS,MAAAK,GAAM,IAAAC,QAAuB;AAGrD,MAAAD,EAAK,CAAC,EAAE,MAAM0B,KACd,CAAC1B,EAAK,CAAC,KACP,CAACA,EAAK,CAAC,EAAE,KACT,CAACA,EAAK,CAAC,KACP,CAACA,EAAK,CAAC,EAAE;AAET,UAAM,IAAI,MAAM,uBAAuBC,CAAE,EAAE;AAG7C,MAAIqI,IAAS,CAAC;AAGd,QAAMU,IAAkB,CAAC;AACzB,MAAIC,IAAmB;AACvB,WAAStF,IAAI,GAAGA,IAAI3D,EAAK,QAAQ2D;AAC/B,IAAI3D,EAAK2D,CAAC,EAAE,MAAM,QAChBsF,OAEKD,EAASC,CAAgB,MAAYD,EAAAC,CAAgB,IAAI,CAAC,IAC/DjJ,EAAK2D,CAAC,EAAE,IAAIqF,EAASC,CAAgB,EAAE,SAAS,GAChDD,EAASC,CAAgB,EAAE,KAAKjJ,EAAK2D,CAAC,CAAC;AAK3C,QAAMuF,IAAY,OAAO,KAAKnJ,GAAe,CAAC,CAAC,EAAE,CAAC;AAGlD,EAAAuI,EAAOY,CAAS,IAAIF,EAAS,CAAC,EAAE,CAAC,EAAE;AAEnC,aAAW3J,KAAM2J;AASf,YAPA3J,EAAG,QAAQ;AAAA,MACT,GAAGqC;AAAAA,MACH,GAAG;AAAA,IAAA,CACJ,GAEerC,EAAG,CAAC,EAAE,GAEL;AAAA;AAAA,MAEf,KAAK,OAAO;AACV,QAAAgJ,GAAWhJ,GAAIiJ,CAAM;AACrB;AAAA,MAAA;AAAA,MAEF,KAAK,UAAU;AACN,QAAAA,EAAA,MAAMjJ,EAAG,CAAC,EAAE;AACnB;AAAA,MAAA;AAAA,MAEF,KAAK,UAAU;AACb,QAAAqJ,GAAerJ,GAAIiJ,CAAM;AACzB;AAAA,MAAA;AAAA,MAEF,KAAK;AAGH;AAAA,MAEF,KAAK,UAAU;AACb,QAAAK,GAActJ,GAAIiJ,CAAM;AACxB;AAAA,MAAA;AAAA,MAEF,KAAK,WAAW;AACL,QAAAA,IAAAM,GAAevJ,GAAIiJ,CAAM;AAClC;AAAA,MAAA;AAAA,MAEF,KAAK,QAAQ;AACF,QAAAA,IAAAQ,GAAYzJ,GAAIiJ,CAAM;AAC/B;AAAA,MAAA;AAAA,MAEF,KAAK,OAAO;AACV,QAAAS,GAAW1J,GAAIiJ,CAAM;AACrB;AAAA,MAAA;AAAA,IAIF;AAIa,EAAA5I,EAAAC,GAAS,OAAO2I,CAAM;AACzC,GAEaa,KAAgB;AAAA,EAC3B,MAAM;AAAA,EAAA,SACNzH;AAAAA,EAAA,gBACA3B;AAAAA,EACAgB,SAAAA;AACF,GC9NM,EAAE,SAAAM,IAAS,OAAAC,GAAA,IAAUG,GAErBC,KAAU,QAEV3B,KAAiB;AAAA,EACrB,EAAE,SAAS,SAAS;AAAA,EACpB,EAAE,QAAQ,SAAS;AAAA,EACnB,EAAE,MAAM,SAAS;AACnB,GAEaqJ,IAAsB,OAAOC,GAAWpJ,MAAe;AAElE,QAAMkD,IAAM,OAAO,KAAKkG,IAAIpJ,CAAE,GACxBqJ,IAAU7E,EAAK,OAAOpD,GAAQ8B,CAAG,CAAC;AACxC,SAAO7B,GAAMgI,CAAO;AACtB,GAEMvI,KAAU,OAAO,EAAE,SAAApB,GAAS,MAAAK,GAAM,IAAAC,QAAuB;AAE3D,MAAA,CAACD,EAAK,UACNA,EAAK,CAAC,EAAE,MAAM,UACd,CAACA,EAAK,CAAC,KACP,CAACA,EAAK,CAAC,EAAE,KACT,CAACA,EAAK,CAAC,KACP,CAACA,EAAK,CAAC,EAAE,KACT,CAACC;AAED,UAAM,IAAI,MAAM,sBAAsBA,CAAE,EAAE;AAItC,QAAAsJ,IAAS,MAAMH,EAAoBpJ,EAAK,CAAC,EAAE,GAAGC,EAAG,GAAG,CAAC,GAErDuJ,IAAO;AAAA,IACX,GAAGxJ,EAAK,CAAC,EAAE;AAAA,IACX,IAAIC,EAAG,GAAG;AAAA,IACV,IAAIsJ;AAAA,EACN;AACA,MAAIE,IAAS,CAAC;AACd,MAAIxJ,EAAG,IAAI;AACT,UAAMyJ,IAAW,MAAMN,EAAoBnJ,EAAG,GAAG,CAAC,EAAE,EAAE,GAAGD,EAAK,CAAC,EAAE,CAAC;AAEzD,IAAAyJ,IAAA;AAAA,MACP,GAAGxJ,EAAG,GAAG,CAAC,EAAE,EAAE;AAAA,MACd,IAAID,EAAK,CAAC,EAAE;AAAA,MACZ,IAAI0J;AAAA,IACN;AAAA,EAAA;AAGE,EAAC/J,EAAQ,YACXA,EAAQ,UAAU,CAAC,IAErBA,EAAQ,QAAQ,KAAK;AAAA,IACnB,MAAA6J;AAAA,IACA,QAAAC;AAAA,EAAA,CACU;AACd,GAEaE,KAAoB;AAAA,EAC/B,MAAM;AAAA,EAAA,SACNjI;AAAAA,EAAA,gBACA3B;AAAAA,EACAgB,SAAAA;AACF,GC9DMJ,KAAgB,CAACX,MAAiB;AAClC,MAAAA,EAAK,SAAS;AAET,WAAA;AAIT,QAAM4J,IAAWC,EAAU7J,GAAM,CAACV,MAAYA,EAAE,QAAQ,OAAO,GACzDwK,IAASD;AAAA,IACb7J;AAAA,IACA,CAACV,GAASqE,MAAcA,IAAIiG,KAAYtK,EAAE,QAAQ;AAAA,EACpD,GACMyK,IAAY/J,EAAK,MAAM4J,GAAUE,CAAM,GACvCE,IAAWhK,EAAK4J,IAAW,CAAC;AAClC,UACEI,KAAA,gBAAAA,EAAU,QAAO,KACjB,CAAC,CAACD,EAAU,CAAC,KACb,CAAC,CAACA,EAAU,CAAC,KACbA,EAAU,CAAC,EAAE,KAAK;AAEtB,GAEMhJ,KAAU,CAAC,EAAE,SAAApB,GAAS,MAAAK,GAAM,KAAAgB,QAA8B;AAC9D,MAAI,CAAChB,EAAK,CAAC,KAAK,CAACgB;AACT,UAAA,IAAI,MAAM,yDAAyD;AAS3E,QAAM4I,IAAWC,EAAU7J,GAAM,CAACV,MAAYA,EAAE,QAAQ,OAAO,GACzDwK,IACJD;AAAA,IACE7J;AAAA,IACA,CAACV,GAASqE,MAAcA,IAAIiG,KAAYtK,EAAE,QAAQ;AAAA,EAAA,IAChD,GACAyK,IAAY/J,EAAK,MAAM4J,GAAUE,CAAM;AAE7C,MAAI,CAACC,EAAU,CAAC,KAAK,CAACA,EAAU,CAAC,KAAKA,EAAU,CAAC,EAAE,MAAM;AACjD,UAAA,IAAI,MAAM,mCAAmC;AAGjD,MAAAlK,GACAoK;AAYJ,MAXAF,EAAU,QAAQ,CAACG,GAAM9J,GAAK+J,MAAQ;AAEhC,IAAAD,EAAK,QAAQ,WACDD,IAAAE,EAAI/J,IAAM,CAAC,EAAE,IAGzB8J,EAAK,QAAQ,WACRrK,IAAAsK,EAAI/J,IAAM,CAAC,EAAE;AAAA,EACtB,CACD,GAEG,CAACP;AACG,UAAA,IAAI,MAAM,mBAAmB;AAErC,MAAI,CAACoK;AACG,UAAA,IAAI,MAAM,2BAA2B;AAQ5B,EAAAvK,EAAAC,GAAS,OALF;AAAA,IACtB,MAAAE;AAAA,IACA,aAAAoK;AAAA,EACF,CAEuC;AACzC,GAEaG,IAAgB;AAAA,EAC3B,MAAM;AAAA,EAAA,SACNrJ;AAAAA,EACA,eAAAJ;AACF;AAEA,SAASkJ,EAAUQ,GAAcC,GAAqB;AAC7C,SAAAC,GAAcF,GAAOC,CAAS;AACvC;AACA,SAASC,GAAcF,GAAcC,GAAqBE,GAAoB;AAC5E,QAAMrK,IAASkK,KAAS,OAAO,IAAIA,EAAM;AACzC,MAAI,CAAClK;AACI,WAAA;AAET,MAAIqD,IAAQrD,IAAS;AAMrB,SAAOsK,GAAcJ,GAAOC,GAAW9G,CAAW;AACpD;AAEA,SAASiH,GACPJ,GACAC,GACAE,GACAE,GACA;AAEI,MAAAlH,IAAQgH,IAAyB;AAErC,SAAmBhH;AACjB,QAAI8G,EAAUD,EAAM7G,CAAK,GAAGA,GAAO6G,CAAK;AAC/B,aAAA7G;AAGJ,SAAA;AACT;ACtHA,MAAM9B,KAAU,sCAEV3B,KAAiB;AAAA,EACrB,EAAE,MAAM,OAAO;AAAA,EACf,EAAE,SAAS,SAAS;AAAA,EACpB,EAAE,WAAW,SAAS;AACxB,GAEMgB,KAAU,CAAC,EAAE,SAAApB,GAAS,MAAAK,GAAM,IAAAC,QAAuB;AACvD,MACED,EAAK,CAAC,EAAE,MAAM0B,MACd,CAAC1B,EAAK,CAAC,KACP,CAACA,EAAK,CAAC,KACP,CAACA,EAAK,CAAC,KACP,CAACA,EAAK,CAAC,EAAE,KACT,CAACA,EAAK,CAAC,EAAE,KACT,CAACA,EAAK,CAAC,EAAE;AAET,UAAM,IAAI,MAAM,sBAAsBC,KAAA,gBAAAA,EAAI,GAAG,CAAC,EAAE;AAGlD,QAAM0K,IAAO,KAAK,MAAM3K,EAAK,CAAC,EAAE,CAAC,GAC3B4K,IAAY,OAAO5K,EAAK,CAAC,EAAE,CAAC;AAElC,EAAAN,EAAiBC,GAAS,OAAO;AAAA,IAC/B,MAAAgL;AAAA,IACA,SAAS3K,EAAK,CAAC,EAAE;AAAA,IACjB,WAAA4K;AAAA,EAAA,CACD;AACH,GAEaC,KAAgB;AAAA,EAC3B,MAAM;AAAA,EAAA,SACNnJ;AAAAA,EAAA,gBACA3B;AAAAA,EACAgB,SAAAA;AACF,GCpCMW,KAAU,qCAEV3B,KAAiB,CAAC,EAAE,KAAK,UAAU,GAEnCgB,KAAU,CAAC,EAAE,SAAApB,GAAS,MAAAK,GAAM,IAAAC,QAAuB;AACvD,MAAID,EAAK,CAAC,EAAE,MAAM0B,MAAW,CAAC1B,EAAK,CAAC,KAAK,CAACA,EAAK,CAAC,EAAE;AAChD,UAAM,IAAI,MAAM,qBAAqBC,CAAE,EAAE;AAG1B,EAAAP,EAAAC,GAAS,SAAS,EAAE,KAAKK,EAAK,CAAC,EAAE,GAAG;AACvD,GAEa8K,KAAQ;AAAA,EACnB,MAAM;AAAA,EACN,SAAApJ;AAAA,EACA,gBAAA3B;AAAA,EACA,SAAAgB;AACF,GCaMgK,KAAmB,oBAAI,IAAoB,EAAE,GAE7CC,KAAmB,oBAAI,IAAqB,EAAE,GAE9CC,KAAyB,oBAAI,IAA2B,EAAE,GAC1DC,yBAA8B,IAAsB,GAE7CC,KAAe;AAAA,EAC1BrF;AAAA,EACAI;AAAA,EACAC;AAAA,EACAgD;AAAA,EACAQ;AAAA,EACAvI;AAAA,EACAkF;AAAA,EACAuB;AAAA,EACAM;AAAA,EACAC;AAAA,EACAyC;AAAA,EACAC;AAAA,EACAV;AACF,GAEagB,KAAqBD,GAAa,IAAI,CAACE,MAAMA,EAAE,IAAI,GACnDC,KAAmB,CAACxF,GAAKI,GAAGC,GAAKgD,IAAKQ,IAASS,CAAG;AAG/D,WAAWzE,KAAY2F;AACrB,EAAI3F,EAAS,WACXoF,GAAiB,IAAIpF,EAAS,SAASA,EAAS,IAAI,GAEtDqF,GAAiB,IAAIrF,EAAS,MAAMA,EAAS,OAAO,GAChDA,EAAS,kBACXuF,GAAwB,IAAIvF,EAAS,MAAMA,EAAS,cAAc,GAEhEA,EAAS,iBACXsF,GAAuB,IAAItF,EAAS,MAAMA,EAAS,aAAa;AAK7D,MAAM4F,GAAK;AAAA,EAChB;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA,cAAc;AAEZ,SAAK,mBAAmBR,IACxB,KAAK,mBAAmBC,IACxB,KAAK,yBAAyBC,IAC9B,KAAK,0BAA0BC;AAAA,EAAA;AAAA,EAGjC,mBAAmB;AAAA,IACjB,MAAAM;AAAA,IACA,SAAA9J;AAAA,IACA,gBAAA3B;AAAA,IACA,SAAAgB;AAAA,IACA,eAAAJ;AAAA,EAAA,GACW;AACX,IAAIe,KACG,KAAA,iBAAiB,IAAIA,GAAS8J,CAAI,GAEpC,KAAA,iBAAiB,IAAIA,GAAMzK,CAAO,GACnChB,KACG,KAAA,wBAAwB,IAAIyL,GAAMzL,CAAc,GAEnDY,KACG,KAAA,uBAAuB,IAAI6K,GAAM7K,CAAa;AAAA,EACrD;AAAA,EAGF,cAAc,OAAOV,MAAuC;AAC1D,QAAI,CAACA,KAAM,CAACA,EAAG,MAAM,CAACA,EAAG;AACjB,YAAA,IAAI,MAAM,mBAAmB;AAIrC,QAAIN,IAA0B,CAAC;AAE/B,eAAW,CAAC8L,GAAKtH,CAAG,KAAK,OAAO,QAAQlE,CAAE;AACxC,UAAIwL,MAAQ;AAEC,mBAAAzK,KAAOf,EAAG,KAAK;AAClB,gBAAA,EAAE,MAAAqD,MAAStC;AAGjB,UAAIsC,KAAA,QAAAA,EAAM,KAAK,CAACjE,MAAOD,GAAcC,CAAE,OACrCM,IAAU,MAAM,KAAK,qBAAqB2D,GAAMtC,GAAKf,GAAIN,CAAO;AAIlE,gBAAM+L,IAAe,KAAK,uBAAuB,IAAItK,EAAM,IAAI,GACzDuK,IAAa,KAAK,uBAAuB,IAAIvB,EAAI,IAAI;AAIzD,cAAA9G,KAAA,QAAAA,EAAM,KAAK,CAACjE,MAAO;AACX,kBAAA,EAAE,MAAAW,MAASX;AAKb,gBAJAqM,KAAA,QAAAA,EAAe1L,MAIf2L,KAAA,QAAAA,EAAa3L;AAER,qBAAA;AAAA,UACT;AAKF,uBAAW4D,KAAiBN,GAAM;AAC1B,oBAAA,EAAE,MAAAtD,MAAS4D;AAEjB,kBAAI,CAAC5D;AACG,sBAAA,IAAI,MAAM,0BAA0B;AAE5C,kBAAIJ,IAAe;AACf,kBAAA8L,KAAA,QAAAA,EAAe1L;AACjB,gBAAAJ,IAAewB,EAAM;AAAA,uBACZuK,KAAA,QAAAA,EAAa3L;AACtB,gBAAAJ,IAAewK,EAAI;AAAA;AAGnB;AAGF,mBAAK,QAAQxK,GAAc;AAAA,gBACzB,IAAAK;AAAA,gBACA,MAAAD;AAAA,gBACA,SAAAL;AAAA,gBACA,MAAA2D;AAAA,gBACA,KAAAtC;AAAA,cAAA,CACD;AAAA,YAAA;AAAA,QAEL;AAAA,UAEJ,CAAWyK,MAAQ,OACjB9L,EAAQ8L,CAAG,IAAItH,EAAI,IAAI,CAACyH,MAAU;AAC1B,cAAAC,IAAI,EAAE,GAAGD,EAAE;AACjB,sBAAOC,EAAE,MACFA;AAAA,MAAA,CACR,IAGDlM,EAAQ8L,CAAG,IAAItH;AAKf,QAAAxE,EAAQ,WAAYM,EAAa,QAAQ;AAC3C,YAAM6L,IAAO;AAAA,QACX,UAAW7L,EAAa;AAAA,QACxB,QAASA,EAAa;AAAA,QACtB,OAAQA,EAAa;AAAA,QACrB,MAAOA,EAAa;AAAA,MACtB;AACC,MAAAN,EAAQ,QAAsB,KAAKmM,CAAI,GAExC,OAAOnM,EAAQ,UACf,OAAOA,EAAQ,OACf,OAAOA,EAAQ,QACf,OAAOA,EAAQ,MACf,OAAOA,EAAQ;AAAA,IAAA;AAGV,WAAAA;AAAA,EACT;AAAA,EAEA,iBAAiB,CAAC8L,GAAa9L,GAA0BqB,MAAa;AAEpE,IAAIyK,KAAO,CAAC9L,EAAQ8L,CAAG,MACb9L,EAAA8L,CAAG,IAAI,CAAC,IAEjB9L,EAAQ8L,CAAG,EAAY,KAAK;AAAA,MAC3B,GAAGzK,EAAI;AAAA,MACP,GAAGA,EAAI;AAAA,MACP,MAAM,CAAA;AAAA,IAAC,CACR;AAAA,EACH;AAAA,EAEA,UAAU,OACRpB,GACA,EAAE,MAAAI,GAAM,SAAAL,GAAS,MAAA2D,GAAM,KAAAtC,GAAK,IAAAf,QACzB;AAED,QAAA,KAAK,iBAAiB,IAAIL,CAAY,KACtC,OAAO,KAAK,iBAAiB,IAAIA,CAAY,KAAM,YACnD;AACA,YAAMmB,IAAU,KAAK,iBAAiB,IAAInB,CAAY;AACtD,MAAImB,KAEF,MAAMA,EAAQ;AAAA,QACZ,SAAApB;AAAA,QACA,MAAAK;AAAA,QACA,MAAAsD;AAAA,QACA,KAAAtC;AAAA,QACA,IAAAf;AAAA,MAAA,CACD;AAAA,IACH;AAEiB,MAAAP,EAAAC,GAASC,GAAcI,CAAI;AAAA,EAEhD;AAAA,EAEA,uBAAuB,OACrBsD,GACAtC,GACAf,GACAN,MAC4B;;AAE5B,eAAWiE,KAAiBN,GAAM;AAC1B,YAAA,EAAE,MAAAtD,MAAS4D;AACjB,UAAI,CAAC5D;AACG,cAAA,IAAI,MAAM,0BAA0B;AAIxC,UAAAT,EAAqBqE,CAAa;AACpC;AAGI,YAAAhB,IAAS5C,EAAK,CAAC,EAAE;AAEvB,UAAI4C,GAAQ;AACV,cAAMmJ,IACJ,KAAK,iBAAiB,IAAInJ,CAAM,OAChCnD,IAAA6L,GAAiB,OAAO,CAACD,MAAMA,EAAE,SAASzI,CAAM,EAAE,CAAC,MAAnD,gBAAAnD,EAAsD;AACxD,QAAIsM,IACI,MAAA,KAAK,QAAQA,GAAgB;AAAA,UACjC,MAAA/L;AAAA,UACA,SAAAL;AAAA,UACA,MAAA2D;AAAA,UACA,KAAAtC;AAAA,UACA,IAAAf;AAAA,QAAA,CACD,IAEI,KAAA,eAAe2C,GAAQjD,GAASqB,CAAG;AAAA,MAC1C;AAAA,IACF;AAEK,WAAArB;AAAA,EACT;AACF;AAEa,MAAAqM,KAAa,OAAO/K,MAAkC;AAC3D,QAAAgL,IAAM,+CAA+ChL,CAAI;AAEvD,iBAAA,IAAI,WAAWgL,CAAG,GAGnB,OADK,MAAM,MAAMA,CAAG,GACV,KAAK;AACxB,GAEaC,KAAe,OAAOC,MACnB,MAAMC,GAAM;AAAA,EACxB,IAAI,EAAE,GAAGD,EAAM;AAAA,EACf,OAAO;AAAA,IACL;AAAA,MACE,OAAO,EAAE,IAAI,IAAI;AAAA,MACjB,SAAS;AAAA,IACX;AAAA,IACA;AAAA,MACE,OAAO,EAAE,GAAG,IAAI;AAAA,IAAA;AAAA,EAClB;AACF,CACD,GASUE,KAAc,OACzBpM,GACAqM,MACG;AACC,MAAA,OAAOrM,KAAO,UAAU;AACtB,QAAAkM;AAOJ,QALIlM,EAAG,WAAW,OAERkM,IAAA,MAAMH,GAAW/L,CAAE,IAGzB,OAAO,KAAKA,CAAE,EAAE,cAAc;AAC1B,YAAA,IAAI,MAAM,eAAe;AAGjC,IAAKkM,MACKA,IAAAlM;AAIJ,UAAAsM,IAAQ,MAAML,GAAaC,CAAK;AAEtC,QAAII;AACG,MAAAtM,IAAAsM;AAAA;AAEC,YAAA,IAAI,MAAM,cAAc;AAAA,EAChC;AAGI,QAAAnI,IAAI,IAAImH,GAAK;AAGnB,MAAIe;AAGE,QADJlI,EAAE,iBAAiB,MAAM,GACrBvF,GAAcyN,CAAS;AAEzB,iBAAW3G,KAAYwF;AACrB,QAAKmB,KAAA,QAAAA,EAAwB,SAAS3G,EAAS,SAC7CvB,EAAE,mBAAmBuB,CAAQ;AAAA,aAGxB3G,GAAcsN,CAAS;AAChC,iBAAWjB,KAAKiB,GAAW;AACzB,cAAM3G,IAAW0F;AACjB,QAAI1F,KACFvB,EAAE,mBAAmBuB,CAAQ;AAAA,MAC/B;AAAA;AAGF,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAIG,SAAAvB,EAAE,YAAYnE,CAAE;AACzB;"}