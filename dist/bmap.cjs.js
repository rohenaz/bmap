"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const we=require("bpu-ts"),u=require("@bsv/sdk"),L=require("@msgpack/msgpack"),{toArray:Et}=u.Utils,Se=t=>t.length>0&&t.every(e=>typeof e=="string"),Ee=t=>t.length>0&&t.every(e=>e==="object"),P=(t,e)=>{if(!t)throw new Error(`cannot get cell value of: ${t}`);return e==="string"?t.s?t.s:t.ls||"":e==="hex"?t.h?t.h:t.lh||(t.b?Buffer.from(t.b,"base64").toString("hex"):t.lb&&Buffer.from(t.lb,"base64").toString("hex"))||"":e==="number"?Number.parseInt(t.h?t.h:t.lh||"0",16):e==="file"?`bitfs://${t.f?t.f:t.lf}`:e==="binary"?t.b||t.lb||"":(t.b?t.b:t.lb)||""},ve=t=>t.cell.some(e=>e.op===106),Y=t=>{var r;if(t.cell.length!==2)return!1;const e=t.cell.findIndex(n=>n.op===106);return e!==-1?((r=t.cell[e-1])==null?void 0:r.op)===0:!1},S=(t,e,r)=>{if(!t[e])t[e]=[r];else{if(!Array.isArray(t[e])){const n=t[e];t[e]=[],t[e][0]=n}t[e].push(r)}},Pe=(t,e,r,n,s)=>{const o={},c=e.length+1;if(n.length<c)throw new Error(`${t} requires at least ${c} fields including the prefix: ${s.tx.h}`);for(const[a,l]of Object.entries(e)){const f=Number.parseInt(a,10),[d]=Object.keys(l),[g]=Object.values(l);o[d]=P(n[f+1],g)}S(r,t,o)},xe=t=>{const e="(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+/]{3}=)?";return new RegExp(`^${e}$`,"gi").test(t)},Ae=(t,e)=>t.length===e.length&&t.every((r,n)=>r===e[n]),K="OP_SIZE <OP_X_PLACEHOLDER> OP_PICK OP_SHA256 OP_SWAP OP_SPLIT OP_DROP OP_EQUALVERIFY OP_DROP OP_CHECKSIG".split(" "),Ie=t=>{if(t.length!==12)return!1;const e=[...t].map(s=>s.ops).splice(2,t.length),r=P(t[1],"hex"),n=Buffer.from(r).byteLength;return e[1]=`OP_${n}`,K[1]=`OP_${n}`,e.join()===K.join()},Be=({dataObj:t,cell:e,out:r})=>{if(!e[0]||!r)throw new Error("Invalid 21e8 tx. dataObj, cell, out and tx are required.");const n=P(e[0],"hex"),s=P(e[1],"hex");if(!s)throw new Error(`Invalid 21e8 target. ${JSON.stringify(e[0],null,2)}`);const o=Buffer.from(s,"hex").byteLength,c={target:s,difficulty:o,value:r.e.v,txid:n};S(t,"21E8",c)},T={name:"21E8",handler:Be,scriptChecker:Ie},{toArray:b,toHex:$,fromBase58Check:F,toBase58Check:q}=u.Utils,Z="15PciHG22SNLQJXMoSUaWVi7WSqc7hCfva",J=[{algorithm:"string"},{address:"string"},{signature:"binary"},[{index:"number[]"}]];function $e(t,e,r){if(!Array.isArray(r)||r.length<3)throw new Error("AIP requires at least 3 cells including the prefix");let n=-1;for(let i=0;i<r.length;i++)if(Ae(r[i].cell,e)){console.log("[validateSignature] found cell in tape"),n=i;break}if(n===-1)throw new Error("AIP could not find cell in tape");console.log("[validateSignature] tape:",r.map(i=>i.cell.map(p=>{var h,m,v;return`c.ii: ${p.ii}, c.h: ${(h=p.h)==null?void 0:h.slice(0,10)}, c.b: ${(m=p.b)==null?void 0:m.slice(0,10)}, c.s: ${(v=p.s)==null?void 0:v.slice(0,10)}`})));let s=t.index||[];const o=[],c=r.flatMap(i=>i.cell).filter(i=>i.ii!==void 0).sort((i,p)=>(i.ii||0)-(p.ii||0)),a=c[0];a==null||a.op,o.push(b("6a","hex"));const l=new Map;for(const i of c)i.ii!==void 0&&l.set(i.ii,i);console.log("[validateSignature] All cells in order:");for(const i of c)console.log(`ii: ${i.ii}, hex: ${i.h}, s: ${i.s}`);if(s.length>0){console.log("[validateSignature] Using indexes:",s);for(let i=0;i<s.length;i++){const p=s[i];if(p===0)continue;const h=c.find(m=>(m.ii||0)===p);if(!h){o.push(b("7c","hex"));continue}if(h.h)o.push(b(h.h,"hex"));else if(h.b)o.push(b(h.b,"base64"));else if(h.s)o.push(b(h.s));else return console.log(`[validateSignature] No usable value found in cell with ii: ${h.ii}`),!1}}else for(let i=1;i<n;i++){const p=r[i].cell;if(!Y({cell:p})){for(const h of p)h.h?o.push(b(h.h,"hex")):h.b?o.push(b(h.b,"base64")):h.s&&o.push(b(h.s));o.push(b("7c","hex"))}}if(t.hashing_algorithm&&t.index_unit_size){const i=t.index_unit_size*2;s=[];const p=e[6].h;for(let h=0;h<p.length;h+=i)s.push(Number.parseInt(p.substr(h,i),16));t.index=s}console.log("[validateSignature] Final signature values:",o.map(i=>$(i)));let f;if(t.hashing_algorithm){t.index_unit_size||o.shift();const i=u.Script.fromHex($(o.flat()));let p=b(i.toHex(),"hex");t.index_unit_size&&(p=p.slice(1)),f=u.Hash.sha256(p)}else f=o.flat();const d=t.address||t.signing_address;if(!d||!t.signature)return!1;let g;try{g=u.Signature.fromCompact(t.signature,"base64")}catch(i){return console.log("[validateSignature] Failed to parse signature:",i),!1}const y=()=>{try{const i=u.BSM.magicHash(f),p=U(i);for(let h=0;h<4;h++)try{const m=g.RecoverPublicKey(h,p),v=m.toHash(),{prefix:I}=F(d);if(q(v,I)===d)return u.BSM.verify(f,g,m)}catch(m){console.log("[tryNormalLogic] Recovery error:",m)}}catch(i){console.log("[tryNormalLogic] error:",i)}return!1},w=()=>{if(o.length<=2)return!1;try{const i=o.slice(1,-1),p=u.Hash.sha256(i.flat()),h=$(p),m=b(h,"utf8"),v=u.BSM.magicHash(m),I=U(v);for(let x=0;x<4;x++)try{const A=g.RecoverPublicKey(x,I),B=A.toHash(),{prefix:R}=F(d);if(q(B,R)===d)return u.BSM.verify(m,g,A)}catch(A){console.log("[tryTwetchLogic] Recovery error:",A)}}catch(i){console.log("[tryTwetchLogic] error:",i)}return!1};let E=y();return E||(E=w()),t.verified=E,E}function U(t){const e=$(t);return new u.BigNumber(e,16)}var G=(t=>(t.HAIP="HAIP",t.AIP="AIP",t))(G||{});const D=async(t,e,r,n,s)=>{const o={};if(n.length<4)throw new Error("AIP requires at least 4 fields including the prefix");for(const[c,a]of Object.entries(t)){const l=Number.parseInt(c,10);if(Array.isArray(a)){const[f]=Object.keys(a[0]);console.log("[AIPhandler] aipField:",f);const d=[];for(let g=l+1;g<n.length;g++)n[g].h&&Array.isArray(d)&&d.push(Number.parseInt(n[g].h||"",16));console.log("[AIPhandler] fieldData:",d),o[f]=d}else{const[f]=Object.keys(a),[d]=Object.values(a);o[f]=P(n[l+1],d)||""}}if(n[0].s===Z&&n[3].s&&xe(n[3].s)&&(o.signature=n[3].s),!o.signature)throw new Error("AIP requires a signature");return $e(o,n,s),S(r,e,o),{dataObj:r,cell:n,tape:s}},ke=async({dataObj:t,cell:e,tape:r})=>{if(!r)throw new Error("Invalid AIP transaction. tape is required");return D(J,"AIP",t,e,r)},W={name:"AIP",address:Z,opReturnSchema:J,handler:ke},He="19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut",C=[{content:["string","binary","file"]},{"content-type":"string"},{encoding:"string"},{filename:"string"}],Re=({dataObj:t,cell:e,tx:r})=>{var o;const n=new Map;if(n.set("utf8","string"),n.set("text","string"),n.set("gzip","binary"),n.set("text/plain","string"),n.set("image/png","binary"),n.set("image/jpeg","binary"),n.set("application/octet-stream","binary"),!e[1]||!e[2])throw new Error(`Invalid B tx: ${r}`);if(e.length>C.length+1)throw new Error("Invalid B tx. Too many fields.");const s={};for(const[c,a]of Object.entries(C)){const l=Number.parseInt(c,10),f=Object.keys(a)[0];let d=Object.values(a)[0];if(f==="content")if(e[1].f)d="file";else if((!e[3]||!e[3].s)&&e[2].s)d=n.get(e[2].s),d||(d="binary"),e[3]||(e[3]={h:"",b:"",s:"",i:0,ii:0}),e[3].s=d==="string"?"utf-8":"binary";else{const y=(o=e[3])!=null&&o.s?n.get(e[3].s.replace("-","").toLowerCase()):null;y?d=y:d="binary"}if(f==="encoding"&&!e[l+1]||f==="filename"&&!e[l+1])continue;if(!e||!e[l+1])throw new Error(`malformed B syntax ${e}`);const g=e[l+1];s[f]=P(g,d)}S(t,"B",s)},X={name:"B",address:He,opReturnSchema:C,handler:Re},Me="1BAPSuaPnfGnSBM3GLV9yhxUdYe4vGbdMT",j=[{type:"string"},{hash:"string"},{sequence:"string"}],Te=({dataObj:t,cell:e,tx:r})=>{if(!r)throw new Error("Invalid BAP tx, tx required");Pe("BAP",j,t,e,r)},ee={name:"BAP",address:Me,opReturnSchema:j,handler:Te},Ce="$",Oe=[{su:[{pubkey:"string"},{sign_position:"string"},{signature:"string"}],echo:[{data:"string"},{to:"string"},{filename:"string"}],route:[[{add:[{bitcom_address:"string"},{route_matcher:"string"},{endpoint_template:"string"}]},{enable:[{path:"string"}]}]],useradd:[{address:"string"}]}],_e=({dataObj:t,cell:e})=>{if(!e.length||!e.every(n=>n.s))throw new Error("Invalid Bitcom tx");const r=e.map(n=>n!=null&&n.s?n.s:"");S(t,"BITCOM",r)},Ne={name:"BITCOM",address:Ce,opReturnSchema:Oe,handler:_e},{toArray:V,toBase58Check:M,toHex:Le}=u.Utils,{magicHash:Ke}=u.BSM,te="13SrNDkVzY5bHBRKNu5iXTQ7K7VqTh5tJC",re=[{bitkey_signature:"string"},{user_signature:"string"},{paymail:"string"},{pubkey:"string"}];function Fe(t){const e=Le(t);return new u.BigNumber(e,16)}function z(t,e){const r=Ke(t),n=Fe(r);for(let s=0;s<4;s++)try{const o=e.RecoverPublicKey(s,n);if(u.BSM.verify(t,e,o))return o}catch{}throw new Error("Failed to recover public key from BSM signature")}const qe=async({dataObj:t,cell:e})=>{if(e.length<5)throw new Error("Invalid Bitkey tx");const r={};for(const[A,B]of Object.entries(re)){const R=Number.parseInt(A,10),N=Object.keys(B)[0],be=Object.values(B)[0];r[N]=P(e[R+1],be)}const n=r.pubkey,o=u.PublicKey.fromString(n).toHash(),c=M(o),l=Buffer.from(r.paymail).toString("hex")+n,f=Buffer.from(l,"hex"),d=u.Hash.sha256(V(f)),g=u.Signature.fromCompact(r.bitkey_signature,"base64"),y=z(d,g),w=y.toHash(),E=M(w),i=u.BSM.verify(d,g,y)&&E===te,p=V(Buffer.from(n,"utf8")),h=u.Signature.fromCompact(r.user_signature,"base64"),m=z(p,h),v=m.toHash(),I=M(v),x=u.BSM.verify(p,h,m)&&I===c;r.verified=i&&x,S(t,"BITKEY",r)},Ue={name:"BITKEY",address:te,opReturnSchema:re,handler:qe},{magicHash:Ve}=u.BSM,{toArray:ze}=u.Utils,ne="18pAqbYqhzErT6Zk3a5dwxHtB9icv8jH2p",Qe=[{paymail:"string"},{pubkey:"binary"},{signature:"string"}],Ye=async({dataObj:t,cell:e,tape:r,tx:n})=>{if(e[0].s!==ne||!e[1]||!e[2]||!e[3]||!e[1].s||!e[2].b||!e[3].s||!r)throw new Error(`Invalid BITPIC record: ${n}`);const s={paymail:e[1].s,pubkey:Buffer.from(e[2].b,"base64").toString("hex"),signature:e[3].s||"",verified:!1};if(r[1].cell[0].s==="19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut")try{const c=e[1].lb||e[1].b,a=u.Hash.sha256(ze(c,"base64")),l=u.Signature.fromCompact(s.signature,"base64"),f=u.PublicKey.fromString(s.pubkey),d=Ve(a);s.verified=u.BSM.verify(d,l,f)}catch{s.verified=!1}S(t,"BITPIC",s)},Ze={name:"BITPIC",address:ne,opReturnSchema:Qe,handler:Ye},Je="1HA1P2exomAwCUycZHr8WeyFoy5vuQASE3",se=[{algorithm:"string"},{algorithm:"string"},{address:"string"},{signature:"string"},{algorithm:"string"},[{index:"binary"}]],Ge=async({dataObj:t,cell:e,tape:r,tx:n})=>{if(!r)throw new Error("Invalid HAIP tx. Bad tape");if(!n)throw new Error("Invalid HAIP tx.");return await D(se,G.HAIP,t,e,r)},De={name:"HAIP",address:Je,opReturnSchema:se,handler:Ge},O="1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5",oe=[{cmd:{SET:[{key:"string"},{val:"string"}],SELECT:[{tx:"string"}],ADD:[{key:"string"},[{val:"string"}]],DELETE:[{key:"string"},[{val:"string"}]],JSON:"string",REMOVE:[[{key:"string"}]],CLEAR:[[{txid:"string"}]]}}],We=(t,e)=>{let r=null;for(const n of t){if(n.i===0||n.i===1)continue;const s=n.s;n.i===2?(e[s]=[],r=s):r&&Array.isArray(e[r])&&e[r].push(s)}},Xe=(t,e)=>{let r=null;for(const n of t){if(n.i===0||n.i===1)continue;const s=n.s;n.i===2?(e[s]=[],r=s):r&&e[r].push(s)}},je=(t,e)=>{for(const r of t)(r.i===0||r.i===1)&&(e.SELECT="TODO")},et=(t,e)=>{for(const r of t)if(!(r.i===0||r.i===1)&&r.i===2)try{if(!L.decode)throw new Error("Msgpack is required but not loaded");const n=Buffer.from(r.b,"base64");e=L.decode(n)}catch{e={}}return e},tt=(t,e)=>{for(const r of t)if(!(r.i===0||r.i===1)&&r.i===2)try{e=JSON.parse(r.s)}catch{e={}}return e},rt=(t,e)=>{let r=null;for(const n of t){if(!n.s||n.i===0||n.i===1)continue;const s=n.s;if(n.i%2===0)e[s]="",r=s;else{if(!r)throw new Error(`malformed MAP syntax. Cannot parse.${r}`);e[r]=s}}},nt=({dataObj:t,cell:e,tx:r})=>{if(e[0].s!==O||!e[1]||!e[1].s||!e[2]||!e[2].s)throw new Error(`Invalid MAP record: ${JSON.stringify(r,null,2).substring(0,100)}`);let n={};const s=[];let o=0;for(let a=1;a<e.length;a++)e[a].s===":::"?o++:(s[o]||(s[o]=[]),e[a].i=s[o].length+1,s[o].push(e[a]));const c=Object.keys(oe[0])[0];n[c]=s[0][0].s;for(const a of s)switch(a.unshift({s:O,i:0}),a[1].s){case"ADD":{We(a,n);break}case"REMOVE":{n.key=a[2].s;break}case"DELETE":{Xe(a,n);break}case"CLEAR":break;case"SELECT":{je(a,n);break}case"MSGPACK":{n=et(a,n);break}case"JSON":{n=tt(a,n);break}case"SET":{rt(a,n);break}}S(t,"MAP",n)},ie={name:"MAP",address:O,opReturnSchema:oe,handler:nt},{toArray:st,toHex:ot}=u.Utils,it="meta",at=[{address:"string"},{parent:"string"},{name:"string"}],Q=async(t,e)=>{const r=Buffer.from(t+e),n=u.Hash.sha256(st(r));return ot(n)},ct=async({dataObj:t,cell:e,tx:r})=>{if(!e.length||e[0].s!=="meta"||!e[1]||!e[1].s||!e[2]||!e[2].s||!r)throw new Error(`Invalid Metanet tx ${r}`);const n=await Q(e[1].s,r.tx.h),s={a:e[1].s,tx:r.tx.h,id:n};let o={a:"",tx:"",id:""};if(r.in){const c=await Q(r.in[0].e.a,e[2].s);o={a:r.in[0].e.a,tx:e[2].s,id:c}}t.METANET||(t.METANET=[]),t.METANET.push({node:s,parent:o})},ae={name:"METANET",address:it,opReturnSchema:at,handler:ct},ft=t=>{if(t.length<13)return!1;const e=H(t,o=>o.ops==="OP_IF"),r=H(t,(o,c)=>c>e&&o.ops==="OP_ENDIF"),n=t.slice(e,r),s=t[e-1];return(s==null?void 0:s.op)===0&&!!n[0]&&!!n[1]&&n[1].s==="ord"},dt=({dataObj:t,cell:e,out:r})=>{if(!e[0]||!r)throw new Error("Invalid Ord tx. dataObj, cell, out and tx are required.");const n=H(e,f=>f.ops==="OP_IF"),s=H(e,(f,d)=>d>n&&f.ops==="OP_ENDIF")+1,o=e.slice(n,s);if(!o[0]||!o[1]||o[1].s!=="ord")throw new Error("Invalid Ord tx. Prefix not found.");let c,a;if(o.forEach((f,d,g)=>{f.ops==="OP_1"&&(a=g[d+1].s),f.ops==="OP_0"&&(c=g[d+1].b)}),!c)throw new Error("Invalid Ord data.");if(!a)throw new Error("Invalid Ord content type.");const l={data:c,contentType:a};t.ORD||(t.ORD=[]),t.ORD.push(l)},k={name:"ORD",handler:dt,scriptChecker:ft};function H(t,e){return ht(t,e)}function ht(t,e,r){const n=t==null?0:t.length;if(!n)return-1;let s=n-1;return ut(t,e,s)}function ut(t,e,r,n){const{length:s}=t;let o=r+1;for(;o--;)if(e(t[o],o,t))return o;return-1}const ce="1GvFYzwtFix3qSAZhESQVTz9DeudHZNoh1",lt=[{pair:"json"},{address:"string"},{timestamp:"string"}],gt=({dataObj:t,cell:e,tx:r})=>{if(e[0].s!==ce||!e[1]||!e[2]||!e[3]||!e[1].s||!e[2].s||!e[3].s)throw new Error(`Invalid RON record ${r==null?void 0:r.tx.h}`);const n=JSON.parse(e[1].s),s=Number(e[3].s);S(t,"RON",{pair:n,address:e[2].s,timestamp:s})},pt={name:"RON",address:ce,opReturnSchema:lt,handler:gt},fe="1SymRe7erxM46GByucUWnB9fEEMgo7spd",mt=[{url:"string"}],yt=({dataObj:t,cell:e,tx:r})=>{if(e[0].s!==fe||!e[1]||!e[1].s)throw new Error(`Invalid SymRe tx: ${r}`);S(t,"SYMRE",{url:e[1].s})},bt={name:"SYMRE",address:fe,opReturnSchema:mt,handler:yt},de=new Map([]),he=new Map([]),ue=new Map([]),le=new Map,_=[W,X,ee,ie,ae,T,Ne,Ue,Ze,De,pt,bt,k],wt=_.map(t=>t.name),ge=[W,X,ee,ie,ae,k];for(const t of ge)t.address&&de.set(t.address,t.name),he.set(t.name,t.handler),t.opReturnSchema&&le.set(t.name,t.opReturnSchema),t.scriptChecker&&ue.set(t.name,t.scriptChecker);class pe{enabledProtocols;protocolHandlers;protocolScriptCheckers;protocolOpReturnSchemas;constructor(){this.enabledProtocols=de,this.protocolHandlers=he,this.protocolScriptCheckers=ue,this.protocolOpReturnSchemas=le}addProtocolHandler({name:e,address:r,opReturnSchema:n,handler:s,scriptChecker:o}){r&&this.enabledProtocols.set(r,e),this.protocolHandlers.set(e,s),n&&this.protocolOpReturnSchemas.set(e,n),o&&this.protocolScriptCheckers.set(e,o)}transformTx=async e=>{var n,s,o;if(!e||!e.in||!e.out)throw new Error("Cannot process tx");let r={blk:{i:((n=e.blk)==null?void 0:n.i)??0,t:((s=e.blk)==null?void 0:s.t)??0,h:((o=e.blk)==null?void 0:o.h)??""}};for(const[c,a]of Object.entries(e))if(c==="out")for(const l of e.out){const{tape:f}=l;f!=null&&f.some(y=>ve(y))&&(r=await this.processDataProtocols(f,l,e,r));const d=this.protocolScriptCheckers.get(T.name),g=this.protocolScriptCheckers.get(k.name);if(f!=null&&f.some(y=>{const{cell:w}=y;if(d!=null&&d(w)||g!=null&&g(w))return!0}))for(const y of f){const{cell:w}=y;if(!w)throw new Error("empty cell while parsing");let E="";if(d!=null&&d(w))E=T.name;else if(g!=null&&g(w))E=k.name;else continue;this.process(E,{tx:e,cell:w,dataObj:r,tape:f,out:l})}}else c==="in"?r[c]=a.map(l=>{const f={...l};return f.tape=void 0,f}):r[c]=a;if(r.METANET&&e.parent){const c={ancestor:e.ancestor,parent:e.parent,child:e.child,head:e.head};r.METANET.push(c),r.ancestor=void 0,r.child=void 0,r.parent=void 0,r.head=void 0,r.node=void 0}return r};processUnknown=(e,r,n)=>{e&&!r[`_${e}`]&&(r[`_${e}`]=[]),r[`_${e}`].push({i:n.i,e:n.e,tape:[]})};process=async(e,{cell:r,dataObj:n,tape:s,out:o,tx:c})=>{if(this.protocolHandlers.has(e)&&typeof this.protocolHandlers.get(e)=="function"){const a=this.protocolHandlers.get(e);a&&await a({dataObj:n,cell:r,tape:s,out:o,tx:c})}else S(n,e,r)};processDataProtocols=async(e,r,n,s)=>{for(const o of e){const{cell:c}=o;if(!c)throw new Error("empty cell while parsing");if(Y(o))continue;const a=c[0].s;if(a){const l=this.enabledProtocols.get(a);l?await this.process(l,{cell:c,dataObj:s,tape:e,out:r,tx:n}):this.processUnknown(a,s,r)}}return s}}const me=async t=>{const e=`https://api.whatsonchain.com/v1/bsv/main/tx/${t}/hex`;return console.log("hitting",e),await(await fetch(e)).text()},ye=async t=>await we.parse({tx:{r:t},split:[{token:{op:106},include:"l"},{token:{s:"|"}}]}),St=async(t,e)=>{if(typeof t=="string"){let n;if(t.length===64&&(n=await me(t)),Buffer.from(t).byteLength<=146)throw new Error("Invalid rawTx");n||(n=t);const s=await ye(n);if(s)t=s;else throw new Error("Invalid txid")}const r=new pe;if(e)if(r.enabledProtocols.clear(),Se(e))for(const n of _)e!=null&&e.includes(n.name)&&r.addProtocolHandler(n);else if(Ee(e))for(const n of e){const s=n;s&&r.addProtocolHandler(s)}else throw new Error("Invalid protocol array. Must be either an array of protocol names (string[]), or Protocol objects (Protocol[]).");return r.transformTx(t)};exports.BMAP=pe;exports.TransformTx=St;exports.allProtocols=_;exports.bobFromRawTx=ye;exports.defaultProtocols=ge;exports.fetchRawTx=me;exports.supportedProtocols=wt;
//# sourceMappingURL=bmap.cjs.js.map
