{"mappings":"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","sources":["src/bmap.ts","src/protocols/aip.ts","src/utils.ts","src/protocols/b.ts","src/protocols/bap.ts","src/protocols/bitcom.ts","src/protocols/bitcomHashed.ts","src/protocols/psp.ts","src/paymail.ts","src/protocols/bitkey.ts","src/protocols/bitpic.ts","src/protocols/boost.ts","src/protocols/haip.ts","src/protocols/map.ts","src/protocols/metanet.ts","src/protocols/ord.ts","src/protocols/ron.ts","src/protocols/symre.ts","src/protocols/_21e8.ts"],"sourcesContent":["import { parse } from 'bpu-ts'\nimport {\n    BmapTx,\n    BobTx,\n    Handler,\n    HandlerProps,\n    In,\n    MetaNet,\n    MomTx,\n    Out,\n    Protocol,\n    ScriptChecker,\n} from '../types/common'\nimport { AIP } from './protocols/aip'\nimport { B } from './protocols/b'\nimport { BAP } from './protocols/bap'\nimport { BITCOM } from './protocols/bitcom'\nimport { BITCOM_HASHED } from './protocols/bitcomHashed'\nimport { BITKEY } from './protocols/bitkey'\nimport { BITPIC } from './protocols/bitpic'\nimport { BOOST } from './protocols/boost'\nimport { HAIP } from './protocols/haip'\nimport { MAP } from './protocols/map'\nimport { METANET } from './protocols/metanet'\nimport { Ord } from './protocols/ord'\nimport { PSP } from './protocols/psp'\nimport { RON } from './protocols/ron'\nimport { SYMRE } from './protocols/symre'\nimport { _21E8 } from './protocols/_21e8'\nimport {\n    checkOpFalseOpReturn,\n    isObjectArray,\n    isStringArray,\n    saveProtocolData,\n} from './utils'\n\n// Names of enabled protocols\nconst enabledProtocols = new Map<string, string>([])\n// Protocol Handlers\nconst protocolHandlers = new Map<string, Handler>([])\n// Script checkers are intentionally minimalistic detection functions for identifying matching scripts for a given protocol. Only if a checker returns true is a handler called for processing.\nconst protocolScriptCheckers = new Map<string, ScriptChecker>([])\nconst protocolOpReturnSchemas = new Map<string, Object[]>()\n\nexport const allProtocols = [\n    AIP,\n    B,\n    BAP,\n    MAP,\n    METANET,\n    BOOST,\n    _21E8,\n    BITCOM,\n    BITKEY,\n    BITPIC,\n    HAIP,\n    BITCOM_HASHED,\n    PSP,\n    RON,\n    SYMRE,\n    Ord,\n]\n\nexport const supportedProtocols = allProtocols.map((p) => p.name)\nexport const defaultProtocols = [AIP, B, BAP, MAP, METANET, Ord]\n\n// prepare protocol map, handlers and schemas\ndefaultProtocols.forEach((protocol) => {\n    if (protocol.address) {\n        enabledProtocols.set(protocol.address, protocol.name)\n    }\n    protocolHandlers.set(protocol.name, protocol.handler)\n    if (protocol.opReturnSchema) {\n        protocolOpReturnSchemas.set(protocol.name, protocol.opReturnSchema)\n    }\n    if (protocol.scriptChecker) {\n        protocolScriptCheckers.set(protocol.name, protocol.scriptChecker)\n    }\n})\n\n// Takes a BOB formatted op_return transaction\nexport class BMAP {\n    enabledProtocols: Map<string, string>\n\n    protocolHandlers: Map<string, Handler>\n\n    protocolScriptCheckers: Map<string, ScriptChecker>\n\n    protocolOpReturnSchemas: Map<string, Object[]>\n\n    constructor() {\n        // initial default protocol handlers in this instantiation\n        this.enabledProtocols = enabledProtocols\n        this.protocolHandlers = protocolHandlers\n        this.protocolScriptCheckers = protocolScriptCheckers\n        this.protocolOpReturnSchemas = protocolOpReturnSchemas\n    }\n\n    addProtocolHandler({\n        name,\n        address,\n        opReturnSchema,\n        handler,\n        scriptChecker,\n    }: Protocol) {\n        if (address) {\n            this.enabledProtocols.set(address, name)\n        }\n        this.protocolHandlers.set(name, handler)\n        if (opReturnSchema) {\n            this.protocolOpReturnSchemas.set(name, opReturnSchema)\n        }\n        if (scriptChecker) {\n            this.protocolScriptCheckers.set(name, scriptChecker)\n        }\n    }\n\n    transformTx = async (tx: BobTx | MomTx): Promise<BmapTx> => {\n        if (!tx || !tx['in'] || !tx['out']) {\n            throw new Error('Cannot process tx')\n        }\n\n        // This will become our nicely formatted response object\n        const dataObj: Partial<BobTx> = {}\n\n        for (const [key, val] of Object.entries(tx)) {\n            if (key === 'out') {\n                // loop over the outputs\n                for (const out of tx.out) {\n                    const { tape } = out\n\n                    if (tape?.some((cc) => checkOpFalseOpReturn(cc))) {\n                        // loop over tape\n                        for (const cellContainer of tape) {\n                            // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n                            if (checkOpFalseOpReturn(cellContainer)) {\n                                continue\n                            }\n\n                            const { cell } = cellContainer\n                            if (!cell) {\n                                throw new Error('empty cell while parsing')\n                            }\n\n                            const prefix = cell[0].s\n\n                            await this.process(\n                                this.enabledProtocols.get(prefix || '') ||\n                                    prefix ||\n                                    '',\n                                {\n                                    cell,\n                                    dataObj: dataObj as BmapTx,\n                                    tape,\n                                    out,\n                                    tx,\n                                }\n                            )\n                        }\n                    } else {\n                        // No OP_FALSE OP_RETURN in this tape\n                        const boostChecker = this.protocolScriptCheckers.get(\n                            BOOST.name\n                        )\n                        const _21e8Checker = this.protocolScriptCheckers.get(\n                            _21E8.name\n                        )\n                        const ordChecker = this.protocolScriptCheckers.get(\n                            Ord.name\n                        )\n\n                        // Check for boostpow and 21e8\n                        if (\n                            tape?.some((cc) => {\n                                const { cell } = cc\n                                if (boostChecker && boostChecker(cell)) {\n                                    // 'found boost'\n                                    return true\n                                }\n                                if (_21e8Checker && _21e8Checker(cell)) {\n                                    // 'found 21e8'\n                                    return true\n                                }\n                                if (ordChecker && ordChecker(cell)) {\n                                    // 'found 1sat ordinal'\n                                    return true\n                                }\n                            })\n                        ) {\n                            // find the cell array\n                            // loop over tape\n                            for (const cellContainer of tape) {\n                                const { cell } = cellContainer\n                                // Skip the OP_RETURN / OP_FALSE OP_RETURN cell\n                                if (!cell) {\n                                    throw new Error('empty cell while parsing')\n                                }\n                                let protocolName = ''\n                                if (boostChecker && boostChecker(cell)) {\n                                    protocolName = BOOST.name\n                                } else if (_21e8Checker && _21e8Checker(cell)) {\n                                    protocolName = _21E8.name\n                                } else if (ordChecker && ordChecker(cell)) {\n                                    protocolName = Ord.name\n                                } else {\n                                    // nothing found\n                                    continue\n                                }\n\n                                this.process(protocolName, {\n                                    tx,\n                                    cell,\n                                    dataObj: dataObj as BmapTx,\n                                    tape,\n                                    out,\n                                })\n                            }\n                        } else {\n                            this.processUnknown(key, dataObj, out)\n                        }\n                    }\n                }\n            } else if (key === 'in') {\n                // TODO: Boost check inputs to see if this is a tx solving a puzzle\n                // TODO: 21e8 check inputs to see if this is a tx solving a puzzle\n                dataObj[key] = val.map((v: In) => {\n                    const r = { ...v }\n                    delete r.tape\n                    return r\n                })\n            } else {\n                // known key, just write it retaining original type\n                dataObj[key] = val\n            }\n        }\n\n        // If this is a MOM planaria it will have metanet keys available\n        if (dataObj['METANET'] && (tx as MomTx).parent) {\n            const meta = {\n                ancestor: (tx as MomTx).ancestor,\n                parent: (tx as MomTx).parent,\n                child: (tx as MomTx).child,\n                head: (tx as MomTx).head,\n            } as MetaNet\n\n            ;(dataObj.METANET as MetaNet[]).push(meta)\n            // remove parent and node from root level for (MOM data)\n            delete dataObj.ancestor\n            delete dataObj.child\n            delete dataObj.parent\n            delete dataObj.head\n            delete dataObj.node\n        }\n\n        return dataObj as BmapTx\n    }\n\n    processUnknown = (key: string, dataObj: Partial<BmapTx>, out: Out) => {\n        // no known non-OP_RETURN scripts\n        if (key && !dataObj[key]) {\n            dataObj[key] = []\n        }\n\n        ;(dataObj[key] as Out[]).push({\n            i: out.i,\n            e: out.e,\n            tape: [],\n        })\n    }\n\n    process = async (\n        protocolName: string,\n        { cell, dataObj, tape, out, tx }: HandlerProps\n    ) => {\n        if (\n            this.protocolHandlers.has(protocolName) &&\n            typeof this.protocolHandlers.get(protocolName) === 'function'\n        ) {\n            const handler = this.protocolHandlers.get(protocolName)\n            if (handler) {\n                /* eslint-disable no-await-in-loop */\n                await handler({\n                    dataObj: dataObj,\n                    cell,\n                    tape,\n                    out,\n                    tx,\n                })\n            }\n        } else {\n            saveProtocolData(dataObj, protocolName, cell)\n        }\n    }\n}\n\nexport const fetchRawTx = async (txid: string): Promise<string> => {\n    const url = 'https://api.whatsonchain.com/v1/bsv/main/tx/' + txid + '/hex'\n\n    console.log('hitting', url)\n\n    const res = await fetch(url)\n    return await res.text()\n}\n\nexport const bobFromRawTx = async (rawTx: string): Promise<BobTx> => {\n    const bpuTx = await parse({\n        tx: { r: rawTx },\n        split: [\n            {\n                token: { op: 106 },\n                include: 'l',\n            },\n            {\n                token: { op: 0 },\n                include: 'l',\n            },\n            {\n                token: { s: '|' },\n            },\n        ],\n    })\n    return bpuTx as BobTx\n}\n\n// TransformTx\n// tx - a raw hex string or a Bob/Bmap/Mom transaction object\n// protocols - the handlers you want to load and use to process the tx\n// reducing the number of supported protocols may improve transform speed\n// at the expense of detecting more data protocols\nexport const TransformTx = async (\n    tx: BobTx | string | MomTx | BmapTx,\n    protocols?: string[] | Protocol[]\n) => {\n    if (typeof tx === 'string') {\n        let rawTx: string | undefined\n        // if it a txid or  complete transaction hex?\n        if (tx.length === 64) {\n            // txid - fetch raw tx\n            rawTx = await fetchRawTx(tx)\n        }\n\n        if (Buffer.from(tx).byteLength <= 146) {\n            throw new Error('Invalid rawTx')\n        }\n\n        if (!rawTx) {\n            rawTx = tx\n        }\n\n        // TODO: Double check 146 is intended to be minimum possible byte length for a tx\n        const bobTx = await bobFromRawTx(rawTx)\n\n        if (bobTx) {\n            tx = bobTx\n        } else {\n            throw new Error(`Invalid txid`)\n        }\n    }\n\n    const b = new BMAP()\n\n    // if protocols are specified\n    if (protocols) {\n        // wipe out defaults\n        b.enabledProtocols.clear()\n        if (isStringArray(protocols)) {\n            // set enabled protocols\n            for (const protocol of allProtocols) {\n                if ((protocols as string[])?.includes(protocol.name)) {\n                    b.addProtocolHandler(protocol)\n                }\n            }\n        } else if (isObjectArray(protocols)) {\n            for (const p of protocols) {\n                const protocol = p as Protocol\n                if (protocol) {\n                    b.addProtocolHandler(protocol)\n                }\n            }\n        } else {\n            throw new Error(\n                `Invalid protocol array. Must be either an array of protocol names (string[]), or Protocol objects (Protocol[]).`\n            )\n        }\n    }\n\n    return b.transformTx(tx)\n}\n","import { Address, Bsm, Script } from '@ts-bitcoin/core'\nimport { Buffer } from 'buffer'\nimport fetch from 'node-fetch'\nimport { BobTx, Cell, HandlerProps, Protocol, Tape } from '../../types/common'\nimport { AIP as AIPType } from '../../types/protocols/aip'\nimport { HAIP as HAIPType } from '../../types/protocols/haip'\n\nimport {\n    cellValue,\n    checkOpFalseOpReturn,\n    isBase64,\n    saveProtocolData,\n    sha256,\n} from '../utils'\n\nconst address = '15PciHG22SNLQJXMoSUaWVi7WSqc7hCfva'\n\nconst opReturnSchema = [\n    { algorithm: 'string' },\n    { address: 'string' },\n    { signature: 'binary' },\n    [{ index: 'binary' }],\n]\n\nconst getFileBuffer = async function (bitfsRef: string) {\n    let fileBuffer = Buffer.from('')\n    try {\n        const result = await fetch(`https://x.bitfs.network/${bitfsRef}`, {})\n        fileBuffer = await result.buffer()\n    } catch (e) {\n        console.error(e)\n    }\n\n    return fileBuffer\n}\n\nconst validateSignature = async function (\n    aipObj: Partial<AIPType | HAIPType>,\n    cell: Cell[],\n    tape: Tape[]\n): Promise<boolean> {\n    if (!Array.isArray(tape) || tape.length < 3) {\n        throw new Error('AIP requires at least 3 cells including the prefix')\n    }\n\n    let cellIndex = -1\n    tape.forEach((cc, index) => {\n        if (cc.cell === cell) {\n            cellIndex = index\n        }\n    })\n    if (cellIndex === -1) {\n        throw new Error('AIP could not find cell in tape')\n    }\n\n    let usingIndexes: number[] = aipObj.index || []\n    const signatureValues = ['6a'] // OP_RETURN - is included in AIP\n    for (let i = 0; i < cellIndex; i++) {\n        const cellContainer = tape[i]\n        if (!checkOpFalseOpReturn(cellContainer)) {\n            for (let nc = 0; nc < cellContainer.cell.length; nc++) {\n                const statement = cellContainer.cell[nc]\n                // add the value as hex\n                if (statement.h) {\n                    signatureValues.push(statement.h)\n                } else if (statement.f) {\n                    // file reference - we need to get the file from bitfs\n                    const fileBuffer = await getFileBuffer(statement.f)\n                    signatureValues.push(fileBuffer.toString('hex'))\n                } else if (statement.b) {\n                    // no hex? try base64\n                    signatureValues.push(\n                        Buffer.from(statement.b, 'base64').toString('hex')\n                    )\n                } else {\n                    if (statement.s) {\n                        signatureValues.push(\n                            Buffer.from(statement.s).toString('hex')\n                        )\n                    }\n                }\n            }\n            signatureValues.push('7c') // | hex\n        }\n    }\n\n    if (aipObj.hashing_algorithm) {\n        // when using HAIP, we need to parse the indexes in a non standard way\n        // indexLength is byte size of the indexes being described\n        if (aipObj.index_unit_size) {\n            const indexLength = aipObj.index_unit_size * 2\n            usingIndexes = []\n            const indexes = cell[6].h as string\n            for (let i = 0; i < indexes.length; i += indexLength) {\n                usingIndexes.push(parseInt(indexes.substr(i, indexLength), 16))\n            }\n            aipObj.index = usingIndexes\n        }\n    }\n\n    const signatureBufferStatements: Buffer[] = []\n    // check whether we need to only sign some indexes\n    if (usingIndexes.length > 0) {\n        usingIndexes.forEach((index) => {\n            signatureBufferStatements.push(\n                Buffer.from(signatureValues[index], 'hex')\n            )\n        })\n    } else {\n        // add all the values to the signature buffer\n        signatureValues.forEach((statement) => {\n            signatureBufferStatements.push(Buffer.from(statement, 'hex'))\n        })\n    }\n\n    let messageBuffer: Buffer | string\n    if (aipObj.hashing_algorithm) {\n        // this is actually Hashed-AIP (HAIP) and works a bit differently\n        if (!aipObj.index_unit_size) {\n            // remove OP_RETURN - will be added by Script.buildDataOut\n            signatureBufferStatements.shift()\n        }\n        const dataScript = Script.fromSafeDataArray(signatureBufferStatements)\n        let dataBuffer = Buffer.from(dataScript.toHex(), 'hex')\n        if (aipObj.index_unit_size) {\n            // the indexed buffer should not contain the OP_RETURN opcode, but this\n            // is added by the buildDataOut function automatically. Remove it.\n            dataBuffer = dataBuffer.slice(1)\n        }\n        messageBuffer = await sha256(Buffer.from(dataBuffer.toString('hex')))\n    } else {\n        // regular AIP\n        messageBuffer = Buffer.concat([...signatureBufferStatements])\n    }\n\n    // AIOP uses address, HAIP uses signing_address field names\n    const adressString =\n        (aipObj as AIPType).address || (aipObj as HAIPType).signing_address\n    // verify aip signature\n    try {\n        aipObj.verified = Bsm.verify(\n            messageBuffer,\n            aipObj.signature || '',\n            Address.fromString(adressString)\n        )\n    } catch (e) {\n        aipObj.verified = false\n    }\n\n    // Try if this is a Twetch compatible AIP signature\n    if (!aipObj.verified) {\n        // Twetch signs a UTF-8 buffer of the hex string of a sha256 hash of the message\n        // Without 0x06 (OP_RETURN) and without 0x7c at the end, the trailing pipe (\"|\")\n\n        messageBuffer = Buffer.concat([\n            ...signatureBufferStatements.slice(\n                1,\n                signatureBufferStatements.length - 1\n            ),\n        ])\n        const buff = await sha256(messageBuffer)\n        messageBuffer = Buffer.from(buff.toString('hex'))\n        try {\n            aipObj.verified = Bsm.verify(\n                messageBuffer,\n                aipObj.signature || '',\n                Address.fromString(adressString)\n            )\n        } catch (e) {\n            aipObj.verified = false\n        }\n    }\n\n    return aipObj.verified || false\n}\n\nexport const enum SIGPROTO {\n    HAIP = 'HAIP',\n    AIP = 'AIP',\n    BITCOM_HASHED = 'BITCOM_HASHED',\n    PSP = 'PSP',\n}\n\nexport const AIPhandler = async function (\n    useOpReturnSchema: Object[],\n    protocol: SIGPROTO,\n    dataObj: Object,\n    cell: Cell[],\n    tape: Tape[],\n    tx: BobTx\n) {\n    // loop over the schema\n    const aipObj: { [key: string]: number | number[] | string } = {}\n\n    // Does not have the required number of fields\n    if (cell.length < 4) {\n        throw new Error(\n            'AIP requires at least 4 fields including the prefix ' + tx\n        )\n    }\n\n    for (const [idx, schemaField] of Object.entries(useOpReturnSchema)) {\n        const x = parseInt(idx, 10)\n\n        let schemaEncoding\n        let aipField: keyof AIPType\n        if (schemaField instanceof Array) {\n            // signature indexes are specified\n            schemaEncoding = schemaField[0].index\n            ;[aipField] = Object.keys(schemaField[0]) as (keyof AIPType)[]\n            // run through the rest of the fields in this cell, should be de indexes\n            const fieldData: number[] = []\n            for (let i = x + 1; i < cell.length; i++) {\n                if (cell[i].h && Array.isArray(fieldData)) {\n                    fieldData.push(parseInt(cell[i].h || '', 16))\n                }\n            }\n            aipObj[aipField] = fieldData\n            continue\n        } else {\n            ;[aipField] = Object.keys(schemaField) as (keyof AIPType)[]\n            ;[schemaEncoding] = Object.values(schemaField)\n        }\n\n        aipObj[aipField] = cellValue(cell[x + 1], schemaEncoding) || ''\n    }\n\n    // There is an issue where some services add the signature as binary to the transaction\n    // whereas others add the signature as base64. This will confuse bob and the parser and\n    // the signature will not be verified. When the signature is added in binary cell[3].s is\n    // binary, otherwise cell[3].s contains the base64 signature and should be used.\n    if (cell[0].s === address && cell[3].s && isBase64(cell[3].s)) {\n        aipObj.signature = cell[3].s\n    }\n\n    if (!aipObj.signature) {\n        throw new Error('AIP requires a signature ' + tx)\n    }\n\n    if (!(await validateSignature(aipObj as Partial<AIPType>, cell, tape))) {\n        // throw new Error('AIP requires a valid signature', tx);\n    }\n\n    saveProtocolData(dataObj, protocol, aipObj)\n}\n\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n    if (!tape) {\n        throw new Error('Invalid AIP transaction. tape is required')\n    }\n    if (!tx) {\n        throw new Error('Invalid AIP transaction. tx is required')\n    }\n    return await AIPhandler(\n        opReturnSchema,\n        SIGPROTO.AIP,\n        dataObj,\n        cell,\n        tape,\n        tx\n    )\n}\n\nexport const AIP: Protocol = {\n    name: 'AIP',\n    address,\n    opReturnSchema,\n    handler,\n}\n","import { Buffer } from 'buffer'\nimport crypto from 'crypto'\nimport { BobTx, Cell, Tape } from '../types/common'\n\nexport const isStringArray = (arr: Array<any>): boolean => {\n    return (\n        arr.length > 0 &&\n        arr.every((value) => {\n            return typeof value === 'string'\n        })\n    )\n}\nexport const isObjectArray = (arr: Array<any>): boolean => {\n    return (\n        arr.length > 0 &&\n        arr.every((value) => {\n            return value === 'object'\n        })\n    )\n}\n/**\n * returns the BOB cell value for a given encoding\n *\n * @param pushData\n * @param schemaEncoding\n * @returns {string|number}\n */\nexport const cellValue = (\n    pushData: Cell,\n    schemaEncoding?: string\n): string | number => {\n    if (!pushData) {\n        throw new Error(`cannot get cell value of: ${pushData}`)\n    } else if (schemaEncoding === 'string') {\n        return pushData['s'] ? pushData.s : pushData.ls || ''\n    } else if (schemaEncoding === 'hex') {\n        return pushData['h']\n            ? pushData.h\n            : pushData.lh ||\n                  (pushData['b']\n                      ? Buffer.from(pushData.b, 'base64').toString('hex')\n                      : pushData.lb &&\n                        Buffer.from(pushData.lb, 'base64').toString('hex')) ||\n                  ''\n    } else if (schemaEncoding === 'number') {\n        return parseInt(pushData['h'] ? pushData.h : pushData.lh || '0', 16)\n    } else if (schemaEncoding === 'file') {\n        return `bitfs://${pushData['f'] ? pushData.f : pushData.lf}`\n    }\n\n    return (pushData['b'] ? pushData.b : pushData.lb) || ''\n}\n\n/**\n * Check a cell starts with OP_FALSE OP_RETURN -or- OP_RETURN\n *\n * @param cc\n * @returns {boolean}\n */\nexport const checkOpFalseOpReturn = function (cc: Tape) {\n    return (\n        (cc.cell[0] &&\n            cc.cell[1] &&\n            cc.cell[0].op === 0 &&\n            cc.cell[1].op &&\n            cc.cell[1].op === 106) ||\n        cc.cell[0].op === 106\n    )\n}\n\n/**\n * Helper function to store protocol data\n *\n * @param dataObj\n * @param protocolName\n * @param data\n */\nexport const saveProtocolData = (\n    dataObj: { [key: string]: any },\n    protocolName: string,\n    data: any\n) => {\n    if (!dataObj[protocolName]) {\n        dataObj[protocolName] = [data]\n    } else {\n        if (!Array.isArray(dataObj[protocolName])) {\n            const prevData = dataObj[protocolName]\n            dataObj[protocolName] = []\n            dataObj[protocolName][0] = prevData\n        }\n        dataObj[protocolName][dataObj[protocolName].length] = data\n    }\n}\n\n/**\n * BMAP default handler to work with query schema's\n *\n * @param opReturnSchema\n * @param protocolName\n * @param dataObj\n * @param cell\n * @param tape\n * @param tx\n */\nexport const bmapOpReturnSchemaHandler = function (\n    protocolName: string,\n    opReturnSchema: Object[],\n    dataObj: Object,\n    cell: Cell[],\n    tx: BobTx\n) {\n    // loop over the schema\n    const obj: { [key: string]: any } = {}\n\n    // Does not have the required number of fields\n    const length = opReturnSchema.length + 1\n    if (cell.length < length) {\n        throw new Error(\n            `${protocolName} requires at least ${length} fields including the prefix: ${tx.tx.h}`\n        )\n    }\n\n    for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n        const x = parseInt(idx, 10)\n\n        const [field] = Object.keys(schemaField)\n        const [schemaEncoding] = Object.values(schemaField)\n        obj[field] = cellValue(cell[x + 1], schemaEncoding)\n    }\n\n    saveProtocolData(dataObj, protocolName, obj)\n}\n\n/**\n * Check whether the given data is base64\n *\n * @param data\n * @returns {boolean}\n */\nexport const isBase64 = function (data: string) {\n    const regex =\n        '(?:[A-Za-z0-9+\\\\/]{4})*(?:[A-Za-z0-9+\\\\/]{2}==|[A-Za-z0-9+/]{3}=)?'\n    return new RegExp(`^${regex}$`, 'gi').test(data)\n}\n\n// hashes a message buffer, returns the hash as a buffer\nexport const sha256 = async (msgBuffer: Buffer) => {\n    let hash: ArrayBuffer\n\n    if (crypto.subtle) {\n        hash = await crypto.subtle.digest('SHA-256', msgBuffer)\n        return Buffer.from(hash)\n    }\n    // }\n    return Buffer.from(new ArrayBuffer(0))\n}\n","import { HandlerProps, Protocol } from '../../types/common'\nimport { cellValue, saveProtocolData } from '../utils'\n\nconst address = '19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut'\n\nconst opReturnSchema = [\n    { content: ['string', 'binary', 'file'] },\n    { 'content-type': 'string' },\n    { encoding: 'string' }, // we use this field to determine content character encoding. If encoding is not a valid character encoding (gzip), we assume it is binary\n    { filename: 'string' },\n]\n\nconst handler = function ({ dataObj, cell, tx }: HandlerProps): void {\n    const encodingMap = new Map<string, string>()\n    encodingMap.set('utf8', 'string')\n    encodingMap.set('text', 'string') // invalid but people use it :(\n    encodingMap.set('gzip', 'binary') // invalid but people use it :(\n    encodingMap.set('text/plain', 'string')\n    encodingMap.set('image/png', 'binary')\n    encodingMap.set('image/jpeg', 'binary')\n\n    if (!cell[1] || !cell[2]) {\n        throw new Error(`Invalid B tx: ${tx}`)\n    }\n\n    // Check pushdata length + 1 for protocol prefix\n    if (cell.length > opReturnSchema.length + 1) {\n        throw new Error('Invalid B tx. Too many fields.')\n    }\n\n    // Make sure there are not more fields than possible\n\n    const bObj: { [key: string]: string | number | undefined } = {}\n    // loop over the schema\n    for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n        const x = parseInt(idx, 10)\n        const bField = Object.keys(schemaField)[0]\n        let schemaEncoding = Object.values(schemaField)[0]\n        if (bField === 'content') {\n            // If the encoding is ommitted, try to infer from content-type instead of breaking\n            if (cell[1].f) {\n                // this is file reference to B files\n                schemaEncoding = 'file'\n            } else if ((!cell[3] || !cell[3].s) && cell[2].s) {\n                schemaEncoding = encodingMap.get(cell[2].s)\n                if (!schemaEncoding) {\n                    console.warn(\n                        'Problem inferring encoding. Malformed B data.',\n                        cell\n                    )\n                    return\n                }\n\n                // add the missing encoding field\n                if (!cell[3]) {\n                    cell[3] = { h: '', b: '', s: '', i: 0, ii: 0 }\n                }\n                cell[3].s = schemaEncoding === 'string' ? 'utf-8' : 'binary'\n            } else {\n                schemaEncoding =\n                    cell[3] && cell[3].s\n                        ? encodingMap.get(\n                              cell[3].s.replace('-', '').toLowerCase()\n                          )\n                        : null\n            }\n        }\n\n        // encoding is not required\n        if (bField === 'encoding' && !cell[x + 1]) {\n            // encoding omitted\n            continue\n        }\n\n        // filename is not required\n        if (bField === 'filename' && !cell[x + 1]) {\n            // filename omitted\n            continue\n        }\n\n        // check for malformed syntax\n        if (!cell || !cell[x + 1]) {\n            throw new Error('malformed B syntax ' + cell)\n        }\n\n        // set field value from either s, b, ls, or lb depending on encoding and availability\n        const data = cell[x + 1]\n        bObj[bField] = cellValue(data, schemaEncoding)\n    }\n\n    saveProtocolData(dataObj, 'B', bObj)\n}\n\nexport const B: Protocol = {\n    name: 'B',\n    address,\n    opReturnSchema,\n    handler,\n}\n","import { HandlerProps, Protocol } from '../../types/common'\nimport { bmapOpReturnSchemaHandler } from '../utils'\n\nconst address = '1BAPSuaPnfGnSBM3GLV9yhxUdYe4vGbdMT'\n\nconst opReturnSchema = [\n    { type: 'string' },\n    { hash: 'string' },\n    { sequence: 'string' },\n]\n\nexport const handler = ({ dataObj, cell, tx }: HandlerProps) => {\n    if (!tx) {\n        throw new Error(`Invalid BAP tx, tx required`)\n    }\n    bmapOpReturnSchemaHandler('BAP', opReturnSchema, dataObj, cell, tx)\n}\n\nexport const BAP: Protocol = {\n    name: 'BAP',\n    address,\n    opReturnSchema,\n    handler,\n}\n","import { HandlerProps, Protocol } from '../../types/common'\nimport { saveProtocolData } from '../utils'\n\nconst protocolAddress = '$'\n\nconst opReturnSchema = [\n    {\n        su: [\n            { pubkey: 'string' },\n            { sign_position: 'string' },\n            { signature: 'string' },\n        ],\n        echo: [{ data: 'string' }, { to: 'string' }, { filename: 'string' }],\n        route: [\n            [\n                {\n                    add: [\n                        { bitcom_address: 'string' },\n                        { route_matcher: 'string' },\n                        { endpoint_template: 'string' },\n                    ],\n                },\n                {\n                    enable: [{ path: 'string' }],\n                },\n            ],\n        ],\n        useradd: [{ address: 'string' }],\n    },\n]\n\n// const handler = function (dataObj, protocolName, cell, tape, tx) {\nconst handler = ({ dataObj, cell }: HandlerProps) => {\n    if (!cell.length || !cell.every((c) => c.s)) {\n        throw new Error('Invalid Bitcom tx')\n    }\n\n    // gather up the string values\n    const bitcomObj = cell.map((c) => (c && c.s ? c.s : ''))\n\n    saveProtocolData(dataObj, 'BITCOM', bitcomObj)\n}\n\nexport const BITCOM: Protocol = {\n    name: 'BITCOM',\n    address: protocolAddress,\n    opReturnSchema,\n    handler,\n}\n","import { HandlerProps, Protocol } from '../../types/common'\nimport { SIGPROTO } from './aip'\nimport { PSPhandler } from './psp'\n\nconst address = '15igChEkUWgx4dsEcSuPitcLNZmNDfUvgA'\n\n// should be very similar to PSP\n// see https://bsvalias.org/05-verify-public-key-owner.html\n\n// TODO: Really need some documentation ro to verify what these fields are\nconst opReturnSchema = [\n    { hash: 'string' }, // sha256?\n    { signature: 'string' }, // not sure\n    { pubkey: 'binary' }, // not sure\n    { paymail: 'string' },\n]\n\nconst handler = async ({ dataObj, cell, tape }: HandlerProps) => {\n    if (!tape) {\n        throw new Error(`Invalid BITCOM_HASHED tx. Bad tape`)\n    }\n\n    return await PSPhandler(\n        opReturnSchema,\n        SIGPROTO.BITCOM_HASHED,\n        dataObj,\n        cell,\n        tape\n    )\n}\n\nexport const BITCOM_HASHED: Protocol = {\n    name: 'BITCOM_HASHED',\n    address,\n    opReturnSchema,\n    handler,\n}\n","import { Address, Bsm, PubKey, Script } from '@ts-bitcoin/core'\nimport { Buffer } from 'buffer'\nimport { Cell, HandlerProps, Protocol, Tape } from '../../types/common'\nimport { BITCOM_HASHED } from '../../types/protocols/bitcomHashed'\nimport { PSP as PSPType } from '../../types/protocols/psp'\nimport { verifyPaymailPublicKey } from '../paymail'\nimport { cellValue, checkOpFalseOpReturn, saveProtocolData } from '../utils'\nimport { SIGPROTO } from './aip'\n\nconst address = '1signyCizp1VyBsJ5Ss2tEAgw7zCYNJu4'\n\nconst opReturnSchema = [\n    { signature: 'string' },\n    { pubkey: 'string' },\n    { paymail: 'string' },\n]\n\nconst validateSignature = (pspObj: PSPType, cell: Cell[], tape: Tape[]) => {\n    if (!Array.isArray(tape) || tape.length < 3) {\n        throw new Error('PSP requires at least 3 cells including the prefix')\n    }\n\n    let cellIndex = -1\n    tape.forEach((cc, index) => {\n        if (cc.cell === cell) {\n            cellIndex = index\n        }\n    })\n    if (cellIndex === -1) {\n        throw new Error('PSP could not find cell in tape')\n    }\n\n    const signatureBufferStatements = []\n    for (let i = 0; i < cellIndex; i++) {\n        const cellContainer = tape[i]\n        if (!checkOpFalseOpReturn(cellContainer)) {\n            cellContainer.cell.forEach((statement) => {\n                // add the value as hex\n                let value = statement.h\n                if (!value) {\n                    value = Buffer.from(\n                        statement.b as string,\n                        'base64'\n                    ).toString('hex')\n                }\n                if (!value) {\n                    value = Buffer.from(statement.s as string).toString('hex')\n                }\n                signatureBufferStatements.push(Buffer.from(value, 'hex'))\n            })\n            signatureBufferStatements.push(Buffer.from('7c', 'hex')) // | hex ????\n        }\n    }\n    const dataScript = Script.fromSafeDataArray(signatureBufferStatements)\n    const messageBuffer = Buffer.from(dataScript.toHex(), 'hex')\n\n    // verify psp signature\n    const publicKey = PubKey.fromString(pspObj.pubkey)\n    const signingAddress = Address.fromPubKey(publicKey)\n    try {\n        pspObj.verified = Bsm.verify(\n            messageBuffer,\n            pspObj.signature,\n            signingAddress\n        )\n    } catch (e) {\n        pspObj.verified = false\n    }\n\n    return pspObj.verified\n}\n\nconst handler = async ({ dataObj, cell, tape }: HandlerProps) => {\n    // Paymail Signature Protocol\n    // Validation\n    if (\n        !cell.length ||\n        cell[0].s !== address ||\n        !cell[1] ||\n        !cell[2] ||\n        !cell[3] ||\n        !cell[1].b ||\n        !cell[2].s ||\n        !cell[3].s ||\n        !tape\n    ) {\n        throw new Error(`Invalid Paymail Signature Protocol record`)\n    }\n\n    return await PSPhandler(opReturnSchema, SIGPROTO.PSP, dataObj, cell, tape)\n}\n\nexport const PSPhandler = async (\n    useOpReturnSchema: Object[],\n    protocol: SIGPROTO,\n    dataObj: Object,\n    cell: Cell[],\n    tape: Tape[]\n) => {\n    // loop over the schema\n    const pspObj: Partial<PSPType | BITCOM_HASHED> = {\n        verified: false,\n    }\n\n    // Does not have the required number of fields\n    if (cell.length < 4) {\n        throw new Error(\n            'PSP requires at least 4 fields including the prefix ' + cell\n        )\n    }\n\n    for (const [idx, schemaField] of Object.entries(useOpReturnSchema)) {\n        const x = parseInt(idx, 10)\n\n        const [pspField] = Object.keys(schemaField) as (keyof PSPType)[]\n        const [schemaEncoding] = Object.values(schemaField) as string[]\n\n        ;(pspObj as any)[pspField] = cellValue(cell[x + 1], schemaEncoding)\n    }\n\n    if (!pspObj.signature) {\n        throw new Error('PSP requires a signature ' + cell)\n    }\n\n    //  TODO: we can only check on PSP until we figure out the BITCOM_HASHED fields\n    //  verify signature\n    if (\n        protocol === SIGPROTO.PSP &&\n        !validateSignature(pspObj as PSPType, cell, tape)\n    ) {\n        throw new Error('PSP requires a valid signature ' + pspObj)\n    }\n\n    // check the paymail public key\n    if (pspObj.pubkey && pspObj.paymail) {\n        const paymailPublicKeyVerified = await verifyPaymailPublicKey(\n            pspObj.paymail,\n            pspObj.pubkey\n        )\n        pspObj.verified = (pspObj.verified &&\n            paymailPublicKeyVerified) as boolean\n    }\n\n    saveProtocolData(dataObj, protocol, pspObj)\n}\n\n// TODO: Add concept of validators so they can be passed in / reused more easily\nexport const PSP: Protocol = {\n    name: 'PSP',\n    address,\n    opReturnSchema,\n    handler,\n}\n","/// <reference path=\"../types/paymail-client/index.d.ts\"/>\nimport { PaymailClient } from '@moneybutton/paymail-client'\n/// <reference path=\"../types/paymail-client/index.d.ts\"/>\nexport { PaymailClient } from '@moneybutton/paymail-client'\n\nimport dns from 'dns'\nimport fetch from 'node-fetch'\n\nexport const verifyPaymailPublicKey = async function (\n    paymail: string,\n    publicKey: string\n): Promise<boolean> {\n    if (typeof window !== 'undefined') {\n        // Paymail client will use BrowserDns if dns is null here\n        // and isomorphic-fetch if fetch is null\n        const client = new PaymailClient()\n        return client.verifyPubkeyOwner(publicKey, paymail)\n    } else {\n        const client = new PaymailClient(dns, fetch)\n        return client.verifyPubkeyOwner(publicKey, paymail)\n    }\n}\n","import { Address, Bsm, PubKey } from '@ts-bitcoin/core'\nimport { Buffer } from 'buffer'\nimport { HandlerProps, Protocol } from '../../types/common'\nimport { cellValue, saveProtocolData, sha256 } from '../utils'\n\nconst address = '13SrNDkVzY5bHBRKNu5iXTQ7K7VqTh5tJC'\n\nconst opReturnSchema = [\n    { bitkey_signature: 'string' },\n    { user_signature: 'string' },\n    { paymail: 'string' },\n    { pubkey: 'string' },\n]\n\n// const handler = function (dataObj, cell, tape, tx) {\n// https://bitkey.network/how\nconst handler = async ({ dataObj, cell }: HandlerProps) => {\n    if (!cell.length) {\n        throw new Error('Invalid Bitkey tx')\n    }\n\n    const bitkeyObj: { [key: string]: string | boolean } = {}\n\n    // loop over the schema\n    for (const [idx, schemaField] of Object.entries(opReturnSchema)) {\n        const x = parseInt(idx, 10)\n        const bitkeyField = Object.keys(schemaField)[0]\n        const schemaEncoding = Object.values(schemaField)[0]\n        bitkeyObj[bitkeyField] = cellValue(\n            cell[x + 1],\n            schemaEncoding\n        ) as string\n    }\n\n    const userAddress = Address.fromPubKey(\n        PubKey.fromString(bitkeyObj.pubkey as string)\n    ).toString()\n\n    // sha256( hex(paymail(USER)) | hex(pubkey(USER)) )\n    const paymailHex = Buffer.from(bitkeyObj.paymail as string).toString('hex')\n    const pubkeyHex = Buffer.from(bitkeyObj.pubkey as string).toString('hex')\n    const concatenated = paymailHex + pubkeyHex\n    const bitkeySignatureBuffer = await sha256(Buffer.from(concatenated, 'hex'))\n\n    const bitkeySignatureVerified = Bsm.verify(\n        bitkeySignatureBuffer,\n        bitkeyObj.bitkey_signature as string,\n        Address.fromString('13SrNDkVzY5bHBRKNu5iXTQ7K7VqTh5tJC')\n    )\n    const userSignatureVerified = Bsm.verify(\n        Buffer.from(bitkeyObj.pubkey as string),\n        bitkeyObj.user_signature as string,\n        Address.fromString(userAddress)\n    )\n    bitkeyObj.verified = bitkeySignatureVerified && userSignatureVerified\n\n    saveProtocolData(dataObj, 'BITKEY', bitkeyObj)\n}\n\nexport const BITKEY: Protocol = {\n    name: 'BITKEY',\n    address,\n    opReturnSchema,\n    handler,\n}\n","import { Address, Bsm, PubKey } from '@ts-bitcoin/core'\nimport { Buffer } from 'buffer'\nimport { HandlerProps, Protocol } from '../../types/common'\nimport { BITPIC as BITPICType } from '../../types/protocols/bitpic'\nimport { saveProtocolData, sha256 } from '../utils'\n\nconst protocolAddress = '18pAqbYqhzErT6Zk3a5dwxHtB9icv8jH2p'\n\nconst opReturnSchema = [\n    { paymail: 'string' },\n    { pubkey: 'binary' },\n    { signature: 'string' },\n]\n\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n    // Validation\n    if (\n        cell[0].s !== protocolAddress ||\n        !cell[1] ||\n        !cell[2] ||\n        !cell[3] ||\n        !cell[1].s ||\n        !cell[2].b ||\n        !cell[3].s ||\n        !tape\n    ) {\n        throw new Error(`Invalid BITPIC record: ${tx}`)\n    }\n\n    const bitpicObj: BITPICType = {\n        paymail: cell[1].s,\n        pubkey: Buffer.from(cell[2].b, 'base64').toString('hex'),\n        signature: cell[3].s || '',\n        verified: false,\n    }\n\n    const b = tape[1].cell\n    if (b[0].s === '19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut') {\n        // verify bitpic signature\n\n        // TODO: Verification\n        // const pubkey = Buffer.from(cell[2].b, 'base64').toString('hex')\n        // const address = Address.fromPubKey(PubKey.fromString(pubkey)).toString()\n        // const hex = Buffer.from(hash, 'hex')\n        // const verified = Message.verify(hex, address, expected)\n        // return verified\n\n        // const expected = res.cell[3].s\n        // const paymail = res.cell[1].s\n        // const pubkey = Buffer.from(res.cell[2].b, \"base64\").toString(\"hex\")\n        // const address = new bsv.PublicKey(pubkey).toAddress().toString()\n        // const hex = Buffer.from(res.hash, \"hex\")\n        // const verified = Message.verify(hex, address, expected)\n        // return verified\n\n        try {\n            // TODO: bob transactions are missing this binary part, cannot verify signature\n            const bin = (cell[1].lb || cell[1].b) as string\n            const buf = Buffer.from(bin, 'base64')\n            const hashBuff = await sha256(buf)\n            const address = Address.fromPubKey(\n                PubKey.fromString(bitpicObj.pubkey as string)\n            )\n\n            bitpicObj.verified = Bsm.verify(\n                hashBuff,\n                bitpicObj.signature,\n                address\n            )\n        } catch (e) {\n            // failed verification\n            bitpicObj.verified = false\n        }\n    }\n\n    saveProtocolData(dataObj, 'BITPIC', bitpicObj)\n}\n\nexport const BITPIC: Protocol = {\n    name: 'BITPIC',\n    address: protocolAddress,\n    opReturnSchema,\n    handler,\n}\n","import { BoostPowJob } from 'boostpow'\nimport { Cell, HandlerProps, Protocol } from '../../types/common'\nimport { cellValue, saveProtocolData } from '../utils'\n\nconst protocolIdentifier = 'boostpow'\n\n/*\n{\n    hash: '0000000086915e291fe43f10bdd8232f65e6eb64628bbb4d128be3836c21b6cc',\n    content: '00000000000000000000000000000000000000000048656c6c6f20776f726c64',\n    bits: 486604799,\n    difficulty: 1,\n    metadataHash: \"acd8278e84b037c47565df65a981d72fb09be5262e8783d4cf4e42633615962a\",\n    time: 1305200806,\n    nonce: 3698479534,\n    category: 1,\n}\n*/\n\nconst scriptChecker = (cell: Cell[]) => {\n    // protocol identifier always in first pushdata\n    return cell[0].s === protocolIdentifier\n}\n\nconst handler = ({ dataObj, cell, out, tx }: HandlerProps): void => {\n    if (!tx || !cell[0] || !out) {\n        throw new Error(\n            `Invalid BOOST tx. dataObj, cell, out and tx are required.`\n        )\n    }\n\n    // build ASM from either op codes and script chunks\n    const asm = cell\n        .map((c) => (c.ops ? c.ops : cellValue(c, 'hex') || ''))\n        .join(' ')\n\n    if (asm) {\n        const boostJob = BoostPowJob.fromASM(\n            asm,\n            tx.tx.h,\n            out.i,\n            out.e.v\n        ).toObject()\n\n        saveProtocolData(dataObj, 'BOOST', boostJob)\n    }\n}\n\nexport const BOOST: Protocol = {\n    name: 'BOOST',\n    handler,\n    address: protocolIdentifier,\n    scriptChecker,\n}\n","import { HandlerProps, Protocol } from '../../types/common'\nimport { AIPhandler, SIGPROTO } from './aip'\n\nconst address = '1HA1P2exomAwCUycZHr8WeyFoy5vuQASE3'\n\nconst opReturnSchema = [\n    { hashing_algorithm: 'string' },\n    { signing_algorithm: 'string' },\n    { signing_address: 'string' },\n    { signature: 'string' },\n    { index_unit_size: 'number' },\n    [{ index: 'binary' }],\n]\n\n// https://github.com/torusJKL/BitcoinBIPs/blob/master/HAIP.md\nconst handler = async ({ dataObj, cell, tape, tx }: HandlerProps) => {\n    if (!tape) {\n        throw new Error(`Invalid HAIP tx. Bad tape`)\n    }\n    if (!tx) {\n        throw new Error(`Invalid HAIP tx.`)\n    }\n    return await AIPhandler(\n        opReturnSchema,\n        SIGPROTO.HAIP,\n        dataObj,\n        cell,\n        tape,\n        tx\n    )\n}\n\nexport const HAIP: Protocol = {\n    name: 'HAIP',\n    address,\n    opReturnSchema,\n    handler,\n}\n","import { decode } from '@msgpack/msgpack'\nimport { Buffer } from 'buffer'\nimport { Cell, HandlerProps, Protocol } from '../../types/common'\nimport { MAP as MAPType } from '../../types/protocols/map'\nimport { saveProtocolData } from '../utils'\n\nconst address = '1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5'\n\nconst opReturnSchema = [\n    {\n        cmd: {\n            SET: [{ key: 'string' }, { val: 'string' }],\n            SELECT: [{ tx: 'string' }],\n            ADD: [{ key: 'string' }, [{ val: 'string' }]],\n            DELETE: [{ key: 'string' }, [{ val: 'string' }]],\n            JSON: 'string',\n            REMOVE: [[{ key: 'string' }]],\n            CLEAR: [[{ txid: 'string' }]],\n        },\n    },\n]\n\nconst processADD = function (cell: Cell[], mapObj: MAPType) {\n    let last = null\n    for (const pushdataContainer of cell) {\n        // ignore MAP command\n        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n            continue\n        }\n        const pushdata = pushdataContainer.s as string\n        if (pushdataContainer.i === 2) {\n            // Key name\n            mapObj[pushdata] = []\n            last = pushdata\n        } else {\n            if (last && Array.isArray(mapObj[last])) {\n                ;(mapObj[last] as string[]).push(pushdata)\n            }\n        }\n    }\n}\n\nconst proccessDELETE = function (cell: Cell[], mapObj: MAPType) {\n    let last = null\n    for (const pushdataContainer of cell) {\n        // ignore MAP command\n        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n            continue\n        }\n        const pushdata = pushdataContainer.s as string\n        if (pushdataContainer.i === 2) {\n            // Key name\n            mapObj[pushdata] = []\n            last = pushdata\n        } else {\n            if (last) {\n                ;(mapObj[last] as string[]).push(pushdata)\n            }\n        }\n    }\n}\n\nconst processSELECT = function (cell: Cell[], mapObj: MAPType) {\n    // TODO\n    // console.log('MAP SELECT');\n    for (const pushdataContainer of cell) {\n        // ignore MAP command\n        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n            mapObj.SELECT = 'TODO'\n            continue\n        }\n    }\n}\n\nconst processMSGPACK = function (cell: Cell[], mapObj: MAPType) {\n    for (const pushdataContainer of cell) {\n        // ignore MAP command\n        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n            continue\n        }\n        if (pushdataContainer.i === 2) {\n            try {\n                if (!decode) {\n                    throw new Error('Msgpack is required but not loaded')\n                }\n                const buff = Buffer.from(\n                    pushdataContainer.b as string,\n                    'base64'\n                )\n                mapObj = decode(buff) as MAPType\n            } catch (e) {\n                mapObj = {} as MAPType\n            }\n        }\n    }\n    return mapObj\n}\n\nconst processJSON = function (cell: Cell[], mapObj: MAPType) {\n    for (const pushdataContainer of cell) {\n        // ignore MAP command\n        if (pushdataContainer.i === 0 || pushdataContainer.i === 1) {\n            continue\n        }\n        if (pushdataContainer.i === 2) {\n            try {\n                mapObj = JSON.parse(pushdataContainer.s as string)\n            } catch (e) {\n                mapObj = {} as MAPType\n            }\n        }\n    }\n    return mapObj\n}\n\nconst processSET = function (cell: Cell[], mapObj: MAPType) {\n    let last = null\n    for (const pushdataContainer of cell) {\n        // ignore MAP command\n        if (\n            !pushdataContainer.s ||\n            pushdataContainer.i === 0 ||\n            pushdataContainer.i === 1\n        ) {\n            continue\n        }\n\n        const pushdata = pushdataContainer.s\n        if (pushdataContainer.i % 2 === 0) {\n            // key\n            mapObj[pushdata] = ''\n            last = pushdata\n        } else {\n            // value\n            if (!last) {\n                throw new Error(`malformed MAP syntax. Cannot parse.${last}`)\n            }\n            mapObj[last] = pushdata\n        }\n    }\n}\n\nconst handler = function ({ dataObj, cell, tx }: HandlerProps) {\n    // Validate\n    if (\n        cell[0].s !== address ||\n        !cell[1] ||\n        !cell[1].s ||\n        !cell[2] ||\n        !cell[2].s\n    ) {\n        throw new Error(`Invalid MAP record: ${tx}`)\n    }\n\n    let mapObj = {} as MAPType\n\n    // parse the protocol separator\n    const commands: any[] = []\n    let commandSeparator = 0\n    for (let i = 1; i < cell.length; i++) {\n        if (cell[i].s === ':::') {\n            commandSeparator++\n        } else {\n            if (!commands[commandSeparator]) commands[commandSeparator] = []\n            cell[i].i = commands[commandSeparator].length + 1\n            commands[commandSeparator].push(cell[i])\n        }\n    }\n\n    // Get the MAP command key name from the query schema\n    const mapCmdKey = Object.keys(opReturnSchema[0])[0]\n\n    // Add the firt MAP command in the response object\n    mapObj[mapCmdKey] = commands[0][0].s\n\n    commands.forEach((cc) => {\n        // re-add the MAP address\n        cc.unshift({\n            s: address,\n            i: 0,\n        })\n\n        const command = cc[1].s\n        // Individual parsing rules for each MAP command\n        switch (command) {\n            // Also check for SELECT commands and strip off the <SELECT> <TXID> part and run it through\n            case 'ADD': {\n                processADD(cc, mapObj)\n                break\n            }\n            case 'REMOVE': {\n                mapObj.key = cc[2].s\n                break\n            }\n            case 'DELETE': {\n                proccessDELETE(cc, mapObj)\n                break\n            }\n            case 'CLEAR': {\n                // TODO\n                // console.log('MAP CLEAR');\n                break\n            }\n            case 'SELECT': {\n                processSELECT(cc, mapObj)\n                break\n            }\n            case 'MSGPACK': {\n                mapObj = processMSGPACK(cc, mapObj)\n                break\n            }\n            case 'JSON': {\n                mapObj = processJSON(cc, mapObj)\n                break\n            }\n            case 'SET': {\n                processSET(cc, mapObj)\n                break\n            }\n            default: {\n                // don't know what to do ...\n            }\n        }\n    })\n\n    saveProtocolData(dataObj, 'MAP', mapObj)\n}\n\nexport const MAP: Protocol = {\n    name: 'MAP',\n    address,\n    opReturnSchema,\n    handler,\n}\n","import { Buffer } from 'buffer'\nimport {\n    HandlerProps,\n    MetaNet,\n    MetanetNode,\n    Protocol,\n} from '../../types/common'\nimport { sha256 } from '../utils'\n\nconst address = 'meta'\n\nconst opReturnSchema = [\n    { address: 'string' },\n    { parent: 'string' },\n    { name: 'string' },\n]\n\nexport const getEnvSafeMetanetID = async function (a: string, tx: string) {\n    // Calculate the node ID\n    const buf = Buffer.from(a + tx)\n    const hashBuf = await sha256(buf)\n    return hashBuf.toString('hex')\n}\n\nconst handler = async ({ dataObj, cell, tx }: HandlerProps) => {\n    if (\n        !cell.length ||\n        cell[0].s !== 'meta' ||\n        !cell[1] ||\n        !cell[1].s ||\n        !cell[2] ||\n        !cell[2].s ||\n        !tx\n    ) {\n        throw new Error('Invalid Metanet tx ' + tx)\n    }\n    // For now, we just copy from MOM keys later if available, or keep BOB format\n\n    const nodeId = await getEnvSafeMetanetID(cell[1].s, tx.tx.h)\n    // Described this node\n    const node = {\n        a: cell[1].s,\n        tx: tx.tx.h,\n        id: nodeId,\n    }\n    let parent = {} as MetanetNode\n    if (tx.in) {\n        const parentId = await getEnvSafeMetanetID(tx.in[0].e.a, cell[2].s)\n        // Parent node\n        parent = {\n            a: tx.in[0].e.a,\n            tx: cell[2].s,\n            id: parentId,\n        }\n    }\n\n    if (!dataObj.METANET) {\n        dataObj.METANET = []\n    }\n    dataObj.METANET.push({\n        node,\n        parent,\n    } as MetaNet)\n}\n\nexport const METANET: Protocol = {\n    name: 'METANET',\n    address,\n    opReturnSchema,\n    handler,\n}\n","import { Cell, HandlerProps, Protocol } from '../../types/common'\nimport { Ord as OrdType } from '../../types/protocols/ord'\nimport { cellValue, saveProtocolData } from '../utils'\n\n// const OrdScript =\n//     'OP_FALSE OP_IF 6F7264 OP_1 <CONTENT_TYPE_PLACEHOLDER> OP_0 <DATA_PLACEHOLDER> OP_ENDIF'.split(\n//         ' '\n//     )\n\nconst scriptChecker = (cell: Cell[]) => {\n    // TODO: What is the actual minimum length?\n    if (cell.length < 11) {\n        // wrong length\n        return false\n    }\n\n    // Find OP_IF wrapper\n    const startIdx = findIndex(cell, (c: Cell) => c.ops === 'OP_IF')\n    const endIdx = findIndex(\n        cell,\n        (c: Cell, i: number) => i > startIdx && c.ops === 'OP_ENDIF'\n    )\n    const ordScript = cell.slice(startIdx, endIdx)\n    const prevCell = cell[startIdx - 1]\n    return (\n        prevCell?.ops === 'OP_FALSE' &&\n        !!ordScript[0] &&\n        !!ordScript[1] &&\n        ordScript[1].s == 'ord'\n    )\n}\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n    if (!cell[0] || !out) {\n        throw new Error(\n            `Invalid Ord tx. dataObj, cell, out and tx are required.`\n        )\n    }\n\n    // assemble asm\n    // make sure first piece matches a txid\n    // 2nd piece matches any difficulty. set some resonable limit in bytes if there isnt one documented somewhere\n    // next\n\n    // Find OP_IF wrapper\n    const startIdx = findIndex(cell, (c: Cell) => c.ops === 'OP_IF')\n    const endIdx = findIndex(\n        cell,\n        (c: Cell, i: number) => i > startIdx && c.ops === 'OP_ENDIF'\n    )\n    const ordScript = cell.slice(startIdx, endIdx)\n\n    if (!ordScript[0] || !ordScript[1] || ordScript[1].s != 'ord') {\n        throw new Error(`Invalid Ord tx. Prefix not found.`)\n    }\n\n    console.log({ ordScript })\n\n    let data: string | undefined\n    let contentType: string | undefined\n    ordScript.forEach((push, idx, all) => {\n        // content-type\n        if (push.ops === 'OP_1') {\n            contentType = cellValue(all[idx + 1], 'string') as string\n        }\n        // data\n        if (push.ops === 'OP_0') {\n            data = cellValue(all[idx + 1]) as string\n        }\n    })\n\n    if (!data) {\n        throw new Error(`Invalid Ord data.`)\n    }\n    if (!contentType) {\n        throw new Error(`Invalid Ord content type.`)\n    }\n\n    const OrdObj: OrdType = {\n        data,\n        contentType,\n    }\n\n    saveProtocolData(dataObj, 'Ord', OrdObj)\n}\n\nexport const Ord: Protocol = {\n    name: 'Ord',\n    handler,\n    scriptChecker,\n}\n\nfunction findIndex(array: any[], predicate: Function) {\n    return findLastIndex(array, predicate)\n}\nfunction findLastIndex(array: any[], predicate: Function, fromIndex?: number) {\n    const length = array == null ? 0 : array.length\n    if (!length) {\n        return -1\n    }\n    let index = length - 1\n    if (fromIndex !== undefined) {\n        index = fromIndex\n        index =\n            fromIndex < 0\n                ? Math.max(length + index, 0)\n                : Math.min(index, length - 1)\n    }\n    return baseFindIndex(array, predicate, index, true)\n}\n\nfunction baseFindIndex(\n    array: any[],\n    predicate: Function,\n    fromIndex: number,\n    fromRight: boolean\n) {\n    const { length } = array\n    let index = fromIndex + (fromRight ? 1 : -1)\n\n    while (fromRight ? index-- : ++index < length) {\n        if (predicate(array[index], index, array)) {\n            return index\n        }\n    }\n    return -1\n}\n","import { HandlerProps, Protocol } from '../../types/common'\nimport { saveProtocolData } from '../utils'\n\nconst address = '1GvFYzwtFix3qSAZhESQVTz9DeudHZNoh1'\n\nconst opReturnSchema = [\n    { pair: 'json' },\n    { address: 'string' },\n    { timestamp: 'string' },\n]\n\nconst handler = function ({ dataObj, cell, tx }: HandlerProps) {\n    if (\n        cell[0].s !== address ||\n        !cell[1] ||\n        !cell[2] ||\n        !cell[3] ||\n        !cell[1].s ||\n        !cell[2].s ||\n        !cell[3].s\n    ) {\n        throw new Error(`Invalid RON record ${tx?.tx.h}`)\n    }\n\n    const pair = JSON.parse(cell[1].s)\n    const timestamp = Number(cell[3].s)\n\n    saveProtocolData(dataObj, 'RON', {\n        pair,\n        address: cell[2].s,\n        timestamp,\n    })\n}\n\nexport const RON: Protocol = {\n    name: 'RON',\n    address,\n    opReturnSchema,\n    handler,\n}\n","import { HandlerProps } from '../../types/common'\nimport { saveProtocolData } from '../utils'\n\nconst address = '1SymRe7erxM46GByucUWnB9fEEMgo7spd'\n\nconst opReturnSchema = [{ url: 'string' }]\n\nconst handler = function ({ dataObj, cell, tx }: HandlerProps) {\n    if (cell[0].s !== address || !cell[1] || !cell[1].s) {\n        throw new Error(`Invalid SymRe tx: ${tx}`)\n    }\n\n    saveProtocolData(dataObj, 'SYMRE', { url: cell[1].s })\n}\n\nexport const SYMRE = {\n    name: 'SYMRE',\n    address,\n    opReturnSchema,\n    handler,\n}\n","import { Cell, HandlerProps, Protocol } from '../../types/common'\nimport { _21E8 as _21E8Type } from '../../types/protocols/_21e8'\nimport { cellValue, saveProtocolData } from '../utils'\n\n// 21e8 does not use the first pushdata for id\n// in fact there is no id since the 21e8 is designed for difficulty and can be changed\n// instead we use the static part of the script to indentfy the transaction\n// TODO - the OP_X_PLACEHOLDER is the number of bytes to push onto the stack and must match difficulty size\nconst _21e8Script =\n    'OP_SIZE <OP_X_PLACEHOLDER> OP_PICK OP_SHA256 OP_SWAP OP_SPLIT OP_DROP OP_EQUALVERIFY OP_DROP OP_CHECKSIG'.split(\n        ' '\n    )\n\nconst scriptChecker = (cell: Cell[]) => {\n    if (cell.length !== 12) {\n        // wrong length\n        return false\n    }\n\n    // match exact script\n    const ops = [...cell].map((c) => c.ops).splice(2, cell.length)\n\n    // calculate target byte length\n    const target = cellValue(cell[1], 'hex') as string\n    const targetOpSize = Buffer.from(target).byteLength\n\n    // replace the placeholder opcode with actual\n    ops[1] = `OP_${targetOpSize}`\n    _21e8Script[1] = `OP_${targetOpSize}`\n\n    // protocol identifier always in first pushdata\n    return ops.join() === _21e8Script.join()\n}\n\nconst handler = ({ dataObj, cell, out }: HandlerProps): void => {\n    if (!cell[0] || !out) {\n        throw new Error(\n            `Invalid 21e8 tx. dataObj, cell, out and tx are required.`\n        )\n    }\n\n    // assemble asm\n    // make sure first piece matches a txid\n    // 2nd piece matches any difficulty. set some resonable limit in bytes if there isnt one documented somewhere\n    // next\n\n    const txid = cellValue(cell[0], 'hex') as string\n    const target = cellValue(cell[1], 'hex') as string\n    if (!target) {\n        throw new Error(\n            `Invalid 21e8 target.` + JSON.stringify(cell[0], null, 2)\n        )\n    }\n    const difficulty = Buffer.from(target, 'hex').byteLength\n\n    const _21e8Obj: _21E8Type = {\n        target,\n        difficulty,\n        value: out.e.v,\n        txid,\n    }\n\n    saveProtocolData(dataObj, '21E8', _21e8Obj)\n}\n\nexport const _21E8: Protocol = {\n    name: '21E8',\n    handler,\n    scriptChecker,\n}\n"],"names":[],"version":3,"file":"bmap.module.js.map","sourceRoot":"../"}